(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"/Users/tommy.cornilleau/Desktop/TEMP/sphere-particle/node_modules/three-js/index.js":[function(require,module,exports){
(function( self ){

	var THREE = require("./three.js");

	module.exports = function( addons ){

		if( addons instanceof Array ){

			for( var addon = 0, length = addons.length; addon < length; addon++ ){

				require("./addons/" + addons[addon] + ".js")(THREE);

			};

		};

		return THREE;

	};

})(this ||Â {});
},{"./three.js":"/Users/tommy.cornilleau/Desktop/TEMP/sphere-particle/node_modules/three-js/three.js"}],"/Users/tommy.cornilleau/Desktop/TEMP/sphere-particle/node_modules/three-js/three.js":[function(require,module,exports){
/**
 * @author mrdoob / http://mrdoob.com/
 */

(function( self ){

	var THREE = { REVISION: '73' };

	// polyfills

	if ( self.requestAnimationFrame === undefined || self.cancelAnimationFrame === undefined ) {

		// Missing in Android stock browser.

		( function () {

			var lastTime = 0;
			var vendors = [ 'ms', 'moz', 'webkit', 'o' ];

			for ( var x = 0; x < vendors.length && ! self.requestAnimationFrame; ++ x ) {

				self.requestAnimationFrame = self[ vendors[ x ] + 'RequestAnimationFrame' ];
				self.cancelAnimationFrame = self[ vendors[ x ] + 'CancelAnimationFrame' ] || self[ vendors[ x ] + 'CancelRequestAnimationFrame' ];

			}

			if ( self.requestAnimationFrame === undefined && self.setTimeout !== undefined ) {

				self.requestAnimationFrame = function ( callback ) {

					var currTime = Date.now(), timeToCall = Math.max( 0, 16 - ( currTime - lastTime ) );
					var id = self.setTimeout( function () {

						callback( currTime + timeToCall );

					}, timeToCall );
					lastTime = currTime + timeToCall;
					return id;

				};

			}

			if ( self.cancelAnimationFrame === undefined && self.clearTimeout !== undefined ) {

				self.cancelAnimationFrame = function ( id ) {

					self.clearTimeout( id );

				};

			}

		} )();

	}

	//

	if ( self.performance === undefined ) {

		self.performance = {};

	}

	if ( self.performance.now === undefined ) {

		( function () {

			var start = Date.now();

			self.performance.now = function () {

				return Date.now() - start;

			}

		} )();

	}

	//

	if ( Number.EPSILON === undefined ) {

		Number.EPSILON = Math.pow( 2, -52 );

	}

	//

	if ( Math.sign === undefined ) {

		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign

		Math.sign = function ( x ) {

			return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;

		};

	}

	if ( Function.prototype.name === undefined && Object.defineProperty !== undefined ) {

		// Missing in IE9-11.
		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name

		Object.defineProperty( Function.prototype, 'name', {

			get: function () {

				return this.toString().match( /^\s*function\s*(\S*)\s*\(/ )[ 1 ];

			}

		} );

	}

	// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.button

	THREE.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };

	// GL STATE CONSTANTS

	THREE.CullFaceNone = 0;
	THREE.CullFaceBack = 1;
	THREE.CullFaceFront = 2;
	THREE.CullFaceFrontBack = 3;

	THREE.FrontFaceDirectionCW = 0;
	THREE.FrontFaceDirectionCCW = 1;

	// SHADOWING TYPES

	THREE.BasicShadowMap = 0;
	THREE.PCFShadowMap = 1;
	THREE.PCFSoftShadowMap = 2;

	// MATERIAL CONSTANTS

	// side

	THREE.FrontSide = 0;
	THREE.BackSide = 1;
	THREE.DoubleSide = 2;

	// shading

	THREE.FlatShading = 1;
	THREE.SmoothShading = 2;

	// colors

	THREE.NoColors = 0;
	THREE.FaceColors = 1;
	THREE.VertexColors = 2;

	// blending modes

	THREE.NoBlending = 0;
	THREE.NormalBlending = 1;
	THREE.AdditiveBlending = 2;
	THREE.SubtractiveBlending = 3;
	THREE.MultiplyBlending = 4;
	THREE.CustomBlending = 5;

	// custom blending equations
	// (numbers start from 100 not to clash with other
	// mappings to OpenGL constants defined in Texture.js)

	THREE.AddEquation = 100;
	THREE.SubtractEquation = 101;
	THREE.ReverseSubtractEquation = 102;
	THREE.MinEquation = 103;
	THREE.MaxEquation = 104;

	// custom blending destination factors

	THREE.ZeroFactor = 200;
	THREE.OneFactor = 201;
	THREE.SrcColorFactor = 202;
	THREE.OneMinusSrcColorFactor = 203;
	THREE.SrcAlphaFactor = 204;
	THREE.OneMinusSrcAlphaFactor = 205;
	THREE.DstAlphaFactor = 206;
	THREE.OneMinusDstAlphaFactor = 207;

	// custom blending source factors

	//THREE.ZeroFactor = 200;
	//THREE.OneFactor = 201;
	//THREE.SrcAlphaFactor = 204;
	//THREE.OneMinusSrcAlphaFactor = 205;
	//THREE.DstAlphaFactor = 206;
	//THREE.OneMinusDstAlphaFactor = 207;
	THREE.DstColorFactor = 208;
	THREE.OneMinusDstColorFactor = 209;
	THREE.SrcAlphaSaturateFactor = 210;

	// depth modes

	THREE.NeverDepth = 0;
	THREE.AlwaysDepth = 1;
	THREE.LessDepth = 2;
	THREE.LessEqualDepth = 3;
	THREE.EqualDepth = 4;
	THREE.GreaterEqualDepth = 5;
	THREE.GreaterDepth = 6;
	THREE.NotEqualDepth = 7;


	// TEXTURE CONSTANTS

	THREE.MultiplyOperation = 0;
	THREE.MixOperation = 1;
	THREE.AddOperation = 2;

	// Mapping modes

	THREE.UVMapping = 300;

	THREE.CubeReflectionMapping = 301;
	THREE.CubeRefractionMapping = 302;

	THREE.EquirectangularReflectionMapping = 303;
	THREE.EquirectangularRefractionMapping = 304;

	THREE.SphericalReflectionMapping = 305;

	// Wrapping modes

	THREE.RepeatWrapping = 1000;
	THREE.ClampToEdgeWrapping = 1001;
	THREE.MirroredRepeatWrapping = 1002;

	// Filters

	THREE.NearestFilter = 1003;
	THREE.NearestMipMapNearestFilter = 1004;
	THREE.NearestMipMapLinearFilter = 1005;
	THREE.LinearFilter = 1006;
	THREE.LinearMipMapNearestFilter = 1007;
	THREE.LinearMipMapLinearFilter = 1008;

	// Data types

	THREE.UnsignedByteType = 1009;
	THREE.ByteType = 1010;
	THREE.ShortType = 1011;
	THREE.UnsignedShortType = 1012;
	THREE.IntType = 1013;
	THREE.UnsignedIntType = 1014;
	THREE.FloatType = 1015;
	THREE.HalfFloatType = 1025;

	// Pixel types

	//THREE.UnsignedByteType = 1009;
	THREE.UnsignedShort4444Type = 1016;
	THREE.UnsignedShort5551Type = 1017;
	THREE.UnsignedShort565Type = 1018;

	// Pixel formats

	THREE.AlphaFormat = 1019;
	THREE.RGBFormat = 1020;
	THREE.RGBAFormat = 1021;
	THREE.LuminanceFormat = 1022;
	THREE.LuminanceAlphaFormat = 1023;
	// THREE.RGBEFormat handled as THREE.RGBAFormat in shaders
	THREE.RGBEFormat = THREE.RGBAFormat; //1024;

	// DDS / ST3C Compressed texture formats

	THREE.RGB_S3TC_DXT1_Format = 2001;
	THREE.RGBA_S3TC_DXT1_Format = 2002;
	THREE.RGBA_S3TC_DXT3_Format = 2003;
	THREE.RGBA_S3TC_DXT5_Format = 2004;


	// PVRTC compressed texture formats

	THREE.RGB_PVRTC_4BPPV1_Format = 2100;
	THREE.RGB_PVRTC_2BPPV1_Format = 2101;
	THREE.RGBA_PVRTC_4BPPV1_Format = 2102;
	THREE.RGBA_PVRTC_2BPPV1_Format = 2103;

	// Loop styles for AnimationAction

	THREE.LoopOnce = 2200;
	THREE.LoopRepeat = 2201;
	THREE.LoopPingPong = 2202;

	// DEPRECATED

	THREE.Projector = function () {

		console.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );

		this.projectVector = function ( vector, camera ) {

			console.warn( 'THREE.Projector: .projectVector() is now vector.project().' );
			vector.project( camera );

		};

		this.unprojectVector = function ( vector, camera ) {

			console.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );
			vector.unproject( camera );

		};

		this.pickingRay = function ( vector, camera ) {

			console.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );

		};

	};

	THREE.CanvasRenderer = function () {

		console.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );

		this.domElement = document.createElement( 'canvas' );
		this.clear = function () {};
		this.render = function () {};
		this.setClearColor = function () {};
		this.setSize = function () {};

	};

	// File:src/math/Color.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Color = function ( color ) {

		if ( arguments.length === 3 ) {

			return this.fromArray( arguments );

		}

		return this.set( color );

	};

	THREE.Color.prototype = {

		constructor: THREE.Color,

		r: 1, g: 1, b: 1,

		set: function ( value ) {

			if ( value instanceof THREE.Color ) {

				this.copy( value );

			} else if ( typeof value === 'number' ) {

				this.setHex( value );

			} else if ( typeof value === 'string' ) {

				this.setStyle( value );

			}

			return this;

		},

		setHex: function ( hex ) {

			hex = Math.floor( hex );

			this.r = ( hex >> 16 & 255 ) / 255;
			this.g = ( hex >> 8 & 255 ) / 255;
			this.b = ( hex & 255 ) / 255;

			return this;

		},

		setRGB: function ( r, g, b ) {

			this.r = r;
			this.g = g;
			this.b = b;

			return this;

		},

		setHSL: function () {

			function hue2rgb( p, q, t ) {

				if ( t < 0 ) t += 1;
				if ( t > 1 ) t -= 1;
				if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
				if ( t < 1 / 2 ) return q;
				if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
				return p;

			}

			return function ( h, s, l ) {

				// h,s,l ranges are in 0.0 - 1.0
				h = THREE.Math.euclideanModulo( h, 1 );
				s = THREE.Math.clamp( s, 0, 1 );
				l = THREE.Math.clamp( l, 0, 1 );

				if ( s === 0 ) {

					this.r = this.g = this.b = l;

				} else {

					var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
					var q = ( 2 * l ) - p;

					this.r = hue2rgb( q, p, h + 1 / 3 );
					this.g = hue2rgb( q, p, h );
					this.b = hue2rgb( q, p, h - 1 / 3 );

				}

				return this;

			};

		}(),

		setStyle: function ( style ) {

			function handleAlpha( string ) {

				if ( string === undefined ) return;

				if ( parseFloat( string ) < 1 ) {

					console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );

				}

			}


			var m;

			if ( m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec( style ) ) {

				// rgb / hsl

				var color;
				var name = m[ 1 ];
				var components = m[ 2 ];

				switch ( name ) {

					case 'rgb':
					case 'rgba':

						if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

							// rgb(255,0,0) rgba(255,0,0,0.5)
							this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
							this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
							this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

							handleAlpha( color[ 5 ] );

							return this;

						}

						if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

							// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
							this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
							this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
							this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

							handleAlpha( color[ 5 ] );

							return this;

						}

						break;

					case 'hsl':
					case 'hsla':

						if ( color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

							// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
							var h = parseFloat( color[ 1 ] ) / 360;
							var s = parseInt( color[ 2 ], 10 ) / 100;
							var l = parseInt( color[ 3 ], 10 ) / 100;

							handleAlpha( color[ 5 ] );

							return this.setHSL( h, s, l );

						}

						break;

				}

			} else if ( m = /^\#([A-Fa-f0-9]+)$/.exec( style ) ) {

				// hex color

				var hex = m[ 1 ];
				var size = hex.length;

				if ( size === 3 ) {

					// #ff0
					this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
					this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
					this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;

					return this;

				} else if ( size === 6 ) {

					// #ff0000
					this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
					this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
					this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;

					return this;

				}

			}

			if ( style && style.length > 0 ) {

				// color keywords
				var hex = THREE.ColorKeywords[ style ];

				if ( hex !== undefined ) {

					// red
					this.setHex( hex );

				} else {

					// unknown color
					console.warn( 'THREE.Color: Unknown color ' + style );

				}

			}

			return this;

		},

		clone: function () {

			return new this.constructor( this.r, this.g, this.b );

		},

		copy: function ( color ) {

			this.r = color.r;
			this.g = color.g;
			this.b = color.b;

			return this;

		},

		copyGammaToLinear: function ( color, gammaFactor ) {

			if ( gammaFactor === undefined ) gammaFactor = 2.0;

			this.r = Math.pow( color.r, gammaFactor );
			this.g = Math.pow( color.g, gammaFactor );
			this.b = Math.pow( color.b, gammaFactor );

			return this;

		},

		copyLinearToGamma: function ( color, gammaFactor ) {

			if ( gammaFactor === undefined ) gammaFactor = 2.0;

			var safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;

			this.r = Math.pow( color.r, safeInverse );
			this.g = Math.pow( color.g, safeInverse );
			this.b = Math.pow( color.b, safeInverse );

			return this;

		},

		convertGammaToLinear: function () {

			var r = this.r, g = this.g, b = this.b;

			this.r = r * r;
			this.g = g * g;
			this.b = b * b;

			return this;

		},

		convertLinearToGamma: function () {

			this.r = Math.sqrt( this.r );
			this.g = Math.sqrt( this.g );
			this.b = Math.sqrt( this.b );

			return this;

		},

		getHex: function () {

			return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

		},

		getHexString: function () {

			return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

		},

		getHSL: function ( optionalTarget ) {

			// h,s,l ranges are in 0.0 - 1.0

			var hsl = optionalTarget || { h: 0, s: 0, l: 0 };

			var r = this.r, g = this.g, b = this.b;

			var max = Math.max( r, g, b );
			var min = Math.min( r, g, b );

			var hue, saturation;
			var lightness = ( min + max ) / 2.0;

			if ( min === max ) {

				hue = 0;
				saturation = 0;

			} else {

				var delta = max - min;

				saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

				switch ( max ) {

					case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
					case g: hue = ( b - r ) / delta + 2; break;
					case b: hue = ( r - g ) / delta + 4; break;

				}

				hue /= 6;

			}

			hsl.h = hue;
			hsl.s = saturation;
			hsl.l = lightness;

			return hsl;

		},

		getStyle: function () {

			return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

		},

		offsetHSL: function ( h, s, l ) {

			var hsl = this.getHSL();

			hsl.h += h; hsl.s += s; hsl.l += l;

			this.setHSL( hsl.h, hsl.s, hsl.l );

			return this;

		},

		add: function ( color ) {

			this.r += color.r;
			this.g += color.g;
			this.b += color.b;

			return this;

		},

		addColors: function ( color1, color2 ) {

			this.r = color1.r + color2.r;
			this.g = color1.g + color2.g;
			this.b = color1.b + color2.b;

			return this;

		},

		addScalar: function ( s ) {

			this.r += s;
			this.g += s;
			this.b += s;

			return this;

		},

		multiply: function ( color ) {

			this.r *= color.r;
			this.g *= color.g;
			this.b *= color.b;

			return this;

		},

		multiplyScalar: function ( s ) {

			this.r *= s;
			this.g *= s;
			this.b *= s;

			return this;

		},

		lerp: function ( color, alpha ) {

			this.r += ( color.r - this.r ) * alpha;
			this.g += ( color.g - this.g ) * alpha;
			this.b += ( color.b - this.b ) * alpha;

			return this;

		},

		equals: function ( c ) {

			return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this.r = array[ offset ];
			this.g = array[ offset + 1 ];
			this.b = array[ offset + 2 ];

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this.r;
			array[ offset + 1 ] = this.g;
			array[ offset + 2 ] = this.b;

			return array;

		}

	};

	THREE.ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
	'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
	'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
	'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
	'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
	'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
	'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
	'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
	'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
	'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
	'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
	'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
	'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
	'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
	'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
	'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
	'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
	'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
	'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
	'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
	'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
	'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
	'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
	'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

	// File:src/math/Quaternion.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://clara.io
	 */

	THREE.Quaternion = function ( x, y, z, w ) {

		this._x = x || 0;
		this._y = y || 0;
		this._z = z || 0;
		this._w = ( w !== undefined ) ? w : 1;

	};

	THREE.Quaternion.prototype = {

		constructor: THREE.Quaternion,

		get x () {

			return this._x;

		},

		set x ( value ) {

			this._x = value;
			this.onChangeCallback();

		},

		get y () {

			return this._y;

		},

		set y ( value ) {

			this._y = value;
			this.onChangeCallback();

		},

		get z () {

			return this._z;

		},

		set z ( value ) {

			this._z = value;
			this.onChangeCallback();

		},

		get w () {

			return this._w;

		},

		set w ( value ) {

			this._w = value;
			this.onChangeCallback();

		},

		set: function ( x, y, z, w ) {

			this._x = x;
			this._y = y;
			this._z = z;
			this._w = w;

			this.onChangeCallback();

			return this;

		},

		clone: function () {

			return new this.constructor( this._x, this._y, this._z, this._w );

		},

		copy: function ( quaternion ) {

			this._x = quaternion.x;
			this._y = quaternion.y;
			this._z = quaternion.z;
			this._w = quaternion.w;

			this.onChangeCallback();

			return this;

		},

		setFromEuler: function ( euler, update ) {

			if ( euler instanceof THREE.Euler === false ) {

				throw new Error( 'THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

			}

			// http://www.mathworks.com/matlabcentral/fileexchange/
			// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
			//	content/SpinCalc.m

			var c1 = Math.cos( euler._x / 2 );
			var c2 = Math.cos( euler._y / 2 );
			var c3 = Math.cos( euler._z / 2 );
			var s1 = Math.sin( euler._x / 2 );
			var s2 = Math.sin( euler._y / 2 );
			var s3 = Math.sin( euler._z / 2 );

			var order = euler.order;

			if ( order === 'XYZ' ) {

				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;

			} else if ( order === 'YXZ' ) {

				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;

			} else if ( order === 'ZXY' ) {

				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;

			} else if ( order === 'ZYX' ) {

				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;

			} else if ( order === 'YZX' ) {

				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;

			} else if ( order === 'XZY' ) {

				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;

			}

			if ( update !== false ) this.onChangeCallback();

			return this;

		},

		setFromAxisAngle: function ( axis, angle ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

			// assumes axis is normalized

			var halfAngle = angle / 2, s = Math.sin( halfAngle );

			this._x = axis.x * s;
			this._y = axis.y * s;
			this._z = axis.z * s;
			this._w = Math.cos( halfAngle );

			this.onChangeCallback();

			return this;

		},

		setFromRotationMatrix: function ( m ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			var te = m.elements,

				m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
				m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
				m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

				trace = m11 + m22 + m33,
				s;

			if ( trace > 0 ) {

				s = 0.5 / Math.sqrt( trace + 1.0 );

				this._w = 0.25 / s;
				this._x = ( m32 - m23 ) * s;
				this._y = ( m13 - m31 ) * s;
				this._z = ( m21 - m12 ) * s;

			} else if ( m11 > m22 && m11 > m33 ) {

				s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

				this._w = ( m32 - m23 ) / s;
				this._x = 0.25 * s;
				this._y = ( m12 + m21 ) / s;
				this._z = ( m13 + m31 ) / s;

			} else if ( m22 > m33 ) {

				s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

				this._w = ( m13 - m31 ) / s;
				this._x = ( m12 + m21 ) / s;
				this._y = 0.25 * s;
				this._z = ( m23 + m32 ) / s;

			} else {

				s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

				this._w = ( m21 - m12 ) / s;
				this._x = ( m13 + m31 ) / s;
				this._y = ( m23 + m32 ) / s;
				this._z = 0.25 * s;

			}

			this.onChangeCallback();

			return this;

		},

		setFromUnitVectors: function () {

			// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final

			// assumes direction vectors vFrom and vTo are normalized

			var v1, r;

			var EPS = 0.000001;

			return function ( vFrom, vTo ) {

				if ( v1 === undefined ) v1 = new THREE.Vector3();

				r = vFrom.dot( vTo ) + 1;

				if ( r < EPS ) {

					r = 0;

					if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

						v1.set( - vFrom.y, vFrom.x, 0 );

					} else {

						v1.set( 0, - vFrom.z, vFrom.y );

					}

				} else {

					v1.crossVectors( vFrom, vTo );

				}

				this._x = v1.x;
				this._y = v1.y;
				this._z = v1.z;
				this._w = r;

				this.normalize();

				return this;

			}

		}(),

		inverse: function () {

			this.conjugate().normalize();

			return this;

		},

		conjugate: function () {

			this._x *= - 1;
			this._y *= - 1;
			this._z *= - 1;

			this.onChangeCallback();

			return this;

		},

		dot: function ( v ) {

			return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

		},

		lengthSq: function () {

			return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

		},

		length: function () {

			return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

		},

		normalize: function () {

			var l = this.length();

			if ( l === 0 ) {

				this._x = 0;
				this._y = 0;
				this._z = 0;
				this._w = 1;

			} else {

				l = 1 / l;

				this._x = this._x * l;
				this._y = this._y * l;
				this._z = this._z * l;
				this._w = this._w * l;

			}

			this.onChangeCallback();

			return this;

		},

		multiply: function ( q, p ) {

			if ( p !== undefined ) {

				console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
				return this.multiplyQuaternions( q, p );

			}

			return this.multiplyQuaternions( this, q );

		},

		multiplyQuaternions: function ( a, b ) {

			// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

			var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
			var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

			this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
			this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
			this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
			this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

			this.onChangeCallback();

			return this;

		},

		multiplyVector3: function ( vector ) {

			console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
			return vector.applyQuaternion( this );

		},

		slerp: function ( qb, t ) {

			if ( t === 0 ) return this;
			if ( t === 1 ) return this.copy( qb );

			var x = this._x, y = this._y, z = this._z, w = this._w;

			// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

			var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

			if ( cosHalfTheta < 0 ) {

				this._w = - qb._w;
				this._x = - qb._x;
				this._y = - qb._y;
				this._z = - qb._z;

				cosHalfTheta = - cosHalfTheta;

			} else {

				this.copy( qb );

			}

			if ( cosHalfTheta >= 1.0 ) {

				this._w = w;
				this._x = x;
				this._y = y;
				this._z = z;

				return this;

			}

			var halfTheta = Math.acos( cosHalfTheta );
			var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );

			if ( Math.abs( sinHalfTheta ) < 0.001 ) {

				this._w = 0.5 * ( w + this._w );
				this._x = 0.5 * ( x + this._x );
				this._y = 0.5 * ( y + this._y );
				this._z = 0.5 * ( z + this._z );

				return this;

			}

			var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
			ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

			this._w = ( w * ratioA + this._w * ratioB );
			this._x = ( x * ratioA + this._x * ratioB );
			this._y = ( y * ratioA + this._y * ratioB );
			this._z = ( z * ratioA + this._z * ratioB );

			this.onChangeCallback();

			return this;

		},

		equals: function ( quaternion ) {

			return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this._x = array[ offset ];
			this._y = array[ offset + 1 ];
			this._z = array[ offset + 2 ];
			this._w = array[ offset + 3 ];

			this.onChangeCallback();

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this._x;
			array[ offset + 1 ] = this._y;
			array[ offset + 2 ] = this._z;
			array[ offset + 3 ] = this._w;

			return array;

		},

		onChange: function ( callback ) {

			this.onChangeCallback = callback;

			return this;

		},

		onChangeCallback: function () {}

	};

	THREE.Quaternion.slerp = function ( qa, qb, qm, t ) {

		return qm.copy( qa ).slerp( qb, t );

	};

	// File:src/math/Vector2.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author philogb / http://blog.thejit.org/
	 * @author egraether / http://egraether.com/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 */

	THREE.Vector2 = function ( x, y ) {

		this.x = x || 0;
		this.y = y || 0;

	};

	THREE.Vector2.prototype = {

		constructor: THREE.Vector2,

		get width() { return this.x },
		set width( value ) { this.x = value },

		get height() { return this.y },
		set height( value ) { this.y = value },

		//

		set: function ( x, y ) {

			this.x = x;
			this.y = y;

			return this;

		},

		setX: function ( x ) {

			this.x = x;

			return this;

		},

		setY: function ( y ) {

			this.y = y;

			return this;

		},

		setComponent: function ( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

		},

		getComponent: function ( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				default: throw new Error( 'index is out of range: ' + index );

			}

		},

		clone: function () {

			return new this.constructor( this.x, this.y );

		},

		copy: function ( v ) {

			this.x = v.x;
			this.y = v.y;

			return this;

		},

		add: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );

			}

			this.x += v.x;
			this.y += v.y;

			return this;

		},

		addScalar: function ( s ) {

			this.x += s;
			this.y += s;

			return this;

		},

		addVectors: function ( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;

			return this;

		},

		addScaledVector: function ( v, s ) {

			this.x += v.x * s;
			this.y += v.y * s;

			return this;

		},

		sub: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );

			}

			this.x -= v.x;
			this.y -= v.y;

			return this;

		},

		subScalar: function ( s ) {

			this.x -= s;
			this.y -= s;

			return this;

		},

		subVectors: function ( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;

			return this;

		},

		multiply: function ( v ) {

			this.x *= v.x;
			this.y *= v.y;

			return this;

		},

		multiplyScalar: function ( scalar ) {

			if ( isFinite( scalar ) ) {
				this.x *= scalar;
				this.y *= scalar;
			} else {
				this.x = 0;
				this.y = 0;
			}

			return this;

		},

		divide: function ( v ) {

			this.x /= v.x;
			this.y /= v.y;

			return this;

		},

		divideScalar: function ( scalar ) {

			return this.multiplyScalar( 1 / scalar );

		},

		min: function ( v ) {

			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );

			return this;

		},

		max: function ( v ) {

			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );

			return this;

		},

		clamp: function ( min, max ) {

			// This function assumes min < max, if this assumption isn't true it will not operate correctly

			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );

			return this;

		},

		clampScalar: function () {

			var min, max;

			return function clampScalar( minVal, maxVal ) {

				if ( min === undefined ) {

					min = new THREE.Vector2();
					max = new THREE.Vector2();

				}

				min.set( minVal, minVal );
				max.set( maxVal, maxVal );

				return this.clamp( min, max );

			};

		}(),

		clampLength: function ( min, max ) {

			var length = this.length();

			this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );

			return this;

		},

		floor: function () {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );

			return this;

		},

		ceil: function () {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );

			return this;

		},

		round: function () {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );

			return this;

		},

		roundToZero: function () {

			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

			return this;

		},

		negate: function () {

			this.x = - this.x;
			this.y = - this.y;

			return this;

		},

		dot: function ( v ) {

			return this.x * v.x + this.y * v.y;

		},

		lengthSq: function () {

			return this.x * this.x + this.y * this.y;

		},

		length: function () {

			return Math.sqrt( this.x * this.x + this.y * this.y );

		},

		lengthManhattan: function() {

			return Math.abs( this.x ) + Math.abs( this.y );

		},

		normalize: function () {

			return this.divideScalar( this.length() );

		},

		distanceTo: function ( v ) {

			return Math.sqrt( this.distanceToSquared( v ) );

		},

		distanceToSquared: function ( v ) {

			var dx = this.x - v.x, dy = this.y - v.y;
			return dx * dx + dy * dy;

		},

		setLength: function ( length ) {

			return this.multiplyScalar( length / this.length() );

		},

		lerp: function ( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;

			return this;

		},

		lerpVectors: function ( v1, v2, alpha ) {

			this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

			return this;

		},

		equals: function ( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;

			return array;

		},

		fromAttribute: function ( attribute, index, offset ) {

			if ( offset === undefined ) offset = 0;

			index = index * attribute.itemSize + offset;

			this.x = attribute.array[ index ];
			this.y = attribute.array[ index + 1 ];

			return this;

		},

		rotateAround: function ( center, angle ) {

			var c = Math.cos( angle ), s = Math.sin( angle );

			var x = this.x - center.x;
			var y = this.y - center.y;

			this.x = x * c - y * s + center.x;
			this.y = x * s + y * c + center.y;

			return this;

		}

	};

	// File:src/math/Vector3.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author *kile / http://kile.stravaganza.org/
	 * @author philogb / http://blog.thejit.org/
	 * @author mikael emtinger / http://gomo.se/
	 * @author egraether / http://egraether.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	THREE.Vector3 = function ( x, y, z ) {

		this.x = x || 0;
		this.y = y || 0;
		this.z = z || 0;

	};

	THREE.Vector3.prototype = {

		constructor: THREE.Vector3,

		set: function ( x, y, z ) {

			this.x = x;
			this.y = y;
			this.z = z;

			return this;

		},

		setX: function ( x ) {

			this.x = x;

			return this;

		},

		setY: function ( y ) {

			this.y = y;

			return this;

		},

		setZ: function ( z ) {

			this.z = z;

			return this;

		},

		setComponent: function ( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

		},

		getComponent: function ( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				default: throw new Error( 'index is out of range: ' + index );

			}

		},

		clone: function () {

			return new this.constructor( this.x, this.y, this.z );

		},

		copy: function ( v ) {

			this.x = v.x;
			this.y = v.y;
			this.z = v.z;

			return this;

		},

		add: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );

			}

			this.x += v.x;
			this.y += v.y;
			this.z += v.z;

			return this;

		},

		addScalar: function ( s ) {

			this.x += s;
			this.y += s;
			this.z += s;

			return this;

		},

		addVectors: function ( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;

			return this;

		},

		addScaledVector: function ( v, s ) {

			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;

			return this;

		},

		sub: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );

			}

			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;

			return this;

		},

		subScalar: function ( s ) {

			this.x -= s;
			this.y -= s;
			this.z -= s;

			return this;

		},

		subVectors: function ( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;

			return this;

		},

		multiply: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
				return this.multiplyVectors( v, w );

			}

			this.x *= v.x;
			this.y *= v.y;
			this.z *= v.z;

			return this;

		},

		multiplyScalar: function ( scalar ) {

			if ( isFinite( scalar ) ) {
				this.x *= scalar;
				this.y *= scalar;
				this.z *= scalar;
			} else {
				this.x = 0;
				this.y = 0;
				this.z = 0;
			}

			return this;

		},

		multiplyVectors: function ( a, b ) {

			this.x = a.x * b.x;
			this.y = a.y * b.y;
			this.z = a.z * b.z;

			return this;

		},

		applyEuler: function () {

			var quaternion;

			return function applyEuler( euler ) {

				if ( euler instanceof THREE.Euler === false ) {

					console.error( 'THREE.Vector3: .applyEuler() now expects a Euler rotation rather than a Vector3 and order.' );

				}

				if ( quaternion === undefined ) quaternion = new THREE.Quaternion();

				this.applyQuaternion( quaternion.setFromEuler( euler ) );

				return this;

			};

		}(),

		applyAxisAngle: function () {

			var quaternion;

			return function applyAxisAngle( axis, angle ) {

				if ( quaternion === undefined ) quaternion = new THREE.Quaternion();

				this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );

				return this;

			};

		}(),

		applyMatrix3: function ( m ) {

			var x = this.x;
			var y = this.y;
			var z = this.z;

			var e = m.elements;

			this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
			this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
			this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

			return this;

		},

		applyMatrix4: function ( m ) {

			// input: THREE.Matrix4 affine matrix

			var x = this.x, y = this.y, z = this.z;

			var e = m.elements;

			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];

			return this;

		},

		applyProjection: function ( m ) {

			// input: THREE.Matrix4 projection matrix

			var x = this.x, y = this.y, z = this.z;

			var e = m.elements;
			var d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide

			this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;
			this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;
			this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;

			return this;

		},

		applyQuaternion: function ( q ) {

			var x = this.x;
			var y = this.y;
			var z = this.z;

			var qx = q.x;
			var qy = q.y;
			var qz = q.z;
			var qw = q.w;

			// calculate quat * vector

			var ix =  qw * x + qy * z - qz * y;
			var iy =  qw * y + qz * x - qx * z;
			var iz =  qw * z + qx * y - qy * x;
			var iw = - qx * x - qy * y - qz * z;

			// calculate result * inverse quat

			this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
			this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
			this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

			return this;

		},

		project: function () {

			var matrix;

			return function project( camera ) {

				if ( matrix === undefined ) matrix = new THREE.Matrix4();

				matrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );
				return this.applyProjection( matrix );

			};

		}(),

		unproject: function () {

			var matrix;

			return function unproject( camera ) {

				if ( matrix === undefined ) matrix = new THREE.Matrix4();

				matrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );
				return this.applyProjection( matrix );

			};

		}(),

		transformDirection: function ( m ) {

			// input: THREE.Matrix4 affine matrix
			// vector interpreted as a direction

			var x = this.x, y = this.y, z = this.z;

			var e = m.elements;

			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

			this.normalize();

			return this;

		},

		divide: function ( v ) {

			this.x /= v.x;
			this.y /= v.y;
			this.z /= v.z;

			return this;

		},

		divideScalar: function ( scalar ) {

			return this.multiplyScalar( 1 / scalar );

		},

		min: function ( v ) {

			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );
			this.z = Math.min( this.z, v.z );

			return this;

		},

		max: function ( v ) {

			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );
			this.z = Math.max( this.z, v.z );

			return this;

		},

		clamp: function ( min, max ) {

			// This function assumes min < max, if this assumption isn't true it will not operate correctly

			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );
			this.z = Math.max( min.z, Math.min( max.z, this.z ) );

			return this;

		},

		clampScalar: function () {

			var min, max;

			return function clampScalar( minVal, maxVal ) {

				if ( min === undefined ) {

					min = new THREE.Vector3();
					max = new THREE.Vector3();

				}

				min.set( minVal, minVal, minVal );
				max.set( maxVal, maxVal, maxVal );

				return this.clamp( min, max );

			};

		}(),

		clampLength: function ( min, max ) {

			var length = this.length();

			this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );

			return this;

		},

		floor: function () {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
			this.z = Math.floor( this.z );

			return this;

		},

		ceil: function () {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
			this.z = Math.ceil( this.z );

			return this;

		},

		round: function () {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
			this.z = Math.round( this.z );

			return this;

		},

		roundToZero: function () {

			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
			this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

			return this;

		},

		negate: function () {

			this.x = - this.x;
			this.y = - this.y;
			this.z = - this.z;

			return this;

		},

		dot: function ( v ) {

			return this.x * v.x + this.y * v.y + this.z * v.z;

		},

		lengthSq: function () {

			return this.x * this.x + this.y * this.y + this.z * this.z;

		},

		length: function () {

			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

		},

		lengthManhattan: function () {

			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

		},

		normalize: function () {

			return this.divideScalar( this.length() );

		},

		setLength: function ( length ) {

			return this.multiplyScalar( length / this.length() );

		},

		lerp: function ( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
			this.z += ( v.z - this.z ) * alpha;

			return this;

		},

		lerpVectors: function ( v1, v2, alpha ) {

			this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

			return this;

		},

		cross: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
				return this.crossVectors( v, w );

			}

			var x = this.x, y = this.y, z = this.z;

			this.x = y * v.z - z * v.y;
			this.y = z * v.x - x * v.z;
			this.z = x * v.y - y * v.x;

			return this;

		},

		crossVectors: function ( a, b ) {

			var ax = a.x, ay = a.y, az = a.z;
			var bx = b.x, by = b.y, bz = b.z;

			this.x = ay * bz - az * by;
			this.y = az * bx - ax * bz;
			this.z = ax * by - ay * bx;

			return this;

		},

		projectOnVector: function () {

			var v1, dot;

			return function projectOnVector( vector ) {

				if ( v1 === undefined ) v1 = new THREE.Vector3();

				v1.copy( vector ).normalize();

				dot = this.dot( v1 );

				return this.copy( v1 ).multiplyScalar( dot );

			};

		}(),

		projectOnPlane: function () {

			var v1;

			return function projectOnPlane( planeNormal ) {

				if ( v1 === undefined ) v1 = new THREE.Vector3();

				v1.copy( this ).projectOnVector( planeNormal );

				return this.sub( v1 );

			}

		}(),

		reflect: function () {

			// reflect incident vector off plane orthogonal to normal
			// normal is assumed to have unit length

			var v1;

			return function reflect( normal ) {

				if ( v1 === undefined ) v1 = new THREE.Vector3();

				return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

			}

		}(),

		angleTo: function ( v ) {

			var theta = this.dot( v ) / ( this.length() * v.length() );

			// clamp, to handle numerical problems

			return Math.acos( THREE.Math.clamp( theta, - 1, 1 ) );

		},

		distanceTo: function ( v ) {

			return Math.sqrt( this.distanceToSquared( v ) );

		},

		distanceToSquared: function ( v ) {

			var dx = this.x - v.x;
			var dy = this.y - v.y;
			var dz = this.z - v.z;

			return dx * dx + dy * dy + dz * dz;

		},

		setEulerFromRotationMatrix: function ( m, order ) {

			console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );

		},

		setEulerFromQuaternion: function ( q, order ) {

			console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );

		},

		getPositionFromMatrix: function ( m ) {

			console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );

			return this.setFromMatrixPosition( m );

		},

		getScaleFromMatrix: function ( m ) {

			console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );

			return this.setFromMatrixScale( m );

		},

		getColumnFromMatrix: function ( index, matrix ) {

			console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );

			return this.setFromMatrixColumn( index, matrix );

		},

		setFromMatrixPosition: function ( m ) {

			this.x = m.elements[ 12 ];
			this.y = m.elements[ 13 ];
			this.z = m.elements[ 14 ];

			return this;

		},

		setFromMatrixScale: function ( m ) {

			var sx = this.set( m.elements[ 0 ], m.elements[ 1 ], m.elements[ 2 ] ).length();
			var sy = this.set( m.elements[ 4 ], m.elements[ 5 ], m.elements[ 6 ] ).length();
			var sz = this.set( m.elements[ 8 ], m.elements[ 9 ], m.elements[ 10 ] ).length();

			this.x = sx;
			this.y = sy;
			this.z = sz;

			return this;

		},

		setFromMatrixColumn: function ( index, matrix ) {

			var offset = index * 4;

			var me = matrix.elements;

			this.x = me[ offset ];
			this.y = me[ offset + 1 ];
			this.z = me[ offset + 2 ];

			return this;

		},

		equals: function ( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
			this.z = array[ offset + 2 ];

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
			array[ offset + 2 ] = this.z;

			return array;

		},

		fromAttribute: function ( attribute, index, offset ) {

			if ( offset === undefined ) offset = 0;

			index = index * attribute.itemSize + offset;

			this.x = attribute.array[ index ];
			this.y = attribute.array[ index + 1 ];
			this.z = attribute.array[ index + 2 ];

			return this;

		}

	};

	// File:src/math/Vector4.js

	/**
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author philogb / http://blog.thejit.org/
	 * @author mikael emtinger / http://gomo.se/
	 * @author egraether / http://egraether.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	THREE.Vector4 = function ( x, y, z, w ) {

		this.x = x || 0;
		this.y = y || 0;
		this.z = z || 0;
		this.w = ( w !== undefined ) ? w : 1;

	};

	THREE.Vector4.prototype = {

		constructor: THREE.Vector4,

		set: function ( x, y, z, w ) {

			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;

			return this;

		},

		setX: function ( x ) {

			this.x = x;

			return this;

		},

		setY: function ( y ) {

			this.y = y;

			return this;

		},

		setZ: function ( z ) {

			this.z = z;

			return this;

		},

		setW: function ( w ) {

			this.w = w;

			return this;

		},

		setComponent: function ( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				case 3: this.w = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

		},

		getComponent: function ( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				case 3: return this.w;
				default: throw new Error( 'index is out of range: ' + index );

			}

		},

		clone: function () {

			return new this.constructor( this.x, this.y, this.z, this.w );

		},

		copy: function ( v ) {

			this.x = v.x;
			this.y = v.y;
			this.z = v.z;
			this.w = ( v.w !== undefined ) ? v.w : 1;

			return this;

		},

		add: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );

			}

			this.x += v.x;
			this.y += v.y;
			this.z += v.z;
			this.w += v.w;

			return this;

		},

		addScalar: function ( s ) {

			this.x += s;
			this.y += s;
			this.z += s;
			this.w += s;

			return this;

		},

		addVectors: function ( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;
			this.w = a.w + b.w;

			return this;

		},

		addScaledVector: function ( v, s ) {

			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;
			this.w += v.w * s;

			return this;

		},

		sub: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );

			}

			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;
			this.w -= v.w;

			return this;

		},

		subScalar: function ( s ) {

			this.x -= s;
			this.y -= s;
			this.z -= s;
			this.w -= s;

			return this;

		},

		subVectors: function ( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;
			this.w = a.w - b.w;

			return this;

		},

		multiplyScalar: function ( scalar ) {

			if ( isFinite( scalar ) ) {
				this.x *= scalar;
				this.y *= scalar;
				this.z *= scalar;
				this.w *= scalar;
			} else {
				this.x = 0;
				this.y = 0;
				this.z = 0;
				this.w = 0;
			}

			return this;

		},

		applyMatrix4: function ( m ) {

			var x = this.x;
			var y = this.y;
			var z = this.z;
			var w = this.w;

			var e = m.elements;

			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
			this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

			return this;

		},

		divideScalar: function ( scalar ) {

			return this.multiplyScalar( 1 / scalar );

		},

		setAxisAngleFromQuaternion: function ( q ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

			// q is assumed to be normalized

			this.w = 2 * Math.acos( q.w );

			var s = Math.sqrt( 1 - q.w * q.w );

			if ( s < 0.0001 ) {

				 this.x = 1;
				 this.y = 0;
				 this.z = 0;

			} else {

				 this.x = q.x / s;
				 this.y = q.y / s;
				 this.z = q.z / s;

			}

			return this;

		},

		setAxisAngleFromRotationMatrix: function ( m ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			var angle, x, y, z,		// variables for result
				epsilon = 0.01,		// margin to allow for rounding errors
				epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

				te = m.elements,

				m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
				m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
				m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

			if ( ( Math.abs( m12 - m21 ) < epsilon )
			   && ( Math.abs( m13 - m31 ) < epsilon )
			   && ( Math.abs( m23 - m32 ) < epsilon ) ) {

				// singularity found
				// first check for identity matrix which must have +1 for all terms
				// in leading diagonal and zero in other terms

				if ( ( Math.abs( m12 + m21 ) < epsilon2 )
				   && ( Math.abs( m13 + m31 ) < epsilon2 )
				   && ( Math.abs( m23 + m32 ) < epsilon2 )
				   && ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

					// this singularity is identity matrix so angle = 0

					this.set( 1, 0, 0, 0 );

					return this; // zero angle, arbitrary axis

				}

				// otherwise this singularity is angle = 180

				angle = Math.PI;

				var xx = ( m11 + 1 ) / 2;
				var yy = ( m22 + 1 ) / 2;
				var zz = ( m33 + 1 ) / 2;
				var xy = ( m12 + m21 ) / 4;
				var xz = ( m13 + m31 ) / 4;
				var yz = ( m23 + m32 ) / 4;

				if ( ( xx > yy ) && ( xx > zz ) ) {

					// m11 is the largest diagonal term

					if ( xx < epsilon ) {

						x = 0;
						y = 0.707106781;
						z = 0.707106781;

					} else {

						x = Math.sqrt( xx );
						y = xy / x;
						z = xz / x;

					}

				} else if ( yy > zz ) {

					// m22 is the largest diagonal term

					if ( yy < epsilon ) {

						x = 0.707106781;
						y = 0;
						z = 0.707106781;

					} else {

						y = Math.sqrt( yy );
						x = xy / y;
						z = yz / y;

					}

				} else {

					// m33 is the largest diagonal term so base result on this

					if ( zz < epsilon ) {

						x = 0.707106781;
						y = 0.707106781;
						z = 0;

					} else {

						z = Math.sqrt( zz );
						x = xz / z;
						y = yz / z;

					}

				}

				this.set( x, y, z, angle );

				return this; // return 180 deg rotation

			}

			// as we have reached here there are no singularities so we can handle normally

			var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 )
							  + ( m13 - m31 ) * ( m13 - m31 )
							  + ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

			if ( Math.abs( s ) < 0.001 ) s = 1;

			// prevent divide by zero, should not happen if matrix is orthogonal and should be
			// caught by singularity test above, but I've left it in just in case

			this.x = ( m32 - m23 ) / s;
			this.y = ( m13 - m31 ) / s;
			this.z = ( m21 - m12 ) / s;
			this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

			return this;

		},

		min: function ( v ) {

			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );
			this.z = Math.min( this.z, v.z );
			this.w = Math.min( this.w, v.w );

			return this;

		},

		max: function ( v ) {

			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );
			this.z = Math.max( this.z, v.z );
			this.w = Math.max( this.w, v.w );

			return this;

		},

		clamp: function ( min, max ) {

			// This function assumes min < max, if this assumption isn't true it will not operate correctly

			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );
			this.z = Math.max( min.z, Math.min( max.z, this.z ) );
			this.w = Math.max( min.w, Math.min( max.w, this.w ) );

			return this;

		},

		clampScalar: function () {

			var min, max;

			return function clampScalar( minVal, maxVal ) {

				if ( min === undefined ) {

					min = new THREE.Vector4();
					max = new THREE.Vector4();

				}

				min.set( minVal, minVal, minVal, minVal );
				max.set( maxVal, maxVal, maxVal, maxVal );

				return this.clamp( min, max );

			};

		}(),

		floor: function () {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
			this.z = Math.floor( this.z );
			this.w = Math.floor( this.w );

			return this;

		},

		ceil: function () {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
			this.z = Math.ceil( this.z );
			this.w = Math.ceil( this.w );

			return this;

		},

		round: function () {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
			this.z = Math.round( this.z );
			this.w = Math.round( this.w );

			return this;

		},

		roundToZero: function () {

			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
			this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
			this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

			return this;

		},

		negate: function () {

			this.x = - this.x;
			this.y = - this.y;
			this.z = - this.z;
			this.w = - this.w;

			return this;

		},

		dot: function ( v ) {

			return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

		},

		lengthSq: function () {

			return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

		},

		length: function () {

			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

		},

		lengthManhattan: function () {

			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

		},

		normalize: function () {

			return this.divideScalar( this.length() );

		},

		setLength: function ( length ) {

			return this.multiplyScalar( length / this.length() );

		},

		lerp: function ( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
			this.z += ( v.z - this.z ) * alpha;
			this.w += ( v.w - this.w ) * alpha;

			return this;

		},

		lerpVectors: function ( v1, v2, alpha ) {

			this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

			return this;

		},

		equals: function ( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
			this.z = array[ offset + 2 ];
			this.w = array[ offset + 3 ];

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
			array[ offset + 2 ] = this.z;
			array[ offset + 3 ] = this.w;

			return array;

		},

		fromAttribute: function ( attribute, index, offset ) {

			if ( offset === undefined ) offset = 0;

			index = index * attribute.itemSize + offset;

			this.x = attribute.array[ index ];
			this.y = attribute.array[ index + 1 ];
			this.z = attribute.array[ index + 2 ];
			this.w = attribute.array[ index + 3 ];

			return this;

		}

	};

	// File:src/math/Euler.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://clara.io
	 */

	THREE.Euler = function ( x, y, z, order ) {

		this._x = x || 0;
		this._y = y || 0;
		this._z = z || 0;
		this._order = order || THREE.Euler.DefaultOrder;

	};

	THREE.Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

	THREE.Euler.DefaultOrder = 'XYZ';

	THREE.Euler.prototype = {

		constructor: THREE.Euler,

		get x () {

			return this._x;

		},

		set x ( value ) {

			this._x = value;
			this.onChangeCallback();

		},

		get y () {

			return this._y;

		},

		set y ( value ) {

			this._y = value;
			this.onChangeCallback();

		},

		get z () {

			return this._z;

		},

		set z ( value ) {

			this._z = value;
			this.onChangeCallback();

		},

		get order () {

			return this._order;

		},

		set order ( value ) {

			this._order = value;
			this.onChangeCallback();

		},

		set: function ( x, y, z, order ) {

			this._x = x;
			this._y = y;
			this._z = z;
			this._order = order || this._order;

			this.onChangeCallback();

			return this;

		},

		clone: function () {

			return new this.constructor( this._x, this._y, this._z, this._order);

		},

		copy: function ( euler ) {

			this._x = euler._x;
			this._y = euler._y;
			this._z = euler._z;
			this._order = euler._order;

			this.onChangeCallback();

			return this;

		},

		setFromRotationMatrix: function ( m, order, update ) {

			var clamp = THREE.Math.clamp;

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			var te = m.elements;
			var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
			var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
			var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

			order = order || this._order;

			if ( order === 'XYZ' ) {

				this._y = Math.asin( clamp( m13, - 1, 1 ) );

				if ( Math.abs( m13 ) < 0.99999 ) {

					this._x = Math.atan2( - m23, m33 );
					this._z = Math.atan2( - m12, m11 );

				} else {

					this._x = Math.atan2( m32, m22 );
					this._z = 0;

				}

			} else if ( order === 'YXZ' ) {

				this._x = Math.asin( - clamp( m23, - 1, 1 ) );

				if ( Math.abs( m23 ) < 0.99999 ) {

					this._y = Math.atan2( m13, m33 );
					this._z = Math.atan2( m21, m22 );

				} else {

					this._y = Math.atan2( - m31, m11 );
					this._z = 0;

				}

			} else if ( order === 'ZXY' ) {

				this._x = Math.asin( clamp( m32, - 1, 1 ) );

				if ( Math.abs( m32 ) < 0.99999 ) {

					this._y = Math.atan2( - m31, m33 );
					this._z = Math.atan2( - m12, m22 );

				} else {

					this._y = 0;
					this._z = Math.atan2( m21, m11 );

				}

			} else if ( order === 'ZYX' ) {

				this._y = Math.asin( - clamp( m31, - 1, 1 ) );

				if ( Math.abs( m31 ) < 0.99999 ) {

					this._x = Math.atan2( m32, m33 );
					this._z = Math.atan2( m21, m11 );

				} else {

					this._x = 0;
					this._z = Math.atan2( - m12, m22 );

				}

			} else if ( order === 'YZX' ) {

				this._z = Math.asin( clamp( m21, - 1, 1 ) );

				if ( Math.abs( m21 ) < 0.99999 ) {

					this._x = Math.atan2( - m23, m22 );
					this._y = Math.atan2( - m31, m11 );

				} else {

					this._x = 0;
					this._y = Math.atan2( m13, m33 );

				}

			} else if ( order === 'XZY' ) {

				this._z = Math.asin( - clamp( m12, - 1, 1 ) );

				if ( Math.abs( m12 ) < 0.99999 ) {

					this._x = Math.atan2( m32, m22 );
					this._y = Math.atan2( m13, m11 );

				} else {

					this._x = Math.atan2( - m23, m33 );
					this._y = 0;

				}

			} else {

				console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order )

			}

			this._order = order;

			if ( update !== false ) this.onChangeCallback();

			return this;

		},

		setFromQuaternion: function () {

			var matrix;

			return function ( q, order, update ) {

				if ( matrix === undefined ) matrix = new THREE.Matrix4();
				matrix.makeRotationFromQuaternion( q );
				this.setFromRotationMatrix( matrix, order, update );

				return this;

			};

		}(),

		setFromVector3: function ( v, order ) {

			return this.set( v.x, v.y, v.z, order || this._order );

		},

		reorder: function () {

			// WARNING: this discards revolution information -bhouston

			var q = new THREE.Quaternion();

			return function ( newOrder ) {

				q.setFromEuler( this );
				this.setFromQuaternion( q, newOrder );

			};

		}(),

		equals: function ( euler ) {

			return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

		},

		fromArray: function ( array ) {

			this._x = array[ 0 ];
			this._y = array[ 1 ];
			this._z = array[ 2 ];
			if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

			this.onChangeCallback();

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this._x;
			array[ offset + 1 ] = this._y;
			array[ offset + 2 ] = this._z;
			array[ offset + 3 ] = this._order;

			return array;

		},

		toVector3: function ( optionalResult ) {

			if ( optionalResult ) {

				return optionalResult.set( this._x, this._y, this._z );

			} else {

				return new THREE.Vector3( this._x, this._y, this._z );

			}

		},

		onChange: function ( callback ) {

			this.onChangeCallback = callback;

			return this;

		},

		onChangeCallback: function () {}

	};

	// File:src/math/Line3.js

	/**
	 * @author bhouston / http://clara.io
	 */

	THREE.Line3 = function ( start, end ) {

		this.start = ( start !== undefined ) ? start : new THREE.Vector3();
		this.end = ( end !== undefined ) ? end : new THREE.Vector3();

	};

	THREE.Line3.prototype = {

		constructor: THREE.Line3,

		set: function ( start, end ) {

			this.start.copy( start );
			this.end.copy( end );

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( line ) {

			this.start.copy( line.start );
			this.end.copy( line.end );

			return this;

		},

		center: function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();
			return result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

		},

		delta: function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();
			return result.subVectors( this.end, this.start );

		},

		distanceSq: function () {

			return this.start.distanceToSquared( this.end );

		},

		distance: function () {

			return this.start.distanceTo( this.end );

		},

		at: function ( t, optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();

			return this.delta( result ).multiplyScalar( t ).add( this.start );

		},

		closestPointToPointParameter: function () {

			var startP = new THREE.Vector3();
			var startEnd = new THREE.Vector3();

			return function ( point, clampToLine ) {

				startP.subVectors( point, this.start );
				startEnd.subVectors( this.end, this.start );

				var startEnd2 = startEnd.dot( startEnd );
				var startEnd_startP = startEnd.dot( startP );

				var t = startEnd_startP / startEnd2;

				if ( clampToLine ) {

					t = THREE.Math.clamp( t, 0, 1 );

				}

				return t;

			};

		}(),

		closestPointToPoint: function ( point, clampToLine, optionalTarget ) {

			var t = this.closestPointToPointParameter( point, clampToLine );

			var result = optionalTarget || new THREE.Vector3();

			return this.delta( result ).multiplyScalar( t ).add( this.start );

		},

		applyMatrix4: function ( matrix ) {

			this.start.applyMatrix4( matrix );
			this.end.applyMatrix4( matrix );

			return this;

		},

		equals: function ( line ) {

			return line.start.equals( this.start ) && line.end.equals( this.end );

		}

	};

	// File:src/math/Box2.js

	/**
	 * @author bhouston / http://clara.io
	 */

	THREE.Box2 = function ( min, max ) {

		this.min = ( min !== undefined ) ? min : new THREE.Vector2( Infinity, Infinity );
		this.max = ( max !== undefined ) ? max : new THREE.Vector2( - Infinity, - Infinity );

	};

	THREE.Box2.prototype = {

		constructor: THREE.Box2,

		set: function ( min, max ) {

			this.min.copy( min );
			this.max.copy( max );

			return this;

		},

		setFromPoints: function ( points ) {

			this.makeEmpty();

			for ( var i = 0, il = points.length; i < il; i ++ ) {

				this.expandByPoint( points[ i ] )

			}

			return this;

		},

		setFromCenterAndSize: function () {

			var v1 = new THREE.Vector2();

			return function ( center, size ) {

				var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
				this.min.copy( center ).sub( halfSize );
				this.max.copy( center ).add( halfSize );

				return this;

			};

		}(),
		
		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( box ) {

			this.min.copy( box.min );
			this.max.copy( box.max );

			return this;

		},

		makeEmpty: function () {

			this.min.x = this.min.y = Infinity;
			this.max.x = this.max.y = - Infinity;

			return this;

		},

		empty: function () {

			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

			return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

		},

		center: function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector2();
			return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

		},

		size: function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector2();
			return result.subVectors( this.max, this.min );

		},

		expandByPoint: function ( point ) {

			this.min.min( point );
			this.max.max( point );

			return this;

		},

		expandByVector: function ( vector ) {

			this.min.sub( vector );
			this.max.add( vector );

			return this;

		},

		expandByScalar: function ( scalar ) {

			this.min.addScalar( - scalar );
			this.max.addScalar( scalar );

			return this;

		},

		containsPoint: function ( point ) {

			if ( point.x < this.min.x || point.x > this.max.x ||
			     point.y < this.min.y || point.y > this.max.y ) {

				return false;

			}

			return true;

		},

		containsBox: function ( box ) {

			if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
			     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {

				return true;

			}

			return false;

		},

		getParameter: function ( point, optionalTarget ) {

			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.

			var result = optionalTarget || new THREE.Vector2();

			return result.set(
				( point.x - this.min.x ) / ( this.max.x - this.min.x ),
				( point.y - this.min.y ) / ( this.max.y - this.min.y )
			);

		},

		isIntersectionBox: function ( box ) {

			// using 6 splitting planes to rule out intersections.

			if ( box.max.x < this.min.x || box.min.x > this.max.x ||
			     box.max.y < this.min.y || box.min.y > this.max.y ) {

				return false;

			}

			return true;

		},

		clampPoint: function ( point, optionalTarget ) {

			var result = optionalTarget || new THREE.Vector2();
			return result.copy( point ).clamp( this.min, this.max );

		},

		distanceToPoint: function () {

			var v1 = new THREE.Vector2();

			return function ( point ) {

				var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
				return clampedPoint.sub( point ).length();

			};

		}(),

		intersect: function ( box ) {

			this.min.max( box.min );
			this.max.min( box.max );

			return this;

		},

		union: function ( box ) {

			this.min.min( box.min );
			this.max.max( box.max );

			return this;

		},

		translate: function ( offset ) {

			this.min.add( offset );
			this.max.add( offset );

			return this;

		},

		equals: function ( box ) {

			return box.min.equals( this.min ) && box.max.equals( this.max );

		}

	};

	// File:src/math/Box3.js

	/**
	 * @author bhouston / http://clara.io
	 * @author WestLangley / http://github.com/WestLangley
	 */

	THREE.Box3 = function ( min, max ) {

		this.min = ( min !== undefined ) ? min : new THREE.Vector3( Infinity, Infinity, Infinity );
		this.max = ( max !== undefined ) ? max : new THREE.Vector3( - Infinity, - Infinity, - Infinity );

	};

	THREE.Box3.prototype = {

		constructor: THREE.Box3,

		set: function ( min, max ) {

			this.min.copy( min );
			this.max.copy( max );

			return this;

		},

		setFromPoints: function ( points ) {

			this.makeEmpty();

			for ( var i = 0, il = points.length; i < il; i ++ ) {

				this.expandByPoint( points[ i ] );

			}

			return this;

		},

		setFromCenterAndSize: function () {

			var v1 = new THREE.Vector3();

			return function ( center, size ) {

				var halfSize = v1.copy( size ).multiplyScalar( 0.5 );

				this.min.copy( center ).sub( halfSize );
				this.max.copy( center ).add( halfSize );

				return this;

			};

		}(),

		setFromObject: function () {

			// Computes the world-axis-aligned bounding box of an object (including its children),
			// accounting for both the object's, and children's, world transforms

			var v1 = new THREE.Vector3();

			return function ( object ) {

				var scope = this;

				object.updateMatrixWorld( true );

				this.makeEmpty();

				object.traverse( function ( node ) {

					var geometry = node.geometry;

					if ( geometry !== undefined ) {

						if ( geometry instanceof THREE.Geometry ) {

							var vertices = geometry.vertices;

							for ( var i = 0, il = vertices.length; i < il; i ++ ) {

								v1.copy( vertices[ i ] );

								v1.applyMatrix4( node.matrixWorld );

								scope.expandByPoint( v1 );

							}

						} else if ( geometry instanceof THREE.BufferGeometry && geometry.attributes[ 'position' ] !== undefined ) {

							var positions = geometry.attributes[ 'position' ].array;

							for ( var i = 0, il = positions.length; i < il; i += 3 ) {

								v1.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );

								v1.applyMatrix4( node.matrixWorld );

								scope.expandByPoint( v1 );

							}

						}

					}

				} );

				return this;

			};

		}(),

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( box ) {

			this.min.copy( box.min );
			this.max.copy( box.max );

			return this;

		},

		makeEmpty: function () {

			this.min.x = this.min.y = this.min.z = Infinity;
			this.max.x = this.max.y = this.max.z = - Infinity;

			return this;

		},

		empty: function () {

			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

			return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

		},

		center: function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();
			return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

		},

		size: function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();
			return result.subVectors( this.max, this.min );

		},

		expandByPoint: function ( point ) {

			this.min.min( point );
			this.max.max( point );

			return this;

		},

		expandByVector: function ( vector ) {

			this.min.sub( vector );
			this.max.add( vector );

			return this;

		},

		expandByScalar: function ( scalar ) {

			this.min.addScalar( - scalar );
			this.max.addScalar( scalar );

			return this;

		},

		containsPoint: function ( point ) {

			if ( point.x < this.min.x || point.x > this.max.x ||
			     point.y < this.min.y || point.y > this.max.y ||
			     point.z < this.min.z || point.z > this.max.z ) {

				return false;

			}

			return true;

		},

		containsBox: function ( box ) {

			if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
				 ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&
				 ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {

				return true;

			}

			return false;

		},

		getParameter: function ( point, optionalTarget ) {

			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.

			var result = optionalTarget || new THREE.Vector3();

			return result.set(
				( point.x - this.min.x ) / ( this.max.x - this.min.x ),
				( point.y - this.min.y ) / ( this.max.y - this.min.y ),
				( point.z - this.min.z ) / ( this.max.z - this.min.z )
			);

		},

		isIntersectionBox: function ( box ) {

			// using 6 splitting planes to rule out intersections.

			if ( box.max.x < this.min.x || box.min.x > this.max.x ||
			     box.max.y < this.min.y || box.min.y > this.max.y ||
			     box.max.z < this.min.z || box.min.z > this.max.z ) {

				return false;

			}

			return true;

		},

		clampPoint: function ( point, optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();
			return result.copy( point ).clamp( this.min, this.max );

		},

		distanceToPoint: function () {

			var v1 = new THREE.Vector3();

			return function ( point ) {

				var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
				return clampedPoint.sub( point ).length();

			};

		}(),

		getBoundingSphere: function () {

			var v1 = new THREE.Vector3();

			return function ( optionalTarget ) {

				var result = optionalTarget || new THREE.Sphere();

				result.center = this.center();
				result.radius = this.size( v1 ).length() * 0.5;

				return result;

			};

		}(),

		intersect: function ( box ) {

			this.min.max( box.min );
			this.max.min( box.max );

			return this;

		},

		union: function ( box ) {

			this.min.min( box.min );
			this.max.max( box.max );

			return this;

		},

		applyMatrix4: function () {

			var points = [
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3()
			];

			return function ( matrix ) {

				// NOTE: I am using a binary pattern to specify all 2^3 combinations below
				points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
				points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
				points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
				points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
				points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
				points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
				points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
				points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );  // 111

				this.makeEmpty();
				this.setFromPoints( points );

				return this;

			};

		}(),

		translate: function ( offset ) {

			this.min.add( offset );
			this.max.add( offset );

			return this;

		},

		equals: function ( box ) {

			return box.min.equals( this.min ) && box.max.equals( this.max );

		}

	};

	// File:src/math/Matrix3.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://clara.io
	 */

	THREE.Matrix3 = function () {

		this.elements = new Float32Array( [

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		] );

		if ( arguments.length > 0 ) {

			console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

		}

	};

	THREE.Matrix3.prototype = {

		constructor: THREE.Matrix3,

		set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

			var te = this.elements;

			te[ 0 ] = n11; te[ 3 ] = n12; te[ 6 ] = n13;
			te[ 1 ] = n21; te[ 4 ] = n22; te[ 7 ] = n23;
			te[ 2 ] = n31; te[ 5 ] = n32; te[ 8 ] = n33;

			return this;

		},

		identity: function () {

			this.set(

				1, 0, 0,
				0, 1, 0,
				0, 0, 1

			);

			return this;

		},

		clone: function () {

			return new this.constructor().fromArray( this.elements );

		},

		copy: function ( m ) {

			var me = m.elements;

			this.set(

				me[ 0 ], me[ 3 ], me[ 6 ],
				me[ 1 ], me[ 4 ], me[ 7 ],
				me[ 2 ], me[ 5 ], me[ 8 ]

			);

			return this;

		},

		multiplyVector3: function ( vector ) {

			console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
			return vector.applyMatrix3( this );

		},

		multiplyVector3Array: function ( a ) {

			console.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
			return this.applyToVector3Array( a );

		},

		applyToVector3Array: function () {

			var v1;

			return function ( array, offset, length ) {

				if ( v1 === undefined ) v1 = new THREE.Vector3();
				if ( offset === undefined ) offset = 0;
				if ( length === undefined ) length = array.length;

				for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {

					v1.fromArray( array, j );
					v1.applyMatrix3( this );
					v1.toArray( array, j );

				}

				return array;

			};

		}(),

		applyToBuffer: function () {

			var v1;

			return function applyToBuffer( buffer, offset, length ) {

				if ( v1 === undefined ) v1 = new THREE.Vector3();
				if ( offset === undefined ) offset = 0;
				if ( length === undefined ) length = buffer.length / buffer.itemSize;

				for ( var i = 0, j = offset; i < length; i ++, j ++ ) {

					v1.x = buffer.getX( j );
					v1.y = buffer.getY( j );
					v1.z = buffer.getZ( j );

					v1.applyMatrix3( this );

					buffer.setXYZ( v1.x, v1.y, v1.z );

				}

				return buffer;

			};

		}(),

		multiplyScalar: function ( s ) {

			var te = this.elements;

			te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
			te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
			te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

			return this;

		},

		determinant: function () {

			var te = this.elements;

			var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
				d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
				g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

			return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

		},

		getInverse: function ( matrix, throwOnInvertible ) {

			// input: THREE.Matrix4
			// ( based on http://code.google.com/p/webgl-mjs/ )

			var me = matrix.elements;
			var te = this.elements;

			te[ 0 ] =   me[ 10 ] * me[ 5 ] - me[ 6 ] * me[ 9 ];
			te[ 1 ] = - me[ 10 ] * me[ 1 ] + me[ 2 ] * me[ 9 ];
			te[ 2 ] =   me[ 6 ] * me[ 1 ] - me[ 2 ] * me[ 5 ];
			te[ 3 ] = - me[ 10 ] * me[ 4 ] + me[ 6 ] * me[ 8 ];
			te[ 4 ] =   me[ 10 ] * me[ 0 ] - me[ 2 ] * me[ 8 ];
			te[ 5 ] = - me[ 6 ] * me[ 0 ] + me[ 2 ] * me[ 4 ];
			te[ 6 ] =   me[ 9 ] * me[ 4 ] - me[ 5 ] * me[ 8 ];
			te[ 7 ] = - me[ 9 ] * me[ 0 ] + me[ 1 ] * me[ 8 ];
			te[ 8 ] =   me[ 5 ] * me[ 0 ] - me[ 1 ] * me[ 4 ];

			var det = me[ 0 ] * te[ 0 ] + me[ 1 ] * te[ 3 ] + me[ 2 ] * te[ 6 ];

			// no inverse

			if ( det === 0 ) {

				var msg = "Matrix3.getInverse(): can't invert matrix, determinant is 0";

				if ( throwOnInvertible || false ) {

					throw new Error( msg );

				} else {

					console.warn( msg );

				}

				this.identity();

				return this;

			}

			this.multiplyScalar( 1.0 / det );

			return this;

		},

		transpose: function () {

			var tmp, m = this.elements;

			tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
			tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
			tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

			return this;

		},

		flattenToArrayOffset: function ( array, offset ) {

			var te = this.elements;

			array[ offset ] = te[ 0 ];
			array[ offset + 1 ] = te[ 1 ];
			array[ offset + 2 ] = te[ 2 ];

			array[ offset + 3 ] = te[ 3 ];
			array[ offset + 4 ] = te[ 4 ];
			array[ offset + 5 ] = te[ 5 ];

			array[ offset + 6 ] = te[ 6 ];
			array[ offset + 7 ] = te[ 7 ];
			array[ offset + 8 ]  = te[ 8 ];

			return array;

		},

		getNormalMatrix: function ( m ) {

			// input: THREE.Matrix4

			this.getInverse( m ).transpose();

			return this;

		},

		transposeIntoArray: function ( r ) {

			var m = this.elements;

			r[ 0 ] = m[ 0 ];
			r[ 1 ] = m[ 3 ];
			r[ 2 ] = m[ 6 ];
			r[ 3 ] = m[ 1 ];
			r[ 4 ] = m[ 4 ];
			r[ 5 ] = m[ 7 ];
			r[ 6 ] = m[ 2 ];
			r[ 7 ] = m[ 5 ];
			r[ 8 ] = m[ 8 ];

			return this;

		},

		fromArray: function ( array ) {

			this.elements.set( array );

			return this;

		},

		toArray: function () {

			var te = this.elements;

			return [
				te[ 0 ], te[ 1 ], te[ 2 ],
				te[ 3 ], te[ 4 ], te[ 5 ],
				te[ 6 ], te[ 7 ], te[ 8 ]
			];

		}

	};

	// File:src/math/Matrix4.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author philogb / http://blog.thejit.org/
	 * @author jordi_ros / http://plattsoft.com
	 * @author D1plo1d / http://github.com/D1plo1d
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author timknip / http://www.floorplanner.com/
	 * @author bhouston / http://clara.io
	 * @author WestLangley / http://github.com/WestLangley
	 */

	THREE.Matrix4 = function () {

		this.elements = new Float32Array( [

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		] );

		if ( arguments.length > 0 ) {

			console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

		}

	};

	THREE.Matrix4.prototype = {

		constructor: THREE.Matrix4,

		set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

			var te = this.elements;

			te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
			te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
			te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
			te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

			return this;

		},

		identity: function () {

			this.set(

				1, 0, 0, 0,
				0, 1, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1

			);

			return this;

		},

		clone: function () {

			return new THREE.Matrix4().fromArray( this.elements );

		},

		copy: function ( m ) {

			this.elements.set( m.elements );

			return this;

		},

		extractPosition: function ( m ) {

			console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
			return this.copyPosition( m );

		},

		copyPosition: function ( m ) {

			var te = this.elements;
			var me = m.elements;

			te[ 12 ] = me[ 12 ];
			te[ 13 ] = me[ 13 ];
			te[ 14 ] = me[ 14 ];

			return this;

		},

		extractBasis: function ( xAxis, yAxis, zAxis ) {

			var te = this.elements;

			xAxis.set( te[ 0 ], te[ 1 ], te[ 2 ] );
			yAxis.set( te[ 4 ], te[ 5 ], te[ 6 ] );
			zAxis.set( te[ 8 ], te[ 9 ], te[ 10 ] );

			return this;

		},

		makeBasis: function ( xAxis, yAxis, zAxis ) {

			this.set(
				xAxis.x, yAxis.x, zAxis.x, 0,
				xAxis.y, yAxis.y, zAxis.y, 0,
				xAxis.z, yAxis.z, zAxis.z, 0,
				0,       0,       0,       1
			);

			return this;

		},

		extractRotation: function () {

			var v1;

			return function ( m ) {

				if ( v1 === undefined ) v1 = new THREE.Vector3();

				var te = this.elements;
				var me = m.elements;

				var scaleX = 1 / v1.set( me[ 0 ], me[ 1 ], me[ 2 ] ).length();
				var scaleY = 1 / v1.set( me[ 4 ], me[ 5 ], me[ 6 ] ).length();
				var scaleZ = 1 / v1.set( me[ 8 ], me[ 9 ], me[ 10 ] ).length();

				te[ 0 ] = me[ 0 ] * scaleX;
				te[ 1 ] = me[ 1 ] * scaleX;
				te[ 2 ] = me[ 2 ] * scaleX;

				te[ 4 ] = me[ 4 ] * scaleY;
				te[ 5 ] = me[ 5 ] * scaleY;
				te[ 6 ] = me[ 6 ] * scaleY;

				te[ 8 ] = me[ 8 ] * scaleZ;
				te[ 9 ] = me[ 9 ] * scaleZ;
				te[ 10 ] = me[ 10 ] * scaleZ;

				return this;

			};

		}(),

		makeRotationFromEuler: function ( euler ) {

			if ( euler instanceof THREE.Euler === false ) {

				console.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

			}

			var te = this.elements;

			var x = euler.x, y = euler.y, z = euler.z;
			var a = Math.cos( x ), b = Math.sin( x );
			var c = Math.cos( y ), d = Math.sin( y );
			var e = Math.cos( z ), f = Math.sin( z );

			if ( euler.order === 'XYZ' ) {

				var ae = a * e, af = a * f, be = b * e, bf = b * f;

				te[ 0 ] = c * e;
				te[ 4 ] = - c * f;
				te[ 8 ] = d;

				te[ 1 ] = af + be * d;
				te[ 5 ] = ae - bf * d;
				te[ 9 ] = - b * c;

				te[ 2 ] = bf - ae * d;
				te[ 6 ] = be + af * d;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'YXZ' ) {

				var ce = c * e, cf = c * f, de = d * e, df = d * f;

				te[ 0 ] = ce + df * b;
				te[ 4 ] = de * b - cf;
				te[ 8 ] = a * d;

				te[ 1 ] = a * f;
				te[ 5 ] = a * e;
				te[ 9 ] = - b;

				te[ 2 ] = cf * b - de;
				te[ 6 ] = df + ce * b;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'ZXY' ) {

				var ce = c * e, cf = c * f, de = d * e, df = d * f;

				te[ 0 ] = ce - df * b;
				te[ 4 ] = - a * f;
				te[ 8 ] = de + cf * b;

				te[ 1 ] = cf + de * b;
				te[ 5 ] = a * e;
				te[ 9 ] = df - ce * b;

				te[ 2 ] = - a * d;
				te[ 6 ] = b;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'ZYX' ) {

				var ae = a * e, af = a * f, be = b * e, bf = b * f;

				te[ 0 ] = c * e;
				te[ 4 ] = be * d - af;
				te[ 8 ] = ae * d + bf;

				te[ 1 ] = c * f;
				te[ 5 ] = bf * d + ae;
				te[ 9 ] = af * d - be;

				te[ 2 ] = - d;
				te[ 6 ] = b * c;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'YZX' ) {

				var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

				te[ 0 ] = c * e;
				te[ 4 ] = bd - ac * f;
				te[ 8 ] = bc * f + ad;

				te[ 1 ] = f;
				te[ 5 ] = a * e;
				te[ 9 ] = - b * e;

				te[ 2 ] = - d * e;
				te[ 6 ] = ad * f + bc;
				te[ 10 ] = ac - bd * f;

			} else if ( euler.order === 'XZY' ) {

				var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

				te[ 0 ] = c * e;
				te[ 4 ] = - f;
				te[ 8 ] = d * e;

				te[ 1 ] = ac * f + bd;
				te[ 5 ] = a * e;
				te[ 9 ] = ad * f - bc;

				te[ 2 ] = bc * f - ad;
				te[ 6 ] = b * e;
				te[ 10 ] = bd * f + ac;

			}

			// last column
			te[ 3 ] = 0;
			te[ 7 ] = 0;
			te[ 11 ] = 0;

			// bottom row
			te[ 12 ] = 0;
			te[ 13 ] = 0;
			te[ 14 ] = 0;
			te[ 15 ] = 1;

			return this;

		},

		setRotationFromQuaternion: function ( q ) {

			console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );

			return this.makeRotationFromQuaternion( q );

		},

		makeRotationFromQuaternion: function ( q ) {

			var te = this.elements;

			var x = q.x, y = q.y, z = q.z, w = q.w;
			var x2 = x + x, y2 = y + y, z2 = z + z;
			var xx = x * x2, xy = x * y2, xz = x * z2;
			var yy = y * y2, yz = y * z2, zz = z * z2;
			var wx = w * x2, wy = w * y2, wz = w * z2;

			te[ 0 ] = 1 - ( yy + zz );
			te[ 4 ] = xy - wz;
			te[ 8 ] = xz + wy;

			te[ 1 ] = xy + wz;
			te[ 5 ] = 1 - ( xx + zz );
			te[ 9 ] = yz - wx;

			te[ 2 ] = xz - wy;
			te[ 6 ] = yz + wx;
			te[ 10 ] = 1 - ( xx + yy );

			// last column
			te[ 3 ] = 0;
			te[ 7 ] = 0;
			te[ 11 ] = 0;

			// bottom row
			te[ 12 ] = 0;
			te[ 13 ] = 0;
			te[ 14 ] = 0;
			te[ 15 ] = 1;

			return this;

		},

		lookAt: function () {

			var x, y, z;

			return function ( eye, target, up ) {

				if ( x === undefined ) x = new THREE.Vector3();
				if ( y === undefined ) y = new THREE.Vector3();
				if ( z === undefined ) z = new THREE.Vector3();

				var te = this.elements;

				z.subVectors( eye, target ).normalize();

				if ( z.lengthSq() === 0 ) {

					z.z = 1;

				}

				x.crossVectors( up, z ).normalize();

				if ( x.lengthSq() === 0 ) {

					z.x += 0.0001;
					x.crossVectors( up, z ).normalize();

				}

				y.crossVectors( z, x );


				te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;
				te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;
				te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;

				return this;

			};

		}(),

		multiply: function ( m, n ) {

			if ( n !== undefined ) {

				console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
				return this.multiplyMatrices( m, n );

			}

			return this.multiplyMatrices( this, m );

		},

		multiplyMatrices: function ( a, b ) {

			var ae = a.elements;
			var be = b.elements;
			var te = this.elements;

			var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
			var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
			var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
			var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

			var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
			var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
			var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
			var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

			te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
			te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
			te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
			te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

			te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
			te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
			te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
			te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

			te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
			te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
			te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
			te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

			te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
			te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
			te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
			te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

			return this;

		},

		multiplyToArray: function ( a, b, r ) {

			var te = this.elements;

			this.multiplyMatrices( a, b );

			r[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];
			r[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];
			r[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];
			r[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];

			return this;

		},

		multiplyScalar: function ( s ) {

			var te = this.elements;

			te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
			te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
			te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
			te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

			return this;

		},

		multiplyVector3: function ( vector ) {

			console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );
			return vector.applyProjection( this );

		},

		multiplyVector4: function ( vector ) {

			console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
			return vector.applyMatrix4( this );

		},

		multiplyVector3Array: function ( a ) {

			console.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
			return this.applyToVector3Array( a );

		},

		applyToVector3Array: function () {

			var v1;

			return function ( array, offset, length ) {

				if ( v1 === undefined ) v1 = new THREE.Vector3();
				if ( offset === undefined ) offset = 0;
				if ( length === undefined ) length = array.length;

				for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {

					v1.fromArray( array, j );
					v1.applyMatrix4( this );
					v1.toArray( array, j );

				}

				return array;

			};

		}(),

		applyToBuffer: function () {

			var v1;

			return function applyToBuffer( buffer, offset, length ) {

				if ( v1 === undefined ) v1 = new THREE.Vector3();
				if ( offset === undefined ) offset = 0;
				if ( length === undefined ) length = buffer.length / buffer.itemSize;

				for ( var i = 0, j = offset; i < length; i ++, j ++ ) {

					v1.x = buffer.getX( j );
					v1.y = buffer.getY( j );
					v1.z = buffer.getZ( j );

					v1.applyMatrix4( this );

					buffer.setXYZ( v1.x, v1.y, v1.z );

				}

				return buffer;

			};

		}(),

		rotateAxis: function ( v ) {

			console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );

			v.transformDirection( this );

		},

		crossVector: function ( vector ) {

			console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
			return vector.applyMatrix4( this );

		},

		determinant: function () {

			var te = this.elements;

			var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
			var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
			var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
			var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

			//TODO: make this more efficient
			//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

			return (
				n41 * (
					+ n14 * n23 * n32
					 - n13 * n24 * n32
					 - n14 * n22 * n33
					 + n12 * n24 * n33
					 + n13 * n22 * n34
					 - n12 * n23 * n34
				) +
				n42 * (
					+ n11 * n23 * n34
					 - n11 * n24 * n33
					 + n14 * n21 * n33
					 - n13 * n21 * n34
					 + n13 * n24 * n31
					 - n14 * n23 * n31
				) +
				n43 * (
					+ n11 * n24 * n32
					 - n11 * n22 * n34
					 - n14 * n21 * n32
					 + n12 * n21 * n34
					 + n14 * n22 * n31
					 - n12 * n24 * n31
				) +
				n44 * (
					- n13 * n22 * n31
					 - n11 * n23 * n32
					 + n11 * n22 * n33
					 + n13 * n21 * n32
					 - n12 * n21 * n33
					 + n12 * n23 * n31
				)

			);

		},

		transpose: function () {

			var te = this.elements;
			var tmp;

			tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
			tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
			tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

			tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
			tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
			tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

			return this;

		},

		flattenToArrayOffset: function ( array, offset ) {

			var te = this.elements;

			array[ offset ] = te[ 0 ];
			array[ offset + 1 ] = te[ 1 ];
			array[ offset + 2 ] = te[ 2 ];
			array[ offset + 3 ] = te[ 3 ];

			array[ offset + 4 ] = te[ 4 ];
			array[ offset + 5 ] = te[ 5 ];
			array[ offset + 6 ] = te[ 6 ];
			array[ offset + 7 ] = te[ 7 ];

			array[ offset + 8 ]  = te[ 8 ];
			array[ offset + 9 ]  = te[ 9 ];
			array[ offset + 10 ] = te[ 10 ];
			array[ offset + 11 ] = te[ 11 ];

			array[ offset + 12 ] = te[ 12 ];
			array[ offset + 13 ] = te[ 13 ];
			array[ offset + 14 ] = te[ 14 ];
			array[ offset + 15 ] = te[ 15 ];

			return array;

		},

		getPosition: function () {

			var v1;

			return function () {

				if ( v1 === undefined ) v1 = new THREE.Vector3();
				console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );

				var te = this.elements;
				return v1.set( te[ 12 ], te[ 13 ], te[ 14 ] );

			};

		}(),

		setPosition: function ( v ) {

			var te = this.elements;

			te[ 12 ] = v.x;
			te[ 13 ] = v.y;
			te[ 14 ] = v.z;

			return this;

		},

		getInverse: function ( m, throwOnInvertible ) {

			// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
			var te = this.elements;
			var me = m.elements;

			var n11 = me[ 0 ], n12 = me[ 4 ], n13 = me[ 8 ], n14 = me[ 12 ];
			var n21 = me[ 1 ], n22 = me[ 5 ], n23 = me[ 9 ], n24 = me[ 13 ];
			var n31 = me[ 2 ], n32 = me[ 6 ], n33 = me[ 10 ], n34 = me[ 14 ];
			var n41 = me[ 3 ], n42 = me[ 7 ], n43 = me[ 11 ], n44 = me[ 15 ];

			te[ 0 ] = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;
			te[ 4 ] = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;
			te[ 8 ] = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;
			te[ 12 ] = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
			te[ 1 ] = n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44;
			te[ 5 ] = n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44;
			te[ 9 ] = n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44;
			te[ 13 ] = n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34;
			te[ 2 ] = n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44;
			te[ 6 ] = n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44;
			te[ 10 ] = n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44;
			te[ 14 ] = n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34;
			te[ 3 ] = n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43;
			te[ 7 ] = n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43;
			te[ 11 ] = n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43;
			te[ 15 ] = n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33;

			var det = n11 * te[ 0 ] + n21 * te[ 4 ] + n31 * te[ 8 ] + n41 * te[ 12 ];

			if ( det === 0 ) {

				var msg = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";

				if ( throwOnInvertible || false ) {

					throw new Error( msg );

				} else {

					console.warn( msg );

				}

				this.identity();

				return this;

			}

			this.multiplyScalar( 1 / det );

			return this;

		},

		translate: function ( v ) {

			console.error( 'THREE.Matrix4: .translate() has been removed.' );

		},

		rotateX: function ( angle ) {

			console.error( 'THREE.Matrix4: .rotateX() has been removed.' );

		},

		rotateY: function ( angle ) {

			console.error( 'THREE.Matrix4: .rotateY() has been removed.' );

		},

		rotateZ: function ( angle ) {

			console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );

		},

		rotateByAxis: function ( axis, angle ) {

			console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );

		},

		scale: function ( v ) {

			var te = this.elements;
			var x = v.x, y = v.y, z = v.z;

			te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
			te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
			te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
			te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

			return this;

		},

		getMaxScaleOnAxis: function () {

			var te = this.elements;

			var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
			var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
			var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

			return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

		},

		makeTranslation: function ( x, y, z ) {

			this.set(

				1, 0, 0, x,
				0, 1, 0, y,
				0, 0, 1, z,
				0, 0, 0, 1

			);

			return this;

		},

		makeRotationX: function ( theta ) {

			var c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				1, 0,  0, 0,
				0, c, - s, 0,
				0, s,  c, 0,
				0, 0,  0, 1

			);

			return this;

		},

		makeRotationY: function ( theta ) {

			var c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				 c, 0, s, 0,
				 0, 1, 0, 0,
				- s, 0, c, 0,
				 0, 0, 0, 1

			);

			return this;

		},

		makeRotationZ: function ( theta ) {

			var c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				c, - s, 0, 0,
				s,  c, 0, 0,
				0,  0, 1, 0,
				0,  0, 0, 1

			);

			return this;

		},

		makeRotationAxis: function ( axis, angle ) {

			// Based on http://www.gamedev.net/reference/articles/article1199.asp

			var c = Math.cos( angle );
			var s = Math.sin( angle );
			var t = 1 - c;
			var x = axis.x, y = axis.y, z = axis.z;
			var tx = t * x, ty = t * y;

			this.set(

				tx * x + c, tx * y - s * z, tx * z + s * y, 0,
				tx * y + s * z, ty * y + c, ty * z - s * x, 0,
				tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
				0, 0, 0, 1

			);

			 return this;

		},

		makeScale: function ( x, y, z ) {

			this.set(

				x, 0, 0, 0,
				0, y, 0, 0,
				0, 0, z, 0,
				0, 0, 0, 1

			);

			return this;

		},

		compose: function ( position, quaternion, scale ) {

			this.makeRotationFromQuaternion( quaternion );
			this.scale( scale );
			this.setPosition( position );

			return this;

		},

		decompose: function () {

			var vector, matrix;

			return function ( position, quaternion, scale ) {

				if ( vector === undefined ) vector = new THREE.Vector3();
				if ( matrix === undefined ) matrix = new THREE.Matrix4();

				var te = this.elements;

				var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
				var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
				var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

				// if determine is negative, we need to invert one scale
				var det = this.determinant();
				if ( det < 0 ) {

					sx = - sx;

				}

				position.x = te[ 12 ];
				position.y = te[ 13 ];
				position.z = te[ 14 ];

				// scale the rotation part

				matrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()

				var invSX = 1 / sx;
				var invSY = 1 / sy;
				var invSZ = 1 / sz;

				matrix.elements[ 0 ] *= invSX;
				matrix.elements[ 1 ] *= invSX;
				matrix.elements[ 2 ] *= invSX;

				matrix.elements[ 4 ] *= invSY;
				matrix.elements[ 5 ] *= invSY;
				matrix.elements[ 6 ] *= invSY;

				matrix.elements[ 8 ] *= invSZ;
				matrix.elements[ 9 ] *= invSZ;
				matrix.elements[ 10 ] *= invSZ;

				quaternion.setFromRotationMatrix( matrix );

				scale.x = sx;
				scale.y = sy;
				scale.z = sz;

				return this;

			};

		}(),

		makeFrustum: function ( left, right, bottom, top, near, far ) {

			var te = this.elements;
			var x = 2 * near / ( right - left );
			var y = 2 * near / ( top - bottom );

			var a = ( right + left ) / ( right - left );
			var b = ( top + bottom ) / ( top - bottom );
			var c = - ( far + near ) / ( far - near );
			var d = - 2 * far * near / ( far - near );

			te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
			te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
			te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
			te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

			return this;

		},

		makePerspective: function ( fov, aspect, near, far ) {

			var ymax = near * Math.tan( THREE.Math.degToRad( fov * 0.5 ) );
			var ymin = - ymax;
			var xmin = ymin * aspect;
			var xmax = ymax * aspect;

			return this.makeFrustum( xmin, xmax, ymin, ymax, near, far );

		},

		makeOrthographic: function ( left, right, top, bottom, near, far ) {

			var te = this.elements;
			var w = right - left;
			var h = top - bottom;
			var p = far - near;

			var x = ( right + left ) / w;
			var y = ( top + bottom ) / h;
			var z = ( far + near ) / p;

			te[ 0 ] = 2 / w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
			te[ 1 ] = 0;	te[ 5 ] = 2 / h;	te[ 9 ] = 0;	te[ 13 ] = - y;
			te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 / p;	te[ 14 ] = - z;
			te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

			return this;

		},

		equals: function ( matrix ) {

			var te = this.elements;
			var me = matrix.elements;

			for ( var i = 0; i < 16; i ++ ) {

				if ( te[ i ] !== me[ i ] ) return false;

			}

			return true;

		},

		fromArray: function ( array ) {

			this.elements.set( array );

			return this;

		},

		toArray: function () {

			var te = this.elements;

			return [
				te[ 0 ], te[ 1 ], te[ 2 ], te[ 3 ],
				te[ 4 ], te[ 5 ], te[ 6 ], te[ 7 ],
				te[ 8 ], te[ 9 ], te[ 10 ], te[ 11 ],
				te[ 12 ], te[ 13 ], te[ 14 ], te[ 15 ]
			];

		}

	};

	// File:src/math/Ray.js

	/**
	 * @author bhouston / http://clara.io
	 */

	THREE.Ray = function ( origin, direction ) {

		this.origin = ( origin !== undefined ) ? origin : new THREE.Vector3();
		this.direction = ( direction !== undefined ) ? direction : new THREE.Vector3();

	};

	THREE.Ray.prototype = {

		constructor: THREE.Ray,

		set: function ( origin, direction ) {

			this.origin.copy( origin );
			this.direction.copy( direction );

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( ray ) {

			this.origin.copy( ray.origin );
			this.direction.copy( ray.direction );

			return this;

		},

		at: function ( t, optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();

			return result.copy( this.direction ).multiplyScalar( t ).add( this.origin );

		},

		recast: function () {

			var v1 = new THREE.Vector3();

			return function ( t ) {

				this.origin.copy( this.at( t, v1 ) );

				return this;

			};

		}(),

		closestPointToPoint: function ( point, optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();
			result.subVectors( point, this.origin );
			var directionDistance = result.dot( this.direction );

			if ( directionDistance < 0 ) {

				return result.copy( this.origin );

			}

			return result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

		},

		distanceToPoint: function ( point ) {

			return Math.sqrt( this.distanceSqToPoint( point ) );

		},

		distanceSqToPoint: function () {

			var v1 = new THREE.Vector3();

			return function ( point ) {

				var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );

				// point behind the ray

				if ( directionDistance < 0 ) {

					return this.origin.distanceToSquared( point );

				}

				v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

				return v1.distanceToSquared( point );

			};

		}(),

		distanceSqToSegment: function () {

			var segCenter = new THREE.Vector3();
			var segDir = new THREE.Vector3();
			var diff = new THREE.Vector3();

			return function ( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

				// from http://www.geometrictools.com/LibMathematics/Distance/Wm5DistRay3Segment3.cpp
				// It returns the min distance between the ray and the segment
				// defined by v0 and v1
				// It can also set two optional targets :
				// - The closest point on the ray
				// - The closest point on the segment

				segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
				segDir.copy( v1 ).sub( v0 ).normalize();
				diff.copy( this.origin ).sub( segCenter );

				var segExtent = v0.distanceTo( v1 ) * 0.5;
				var a01 = - this.direction.dot( segDir );
				var b0 = diff.dot( this.direction );
				var b1 = - diff.dot( segDir );
				var c = diff.lengthSq();
				var det = Math.abs( 1 - a01 * a01 );
				var s0, s1, sqrDist, extDet;

				if ( det > 0 ) {

					// The ray and segment are not parallel.

					s0 = a01 * b1 - b0;
					s1 = a01 * b0 - b1;
					extDet = segExtent * det;

					if ( s0 >= 0 ) {

						if ( s1 >= - extDet ) {

							if ( s1 <= extDet ) {

								// region 0
								// Minimum at interior points of ray and segment.

								var invDet = 1 / det;
								s0 *= invDet;
								s1 *= invDet;
								sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

							} else {

								// region 1

								s1 = segExtent;
								s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
								sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

							}

						} else {

							// region 5

							s1 = - segExtent;
							s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

						}

					} else {

						if ( s1 <= - extDet ) {

							// region 4

							s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
							s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

						} else if ( s1 <= extDet ) {

							// region 3

							s0 = 0;
							s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
							sqrDist = s1 * ( s1 + 2 * b1 ) + c;

						} else {

							// region 2

							s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
							s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

						}

					}

				} else {

					// Ray and segment are parallel.

					s1 = ( a01 > 0 ) ? - segExtent : segExtent;
					s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				}

				if ( optionalPointOnRay ) {

					optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );

				}

				if ( optionalPointOnSegment ) {

					optionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );

				}

				return sqrDist;

			};

		}(),


		isIntersectionSphere: function ( sphere ) {

			return this.distanceToPoint( sphere.center ) <= sphere.radius;

		},

		intersectSphere: function () {

			// from http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-sphere-intersection/

			var v1 = new THREE.Vector3();

			return function ( sphere, optionalTarget ) {

				v1.subVectors( sphere.center, this.origin );

				var tca = v1.dot( this.direction );

				var d2 = v1.dot( v1 ) - tca * tca;

				var radius2 = sphere.radius * sphere.radius;

				if ( d2 > radius2 ) return null;

				var thc = Math.sqrt( radius2 - d2 );

				// t0 = first intersect point - entrance on front of sphere
				var t0 = tca - thc;

				// t1 = second intersect point - exit point on back of sphere
				var t1 = tca + thc;

				// test to see if both t0 and t1 are behind the ray - if so, return null
				if ( t0 < 0 && t1 < 0 ) return null;

				// test to see if t0 is behind the ray:
				// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
				// in order to always return an intersect point that is in front of the ray.
				if ( t0 < 0 ) return this.at( t1, optionalTarget );

				// else t0 is in front of the ray, so return the first collision point scaled by t0
				return this.at( t0, optionalTarget );

			}

		}(),

		isIntersectionPlane: function ( plane ) {

			// check if the ray lies on the plane first

			var distToPoint = plane.distanceToPoint( this.origin );

			if ( distToPoint === 0 ) {

				return true;

			}

			var denominator = plane.normal.dot( this.direction );

			if ( denominator * distToPoint < 0 ) {

				return true;

			}

			// ray origin is behind the plane (and is pointing behind it)

			return false;

		},

		distanceToPlane: function ( plane ) {

			var denominator = plane.normal.dot( this.direction );
			if ( denominator === 0 ) {

				// line is coplanar, return origin
				if ( plane.distanceToPoint( this.origin ) === 0 ) {

					return 0;

				}

				// Null is preferable to undefined since undefined means.... it is undefined

				return null;

			}

			var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

			// Return if the ray never intersects the plane

			return t >= 0 ? t :  null;

		},

		intersectPlane: function ( plane, optionalTarget ) {

			var t = this.distanceToPlane( plane );

			if ( t === null ) {

				return null;

			}

			return this.at( t, optionalTarget );

		},

		isIntersectionBox: function () {

			var v = new THREE.Vector3();

			return function ( box ) {

				return this.intersectBox( box, v ) !== null;

			};

		}(),

		intersectBox: function ( box, optionalTarget ) {

			// http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-box-intersection/

			var tmin, tmax, tymin, tymax, tzmin, tzmax;

			var invdirx = 1 / this.direction.x,
				invdiry = 1 / this.direction.y,
				invdirz = 1 / this.direction.z;

			var origin = this.origin;

			if ( invdirx >= 0 ) {

				tmin = ( box.min.x - origin.x ) * invdirx;
				tmax = ( box.max.x - origin.x ) * invdirx;

			} else {

				tmin = ( box.max.x - origin.x ) * invdirx;
				tmax = ( box.min.x - origin.x ) * invdirx;

			}

			if ( invdiry >= 0 ) {

				tymin = ( box.min.y - origin.y ) * invdiry;
				tymax = ( box.max.y - origin.y ) * invdiry;

			} else {

				tymin = ( box.max.y - origin.y ) * invdiry;
				tymax = ( box.min.y - origin.y ) * invdiry;

			}

			if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

			// These lines also handle the case where tmin or tmax is NaN
			// (result of 0 * Infinity). x !== x returns true if x is NaN

			if ( tymin > tmin || tmin !== tmin ) tmin = tymin;

			if ( tymax < tmax || tmax !== tmax ) tmax = tymax;

			if ( invdirz >= 0 ) {

				tzmin = ( box.min.z - origin.z ) * invdirz;
				tzmax = ( box.max.z - origin.z ) * invdirz;

			} else {

				tzmin = ( box.max.z - origin.z ) * invdirz;
				tzmax = ( box.min.z - origin.z ) * invdirz;

			}

			if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

			if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

			if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

			//return point closest to the ray (positive side)

			if ( tmax < 0 ) return null;

			return this.at( tmin >= 0 ? tmin : tmax, optionalTarget );

		},

		intersectTriangle: function () {

			// Compute the offset origin, edges, and normal.
			var diff = new THREE.Vector3();
			var edge1 = new THREE.Vector3();
			var edge2 = new THREE.Vector3();
			var normal = new THREE.Vector3();

			return function ( a, b, c, backfaceCulling, optionalTarget ) {

				// from http://www.geometrictools.com/LibMathematics/Intersection/Wm5IntrRay3Triangle3.cpp

				edge1.subVectors( b, a );
				edge2.subVectors( c, a );
				normal.crossVectors( edge1, edge2 );

				// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
				// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
				//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
				//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
				//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
				var DdN = this.direction.dot( normal );
				var sign;

				if ( DdN > 0 ) {

					if ( backfaceCulling ) return null;
					sign = 1;

				} else if ( DdN < 0 ) {

					sign = - 1;
					DdN = - DdN;

				} else {

					return null;

				}

				diff.subVectors( this.origin, a );
				var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );

				// b1 < 0, no intersection
				if ( DdQxE2 < 0 ) {

					return null;

				}

				var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );

				// b2 < 0, no intersection
				if ( DdE1xQ < 0 ) {

					return null;

				}

				// b1+b2 > 1, no intersection
				if ( DdQxE2 + DdE1xQ > DdN ) {

					return null;

				}

				// Line intersects triangle, check if ray does.
				var QdN = - sign * diff.dot( normal );

				// t < 0, no intersection
				if ( QdN < 0 ) {

					return null;

				}

				// Ray intersects triangle.
				return this.at( QdN / DdN, optionalTarget );

			};

		}(),

		applyMatrix4: function ( matrix4 ) {

			this.direction.add( this.origin ).applyMatrix4( matrix4 );
			this.origin.applyMatrix4( matrix4 );
			this.direction.sub( this.origin );
			this.direction.normalize();

			return this;

		},

		equals: function ( ray ) {

			return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

		}

	};

	// File:src/math/Sphere.js

	/**
	 * @author bhouston / http://clara.io
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Sphere = function ( center, radius ) {

		this.center = ( center !== undefined ) ? center : new THREE.Vector3();
		this.radius = ( radius !== undefined ) ? radius : 0;

	};

	THREE.Sphere.prototype = {

		constructor: THREE.Sphere,

		set: function ( center, radius ) {

			this.center.copy( center );
			this.radius = radius;

			return this;

		},

		setFromPoints: function () {

			var box = new THREE.Box3();

			return function ( points, optionalCenter ) {

				var center = this.center;

				if ( optionalCenter !== undefined ) {

					center.copy( optionalCenter );

				} else {

					box.setFromPoints( points ).center( center );

				}

				var maxRadiusSq = 0;

				for ( var i = 0, il = points.length; i < il; i ++ ) {

					maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

				}

				this.radius = Math.sqrt( maxRadiusSq );

				return this;

			};

		}(),

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( sphere ) {

			this.center.copy( sphere.center );
			this.radius = sphere.radius;

			return this;

		},

		empty: function () {

			return ( this.radius <= 0 );

		},

		containsPoint: function ( point ) {

			return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

		},

		distanceToPoint: function ( point ) {

			return ( point.distanceTo( this.center ) - this.radius );

		},

		intersectsSphere: function ( sphere ) {

			var radiusSum = this.radius + sphere.radius;

			return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

		},

		clampPoint: function ( point, optionalTarget ) {

			var deltaLengthSq = this.center.distanceToSquared( point );

			var result = optionalTarget || new THREE.Vector3();
			result.copy( point );

			if ( deltaLengthSq > ( this.radius * this.radius ) ) {

				result.sub( this.center ).normalize();
				result.multiplyScalar( this.radius ).add( this.center );

			}

			return result;

		},

		getBoundingBox: function ( optionalTarget ) {

			var box = optionalTarget || new THREE.Box3();

			box.set( this.center, this.center );
			box.expandByScalar( this.radius );

			return box;

		},

		applyMatrix4: function ( matrix ) {

			this.center.applyMatrix4( matrix );
			this.radius = this.radius * matrix.getMaxScaleOnAxis();

			return this;

		},

		translate: function ( offset ) {

			this.center.add( offset );

			return this;

		},

		equals: function ( sphere ) {

			return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

		}

	};

	// File:src/math/Frustum.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author bhouston / http://clara.io
	 */

	THREE.Frustum = function ( p0, p1, p2, p3, p4, p5 ) {

		this.planes = [

			( p0 !== undefined ) ? p0 : new THREE.Plane(),
			( p1 !== undefined ) ? p1 : new THREE.Plane(),
			( p2 !== undefined ) ? p2 : new THREE.Plane(),
			( p3 !== undefined ) ? p3 : new THREE.Plane(),
			( p4 !== undefined ) ? p4 : new THREE.Plane(),
			( p5 !== undefined ) ? p5 : new THREE.Plane()

		];

	};

	THREE.Frustum.prototype = {

		constructor: THREE.Frustum,

		set: function ( p0, p1, p2, p3, p4, p5 ) {

			var planes = this.planes;

			planes[ 0 ].copy( p0 );
			planes[ 1 ].copy( p1 );
			planes[ 2 ].copy( p2 );
			planes[ 3 ].copy( p3 );
			planes[ 4 ].copy( p4 );
			planes[ 5 ].copy( p5 );

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( frustum ) {

			var planes = this.planes;

			for ( var i = 0; i < 6; i ++ ) {

				planes[ i ].copy( frustum.planes[ i ] );

			}

			return this;

		},

		setFromMatrix: function ( m ) {

			var planes = this.planes;
			var me = m.elements;
			var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
			var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
			var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
			var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

			planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
			planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
			planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
			planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
			planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
			planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

			return this;

		},

		intersectsObject: function () {

			var sphere = new THREE.Sphere();

			return function ( object ) {

				var geometry = object.geometry;

				if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

				sphere.copy( geometry.boundingSphere );
				sphere.applyMatrix4( object.matrixWorld );

				return this.intersectsSphere( sphere );

			};

		}(),

		intersectsSphere: function ( sphere ) {

			var planes = this.planes;
			var center = sphere.center;
			var negRadius = - sphere.radius;

			for ( var i = 0; i < 6; i ++ ) {

				var distance = planes[ i ].distanceToPoint( center );

				if ( distance < negRadius ) {

					return false;

				}

			}

			return true;

		},

		intersectsBox: function () {

			var p1 = new THREE.Vector3(),
				p2 = new THREE.Vector3();

			return function ( box ) {

				var planes = this.planes;

				for ( var i = 0; i < 6 ; i ++ ) {

					var plane = planes[ i ];

					p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
					p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
					p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
					p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
					p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
					p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;

					var d1 = plane.distanceToPoint( p1 );
					var d2 = plane.distanceToPoint( p2 );

					// if both outside plane, no intersection

					if ( d1 < 0 && d2 < 0 ) {

						return false;

					}

				}

				return true;

			};

		}(),


		containsPoint: function ( point ) {

			var planes = this.planes;

			for ( var i = 0; i < 6; i ++ ) {

				if ( planes[ i ].distanceToPoint( point ) < 0 ) {

					return false;

				}

			}

			return true;

		}

	};

	// File:src/math/Plane.js

	/**
	 * @author bhouston / http://clara.io
	 */

	THREE.Plane = function ( normal, constant ) {

		this.normal = ( normal !== undefined ) ? normal : new THREE.Vector3( 1, 0, 0 );
		this.constant = ( constant !== undefined ) ? constant : 0;

	};

	THREE.Plane.prototype = {

		constructor: THREE.Plane,

		set: function ( normal, constant ) {

			this.normal.copy( normal );
			this.constant = constant;

			return this;

		},

		setComponents: function ( x, y, z, w ) {

			this.normal.set( x, y, z );
			this.constant = w;

			return this;

		},

		setFromNormalAndCoplanarPoint: function ( normal, point ) {

			this.normal.copy( normal );
			this.constant = - point.dot( this.normal );	// must be this.normal, not normal, as this.normal is normalized

			return this;

		},

		setFromCoplanarPoints: function () {

			var v1 = new THREE.Vector3();
			var v2 = new THREE.Vector3();

			return function ( a, b, c ) {

				var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();

				// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

				this.setFromNormalAndCoplanarPoint( normal, a );

				return this;

			};

		}(),

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( plane ) {

			this.normal.copy( plane.normal );
			this.constant = plane.constant;

			return this;

		},

		normalize: function () {

			// Note: will lead to a divide by zero if the plane is invalid.

			var inverseNormalLength = 1.0 / this.normal.length();
			this.normal.multiplyScalar( inverseNormalLength );
			this.constant *= inverseNormalLength;

			return this;

		},

		negate: function () {

			this.constant *= - 1;
			this.normal.negate();

			return this;

		},

		distanceToPoint: function ( point ) {

			return this.normal.dot( point ) + this.constant;

		},

		distanceToSphere: function ( sphere ) {

			return this.distanceToPoint( sphere.center ) - sphere.radius;

		},

		projectPoint: function ( point, optionalTarget ) {

			return this.orthoPoint( point, optionalTarget ).sub( point ).negate();

		},

		orthoPoint: function ( point, optionalTarget ) {

			var perpendicularMagnitude = this.distanceToPoint( point );

			var result = optionalTarget || new THREE.Vector3();
			return result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );

		},

		isIntersectionLine: function ( line ) {

			// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

			var startSign = this.distanceToPoint( line.start );
			var endSign = this.distanceToPoint( line.end );

			return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

		},

		intersectLine: function () {

			var v1 = new THREE.Vector3();

			return function ( line, optionalTarget ) {

				var result = optionalTarget || new THREE.Vector3();

				var direction = line.delta( v1 );

				var denominator = this.normal.dot( direction );

				if ( denominator === 0 ) {

					// line is coplanar, return origin
					if ( this.distanceToPoint( line.start ) === 0 ) {

						return result.copy( line.start );

					}

					// Unsure if this is the correct method to handle this case.
					return undefined;

				}

				var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

				if ( t < 0 || t > 1 ) {

					return undefined;

				}

				return result.copy( direction ).multiplyScalar( t ).add( line.start );

			};

		}(),


		coplanarPoint: function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();
			return result.copy( this.normal ).multiplyScalar( - this.constant );

		},

		applyMatrix4: function () {

			var v1 = new THREE.Vector3();
			var v2 = new THREE.Vector3();
			var m1 = new THREE.Matrix3();

			return function ( matrix, optionalNormalMatrix ) {

				// compute new normal based on theory here:
				// http://www.songho.ca/opengl/gl_normaltransform.html
				var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );
				var newNormal = v1.copy( this.normal ).applyMatrix3( normalMatrix );

				var newCoplanarPoint = this.coplanarPoint( v2 );
				newCoplanarPoint.applyMatrix4( matrix );

				this.setFromNormalAndCoplanarPoint( newNormal, newCoplanarPoint );

				return this;

			};

		}(),

		translate: function ( offset ) {

			this.constant = this.constant - offset.dot( this.normal );

			return this;

		},

		equals: function ( plane ) {

			return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

		}

	};

	// File:src/math/Math.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Math = {

		generateUUID: function () {

			// http://www.broofa.com/Tools/Math.uuid.htm

			var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );
			var uuid = new Array( 36 );
			var rnd = 0, r;

			return function () {

				for ( var i = 0; i < 36; i ++ ) {

					if ( i === 8 || i === 13 || i === 18 || i === 23 ) {

						uuid[ i ] = '-';

					} else if ( i === 14 ) {

						uuid[ i ] = '4';

					} else {

						if ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;
						r = rnd & 0xf;
						rnd = rnd >> 4;
						uuid[ i ] = chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];

					}

				}

				return uuid.join( '' );

			};

		}(),

		clamp: function ( value, min, max ) {

			return Math.max( min, Math.min( max, value ) );

		},

		// compute euclidian modulo of m % n
		// https://en.wikipedia.org/wiki/Modulo_operation

		euclideanModulo: function ( n, m ) {

			return ( ( n % m ) + m ) % m;

		},

		// Linear mapping from range <a1, a2> to range <b1, b2>

		mapLinear: function ( x, a1, a2, b1, b2 ) {

			return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

		},

		// http://en.wikipedia.org/wiki/Smoothstep

		smoothstep: function ( x, min, max ) {

			if ( x <= min ) return 0;
			if ( x >= max ) return 1;

			x = ( x - min ) / ( max - min );

			return x * x * ( 3 - 2 * x );

		},

		smootherstep: function ( x, min, max ) {

			if ( x <= min ) return 0;
			if ( x >= max ) return 1;

			x = ( x - min ) / ( max - min );

			return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

		},

		// Random float from <0, 1> with 16 bits of randomness
		// (standard Math.random() creates repetitive patterns when applied over larger space)

		random16: function () {

			return ( 65280 * Math.random() + 255 * Math.random() ) / 65535;

		},

		// Random integer from <low, high> interval

		randInt: function ( low, high ) {

			return low + Math.floor( Math.random() * ( high - low + 1 ) );

		},

		// Random float from <low, high> interval

		randFloat: function ( low, high ) {

			return low + Math.random() * ( high - low );

		},

		// Random float from <-range/2, range/2> interval

		randFloatSpread: function ( range ) {

			return range * ( 0.5 - Math.random() );

		},

		degToRad: function () {

			var degreeToRadiansFactor = Math.PI / 180;

			return function ( degrees ) {

				return degrees * degreeToRadiansFactor;

			};

		}(),

		radToDeg: function () {

			var radianToDegreesFactor = 180 / Math.PI;

			return function ( radians ) {

				return radians * radianToDegreesFactor;

			};

		}(),

		isPowerOfTwo: function ( value ) {

			return ( value & ( value - 1 ) ) === 0 && value !== 0;

		},

		nearestPowerOfTwo: function ( value ) {

			return Math.pow( 2, Math.round( Math.log( value ) / Math.LN2 ) );

		},

		nextPowerOfTwo: function ( value ) {

			value --;
			value |= value >> 1;
			value |= value >> 2;
			value |= value >> 4;
			value |= value >> 8;
			value |= value >> 16;
			value ++;

			return value;

		}

	};

	// File:src/math/Spline.js

	/**
	 * Spline from Tween.js, slightly optimized (and trashed)
	 * http://sole.github.com/tween.js/examples/05_spline.html
	 *
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Spline = function ( points ) {

		this.points = points;

		var c = [], v3 = { x: 0, y: 0, z: 0 },
		point, intPoint, weight, w2, w3,
		pa, pb, pc, pd;

		this.initFromArray = function ( a ) {

			this.points = [];

			for ( var i = 0; i < a.length; i ++ ) {

				this.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };

			}

		};

		this.getPoint = function ( k ) {

			point = ( this.points.length - 1 ) * k;
			intPoint = Math.floor( point );
			weight = point - intPoint;

			c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
			c[ 1 ] = intPoint;
			c[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;
			c[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;

			pa = this.points[ c[ 0 ] ];
			pb = this.points[ c[ 1 ] ];
			pc = this.points[ c[ 2 ] ];
			pd = this.points[ c[ 3 ] ];

			w2 = weight * weight;
			w3 = weight * w2;

			v3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );
			v3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );
			v3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );

			return v3;

		};

		this.getControlPointsArray = function () {

			var i, p, l = this.points.length,
				coords = [];

			for ( i = 0; i < l; i ++ ) {

				p = this.points[ i ];
				coords[ i ] = [ p.x, p.y, p.z ];

			}

			return coords;

		};

		// approximate length by summing linear segments

		this.getLength = function ( nSubDivisions ) {

			var i, index, nSamples, position,
				point = 0, intPoint = 0, oldIntPoint = 0,
				oldPosition = new THREE.Vector3(),
				tmpVec = new THREE.Vector3(),
				chunkLengths = [],
				totalLength = 0;

			// first point has 0 length

			chunkLengths[ 0 ] = 0;

			if ( ! nSubDivisions ) nSubDivisions = 100;

			nSamples = this.points.length * nSubDivisions;

			oldPosition.copy( this.points[ 0 ] );

			for ( i = 1; i < nSamples; i ++ ) {

				index = i / nSamples;

				position = this.getPoint( index );
				tmpVec.copy( position );

				totalLength += tmpVec.distanceTo( oldPosition );

				oldPosition.copy( position );

				point = ( this.points.length - 1 ) * index;
				intPoint = Math.floor( point );

				if ( intPoint !== oldIntPoint ) {

					chunkLengths[ intPoint ] = totalLength;
					oldIntPoint = intPoint;

				}

			}

			// last point ends with total length

			chunkLengths[ chunkLengths.length ] = totalLength;

			return { chunks: chunkLengths, total: totalLength };

		};

		this.reparametrizeByArcLength = function ( samplingCoef ) {

			var i, j,
				index, indexCurrent, indexNext,
				realDistance,
				sampling, position,
				newpoints = [],
				tmpVec = new THREE.Vector3(),
				sl = this.getLength();

			newpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );

			for ( i = 1; i < this.points.length; i ++ ) {

				//tmpVec.copy( this.points[ i - 1 ] );
				//linearDistance = tmpVec.distanceTo( this.points[ i ] );

				realDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];

				sampling = Math.ceil( samplingCoef * realDistance / sl.total );

				indexCurrent = ( i - 1 ) / ( this.points.length - 1 );
				indexNext = i / ( this.points.length - 1 );

				for ( j = 1; j < sampling - 1; j ++ ) {

					index = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );

					position = this.getPoint( index );
					newpoints.push( tmpVec.copy( position ).clone() );

				}

				newpoints.push( tmpVec.copy( this.points[ i ] ).clone() );

			}

			this.points = newpoints;

		};

		// Catmull-Rom

		function interpolate( p0, p1, p2, p3, t, t2, t3 ) {

			var v0 = ( p2 - p0 ) * 0.5,
				v1 = ( p3 - p1 ) * 0.5;

			return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;

		}

	};

	// File:src/math/Triangle.js

	/**
	 * @author bhouston / http://clara.io
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Triangle = function ( a, b, c ) {

		this.a = ( a !== undefined ) ? a : new THREE.Vector3();
		this.b = ( b !== undefined ) ? b : new THREE.Vector3();
		this.c = ( c !== undefined ) ? c : new THREE.Vector3();

	};

	THREE.Triangle.normal = function () {

		var v0 = new THREE.Vector3();

		return function ( a, b, c, optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();

			result.subVectors( c, b );
			v0.subVectors( a, b );
			result.cross( v0 );

			var resultLengthSq = result.lengthSq();
			if ( resultLengthSq > 0 ) {

				return result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );

			}

			return result.set( 0, 0, 0 );

		};

	}();

	// static/instance method to calculate barycentric coordinates
	// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
	THREE.Triangle.barycoordFromPoint = function () {

		var v0 = new THREE.Vector3();
		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();

		return function ( point, a, b, c, optionalTarget ) {

			v0.subVectors( c, a );
			v1.subVectors( b, a );
			v2.subVectors( point, a );

			var dot00 = v0.dot( v0 );
			var dot01 = v0.dot( v1 );
			var dot02 = v0.dot( v2 );
			var dot11 = v1.dot( v1 );
			var dot12 = v1.dot( v2 );

			var denom = ( dot00 * dot11 - dot01 * dot01 );

			var result = optionalTarget || new THREE.Vector3();

			// collinear or singular triangle
			if ( denom === 0 ) {

				// arbitrary location outside of triangle?
				// not sure if this is the best idea, maybe should be returning undefined
				return result.set( - 2, - 1, - 1 );

			}

			var invDenom = 1 / denom;
			var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
			var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

			// barycentric coordinates must always sum to 1
			return result.set( 1 - u - v, v, u );

		};

	}();

	THREE.Triangle.containsPoint = function () {

		var v1 = new THREE.Vector3();

		return function ( point, a, b, c ) {

			var result = THREE.Triangle.barycoordFromPoint( point, a, b, c, v1 );

			return ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );

		};

	}();

	THREE.Triangle.prototype = {

		constructor: THREE.Triangle,

		set: function ( a, b, c ) {

			this.a.copy( a );
			this.b.copy( b );
			this.c.copy( c );

			return this;

		},

		setFromPointsAndIndices: function ( points, i0, i1, i2 ) {

			this.a.copy( points[ i0 ] );
			this.b.copy( points[ i1 ] );
			this.c.copy( points[ i2 ] );

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( triangle ) {

			this.a.copy( triangle.a );
			this.b.copy( triangle.b );
			this.c.copy( triangle.c );

			return this;

		},

		area: function () {

			var v0 = new THREE.Vector3();
			var v1 = new THREE.Vector3();

			return function () {

				v0.subVectors( this.c, this.b );
				v1.subVectors( this.a, this.b );

				return v0.cross( v1 ).length() * 0.5;

			};

		}(),

		midpoint: function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();
			return result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

		},

		normal: function ( optionalTarget ) {

			return THREE.Triangle.normal( this.a, this.b, this.c, optionalTarget );

		},

		plane: function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Plane();

			return result.setFromCoplanarPoints( this.a, this.b, this.c );

		},

		barycoordFromPoint: function ( point, optionalTarget ) {

			return THREE.Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );

		},

		containsPoint: function ( point ) {

			return THREE.Triangle.containsPoint( point, this.a, this.b, this.c );

		},

		equals: function ( triangle ) {

			return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

		}

	};

	// File:src/core/Channels.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Channels = function () {

		this.mask = 1;

	};

	THREE.Channels.prototype = {

		constructor: THREE.Channels,

		set: function ( channel ) {

			this.mask = 1 << channel;

		},

		enable: function ( channel ) {

			this.mask |= 1 << channel;

		},

		toggle: function ( channel ) {

			this.mask ^= 1 << channel;

		},

		disable: function ( channel ) {

			this.mask &= ~ ( 1 << channel );

		}

	};

	// File:src/core/Clock.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Clock = function ( autoStart ) {

		this.autoStart = ( autoStart !== undefined ) ? autoStart : true;

		this.startTime = 0;
		this.oldTime = 0;
		this.elapsedTime = 0;

		this.running = false;

	};

	THREE.Clock.prototype = {

		constructor: THREE.Clock,

		start: function () {

			this.startTime = self.performance.now();

			this.oldTime = this.startTime;
			this.running = true;

		},

		stop: function () {

			this.getElapsedTime();
			this.running = false;

		},

		getElapsedTime: function () {

			this.getDelta();
			return this.elapsedTime;

		},

		getDelta: function () {

			var diff = 0;

			if ( this.autoStart && ! this.running ) {

				this.start();

			}

			if ( this.running ) {

				var newTime = self.performance.now();

				diff = 0.001 * ( newTime - this.oldTime );
				this.oldTime = newTime;

				this.elapsedTime += diff;

			}

			return diff;

		}

	};

	// File:src/core/EventDispatcher.js

	/**
	 * https://github.com/mrdoob/eventdispatcher.js/
	 */

	THREE.EventDispatcher = function () {};

	THREE.EventDispatcher.prototype = {

		constructor: THREE.EventDispatcher,

		apply: function ( object ) {

			object.addEventListener = THREE.EventDispatcher.prototype.addEventListener;
			object.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;
			object.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;
			object.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent;

		},

		addEventListener: function ( type, listener ) {

			if ( this._listeners === undefined ) this._listeners = {};

			var listeners = this._listeners;

			if ( listeners[ type ] === undefined ) {

				listeners[ type ] = [];

			}

			if ( listeners[ type ].indexOf( listener ) === - 1 ) {

				listeners[ type ].push( listener );

			}

		},

		hasEventListener: function ( type, listener ) {

			if ( this._listeners === undefined ) return false;

			var listeners = this._listeners;

			if ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {

				return true;

			}

			return false;

		},

		removeEventListener: function ( type, listener ) {

			if ( this._listeners === undefined ) return;

			var listeners = this._listeners;
			var listenerArray = listeners[ type ];

			if ( listenerArray !== undefined ) {

				var index = listenerArray.indexOf( listener );

				if ( index !== - 1 ) {

					listenerArray.splice( index, 1 );

				}

			}

		},

		dispatchEvent: function ( event ) {

			if ( this._listeners === undefined ) return;

			var listeners = this._listeners;
			var listenerArray = listeners[ event.type ];

			if ( listenerArray !== undefined ) {

				event.target = this;

				var array = [];
				var length = listenerArray.length;

				for ( var i = 0; i < length; i ++ ) {

					array[ i ] = listenerArray[ i ];

				}

				for ( var i = 0; i < length; i ++ ) {

					array[ i ].call( this, event );

				}

			}

		}

	};

	// File:src/core/Raycaster.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author bhouston / http://clara.io/
	 * @author stephomi / http://stephaneginier.com/
	 */

	( function ( THREE ) {

		THREE.Raycaster = function ( origin, direction, near, far ) {

			this.ray = new THREE.Ray( origin, direction );
			// direction is assumed to be normalized (for accurate distance calculations)

			this.near = near || 0;
			this.far = far || Infinity;

			this.params = {
				Mesh: {},
				Line: {},
				LOD: {},
				Points: { threshold: 1 },
				Sprite: {}
			};

			Object.defineProperties( this.params, {
				PointCloud: {
					get: function () {
						console.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );
						return this.Points;
					}
				}
			} );

		};

		function descSort( a, b ) {

			return a.distance - b.distance;

		}

		function intersectObject( object, raycaster, intersects, recursive ) {

			if ( object.visible === false ) return;

			object.raycast( raycaster, intersects );

			if ( recursive === true ) {

				var children = object.children;

				for ( var i = 0, l = children.length; i < l; i ++ ) {

					intersectObject( children[ i ], raycaster, intersects, true );

				}

			}

		}

		//

		THREE.Raycaster.prototype = {

			constructor: THREE.Raycaster,

			linePrecision: 1,

			set: function ( origin, direction ) {

				// direction is assumed to be normalized (for accurate distance calculations)

				this.ray.set( origin, direction );

			},

			setFromCamera: function ( coords, camera ) {

				if ( camera instanceof THREE.PerspectiveCamera ) {

					this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
					this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();

				} else if ( camera instanceof THREE.OrthographicCamera ) {

					this.ray.origin.set( coords.x, coords.y, - 1 ).unproject( camera );
					this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );

				} else {

					console.error( 'THREE.Raycaster: Unsupported camera type.' );

				}

			},

			intersectObject: function ( object, recursive ) {

				var intersects = [];

				intersectObject( object, this, intersects, recursive );

				intersects.sort( descSort );

				return intersects;

			},

			intersectObjects: function ( objects, recursive ) {

				var intersects = [];

				if ( Array.isArray( objects ) === false ) {

					console.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );
					return intersects;

				}

				for ( var i = 0, l = objects.length; i < l; i ++ ) {

					intersectObject( objects[ i ], this, intersects, recursive );

				}

				intersects.sort( descSort );

				return intersects;

			}

		};

	}( THREE ) );

	// File:src/core/Object3D.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author elephantatwork / www.elephantatwork.ch
	 */

	THREE.Object3D = function () {

		Object.defineProperty( this, 'id', { value: THREE.Object3DIdCount ++ } );

		this.uuid = THREE.Math.generateUUID();

		this.name = '';
		this.type = 'Object3D';

		this.parent = null;
		this.channels = new THREE.Channels();
		this.children = [];

		this.up = THREE.Object3D.DefaultUp.clone();

		var position = new THREE.Vector3();
		var rotation = new THREE.Euler();
		var quaternion = new THREE.Quaternion();
		var scale = new THREE.Vector3( 1, 1, 1 );

		function onRotationChange() {

			quaternion.setFromEuler( rotation, false );

		}

		function onQuaternionChange() {

			rotation.setFromQuaternion( quaternion, undefined, false );

		}

		rotation.onChange( onRotationChange );
		quaternion.onChange( onQuaternionChange );

		Object.defineProperties( this, {
			position: {
				enumerable: true,
				value: position
			},
			rotation: {
				enumerable: true,
				value: rotation
			},
			quaternion: {
				enumerable: true,
				value: quaternion
			},
			scale: {
				enumerable: true,
				value: scale
			},
			modelViewMatrix: {
				value: new THREE.Matrix4()
			},
			normalMatrix: {
				value: new THREE.Matrix3()
			}
		} );

		this.rotationAutoUpdate = true;

		this.matrix = new THREE.Matrix4();
		this.matrixWorld = new THREE.Matrix4();

		this.matrixAutoUpdate = THREE.Object3D.DefaultMatrixAutoUpdate;
		this.matrixWorldNeedsUpdate = false;

		this.visible = true;

		this.castShadow = false;
		this.receiveShadow = false;

		this.frustumCulled = true;
		this.renderOrder = 0;

		this.userData = {};

	};

	THREE.Object3D.DefaultUp = new THREE.Vector3( 0, 1, 0 );
	THREE.Object3D.DefaultMatrixAutoUpdate = true;

	THREE.Object3D.prototype = {

		constructor: THREE.Object3D,

		get eulerOrder () {

			console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );

			return this.rotation.order;

		},

		set eulerOrder ( value ) {

			console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );

			this.rotation.order = value;

		},

		get useQuaternion () {

			console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

		},

		set useQuaternion ( value ) {

			console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

		},

		set renderDepth ( value ) {

			console.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );

		},

		//

		applyMatrix: function ( matrix ) {

			this.matrix.multiplyMatrices( matrix, this.matrix );

			this.matrix.decompose( this.position, this.quaternion, this.scale );

		},

		setRotationFromAxisAngle: function ( axis, angle ) {

			// assumes axis is normalized

			this.quaternion.setFromAxisAngle( axis, angle );

		},

		setRotationFromEuler: function ( euler ) {

			this.quaternion.setFromEuler( euler, true );

		},

		setRotationFromMatrix: function ( m ) {

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			this.quaternion.setFromRotationMatrix( m );

		},

		setRotationFromQuaternion: function ( q ) {

			// assumes q is normalized

			this.quaternion.copy( q );

		},

		rotateOnAxis: function () {

			// rotate object on axis in object space
			// axis is assumed to be normalized

			var q1 = new THREE.Quaternion();

			return function ( axis, angle ) {

				q1.setFromAxisAngle( axis, angle );

				this.quaternion.multiply( q1 );

				return this;

			};

		}(),

		rotateX: function () {

			var v1 = new THREE.Vector3( 1, 0, 0 );

			return function ( angle ) {

				return this.rotateOnAxis( v1, angle );

			};

		}(),

		rotateY: function () {

			var v1 = new THREE.Vector3( 0, 1, 0 );

			return function ( angle ) {

				return this.rotateOnAxis( v1, angle );

			};

		}(),

		rotateZ: function () {

			var v1 = new THREE.Vector3( 0, 0, 1 );

			return function ( angle ) {

				return this.rotateOnAxis( v1, angle );

			};

		}(),

		translateOnAxis: function () {

			// translate object by distance along axis in object space
			// axis is assumed to be normalized

			var v1 = new THREE.Vector3();

			return function ( axis, distance ) {

				v1.copy( axis ).applyQuaternion( this.quaternion );

				this.position.add( v1.multiplyScalar( distance ) );

				return this;

			};

		}(),

		translate: function ( distance, axis ) {

			console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
			return this.translateOnAxis( axis, distance );

		},

		translateX: function () {

			var v1 = new THREE.Vector3( 1, 0, 0 );

			return function ( distance ) {

				return this.translateOnAxis( v1, distance );

			};

		}(),

		translateY: function () {

			var v1 = new THREE.Vector3( 0, 1, 0 );

			return function ( distance ) {

				return this.translateOnAxis( v1, distance );

			};

		}(),

		translateZ: function () {

			var v1 = new THREE.Vector3( 0, 0, 1 );

			return function ( distance ) {

				return this.translateOnAxis( v1, distance );

			};

		}(),

		localToWorld: function ( vector ) {

			return vector.applyMatrix4( this.matrixWorld );

		},

		worldToLocal: function () {

			var m1 = new THREE.Matrix4();

			return function ( vector ) {

				return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );

			};

		}(),

		lookAt: function () {

			// This routine does not support objects with rotated and/or translated parent(s)

			var m1 = new THREE.Matrix4();

			return function ( vector ) {

				m1.lookAt( vector, this.position, this.up );

				this.quaternion.setFromRotationMatrix( m1 );

			};

		}(),

		add: function ( object ) {

			if ( arguments.length > 1 ) {

				for ( var i = 0; i < arguments.length; i ++ ) {

					this.add( arguments[ i ] );

				}

				return this;

			}

			if ( object === this ) {

				console.error( "THREE.Object3D.add: object can't be added as a child of itself.", object );
				return this;

			}

			if ( object instanceof THREE.Object3D ) {

				if ( object.parent !== null ) {

					object.parent.remove( object );

				}

				object.parent = this;
				object.dispatchEvent( { type: 'added' } );

				this.children.push( object );

			} else {

				console.error( "THREE.Object3D.add: object not an instance of THREE.Object3D.", object );

			}

			return this;

		},

		remove: function ( object ) {

			if ( arguments.length > 1 ) {

				for ( var i = 0; i < arguments.length; i ++ ) {

					this.remove( arguments[ i ] );

				}

			}

			var index = this.children.indexOf( object );

			if ( index !== - 1 ) {

				object.parent = null;

				object.dispatchEvent( { type: 'removed' } );

				this.children.splice( index, 1 );

			}

		},

		getChildByName: function ( name ) {

			console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
			return this.getObjectByName( name );

		},

		getObjectById: function ( id ) {

			return this.getObjectByProperty( 'id', id );

		},

		getObjectByName: function ( name ) {

			return this.getObjectByProperty( 'name', name );

		},

		getObjectByProperty: function ( name, value ) {

			if ( this[ name ] === value ) return this;

			for ( var i = 0, l = this.children.length; i < l; i ++ ) {

				var child = this.children[ i ];
				var object = child.getObjectByProperty( name, value );

				if ( object !== undefined ) {

					return object;

				}

			}

			return undefined;

		},

		getWorldPosition: function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();

			this.updateMatrixWorld( true );

			return result.setFromMatrixPosition( this.matrixWorld );

		},

		getWorldQuaternion: function () {

			var position = new THREE.Vector3();
			var scale = new THREE.Vector3();

			return function ( optionalTarget ) {

				var result = optionalTarget || new THREE.Quaternion();

				this.updateMatrixWorld( true );

				this.matrixWorld.decompose( position, result, scale );

				return result;

			};

		}(),

		getWorldRotation: function () {

			var quaternion = new THREE.Quaternion();

			return function ( optionalTarget ) {

				var result = optionalTarget || new THREE.Euler();

				this.getWorldQuaternion( quaternion );

				return result.setFromQuaternion( quaternion, this.rotation.order, false );

			};

		}(),

		getWorldScale: function () {

			var position = new THREE.Vector3();
			var quaternion = new THREE.Quaternion();

			return function ( optionalTarget ) {

				var result = optionalTarget || new THREE.Vector3();

				this.updateMatrixWorld( true );

				this.matrixWorld.decompose( position, quaternion, result );

				return result;

			};

		}(),

		getWorldDirection: function () {

			var quaternion = new THREE.Quaternion();

			return function ( optionalTarget ) {

				var result = optionalTarget || new THREE.Vector3();

				this.getWorldQuaternion( quaternion );

				return result.set( 0, 0, 1 ).applyQuaternion( quaternion );

			};

		}(),

		raycast: function () {},

		traverse: function ( callback ) {

			callback( this );

			var children = this.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].traverse( callback );

			}

		},

		traverseVisible: function ( callback ) {

			if ( this.visible === false ) return;

			callback( this );

			var children = this.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].traverseVisible( callback );

			}

		},

		traverseAncestors: function ( callback ) {

			var parent = this.parent;

			if ( parent !== null ) {

				callback( parent );

				parent.traverseAncestors( callback );

			}

		},

		updateMatrix: function () {

			this.matrix.compose( this.position, this.quaternion, this.scale );

			this.matrixWorldNeedsUpdate = true;

		},

		updateMatrixWorld: function ( force ) {

			if ( this.matrixAutoUpdate === true ) this.updateMatrix();

			if ( this.matrixWorldNeedsUpdate === true || force === true ) {

				if ( this.parent === null ) {

					this.matrixWorld.copy( this.matrix );

				} else {

					this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

				}

				this.matrixWorldNeedsUpdate = false;

				force = true;

			}

			// update children

			for ( var i = 0, l = this.children.length; i < l; i ++ ) {

				this.children[ i ].updateMatrixWorld( force );

			}

		},

		toJSON: function ( meta ) {

			var isRootObject = ( meta === undefined );

			var output = {};

			// meta is a hash used to collect geometries, materials.
			// not providing it implies that this is the root object
			// being serialized.
			if ( isRootObject ) {

				// initialize meta obj
				meta = {
					geometries: {},
					materials: {},
					textures: {},
					images: {}
				};

				output.metadata = {
					version: 4.4,
					type: 'Object',
					generator: 'Object3D.toJSON'
				};

			}

			// standard Object3D serialization

			var object = {};

			object.uuid = this.uuid;
			object.type = this.type;

			if ( this.name !== '' ) object.name = this.name;
			if ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;
			if ( this.castShadow === true ) object.castShadow = true;
			if ( this.receiveShadow === true ) object.receiveShadow = true;
			if ( this.visible === false ) object.visible = false;

			object.matrix = this.matrix.toArray();

			//

			if ( this.geometry !== undefined ) {

				if ( meta.geometries[ this.geometry.uuid ] === undefined ) {

					meta.geometries[ this.geometry.uuid ] = this.geometry.toJSON( meta );

				}

				object.geometry = this.geometry.uuid;

			}

			if ( this.material !== undefined ) {

				if ( meta.materials[ this.material.uuid ] === undefined ) {

					meta.materials[ this.material.uuid ] = this.material.toJSON( meta );

				}

				object.material = this.material.uuid;

			}

			//

			if ( this.children.length > 0 ) {

				object.children = [];

				for ( var i = 0; i < this.children.length; i ++ ) {

					object.children.push( this.children[ i ].toJSON( meta ).object );

				}

			}

			if ( isRootObject ) {

				var geometries = extractFromCache( meta.geometries );
				var materials = extractFromCache( meta.materials );
				var textures = extractFromCache( meta.textures );
				var images = extractFromCache( meta.images );

				if ( geometries.length > 0 ) output.geometries = geometries;
				if ( materials.length > 0 ) output.materials = materials;
				if ( textures.length > 0 ) output.textures = textures;
				if ( images.length > 0 ) output.images = images;

			}

			output.object = object;

			return output;

			// extract data from the cache hash
			// remove metadata on each item
			// and return as array
			function extractFromCache ( cache ) {

				var values = [];
				for ( var key in cache ) {

					var data = cache[ key ];
					delete data.metadata;
					values.push( data );

				}
				return values;

			}

		},

		clone: function ( recursive ) {

			return new this.constructor().copy( this, recursive );

		},

		copy: function ( source, recursive ) {

			if ( recursive === undefined ) recursive = true;

			this.name = source.name;

			this.up.copy( source.up );

			this.position.copy( source.position );
			this.quaternion.copy( source.quaternion );
			this.scale.copy( source.scale );

			this.rotationAutoUpdate = source.rotationAutoUpdate;

			this.matrix.copy( source.matrix );
			this.matrixWorld.copy( source.matrixWorld );

			this.matrixAutoUpdate = source.matrixAutoUpdate;
			this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

			this.visible = source.visible;

			this.castShadow = source.castShadow;
			this.receiveShadow = source.receiveShadow;

			this.frustumCulled = source.frustumCulled;
			this.renderOrder = source.renderOrder;

			this.userData = JSON.parse( JSON.stringify( source.userData ) );

			if ( recursive === true ) {

				for ( var i = 0; i < source.children.length; i ++ ) {

					var child = source.children[ i ];
					this.add( child.clone() );

				}

			}

			return this;

		}

	};

	THREE.EventDispatcher.prototype.apply( THREE.Object3D.prototype );

	THREE.Object3DIdCount = 0;

	// File:src/core/Face3.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Face3 = function ( a, b, c, normal, color, materialIndex ) {

		this.a = a;
		this.b = b;
		this.c = c;

		this.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();
		this.vertexNormals = Array.isArray( normal ) ? normal : [];

		this.color = color instanceof THREE.Color ? color : new THREE.Color();
		this.vertexColors = Array.isArray( color ) ? color : [];

		this.materialIndex = materialIndex !== undefined ? materialIndex : 0;

	};

	THREE.Face3.prototype = {

		constructor: THREE.Face3,

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( source ) {

			this.a = source.a;
			this.b = source.b;
			this.c = source.c;

			this.normal.copy( source.normal );
			this.color.copy( source.color );

			this.materialIndex = source.materialIndex;

			for ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {

				this.vertexNormals[ i ] = source.vertexNormals[ i ].clone();

			}

			for ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {

				this.vertexColors[ i ] = source.vertexColors[ i ].clone();

			}

			return this;

		}

	};

	// File:src/core/Face4.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Face4 = function ( a, b, c, d, normal, color, materialIndex ) {

		console.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );
		return new THREE.Face3( a, b, c, normal, color, materialIndex );

	};

	// File:src/core/BufferAttribute.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.BufferAttribute = function ( array, itemSize ) {

		this.uuid = THREE.Math.generateUUID();

		this.array = array;
		this.itemSize = itemSize;

		this.dynamic = false;
		this.updateRange = { offset: 0, count: - 1 };

		this.version = 0;

	};

	THREE.BufferAttribute.prototype = {

		constructor: THREE.BufferAttribute,

		get length() {

			console.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );
			return this.array.length;

		},

		get count() {

			return this.array.length / this.itemSize;

		},

		set needsUpdate( value ) {

			if ( value === true ) this.version ++;

		},

		setDynamic: function ( value ) {

			this.dynamic = value;

			return this;

		},

		copy: function ( source ) {

			this.array = new source.array.constructor( source.array );
			this.itemSize = source.itemSize;

			this.dynamic = source.dynamic;

			return this;

		},

		copyAt: function ( index1, attribute, index2 ) {

			index1 *= this.itemSize;
			index2 *= attribute.itemSize;

			for ( var i = 0, l = this.itemSize; i < l; i ++ ) {

				this.array[ index1 + i ] = attribute.array[ index2 + i ];

			}

			return this;

		},

		copyArray: function ( array ) {

			this.array.set( array );

			return this;

		},

		copyColorsArray: function ( colors ) {

			var array = this.array, offset = 0;

			for ( var i = 0, l = colors.length; i < l; i ++ ) {

				var color = colors[ i ];

				if ( color === undefined ) {

					console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
					color = new THREE.Color();

				}

				array[ offset ++ ] = color.r;
				array[ offset ++ ] = color.g;
				array[ offset ++ ] = color.b;

			}

			return this;

		},

		copyIndicesArray: function ( indices ) {

			var array = this.array, offset = 0;

			for ( var i = 0, l = indices.length; i < l; i ++ ) {

				var index = indices[ i ];

				array[ offset ++ ] = index.a;
				array[ offset ++ ] = index.b;
				array[ offset ++ ] = index.c;

			}

			return this;

		},

		copyVector2sArray: function ( vectors ) {

			var array = this.array, offset = 0;

			for ( var i = 0, l = vectors.length; i < l; i ++ ) {

				var vector = vectors[ i ];

				if ( vector === undefined ) {

					console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
					vector = new THREE.Vector2();

				}

				array[ offset ++ ] = vector.x;
				array[ offset ++ ] = vector.y;

			}

			return this;

		},

		copyVector3sArray: function ( vectors ) {

			var array = this.array, offset = 0;

			for ( var i = 0, l = vectors.length; i < l; i ++ ) {

				var vector = vectors[ i ];

				if ( vector === undefined ) {

					console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
					vector = new THREE.Vector3();

				}

				array[ offset ++ ] = vector.x;
				array[ offset ++ ] = vector.y;
				array[ offset ++ ] = vector.z;

			}

			return this;

		},

		copyVector4sArray: function ( vectors ) {

			var array = this.array, offset = 0;

			for ( var i = 0, l = vectors.length; i < l; i ++ ) {

				var vector = vectors[ i ];

				if ( vector === undefined ) {

					console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
					vector = new THREE.Vector4();

				}

				array[ offset ++ ] = vector.x;
				array[ offset ++ ] = vector.y;
				array[ offset ++ ] = vector.z;
				array[ offset ++ ] = vector.w;

			}

			return this;

		},

		set: function ( value, offset ) {

			if ( offset === undefined ) offset = 0;

			this.array.set( value, offset );

			return this;

		},

		getX: function ( index ) {

			return this.array[ index * this.itemSize ];

		},

		setX: function ( index, x ) {

			this.array[ index * this.itemSize ] = x;

			return this;

		},

		getY: function ( index ) {

			return this.array[ index * this.itemSize + 1 ];

		},

		setY: function ( index, y ) {

			this.array[ index * this.itemSize + 1 ] = y;

			return this;

		},

		getZ: function ( index ) {

			return this.array[ index * this.itemSize + 2 ];

		},

		setZ: function ( index, z ) {

			this.array[ index * this.itemSize + 2 ] = z;

			return this;

		},

		getW: function ( index ) {

			return this.array[ index * this.itemSize + 3 ];

		},

		setW: function ( index, w ) {

			this.array[ index * this.itemSize + 3 ] = w;

			return this;

		},

		setXY: function ( index, x, y ) {

			index *= this.itemSize;

			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;

			return this;

		},

		setXYZ: function ( index, x, y, z ) {

			index *= this.itemSize;

			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;
			this.array[ index + 2 ] = z;

			return this;

		},

		setXYZW: function ( index, x, y, z, w ) {

			index *= this.itemSize;

			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;
			this.array[ index + 2 ] = z;
			this.array[ index + 3 ] = w;

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		}

	};

	//

	THREE.Int8Attribute = function ( array, itemSize ) {

		return new THREE.BufferAttribute( new Int8Array( array ), itemSize );

	};

	THREE.Uint8Attribute = function ( array, itemSize ) {

		return new THREE.BufferAttribute( new Uint8Array( array ), itemSize );

	};

	THREE.Uint8ClampedAttribute = function ( array, itemSize ) {

		return new THREE.BufferAttribute( new Uint8ClampedArray( array ), itemSize );

	};

	THREE.Int16Attribute = function ( array, itemSize ) {

		return new THREE.BufferAttribute( new Int16Array( array ), itemSize );

	};

	THREE.Uint16Attribute = function ( array, itemSize ) {

		return new THREE.BufferAttribute( new Uint16Array( array ), itemSize );

	};

	THREE.Int32Attribute = function ( array, itemSize ) {

		return new THREE.BufferAttribute( new Int32Array( array ), itemSize );

	};

	THREE.Uint32Attribute = function ( array, itemSize ) {

		return new THREE.BufferAttribute( new Uint32Array( array ), itemSize );

	};

	THREE.Float32Attribute = function ( array, itemSize ) {

		return new THREE.BufferAttribute( new Float32Array( array ), itemSize );

	};

	THREE.Float64Attribute = function ( array, itemSize ) {

		return new THREE.BufferAttribute( new Float64Array( array ), itemSize );

	};


	// Deprecated

	THREE.DynamicBufferAttribute = function ( array, itemSize ) {

		console.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );
		return new THREE.BufferAttribute( array, itemSize ).setDynamic( true );

	};

	// File:src/core/InstancedBufferAttribute.js

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */

	THREE.InstancedBufferAttribute = function ( array, itemSize, meshPerAttribute ) {

		THREE.BufferAttribute.call( this, array, itemSize );

		this.meshPerAttribute = meshPerAttribute || 1;

	};

	THREE.InstancedBufferAttribute.prototype = Object.create( THREE.BufferAttribute.prototype );
	THREE.InstancedBufferAttribute.prototype.constructor = THREE.InstancedBufferAttribute;

	THREE.InstancedBufferAttribute.prototype.copy = function ( source ) {

		THREE.BufferAttribute.prototype.copy.call( this, source );

		this.meshPerAttribute = source.meshPerAttribute;

		return this;

	};

	// File:src/core/InterleavedBuffer.js

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */

	THREE.InterleavedBuffer = function ( array, stride ) {

		this.uuid = THREE.Math.generateUUID();

		this.array = array;
		this.stride = stride;

		this.dynamic = false;
		this.updateRange = { offset: 0, count: - 1 };

		this.version = 0;

	};

	THREE.InterleavedBuffer.prototype = {

		constructor: THREE.InterleavedBuffer,

		get length () {

			return this.array.length;

		},

		get count () {

			return this.array.length / this.stride;

		},

		set needsUpdate( value ) {

			if ( value === true ) this.version ++;

		},

		setDynamic: function ( value ) {

			this.dynamic = value;

			return this;

		},

		copy: function ( source ) {

			this.array = new source.array.constructor( source.array );
			this.stride = source.stride;
			this.dynamic = source.dynamic;

		},

		copyAt: function ( index1, attribute, index2 ) {

			index1 *= this.stride;
			index2 *= attribute.stride;

			for ( var i = 0, l = this.stride; i < l; i ++ ) {

				this.array[ index1 + i ] = attribute.array[ index2 + i ];

			}

			return this;

		},

		set: function ( value, offset ) {

			if ( offset === undefined ) offset = 0;

			this.array.set( value, offset );

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		}

	};

	// File:src/core/InstancedInterleavedBuffer.js

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */

	THREE.InstancedInterleavedBuffer = function ( array, stride, meshPerAttribute ) {

		THREE.InterleavedBuffer.call( this, array, stride );

		this.meshPerAttribute = meshPerAttribute || 1;

	};

	THREE.InstancedInterleavedBuffer.prototype = Object.create( THREE.InterleavedBuffer.prototype );
	THREE.InstancedInterleavedBuffer.prototype.constructor = THREE.InstancedInterleavedBuffer;

	THREE.InstancedInterleavedBuffer.prototype.copy = function ( source ) {

		THREE.InterleavedBuffer.prototype.copy.call( this, source );

		this.meshPerAttribute = source.meshPerAttribute;

		return this;

	};

	// File:src/core/InterleavedBufferAttribute.js

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */

	THREE.InterleavedBufferAttribute = function ( interleavedBuffer, itemSize, offset ) {

		this.uuid = THREE.Math.generateUUID();

		this.data = interleavedBuffer;
		this.itemSize = itemSize;
		this.offset = offset;

	};


	THREE.InterleavedBufferAttribute.prototype = {

		constructor: THREE.InterleavedBufferAttribute,

		get length() {

			console.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );
			return this.array.length;

		},

		get count() {

			return this.data.array.length / this.data.stride;

		},

		setX: function ( index, x ) {

			this.data.array[ index * this.data.stride + this.offset ] = x;

			return this;

		},

		setY: function ( index, y ) {

			this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

			return this;

		},

		setZ: function ( index, z ) {

			this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

			return this;

		},

		setW: function ( index, w ) {

			this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

			return this;

		},

		getX: function ( index ) {

			return this.data.array[ index * this.data.stride + this.offset ];

		},

		getY: function ( index ) {

			return this.data.array[ index * this.data.stride + this.offset + 1 ];

		},

		getZ: function ( index ) {

			return this.data.array[ index * this.data.stride + this.offset + 2 ];

		},

		getW: function ( index ) {

			return this.data.array[ index * this.data.stride + this.offset + 3 ];

		},

		setXY: function ( index, x, y ) {

			index = index * this.data.stride + this.offset;

			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;

			return this;

		},

		setXYZ: function ( index, x, y, z ) {

			index = index * this.data.stride + this.offset;

			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;
			this.data.array[ index + 2 ] = z;

			return this;

		},

		setXYZW: function ( index, x, y, z, w ) {

			index = index * this.data.stride + this.offset;

			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;
			this.data.array[ index + 2 ] = z;
			this.data.array[ index + 3 ] = w;

			return this;

		}

	};

	// File:src/core/Geometry.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author kile / http://kile.stravaganza.org/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author bhouston / http://clara.io
	 */

	THREE.Geometry = function () {

		Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );

		this.uuid = THREE.Math.generateUUID();

		this.name = '';
		this.type = 'Geometry';

		this.vertices = [];
		this.colors = [];
		this.faces = [];
		this.faceVertexUvs = [ [] ];

		this.morphTargets = [];
		this.morphNormals = [];

		this.skinWeights = [];
		this.skinIndices = [];

		this.lineDistances = [];

		this.boundingBox = null;
		this.boundingSphere = null;

		// update flags

		this.verticesNeedUpdate = false;
		this.elementsNeedUpdate = false;
		this.uvsNeedUpdate = false;
		this.normalsNeedUpdate = false;
		this.colorsNeedUpdate = false;
		this.lineDistancesNeedUpdate = false;
		this.groupsNeedUpdate = false;

	};

	THREE.Geometry.prototype = {

		constructor: THREE.Geometry,

		applyMatrix: function ( matrix ) {

			var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

			for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {

				var vertex = this.vertices[ i ];
				vertex.applyMatrix4( matrix );

			}

			for ( var i = 0, il = this.faces.length; i < il; i ++ ) {

				var face = this.faces[ i ];
				face.normal.applyMatrix3( normalMatrix ).normalize();

				for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

					face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();

				}

			}

			if ( this.boundingBox !== null ) {

				this.computeBoundingBox();

			}

			if ( this.boundingSphere !== null ) {

				this.computeBoundingSphere();

			}

			this.verticesNeedUpdate = true;
			this.normalsNeedUpdate = true;

		},

		rotateX: function () {

			// rotate geometry around world x-axis

			var m1;

			return function rotateX( angle ) {

				if ( m1 === undefined ) m1 = new THREE.Matrix4();

				m1.makeRotationX( angle );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		rotateY: function () {

			// rotate geometry around world y-axis

			var m1;

			return function rotateY( angle ) {

				if ( m1 === undefined ) m1 = new THREE.Matrix4();

				m1.makeRotationY( angle );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		rotateZ: function () {

			// rotate geometry around world z-axis

			var m1;

			return function rotateZ( angle ) {

				if ( m1 === undefined ) m1 = new THREE.Matrix4();

				m1.makeRotationZ( angle );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		translate: function () {

			// translate geometry

			var m1;

			return function translate( x, y, z ) {

				if ( m1 === undefined ) m1 = new THREE.Matrix4();

				m1.makeTranslation( x, y, z );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		scale: function () {

			// scale geometry

			var m1;

			return function scale( x, y, z ) {

				if ( m1 === undefined ) m1 = new THREE.Matrix4();

				m1.makeScale( x, y, z );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		lookAt: function () {

			var obj;

			return function lookAt( vector ) {

				if ( obj === undefined ) obj = new THREE.Object3D();

				obj.lookAt( vector );

				obj.updateMatrix();

				this.applyMatrix( obj.matrix );

			};

		}(),

		fromBufferGeometry: function ( geometry ) {

			var scope = this;

			var indices = geometry.index !== null ? geometry.index.array : undefined;
			var attributes = geometry.attributes;

			var vertices = attributes.position.array;
			var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
			var colors = attributes.color !== undefined ? attributes.color.array : undefined;
			var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
			var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;

			if ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];

			var tempNormals = [];
			var tempUVs = [];
			var tempUVs2 = [];

			for ( var i = 0, j = 0, k = 0; i < vertices.length; i += 3, j += 2, k += 4 ) {

				scope.vertices.push( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );

				if ( normals !== undefined ) {

					tempNormals.push( new THREE.Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );

				}

				if ( colors !== undefined ) {

					scope.colors.push( new THREE.Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );

				}

				if ( uvs !== undefined ) {

					tempUVs.push( new THREE.Vector2( uvs[ j ], uvs[ j + 1 ] ) );

				}

				if ( uvs2 !== undefined ) {

					tempUVs2.push( new THREE.Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );

				}

			}

			function addFace( a, b, c ) {

				var vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];
				var vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];

				var face = new THREE.Face3( a, b, c, vertexNormals, vertexColors );

				scope.faces.push( face );

				if ( uvs !== undefined ) {

					scope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );

				}

				if ( uvs2 !== undefined ) {

					scope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );

				}

			};

			if ( indices !== undefined ) {

				var groups = geometry.groups;

				if ( groups.length > 0 ) {

					for ( var i = 0; i < groups.length; i ++ ) {

						var group = groups[ i ];

						var start = group.start;
						var count = group.count;

						for ( var j = start, jl = start + count; j < jl; j += 3 ) {

							addFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ] );

						}

					}

				} else {

					for ( var i = 0; i < indices.length; i += 3 ) {

						addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );

					}

				}

			} else {

				for ( var i = 0; i < vertices.length / 3; i += 3 ) {

					addFace( i, i + 1, i + 2 );

				}

			}

			this.computeFaceNormals();

			if ( geometry.boundingBox !== null ) {

				this.boundingBox = geometry.boundingBox.clone();

			}

			if ( geometry.boundingSphere !== null ) {

				this.boundingSphere = geometry.boundingSphere.clone();

			}

			return this;

		},

		center: function () {

			this.computeBoundingBox();

			var offset = this.boundingBox.center().negate();

			this.translate( offset.x, offset.y, offset.z );

			return offset;

		},

		normalize: function () {

			this.computeBoundingSphere();

			var center = this.boundingSphere.center;
			var radius = this.boundingSphere.radius;

			var s = radius === 0 ? 1 : 1.0 / radius;

			var matrix = new THREE.Matrix4();
			matrix.set(
				s, 0, 0, - s * center.x,
				0, s, 0, - s * center.y,
				0, 0, s, - s * center.z,
				0, 0, 0, 1
			);

			this.applyMatrix( matrix );

			return this;

		},

		computeFaceNormals: function () {

			var cb = new THREE.Vector3(), ab = new THREE.Vector3();

			for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {

				var face = this.faces[ f ];

				var vA = this.vertices[ face.a ];
				var vB = this.vertices[ face.b ];
				var vC = this.vertices[ face.c ];

				cb.subVectors( vC, vB );
				ab.subVectors( vA, vB );
				cb.cross( ab );

				cb.normalize();

				face.normal.copy( cb );

			}

		},

		computeVertexNormals: function ( areaWeighted ) {

			var v, vl, f, fl, face, vertices;

			vertices = new Array( this.vertices.length );

			for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

				vertices[ v ] = new THREE.Vector3();

			}

			if ( areaWeighted ) {

				// vertex normals weighted by triangle areas
				// http://www.iquilezles.org/www/articles/normals/normals.htm

				var vA, vB, vC;
				var cb = new THREE.Vector3(), ab = new THREE.Vector3();

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					face = this.faces[ f ];

					vA = this.vertices[ face.a ];
					vB = this.vertices[ face.b ];
					vC = this.vertices[ face.c ];

					cb.subVectors( vC, vB );
					ab.subVectors( vA, vB );
					cb.cross( ab );

					vertices[ face.a ].add( cb );
					vertices[ face.b ].add( cb );
					vertices[ face.c ].add( cb );

				}

			} else {

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					face = this.faces[ f ];

					vertices[ face.a ].add( face.normal );
					vertices[ face.b ].add( face.normal );
					vertices[ face.c ].add( face.normal );

				}

			}

			for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

				vertices[ v ].normalize();

			}

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				var vertexNormals = face.vertexNormals;

				if ( vertexNormals.length === 3 ) {

					vertexNormals[ 0 ].copy( vertices[ face.a ] );
					vertexNormals[ 1 ].copy( vertices[ face.b ] );
					vertexNormals[ 2 ].copy( vertices[ face.c ] );

				} else {

					vertexNormals[ 0 ] = vertices[ face.a ].clone();
					vertexNormals[ 1 ] = vertices[ face.b ].clone();
					vertexNormals[ 2 ] = vertices[ face.c ].clone();

				}

			}

		},

		computeMorphNormals: function () {

			var i, il, f, fl, face;

			// save original normals
			// - create temp variables on first access
			//   otherwise just copy (for faster repeated calls)

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				if ( ! face.__originalFaceNormal ) {

					face.__originalFaceNormal = face.normal.clone();

				} else {

					face.__originalFaceNormal.copy( face.normal );

				}

				if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];

				for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {

					if ( ! face.__originalVertexNormals[ i ] ) {

						face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();

					} else {

						face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );

					}

				}

			}

			// use temp geometry to compute face and vertex normals for each morph

			var tmpGeo = new THREE.Geometry();
			tmpGeo.faces = this.faces;

			for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {

				// create on first access

				if ( ! this.morphNormals[ i ] ) {

					this.morphNormals[ i ] = {};
					this.morphNormals[ i ].faceNormals = [];
					this.morphNormals[ i ].vertexNormals = [];

					var dstNormalsFace = this.morphNormals[ i ].faceNormals;
					var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;

					var faceNormal, vertexNormals;

					for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

						faceNormal = new THREE.Vector3();
						vertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() };

						dstNormalsFace.push( faceNormal );
						dstNormalsVertex.push( vertexNormals );

					}

				}

				var morphNormals = this.morphNormals[ i ];

				// set vertices to morph target

				tmpGeo.vertices = this.morphTargets[ i ].vertices;

				// compute morph normals

				tmpGeo.computeFaceNormals();
				tmpGeo.computeVertexNormals();

				// store morph normals

				var faceNormal, vertexNormals;

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					face = this.faces[ f ];

					faceNormal = morphNormals.faceNormals[ f ];
					vertexNormals = morphNormals.vertexNormals[ f ];

					faceNormal.copy( face.normal );

					vertexNormals.a.copy( face.vertexNormals[ 0 ] );
					vertexNormals.b.copy( face.vertexNormals[ 1 ] );
					vertexNormals.c.copy( face.vertexNormals[ 2 ] );

				}

			}

			// restore original normals

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				face.normal = face.__originalFaceNormal;
				face.vertexNormals = face.__originalVertexNormals;

			}

		},

		computeTangents: function () {

			console.warn( 'THREE.Geometry: .computeTangents() has been removed.' );

		},

		computeLineDistances: function () {

			var d = 0;
			var vertices = this.vertices;

			for ( var i = 0, il = vertices.length; i < il; i ++ ) {

				if ( i > 0 ) {

					d += vertices[ i ].distanceTo( vertices[ i - 1 ] );

				}

				this.lineDistances[ i ] = d;

			}

		},

		computeBoundingBox: function () {

			if ( this.boundingBox === null ) {

				this.boundingBox = new THREE.Box3();

			}

			this.boundingBox.setFromPoints( this.vertices );

		},

		computeBoundingSphere: function () {

			if ( this.boundingSphere === null ) {

				this.boundingSphere = new THREE.Sphere();

			}

			this.boundingSphere.setFromPoints( this.vertices );

		},

		merge: function ( geometry, matrix, materialIndexOffset ) {

			if ( geometry instanceof THREE.Geometry === false ) {

				console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );
				return;

			}

			var normalMatrix,
			vertexOffset = this.vertices.length,
			vertices1 = this.vertices,
			vertices2 = geometry.vertices,
			faces1 = this.faces,
			faces2 = geometry.faces,
			uvs1 = this.faceVertexUvs[ 0 ],
			uvs2 = geometry.faceVertexUvs[ 0 ];

			if ( materialIndexOffset === undefined ) materialIndexOffset = 0;

			if ( matrix !== undefined ) {

				normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

			}

			// vertices

			for ( var i = 0, il = vertices2.length; i < il; i ++ ) {

				var vertex = vertices2[ i ];

				var vertexCopy = vertex.clone();

				if ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );

				vertices1.push( vertexCopy );

			}

			// faces

			for ( i = 0, il = faces2.length; i < il; i ++ ) {

				var face = faces2[ i ], faceCopy, normal, color,
				faceVertexNormals = face.vertexNormals,
				faceVertexColors = face.vertexColors;

				faceCopy = new THREE.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
				faceCopy.normal.copy( face.normal );

				if ( normalMatrix !== undefined ) {

					faceCopy.normal.applyMatrix3( normalMatrix ).normalize();

				}

				for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {

					normal = faceVertexNormals[ j ].clone();

					if ( normalMatrix !== undefined ) {

						normal.applyMatrix3( normalMatrix ).normalize();

					}

					faceCopy.vertexNormals.push( normal );

				}

				faceCopy.color.copy( face.color );

				for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {

					color = faceVertexColors[ j ];
					faceCopy.vertexColors.push( color.clone() );

				}

				faceCopy.materialIndex = face.materialIndex + materialIndexOffset;

				faces1.push( faceCopy );

			}

			// uvs

			for ( i = 0, il = uvs2.length; i < il; i ++ ) {

				var uv = uvs2[ i ], uvCopy = [];

				if ( uv === undefined ) {

					continue;

				}

				for ( var j = 0, jl = uv.length; j < jl; j ++ ) {

					uvCopy.push( uv[ j ].clone() );

				}

				uvs1.push( uvCopy );

			}

		},

		mergeMesh: function ( mesh ) {

			if ( mesh instanceof THREE.Mesh === false ) {

				console.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );
				return;

			}

			mesh.matrixAutoUpdate && mesh.updateMatrix();

			this.merge( mesh.geometry, mesh.matrix );

		},

		/*
		 * Checks for duplicate vertices with hashmap.
		 * Duplicated vertices are removed
		 * and faces' vertices are updated.
		 */

		mergeVertices: function () {

			var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
			var unique = [], changes = [];

			var v, key;
			var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
			var precision = Math.pow( 10, precisionPoints );
			var i, il, face;
			var indices, j, jl;

			for ( i = 0, il = this.vertices.length; i < il; i ++ ) {

				v = this.vertices[ i ];
				key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );

				if ( verticesMap[ key ] === undefined ) {

					verticesMap[ key ] = i;
					unique.push( this.vertices[ i ] );
					changes[ i ] = unique.length - 1;

				} else {

					//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
					changes[ i ] = changes[ verticesMap[ key ] ];

				}

			}


			// if faces are completely degenerate after merging vertices, we
			// have to remove them from the geometry.
			var faceIndicesToRemove = [];

			for ( i = 0, il = this.faces.length; i < il; i ++ ) {

				face = this.faces[ i ];

				face.a = changes[ face.a ];
				face.b = changes[ face.b ];
				face.c = changes[ face.c ];

				indices = [ face.a, face.b, face.c ];

				var dupIndex = - 1;

				// if any duplicate vertices are found in a Face3
				// we have to remove the face as nothing can be saved
				for ( var n = 0; n < 3; n ++ ) {

					if ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {

						dupIndex = n;
						faceIndicesToRemove.push( i );
						break;

					}

				}

			}

			for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {

				var idx = faceIndicesToRemove[ i ];

				this.faces.splice( idx, 1 );

				for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {

					this.faceVertexUvs[ j ].splice( idx, 1 );

				}

			}

			// Use unique set of vertices

			var diff = this.vertices.length - unique.length;
			this.vertices = unique;
			return diff;

		},

		sortFacesByMaterialIndex: function () {

			var faces = this.faces;
			var length = faces.length;

			// tag faces

			for ( var i = 0; i < length; i ++ ) {

				faces[ i ]._id = i;

			}

			// sort faces

			function materialIndexSort( a, b ) {

				return a.materialIndex - b.materialIndex;

			}

			faces.sort( materialIndexSort );

			// sort uvs

			var uvs1 = this.faceVertexUvs[ 0 ];
			var uvs2 = this.faceVertexUvs[ 1 ];

			var newUvs1, newUvs2;

			if ( uvs1 && uvs1.length === length ) newUvs1 = [];
			if ( uvs2 && uvs2.length === length ) newUvs2 = [];

			for ( var i = 0; i < length; i ++ ) {

				var id = faces[ i ]._id;

				if ( newUvs1 ) newUvs1.push( uvs1[ id ] );
				if ( newUvs2 ) newUvs2.push( uvs2[ id ] );

			}

			if ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;
			if ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;

		},

		toJSON: function () {

			var data = {
				metadata: {
					version: 4.4,
					type: 'Geometry',
					generator: 'Geometry.toJSON'
				}
			};

			// standard Geometry serialization

			data.uuid = this.uuid;
			data.type = this.type;
			if ( this.name !== '' ) data.name = this.name;

			if ( this.parameters !== undefined ) {

				var parameters = this.parameters;

				for ( var key in parameters ) {

					if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

				}

				return data;

			}

			var vertices = [];

			for ( var i = 0; i < this.vertices.length; i ++ ) {

				var vertex = this.vertices[ i ];
				vertices.push( vertex.x, vertex.y, vertex.z );

			}

			var faces = [];
			var normals = [];
			var normalsHash = {};
			var colors = [];
			var colorsHash = {};
			var uvs = [];
			var uvsHash = {};

			for ( var i = 0; i < this.faces.length; i ++ ) {

				var face = this.faces[ i ];

				var hasMaterial = false; // face.materialIndex !== undefined;
				var hasFaceUv = false; // deprecated
				var hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;
				var hasFaceNormal = face.normal.length() > 0;
				var hasFaceVertexNormal = face.vertexNormals.length > 0;
				var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
				var hasFaceVertexColor = face.vertexColors.length > 0;

				var faceType = 0;

				faceType = setBit( faceType, 0, 0 );
				faceType = setBit( faceType, 1, hasMaterial );
				faceType = setBit( faceType, 2, hasFaceUv );
				faceType = setBit( faceType, 3, hasFaceVertexUv );
				faceType = setBit( faceType, 4, hasFaceNormal );
				faceType = setBit( faceType, 5, hasFaceVertexNormal );
				faceType = setBit( faceType, 6, hasFaceColor );
				faceType = setBit( faceType, 7, hasFaceVertexColor );

				faces.push( faceType );
				faces.push( face.a, face.b, face.c );

				if ( hasFaceVertexUv ) {

					var faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];

					faces.push(
						getUvIndex( faceVertexUvs[ 0 ] ),
						getUvIndex( faceVertexUvs[ 1 ] ),
						getUvIndex( faceVertexUvs[ 2 ] )
					);

				}

				if ( hasFaceNormal ) {

					faces.push( getNormalIndex( face.normal ) );

				}

				if ( hasFaceVertexNormal ) {

					var vertexNormals = face.vertexNormals;

					faces.push(
						getNormalIndex( vertexNormals[ 0 ] ),
						getNormalIndex( vertexNormals[ 1 ] ),
						getNormalIndex( vertexNormals[ 2 ] )
					);

				}

				if ( hasFaceColor ) {

					faces.push( getColorIndex( face.color ) );

				}

				if ( hasFaceVertexColor ) {

					var vertexColors = face.vertexColors;

					faces.push(
						getColorIndex( vertexColors[ 0 ] ),
						getColorIndex( vertexColors[ 1 ] ),
						getColorIndex( vertexColors[ 2 ] )
					);

				}

			}

			function setBit( value, position, enabled ) {

				return enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );

			}

			function getNormalIndex( normal ) {

				var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();

				if ( normalsHash[ hash ] !== undefined ) {

					return normalsHash[ hash ];

				}

				normalsHash[ hash ] = normals.length / 3;
				normals.push( normal.x, normal.y, normal.z );

				return normalsHash[ hash ];

			}

			function getColorIndex( color ) {

				var hash = color.r.toString() + color.g.toString() + color.b.toString();

				if ( colorsHash[ hash ] !== undefined ) {

					return colorsHash[ hash ];

				}

				colorsHash[ hash ] = colors.length;
				colors.push( color.getHex() );

				return colorsHash[ hash ];

			}

			function getUvIndex( uv ) {

				var hash = uv.x.toString() + uv.y.toString();

				if ( uvsHash[ hash ] !== undefined ) {

					return uvsHash[ hash ];

				}

				uvsHash[ hash ] = uvs.length / 2;
				uvs.push( uv.x, uv.y );

				return uvsHash[ hash ];

			}

			data.data = {};

			data.data.vertices = vertices;
			data.data.normals = normals;
			if ( colors.length > 0 ) data.data.colors = colors;
			if ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility
			data.data.faces = faces;

			return data;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( source ) {

			this.vertices = [];
			this.faces = [];
			this.faceVertexUvs = [ [] ];

			var vertices = source.vertices;

			for ( var i = 0, il = vertices.length; i < il; i ++ ) {

				this.vertices.push( vertices[ i ].clone() );

			}

			var faces = source.faces;

			for ( var i = 0, il = faces.length; i < il; i ++ ) {

				this.faces.push( faces[ i ].clone() );

			}

			for ( var i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {

				var faceVertexUvs = source.faceVertexUvs[ i ];

				if ( this.faceVertexUvs[ i ] === undefined ) {

					this.faceVertexUvs[ i ] = [];

				}

				for ( var j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {

					var uvs = faceVertexUvs[ j ], uvsCopy = [];

					for ( var k = 0, kl = uvs.length; k < kl; k ++ ) {

						var uv = uvs[ k ];

						uvsCopy.push( uv.clone() );

					}

					this.faceVertexUvs[ i ].push( uvsCopy );

				}

			}

			return this;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	};

	THREE.EventDispatcher.prototype.apply( THREE.Geometry.prototype );

	THREE.GeometryIdCount = 0;

	// File:src/core/DirectGeometry.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.DirectGeometry = function () {

		Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );

		this.uuid = THREE.Math.generateUUID();

		this.name = '';
		this.type = 'DirectGeometry';

		this.indices = [];
		this.vertices = [];
		this.normals = [];
		this.colors = [];
		this.uvs = [];
		this.uvs2 = [];

		this.groups = [];

		this.morphTargets = {};

		this.skinWeights = [];
		this.skinIndices = [];

		// this.lineDistances = [];

		this.boundingBox = null;
		this.boundingSphere = null;

		// update flags

		this.verticesNeedUpdate = false;
		this.normalsNeedUpdate = false;
		this.colorsNeedUpdate = false;
		this.uvsNeedUpdate = false;
		this.groupsNeedUpdate = false;

	};

	THREE.DirectGeometry.prototype = {

		constructor: THREE.DirectGeometry,

		computeBoundingBox: THREE.Geometry.prototype.computeBoundingBox,
		computeBoundingSphere: THREE.Geometry.prototype.computeBoundingSphere,

		computeFaceNormals: function () {

			console.warn( 'THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.' );

		},

		computeVertexNormals: function () {

			console.warn( 'THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.' );

		},

		computeGroups: function ( geometry ) {

			var group;
			var groups = [];
			var materialIndex;

			var faces = geometry.faces;

			for ( var i = 0; i < faces.length; i ++ ) {

				var face = faces[ i ];

				// materials

				if ( face.materialIndex !== materialIndex ) {

					materialIndex = face.materialIndex;

					if ( group !== undefined ) {

						group.count = ( i * 3 ) - group.start;
						groups.push( group );

					}

					group = {
						start: i * 3,
						materialIndex: materialIndex
					};

				}

			}

			if ( group !== undefined ) {

				group.count = ( i * 3 ) - group.start;
				groups.push( group );

			}

			this.groups = groups;

		},

		fromGeometry: function ( geometry ) {

			var faces = geometry.faces;
			var vertices = geometry.vertices;
			var faceVertexUvs = geometry.faceVertexUvs;

			var hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;
			var hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;

			// morphs

			var morphTargets = geometry.morphTargets;
			var morphTargetsLength = morphTargets.length;

			if ( morphTargetsLength > 0 ) {

				var morphTargetsPosition = [];

				for ( var i = 0; i < morphTargetsLength; i ++ ) {

					morphTargetsPosition[ i ] = [];

				}

				this.morphTargets.position = morphTargetsPosition;

			}

			var morphNormals = geometry.morphNormals;
			var morphNormalsLength = morphNormals.length;

			if ( morphNormalsLength > 0 ) {

				var morphTargetsNormal = [];

				for ( var i = 0; i < morphNormalsLength; i ++ ) {

					morphTargetsNormal[ i ] = [];

				}

				this.morphTargets.normal = morphTargetsNormal;

			}

			// skins

			var skinIndices = geometry.skinIndices;
			var skinWeights = geometry.skinWeights;

			var hasSkinIndices = skinIndices.length === vertices.length;
			var hasSkinWeights = skinWeights.length === vertices.length;

			//

			for ( var i = 0; i < faces.length; i ++ ) {

				var face = faces[ i ];

				this.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );

				var vertexNormals = face.vertexNormals;

				if ( vertexNormals.length === 3 ) {

					this.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );

				} else {

					var normal = face.normal;

					this.normals.push( normal, normal, normal );

				}

				var vertexColors = face.vertexColors;

				if ( vertexColors.length === 3 ) {

					this.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );

				} else {

					var color = face.color;

					this.colors.push( color, color, color );

				}

				if ( hasFaceVertexUv === true ) {

					var vertexUvs = faceVertexUvs[ 0 ][ i ];

					if ( vertexUvs !== undefined ) {

						this.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

					} else {

						console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );

						this.uvs.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );

					}

				}

				if ( hasFaceVertexUv2 === true ) {

					var vertexUvs = faceVertexUvs[ 1 ][ i ];

					if ( vertexUvs !== undefined ) {

						this.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

					} else {

						console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );

						this.uvs2.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );

					}

				}

				// morphs

				for ( var j = 0; j < morphTargetsLength; j ++ ) {

					var morphTarget = morphTargets[ j ].vertices;

					morphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );

				}

				for ( var j = 0; j < morphNormalsLength; j ++ ) {

					var morphNormal = morphNormals[ j ].vertexNormals[ i ];

					morphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );

				}

				// skins

				if ( hasSkinIndices ) {

					this.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );

				}

				if ( hasSkinWeights ) {

					this.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );

				}

			}

			this.computeGroups( geometry );

			this.verticesNeedUpdate = geometry.verticesNeedUpdate;
			this.normalsNeedUpdate = geometry.normalsNeedUpdate;
			this.colorsNeedUpdate = geometry.colorsNeedUpdate;
			this.uvsNeedUpdate = geometry.uvsNeedUpdate;
			this.groupsNeedUpdate = geometry.groupsNeedUpdate;

			return this;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	};

	THREE.EventDispatcher.prototype.apply( THREE.DirectGeometry.prototype );

	// File:src/core/BufferGeometry.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.BufferGeometry = function () {

		Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );

		this.uuid = THREE.Math.generateUUID();

		this.name = '';
		this.type = 'BufferGeometry';

		this.index = null;
		this.attributes = {};

		this.morphAttributes = {};

		this.groups = [];

		this.boundingBox = null;
		this.boundingSphere = null;

		this.drawRange = { start: 0, count: Infinity };

	};

	THREE.BufferGeometry.prototype = {

		constructor: THREE.BufferGeometry,

		addIndex: function ( index ) {

			console.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );
			this.setIndex( index );

		},

		getIndex: function () {

			return this.index;

		},

		setIndex: function ( index ) {

			this.index = index;

		},

		addAttribute: function ( name, attribute ) {

			if ( attribute instanceof THREE.BufferAttribute === false && attribute instanceof THREE.InterleavedBufferAttribute === false ) {

				console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );

				this.addAttribute( name, new THREE.BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );

				return;

			}

			if ( name === 'index' ) {

				console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );
				this.setIndex( attribute );

				return;

			}

			this.attributes[ name ] = attribute;

		},

		getAttribute: function ( name ) {

			return this.attributes[ name ];

		},

		removeAttribute: function ( name ) {

			delete this.attributes[ name ];

		},

		get drawcalls() {

			console.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );
			return this.groups;

		},

		get offsets() {

			console.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );
			return this.groups;

		},

		addDrawCall: function ( start, count, indexOffset ) {

			if ( indexOffset !== undefined ) {

				console.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );

			}

			console.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );
			this.addGroup( start, count );

		},

		clearDrawCalls: function () {

			console.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );
			this.clearGroups();

		},

		addGroup: function ( start, count, materialIndex ) {

			this.groups.push( {

				start: start,
				count: count,
				materialIndex: materialIndex !== undefined ? materialIndex : 0

			} );

		},

		clearGroups: function () {

			this.groups = [];

		},

		setDrawRange: function ( start, count ) {

			this.drawRange.start = start;
			this.drawRange.count = count;

		},

		applyMatrix: function ( matrix ) {

			var position = this.attributes.position;

			if ( position !== undefined ) {

				matrix.applyToVector3Array( position.array );
				position.needsUpdate = true;

			}

			var normal = this.attributes.normal;

			if ( normal !== undefined ) {

				var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

				normalMatrix.applyToVector3Array( normal.array );
				normal.needsUpdate = true;

			}

			if ( this.boundingBox !== null ) {

				this.computeBoundingBox();

			}

			if ( this.boundingSphere !== null ) {

				this.computeBoundingSphere();

			}

		},

		rotateX: function () {

			// rotate geometry around world x-axis

			var m1;

			return function rotateX( angle ) {

				if ( m1 === undefined ) m1 = new THREE.Matrix4();

				m1.makeRotationX( angle );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		rotateY: function () {

			// rotate geometry around world y-axis

			var m1;

			return function rotateY( angle ) {

				if ( m1 === undefined ) m1 = new THREE.Matrix4();

				m1.makeRotationY( angle );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		rotateZ: function () {

			// rotate geometry around world z-axis

			var m1;

			return function rotateZ( angle ) {

				if ( m1 === undefined ) m1 = new THREE.Matrix4();

				m1.makeRotationZ( angle );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		translate: function () {

			// translate geometry

			var m1;

			return function translate( x, y, z ) {

				if ( m1 === undefined ) m1 = new THREE.Matrix4();

				m1.makeTranslation( x, y, z );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		scale: function () {

			// scale geometry

			var m1;

			return function scale( x, y, z ) {

				if ( m1 === undefined ) m1 = new THREE.Matrix4();

				m1.makeScale( x, y, z );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		lookAt: function () {

			var obj;

			return function lookAt( vector ) {

				if ( obj === undefined ) obj = new THREE.Object3D();

				obj.lookAt( vector );

				obj.updateMatrix();

				this.applyMatrix( obj.matrix );

			};

		}(),

		center: function () {

			this.computeBoundingBox();

			var offset = this.boundingBox.center().negate();

			this.translate( offset.x, offset.y, offset.z );

			return offset;

		},

		setFromObject: function ( object ) {

			// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );

			var geometry = object.geometry;

			if ( object instanceof THREE.Points || object instanceof THREE.Line ) {

				var positions = new THREE.Float32Attribute( geometry.vertices.length * 3, 3 );
				var colors = new THREE.Float32Attribute( geometry.colors.length * 3, 3 );

				this.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );
				this.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );

				if ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {

					var lineDistances = new THREE.Float32Attribute( geometry.lineDistances.length, 1 );

					this.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );

				}

				if ( geometry.boundingSphere !== null ) {

					this.boundingSphere = geometry.boundingSphere.clone();

				}

				if ( geometry.boundingBox !== null ) {

					this.boundingBox = geometry.boundingBox.clone();

				}

			} else if ( object instanceof THREE.Mesh ) {

				if ( geometry instanceof THREE.Geometry ) {

					this.fromGeometry( geometry );

				}

			}

			return this;

		},

		updateFromObject: function ( object ) {

			var geometry = object.geometry;

			if ( object instanceof THREE.Mesh ) {

				var direct = geometry.__directGeometry;

				if ( direct === undefined ) {

					return this.fromGeometry( geometry );

				}

				direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
				direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
				direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
				direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
				direct.groupsNeedUpdate = geometry.groupsNeedUpdate;

				geometry.verticesNeedUpdate = false;
				geometry.normalsNeedUpdate = false;
				geometry.colorsNeedUpdate = false;
				geometry.uvsNeedUpdate = false;
				geometry.groupsNeedUpdate = false;

				geometry = direct;

			}

			if ( geometry.verticesNeedUpdate === true ) {

				var attribute = this.attributes.position;

				if ( attribute !== undefined ) {

					attribute.copyVector3sArray( geometry.vertices );
					attribute.needsUpdate = true;

				}

				geometry.verticesNeedUpdate = false;

			}

			if ( geometry.normalsNeedUpdate === true ) {

				var attribute = this.attributes.normal;

				if ( attribute !== undefined ) {

					attribute.copyVector3sArray( geometry.normals );
					attribute.needsUpdate = true;

				}

				geometry.normalsNeedUpdate = false;

			}

			if ( geometry.colorsNeedUpdate === true ) {

				var attribute = this.attributes.color;

				if ( attribute !== undefined ) {

					attribute.copyColorsArray( geometry.colors );
					attribute.needsUpdate = true;

				}

				geometry.colorsNeedUpdate = false;

			}

			if ( geometry.uvsNeedUpdate ) {

					var attribute = this.attributes.uv;

					if ( attribute !== undefined ) {

							attribute.copyVector2sArray( geometry.uvs );
							attribute.needsUpdate = true;

					}

					geometry.uvsNeedUpdate = false;

			}

			if ( geometry.lineDistancesNeedUpdate ) {

				var attribute = this.attributes.lineDistance;

				if ( attribute !== undefined ) {

					attribute.copyArray( geometry.lineDistances );
					attribute.needsUpdate = true;

				}

				geometry.lineDistancesNeedUpdate = false;

			}

			if ( geometry.groupsNeedUpdate ) {

				geometry.computeGroups( object.geometry );
				this.groups = geometry.groups;

				geometry.groupsNeedUpdate = false;

			}

			return this;

		},

		fromGeometry: function ( geometry ) {

			geometry.__directGeometry = new THREE.DirectGeometry().fromGeometry( geometry );

			return this.fromDirectGeometry( geometry.__directGeometry );

		},

		fromDirectGeometry: function ( geometry ) {

			var positions = new Float32Array( geometry.vertices.length * 3 );
			this.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );

			if ( geometry.normals.length > 0 ) {

				var normals = new Float32Array( geometry.normals.length * 3 );
				this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );

			}

			if ( geometry.colors.length > 0 ) {

				var colors = new Float32Array( geometry.colors.length * 3 );
				this.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );

			}

			if ( geometry.uvs.length > 0 ) {

				var uvs = new Float32Array( geometry.uvs.length * 2 );
				this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );

			}

			if ( geometry.uvs2.length > 0 ) {

				var uvs2 = new Float32Array( geometry.uvs2.length * 2 );
				this.addAttribute( 'uv2', new THREE.BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );

			}

			if ( geometry.indices.length > 0 ) {

				var TypeArray = geometry.vertices.length > 65535 ? Uint32Array : Uint16Array;
				var indices = new TypeArray( geometry.indices.length * 3 );
				this.setIndex( new THREE.BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );

			}

			// groups

			this.groups = geometry.groups;

			// morphs

			for ( var name in geometry.morphTargets ) {

				var array = [];
				var morphTargets = geometry.morphTargets[ name ];

				for ( var i = 0, l = morphTargets.length; i < l; i ++ ) {

					var morphTarget = morphTargets[ i ];

					var attribute = new THREE.Float32Attribute( morphTarget.length * 3, 3 );

					array.push( attribute.copyVector3sArray( morphTarget ) );

				}

				this.morphAttributes[ name ] = array;

			}

			// skinning

			if ( geometry.skinIndices.length > 0 ) {

				var skinIndices = new THREE.Float32Attribute( geometry.skinIndices.length * 4, 4 );
				this.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );

			}

			if ( geometry.skinWeights.length > 0 ) {

				var skinWeights = new THREE.Float32Attribute( geometry.skinWeights.length * 4, 4 );
				this.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );

			}

			//

			if ( geometry.boundingSphere !== null ) {

				this.boundingSphere = geometry.boundingSphere.clone();

			}

			if ( geometry.boundingBox !== null ) {

				this.boundingBox = geometry.boundingBox.clone();

			}

			return this;

		},

		computeBoundingBox: function () {

			var vector = new THREE.Vector3();

			return function () {

				if ( this.boundingBox === null ) {

					this.boundingBox = new THREE.Box3();

				}

				var positions = this.attributes.position.array;

				if ( positions ) {

					var bb = this.boundingBox;
					bb.makeEmpty();

					for ( var i = 0, il = positions.length; i < il; i += 3 ) {

						vector.fromArray( positions, i );
						bb.expandByPoint( vector );

					}

				}

				if ( positions === undefined || positions.length === 0 ) {

					this.boundingBox.min.set( 0, 0, 0 );
					this.boundingBox.max.set( 0, 0, 0 );

				}

				if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

					console.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

				}

			};

		}(),

		computeBoundingSphere: function () {

			var box = new THREE.Box3();
			var vector = new THREE.Vector3();

			return function () {

				if ( this.boundingSphere === null ) {

					this.boundingSphere = new THREE.Sphere();

				}

				var positions = this.attributes.position.array;

				if ( positions ) {

					box.makeEmpty();

					var center = this.boundingSphere.center;

					for ( var i = 0, il = positions.length; i < il; i += 3 ) {

						vector.fromArray( positions, i );
						box.expandByPoint( vector );

					}

					box.center( center );

					// hoping to find a boundingSphere with a radius smaller than the
					// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

					var maxRadiusSq = 0;

					for ( var i = 0, il = positions.length; i < il; i += 3 ) {

						vector.fromArray( positions, i );
						maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );

					}

					this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

					if ( isNaN( this.boundingSphere.radius ) ) {

						console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

					}

				}

			};

		}(),

		computeFaceNormals: function () {

			// backwards compatibility

		},

		computeVertexNormals: function () {

			var index = this.index;
			var attributes = this.attributes;
			var groups = this.groups;

			if ( attributes.position ) {

				var positions = attributes.position.array;

				if ( attributes.normal === undefined ) {

					this.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( positions.length ), 3 ) );

				} else {

					// reset existing normals to zero

					var normals = attributes.normal.array;

					for ( var i = 0, il = normals.length; i < il; i ++ ) {

						normals[ i ] = 0;

					}

				}

				var normals = attributes.normal.array;

				var vA, vB, vC,

				pA = new THREE.Vector3(),
				pB = new THREE.Vector3(),
				pC = new THREE.Vector3(),

				cb = new THREE.Vector3(),
				ab = new THREE.Vector3();

				// indexed elements

				if ( index ) {

					var indices = index.array;

					if ( groups.length === 0 ) {

						this.addGroup( 0, indices.length );

					}

					for ( var j = 0, jl = groups.length; j < jl; ++ j ) {

						var group = groups[ j ];

						var start = group.start;
						var count = group.count;

						for ( var i = start, il = start + count; i < il; i += 3 ) {

							vA = indices[ i + 0 ] * 3;
							vB = indices[ i + 1 ] * 3;
							vC = indices[ i + 2 ] * 3;

							pA.fromArray( positions, vA );
							pB.fromArray( positions, vB );
							pC.fromArray( positions, vC );

							cb.subVectors( pC, pB );
							ab.subVectors( pA, pB );
							cb.cross( ab );

							normals[ vA ] += cb.x;
							normals[ vA + 1 ] += cb.y;
							normals[ vA + 2 ] += cb.z;

							normals[ vB ] += cb.x;
							normals[ vB + 1 ] += cb.y;
							normals[ vB + 2 ] += cb.z;

							normals[ vC ] += cb.x;
							normals[ vC + 1 ] += cb.y;
							normals[ vC + 2 ] += cb.z;

						}

					}

				} else {

					// non-indexed elements (unconnected triangle soup)

					for ( var i = 0, il = positions.length; i < il; i += 9 ) {

						pA.fromArray( positions, i );
						pB.fromArray( positions, i + 3 );
						pC.fromArray( positions, i + 6 );

						cb.subVectors( pC, pB );
						ab.subVectors( pA, pB );
						cb.cross( ab );

						normals[ i ] = cb.x;
						normals[ i + 1 ] = cb.y;
						normals[ i + 2 ] = cb.z;

						normals[ i + 3 ] = cb.x;
						normals[ i + 4 ] = cb.y;
						normals[ i + 5 ] = cb.z;

						normals[ i + 6 ] = cb.x;
						normals[ i + 7 ] = cb.y;
						normals[ i + 8 ] = cb.z;

					}

				}

				this.normalizeNormals();

				attributes.normal.needsUpdate = true;

			}

		},

		computeTangents: function () {

			console.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );

		},

		computeOffsets: function ( size ) {

			console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.')

		},

		merge: function ( geometry, offset ) {

			if ( geometry instanceof THREE.BufferGeometry === false ) {

				console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
				return;

			}

			if ( offset === undefined ) offset = 0;

			var attributes = this.attributes;

			for ( var key in attributes ) {

				if ( geometry.attributes[ key ] === undefined ) continue;

				var attribute1 = attributes[ key ];
				var attributeArray1 = attribute1.array;

				var attribute2 = geometry.attributes[ key ];
				var attributeArray2 = attribute2.array;

				var attributeSize = attribute2.itemSize;

				for ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {

					attributeArray1[ j ] = attributeArray2[ i ];

				}

			}

			return this;

		},

		normalizeNormals: function () {

			var normals = this.attributes.normal.array;

			var x, y, z, n;

			for ( var i = 0, il = normals.length; i < il; i += 3 ) {

				x = normals[ i ];
				y = normals[ i + 1 ];
				z = normals[ i + 2 ];

				n = 1.0 / Math.sqrt( x * x + y * y + z * z );

				normals[ i ] *= n;
				normals[ i + 1 ] *= n;
				normals[ i + 2 ] *= n;

			}

		},

		toJSON: function () {

			var data = {
				metadata: {
					version: 4.4,
					type: 'BufferGeometry',
					generator: 'BufferGeometry.toJSON'
				}
			};

			// standard BufferGeometry serialization

			data.uuid = this.uuid;
			data.type = this.type;
			if ( this.name !== '' ) data.name = this.name;

			if ( this.parameters !== undefined ) {

				var parameters = this.parameters;

				for ( var key in parameters ) {

					if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

				}

				return data;

			}

			data.data = { attributes: {} };

			var index = this.index;

			if ( index !== null ) {

				var array = Array.prototype.slice.call( index.array );

				data.data.index = {
					type: index.array.constructor.name,
					array: array
				};

			}

			var attributes = this.attributes;

			for ( var key in attributes ) {

				var attribute = attributes[ key ];

				var array = Array.prototype.slice.call( attribute.array );

				data.data.attributes[ key ] = {
					itemSize: attribute.itemSize,
					type: attribute.array.constructor.name,
					array: array
				};

			}

			var groups = this.groups;

			if ( groups.length > 0 ) {

				data.data.groups = JSON.parse( JSON.stringify( groups ) );

			}

			var boundingSphere = this.boundingSphere;

			if ( boundingSphere !== null ) {

				data.data.boundingSphere = {
					center: boundingSphere.center.toArray(),
					radius: boundingSphere.radius
				};

			}

			return data;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( source ) {

			var index = source.index;

			if ( index !== null ) {

				this.setIndex( index.clone() );

			}

			var attributes = source.attributes;

			for ( var name in attributes ) {

				var attribute = attributes[ name ];
				this.addAttribute( name, attribute.clone() );

			}

			var groups = source.groups;

			for ( var i = 0, l = groups.length; i < l; i ++ ) {

				var group = groups[ i ];
				this.addGroup( group.start, group.count );

			}

			return this;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	};

	THREE.EventDispatcher.prototype.apply( THREE.BufferGeometry.prototype );

	THREE.BufferGeometry.MaxIndex = 65535;

	// File:src/core/InstancedBufferGeometry.js

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */

	THREE.InstancedBufferGeometry = function () {

		THREE.BufferGeometry.call( this );

		this.type = 'InstancedBufferGeometry';
		this.maxInstancedCount = undefined;

	};

	THREE.InstancedBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
	THREE.InstancedBufferGeometry.prototype.constructor = THREE.InstancedBufferGeometry;

	THREE.InstancedBufferGeometry.prototype.addGroup = function ( start, count, instances ) {

		this.groups.push( {

			start: start,
			count: count,
			instances: instances

		} );

	};

	THREE.InstancedBufferGeometry.prototype.copy = function ( source ) {

		var index = source.index;

		if ( index !== null ) {

			this.setIndex( index.clone() );

		}

		var attributes = source.attributes;

		for ( var name in attributes ) {

			var attribute = attributes[ name ];
			this.addAttribute( name, attribute.clone() );

		}

		var groups = source.groups;

		for ( var i = 0, l = groups.length; i < l; i ++ ) {

			var group = groups[ i ];
			this.addGroup( group.start, group.count, group.instances );

		}

		return this;

	};

	THREE.EventDispatcher.prototype.apply( THREE.InstancedBufferGeometry.prototype );

	// File:src/animation/AnimationAction.js

	/**
	 *
	 * A clip that has been explicitly scheduled.
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 */

	THREE.AnimationAction = function ( clip, startTime, timeScale, weight, loop ) {

		if ( clip === undefined ) throw new Error( 'clip is null' );
		this.clip = clip;
		this.localRoot = null;
		this.startTime = startTime || 0;
		this.timeScale = timeScale || 1;
		this.weight = weight || 1;
		this.loop = loop || THREE.LoopRepeat;
		this.loopCount = 0;
		this.enabled = true;	// allow for easy disabling of the action.

		this.actionTime = - this.startTime;
		this.clipTime = 0;

		this.propertyBindings = [];
	};

	/*
	THREE.LoopOnce = 2200;
	THREE.LoopRepeat = 2201;
	THREE.LoopPingPing = 2202;
	*/

	THREE.AnimationAction.prototype = {

		constructor: THREE.AnimationAction,

		setLocalRoot: function( localRoot ) {

			this.localRoot = localRoot;

			return this;

		},

		updateTime: function( clipDeltaTime ) {

			var previousClipTime = this.clipTime;
	   		var previousLoopCount = this.loopCount;
	   		var previousActionTime = this.actionTime;

			var duration = this.clip.duration;

			this.actionTime = this.actionTime + clipDeltaTime;

			if ( this.loop === THREE.LoopOnce ) {

				this.loopCount = 0;
				this.clipTime = Math.min( Math.max( this.actionTime, 0 ), duration );

				// if time is changed since last time, see if we have hit a start/end limit
				if ( this.clipTime !== previousClipTime ) {

					if ( this.clipTime === duration ) {

						this.mixer.dispatchEvent( { type: 'finished', action: this, direction: 1 } );

					} else if ( this.clipTime === 0 ) {

						this.mixer.dispatchEvent( { type: 'finished', action: this, direction: -1 } );

					}

				}


				return this.clipTime;

			}

			this.loopCount = Math.floor( this.actionTime / duration );

			var newClipTime = this.actionTime - this.loopCount * duration;
			newClipTime = newClipTime % duration;

			// if we are ping pong looping, ensure that we go backwards when appropriate
			if ( this.loop == THREE.LoopPingPong ) {

				if ( Math.abs( this.loopCount % 2 ) === 1 ) {

					newClipTime = duration - newClipTime;

				}

			}

			this.clipTime = newClipTime;

			if ( this.loopCount !== previousLoopCount ) {

	   			this.mixer.dispatchEvent( { type: 'loop', action: this, loopDelta: ( this.loopCount - this.loopCount ) } );

	   		}

		   	return this.clipTime;

		},

		syncWith: function( action ) {

			this.actionTime = action.actionTime;
			this.timeScale = action.timeScale;

			return this;
		},

		warpToDuration: function( duration ) {

			this.timeScale = this.clip.duration / duration;

			return this;
		},

		init: function( time ) {

			this.clipTime = time - this.startTime;

			return this;

		},

		update: function( clipDeltaTime ) {

			this.updateTime( clipDeltaTime );

			var clipResults = this.clip.getAt( this.clipTime );

			return clipResults;

		},

		getTimeScaleAt: function( time ) {

			if ( this.timeScale.getAt ) {
				// pass in time, not clip time, allows for fadein/fadeout across multiple loops of the clip
				return this.timeScale.getAt( time );

			}

			return this.timeScale;

		},

		getWeightAt: function( time ) {

			if ( this.weight.getAt ) {
				// pass in time, not clip time, allows for fadein/fadeout across multiple loops of the clip
				return this.weight.getAt( time );

			}

			return this.weight;

		}

	};

	// File:src/animation/AnimationClip.js

	/**
	 *
	 * Reusable set of Tracks that represent an animation.
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 */

	THREE.AnimationClip = function ( name, duration, tracks ) {

		this.name = name;
		this.tracks = tracks;
		this.duration = ( duration !== undefined ) ? duration : -1;

		// this means it should figure out its duration by scanning the tracks
		if ( this.duration < 0 ) {
			for ( var i = 0; i < this.tracks.length; i ++ ) {
				var track = this.tracks[i];
				this.duration = Math.max( track.keys[ track.keys.length - 1 ].time );
			}
		}

		// maybe only do these on demand, as doing them here could potentially slow down loading
		// but leaving these here during development as this ensures a lot of testing of these functions
		this.trim();
		this.optimize();

		this.results = [];

	};

	THREE.AnimationClip.prototype = {

		constructor: THREE.AnimationClip,

		getAt: function( clipTime ) {

			clipTime = Math.max( 0, Math.min( clipTime, this.duration ) );

			for ( var i = 0; i < this.tracks.length; i ++ ) {

				var track = this.tracks[ i ];

				this.results[ i ] = track.getAt( clipTime );

			}

			return this.results;
		},

		trim: function() {

			for ( var i = 0; i < this.tracks.length; i ++ ) {

				this.tracks[ i ].trim( 0, this.duration );

			}

			return this;

		},

		optimize: function() {

			for ( var i = 0; i < this.tracks.length; i ++ ) {

				this.tracks[ i ].optimize();

			}

			return this;

		}

	};


	THREE.AnimationClip.CreateFromMorphTargetSequence = function( name, morphTargetSequence, fps ) {


		var numMorphTargets = morphTargetSequence.length;
		var tracks = [];

		for ( var i = 0; i < numMorphTargets; i ++ ) {

			var keys = [];

			keys.push( { time: ( i + numMorphTargets - 1 ) % numMorphTargets, value: 0 } );
			keys.push( { time: i, value: 1 } );
			keys.push( { time: ( i + 1 ) % numMorphTargets, value: 0 } );

			keys.sort( THREE.KeyframeTrack.keyComparer );

			// if there is a key at the first frame, duplicate it as the last frame as well for perfect loop.
			if ( keys[0].time === 0 ) {
				keys.push( {
					time: numMorphTargets,
					value: keys[0].value
				});
			}

			tracks.push( new THREE.NumberKeyframeTrack( '.morphTargetInfluences[' + morphTargetSequence[i].name + ']', keys ).scale( 1.0 / fps ) );
		}

		return new THREE.AnimationClip( name, -1, tracks );

	};

	THREE.AnimationClip.findByName = function( clipArray, name ) {

		for ( var i = 0; i < clipArray.length; i ++ ) {

			if ( clipArray[i].name === name ) {

				return clipArray[i];

			}
		}

		return null;

	};

	THREE.AnimationClip.CreateClipsFromMorphTargetSequences = function( morphTargets, fps ) {

		var animationToMorphTargets = {};

		// tested with https://regex101.com/ on trick sequences such flamingo_flyA_003, flamingo_run1_003, crdeath0059
		var pattern = /^([\w-]*?)([\d]+)$/;

		// sort morph target names into animation groups based patterns like Walk_001, Walk_002, Run_001, Run_002
		for ( var i = 0, il = morphTargets.length; i < il; i ++ ) {

			var morphTarget = morphTargets[ i ];
			var parts = morphTarget.name.match( pattern );

			if ( parts && parts.length > 1 ) {

				var name = parts[ 1 ];

				var animationMorphTargets = animationToMorphTargets[ name ];
				if ( ! animationMorphTargets ) {
					animationToMorphTargets[ name ] = animationMorphTargets = [];
				}

				animationMorphTargets.push( morphTarget );

			}

		}

		var clips = [];

		for ( var name in animationToMorphTargets ) {

			clips.push( THREE.AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps ) );
		}

		return clips;

	};

	// parse the standard JSON format for clips
	THREE.AnimationClip.parse = function( json ) {

		var tracks = [];

		for ( var i = 0; i < json.tracks.length; i ++ ) {

			tracks.push( THREE.KeyframeTrack.parse( json.tracks[i] ).scale( 1.0 / json.fps ) );

		}

		return new THREE.AnimationClip( json.name, json.duration, tracks );

	};


	// parse the animation.hierarchy format
	THREE.AnimationClip.parseAnimation = function( animation, bones, nodeName ) {

		if ( ! animation ) {
			console.error( "  no animation in JSONLoader data" );
			return null;
		}

		var convertTrack = function( trackName, animationKeys, propertyName, trackType, animationKeyToValueFunc ) {

			var keys = [];

			for ( var k = 0; k < animationKeys.length; k ++ ) {

				var animationKey = animationKeys[k];

				if ( animationKey[propertyName] !== undefined ) {

					keys.push( { time: animationKey.time, value: animationKeyToValueFunc( animationKey ) } );
				}

			}

			// only return track if there are actually keys.
			if ( keys.length > 0 ) {

				return new trackType( trackName, keys );

			}

			return null;

		};

		var tracks = [];

		var clipName = animation.name || 'default';
		var duration = animation.length || -1; // automatic length determination in AnimationClip.
		var fps = animation.fps || 30;

		var hierarchyTracks = animation.hierarchy || [];

		for ( var h = 0; h < hierarchyTracks.length; h ++ ) {

			var animationKeys = hierarchyTracks[ h ].keys;

			// skip empty tracks
			if ( ! animationKeys || animationKeys.length == 0 ) {
				continue;
			}

			// process morph targets in a way exactly compatible with AnimationHandler.init( animation )
			if ( animationKeys[0].morphTargets ) {

				// figure out all morph targets used in this track
				var morphTargetNames = {};
				for ( var k = 0; k < animationKeys.length; k ++ ) {

					if ( animationKeys[k].morphTargets ) {
						for ( var m = 0; m < animationKeys[k].morphTargets.length; m ++ ) {

							morphTargetNames[ animationKeys[k].morphTargets[m] ] = -1;
						}
					}

				}

				// create a track for each morph target with all zero morphTargetInfluences except for the keys in which the morphTarget is named.
				for ( var morphTargetName in morphTargetNames ) {

					var keys = [];

					for ( var m = 0; m < animationKeys[k].morphTargets.length; m ++ ) {

						var animationKey = animationKeys[k];

						keys.push( {
								time: animationKey.time,
								value: (( animationKey.morphTarget === morphTargetName ) ? 1 : 0 )
							});

					}

					tracks.push( new THREE.NumberKeyframeTrack( nodeName + '.morphTargetInfluence[' + morphTargetName + ']', keys ) );

				}

				duration = morphTargetNames.length * ( fps || 1.0 );

			} else {

				var boneName = nodeName + '.bones[' + bones[ h ].name + ']';

				// track contains positions...
				var positionTrack = convertTrack( boneName + '.position', animationKeys, 'pos', THREE.VectorKeyframeTrack, function( animationKey ) {
						return new THREE.Vector3().fromArray( animationKey.pos )
					} );

				if ( positionTrack ) tracks.push( positionTrack );

				// track contains quaternions...
				var quaternionTrack = convertTrack( boneName + '.quaternion', animationKeys, 'rot', THREE.QuaternionKeyframeTrack, function( animationKey ) {
						if ( animationKey.rot.slerp ) {
							return animationKey.rot.clone();
						} else {
							return new THREE.Quaternion().fromArray( animationKey.rot );
						}
					} );

				if ( quaternionTrack ) tracks.push( quaternionTrack );

				// track contains quaternions...
				var scaleTrack = convertTrack( boneName + '.scale', animationKeys, 'scl', THREE.VectorKeyframeTrack, function( animationKey ) {
						return new THREE.Vector3().fromArray( animationKey.scl )
					} );

				if ( scaleTrack ) tracks.push( scaleTrack );

			}
		}

		if ( tracks.length === 0 ) {

			return null;

		}

		var clip = new THREE.AnimationClip( clipName, duration, tracks );

		return clip;

	};

	// File:src/animation/AnimationMixer.js

	/**
	 *
	 * Mixes together the AnimationClips scheduled by AnimationActions and applies them to the root and subtree
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 */

	THREE.AnimationMixer = function( root ) {

		this.root = root;
		this.time = 0;
		this.timeScale = 1.0;
		this.actions = [];
		this.propertyBindingMap = {};

	};

	THREE.AnimationMixer.prototype = {

		constructor: THREE.AnimationMixer,

		addAction: function( action ) {

			// TODO: check for duplicate action names?  Or provide each action with a UUID?

			this.actions.push( action );
			action.init( this.time );
			action.mixer = this;

			var tracks = action.clip.tracks;

			var root = action.localRoot || this.root;

			for ( var i = 0; i < tracks.length; i ++ ) {

				var track = tracks[ i ];

				var propertyBindingKey = root.uuid + '-' + track.name;
				var propertyBinding = this.propertyBindingMap[ propertyBindingKey ];

				if ( propertyBinding === undefined ) {

					propertyBinding = new THREE.PropertyBinding( root, track.name );
					this.propertyBindingMap[ propertyBindingKey ] = propertyBinding;

				}

				// push in the same order as the tracks.
				action.propertyBindings.push( propertyBinding );

				// track usages of shared property bindings, because if we leave too many around, the mixer can get slow
				propertyBinding.referenceCount += 1;

			}

		},

		removeAllActions: function() {

			for ( var i = 0; i < this.actions.length; i ++ ) {

				this.actions[i].mixer = null;

			}

			// unbind all property bindings
			for ( var properyBindingKey in this.propertyBindingMap ) {

				this.propertyBindingMap[ properyBindingKey ].unbind();

			}

			this.actions = [];
			this.propertyBindingMap = {};

			return this;

		},

		removeAction: function( action ) {

			var index = this.actions.indexOf( action );

			if ( index !== - 1 ) {

				this.actions.splice( index, 1 );
				action.mixer = null;

			}


			// remove unused property bindings because if we leave them around the mixer can get slow
			var root = action.localRoot || this.root;
			var tracks = action.clip.tracks;

			for ( var i = 0; i < tracks.length; i ++ ) {

				var track = tracks[ i ];

				var propertyBindingKey = root.uuid + '-' + track.name;
				var propertyBinding = this.propertyBindingMap[ propertyBindingKey ];

				propertyBinding.referenceCount -= 1;

				if ( propertyBinding.referenceCount <= 0 ) {

					propertyBinding.unbind();

					delete this.propertyBindingMap[ propertyBindingKey ];

				}
			}

			return this;

		},

		// can be optimized if needed
		findActionByName: function( name ) {

			for ( var i = 0; i < this.actions.length; i ++ ) {

				if ( this.actions[i].name === name ) return this.actions[i];

			}

			return null;

		},

		play: function( action, optionalFadeInDuration ) {

			action.startTime = this.time;
			this.addAction( action );

			return this;

		},

		fadeOut: function( action, duration ) {

			var keys = [];

			keys.push( { time: this.time, value: 1 } );
			keys.push( { time: this.time + duration, value: 0 } );

			action.weight = new THREE.NumberKeyframeTrack( "weight", keys );

			return this;

		},

		fadeIn: function( action, duration ) {

			var keys = [];

			keys.push( { time: this.time, value: 0 } );
			keys.push( { time: this.time + duration, value: 1 } );

			action.weight = new THREE.NumberKeyframeTrack( "weight", keys );

			return this;

		},

		warp: function( action, startTimeScale, endTimeScale, duration ) {

			var keys = [];

			keys.push( { time: this.time, value: startTimeScale } );
			keys.push( { time: this.time + duration, value: endTimeScale } );

			action.timeScale = new THREE.NumberKeyframeTrack( "timeScale", keys );

			return this;

		},

		crossFade: function( fadeOutAction, fadeInAction, duration, warp ) {

			this.fadeOut( fadeOutAction, duration );
			this.fadeIn( fadeInAction, duration );

			if ( warp ) {

				var startEndRatio = fadeOutAction.clip.duration / fadeInAction.clip.duration;
				var endStartRatio = 1.0 / startEndRatio;

				this.warp( fadeOutAction, 1.0, startEndRatio, duration );
				this.warp( fadeInAction, endStartRatio, 1.0, duration );

			}

			return this;

		},

		update: function( deltaTime ) {

			var mixerDeltaTime = deltaTime * this.timeScale;
			this.time += mixerDeltaTime;

			for ( var i = 0; i < this.actions.length; i ++ ) {

				var action = this.actions[i];

				var weight = action.getWeightAt( this.time );

				var actionTimeScale = action.getTimeScaleAt( this.time );
				var actionDeltaTime = mixerDeltaTime * actionTimeScale;

				var actionResults = action.update( actionDeltaTime );

				if ( action.weight <= 0 || ! action.enabled ) continue;

				for ( var j = 0; j < actionResults.length; j ++ ) {

					var name = action.clip.tracks[j].name;

					action.propertyBindings[ j ].accumulate( actionResults[j], weight );

				}

			}

			// apply to nodes
			for ( var propertyBindingKey in this.propertyBindingMap ) {

				this.propertyBindingMap[ propertyBindingKey ].apply();

			}

			return this;

		}

	};

	THREE.EventDispatcher.prototype.apply( THREE.AnimationMixer.prototype );

	// File:src/animation/AnimationUtils.js

	/**
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 */

	THREE.AnimationUtils = {

		getEqualsFunc: function( exemplarValue ) {

			if ( exemplarValue.equals ) {
				return function equals_object( a, b ) {
					return a.equals( b );
				}
			}

			return function equals_primitive( a, b ) {
				return ( a === b );
			};

		},

		clone: function( exemplarValue ) {

			var typeName = typeof exemplarValue;
			if ( typeName === "object" ) {
				if ( exemplarValue.clone ) {
					return exemplarValue.clone();
				}
				console.error( "can not figure out how to copy exemplarValue", exemplarValue );
			}

			return exemplarValue;

		},

		lerp: function( a, b, alpha, interTrack ) {

			var lerpFunc = THREE.AnimationUtils.getLerpFunc( a, interTrack );

			return lerpFunc( a, b, alpha );

		},

		lerp_object: function( a, b, alpha ) {
			return a.lerp( b, alpha );
		},

		slerp_object: function( a, b, alpha ) {
			return a.slerp( b, alpha );
		},

		lerp_number: function( a, b, alpha ) {
			return a * ( 1 - alpha ) + b * alpha;
		},

		lerp_boolean: function( a, b, alpha ) {
			return ( alpha < 0.5 ) ? a : b;
		},

		lerp_boolean_immediate: function( a, b, alpha ) {
			return a;
		},

		lerp_string: function( a, b, alpha ) {
			return ( alpha < 0.5 ) ? a : b;
		},

		lerp_string_immediate: function( a, b, alpha ) {
	 		return a;
	 	},

		// NOTE: this is an accumulator function that modifies the first argument (e.g. a).	This is to minimize memory alocations.
		getLerpFunc: function( exemplarValue, interTrack ) {

			if ( exemplarValue === undefined || exemplarValue === null ) throw new Error( "examplarValue is null" );

			var typeName = typeof exemplarValue;

			switch( typeName ) {

				case "object":
					if ( exemplarValue.lerp ) {
						return THREE.AnimationUtils.lerp_object;
					}

					if ( exemplarValue.slerp ) {
						return THREE.AnimationUtils.slerp_object;
					}
					break;

				case "number":
					return THREE.AnimationUtils.lerp_number;

				case "boolean":
					if ( interTrack ) {
						return THREE.AnimationUtils.lerp_boolean;
					} else {
						return THREE.AnimationUtils.lerp_boolean_immediate;
					}

				case "string":
					if ( interTrack ) {
						return THREE.AnimationUtils.lerp_string;
					} else {
						return THREE.AnimationUtils.lerp_string_immediate;
					}

			}

		}

	};

	// File:src/animation/KeyframeTrack.js

	/**
	 *
	 * A Track that returns a keyframe interpolated value, currently linearly interpolated
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 */

	THREE.KeyframeTrack = function ( name, keys ) {

		if ( name === undefined ) throw new Error( "track name is undefined" );
		if ( keys === undefined || keys.length === 0 ) throw new Error( "no keys in track named " + name );

		this.name = name;
		this.keys = keys;	// time in seconds, value as value

		// the index of the last result, used as a starting point for local search.
		this.lastIndex = 0;

		this.validate();
		this.optimize();

	};

	THREE.KeyframeTrack.prototype = {

		constructor: THREE.KeyframeTrack,

		getAt: function( time ) {


			// this can not go higher than this.keys.length.
			while( ( this.lastIndex < this.keys.length ) && ( time >= this.keys[this.lastIndex].time ) ) {
				this.lastIndex ++;
			};

			// this can not go lower than 0.
			while( ( this.lastIndex > 0 ) && ( time < this.keys[this.lastIndex - 1].time ) ) {
				this.lastIndex --;
			}

			if ( this.lastIndex >= this.keys.length ) {

				this.setResult( this.keys[ this.keys.length - 1 ].value );

				return this.result;

			}

			if ( this.lastIndex === 0 ) {

				this.setResult( this.keys[ 0 ].value );

				return this.result;

			}

			var prevKey = this.keys[ this.lastIndex - 1 ];
			this.setResult( prevKey.value );

			// if true, means that prev/current keys are identical, thus no interpolation required.
			if ( prevKey.constantToNext ) {

				return this.result;

			}

			// linear interpolation to start with
			var currentKey = this.keys[ this.lastIndex ];
			var alpha = ( time - prevKey.time ) / ( currentKey.time - prevKey.time );
			this.result = this.lerpValues( this.result, currentKey.value, alpha );

			return this.result;

		},

		// move all keyframes either forwards or backwards in time
		shift: function( timeOffset ) {

			if ( timeOffset !== 0.0 ) {

				for ( var i = 0; i < this.keys.length; i ++ ) {
					this.keys[i].time += timeOffset;
				}

			}

			return this;

		},

		// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
		scale: function( timeScale ) {

			if ( timeScale !== 1.0 ) {

				for ( var i = 0; i < this.keys.length; i ++ ) {
					this.keys[i].time *= timeScale;
				}

			}

			return this;

		},

		// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
		// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
	 	trim: function( startTime, endTime ) {

			var firstKeysToRemove = 0;
			for ( var i = 1; i < this.keys.length; i ++ ) {
				if ( this.keys[i] <= startTime ) {
					firstKeysToRemove ++;
				}
			}

			var lastKeysToRemove = 0;
			for ( var i = this.keys.length - 2; i > 0; i ++ ) {
				if ( this.keys[i] >= endTime ) {
					lastKeysToRemove ++;
				} else {
					break;
				}
			}

			// remove last keys first because it doesn't affect the position of the first keys (the otherway around doesn't work as easily)
			if ( ( firstKeysToRemove + lastKeysToRemove ) > 0 ) {
				this.keys = this.keys.splice( firstKeysToRemove, this.keys.length - lastKeysToRemove - firstKeysToRemove );;
			}

			return this;

		},

		/* NOTE: This is commented out because we really shouldn't have to handle unsorted key lists
		         Tracks with out of order keys should be considered to be invalid.  - bhouston
		sort: function() {

			this.keys.sort( THREE.KeyframeTrack.keyComparer );

			return this;

		},*/

		// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
		// One could eventually ensure that all key.values in a track are all of the same type (otherwise interpolation makes no sense.)
		validate: function() {

			var prevKey = null;

			if ( this.keys.length === 0 ) {
				console.error( "  track is empty, no keys", this );
				return;
			}

			for ( var i = 0; i < this.keys.length; i ++ ) {

				var currKey = this.keys[i];

				if ( ! currKey ) {
					console.error( "  key is null in track", this, i );
					return;
				}

				if ( ( typeof currKey.time ) !== 'number' || isNaN( currKey.time ) ) {
					console.error( "  key.time is not a valid number", this, i, currKey );
					return;
				}

				if ( currKey.value === undefined || currKey.value === null) {
					console.error( "  key.value is null in track", this, i, currKey );
					return;
				}

				if ( prevKey && prevKey.time > currKey.time ) {
					console.error( "  key.time is less than previous key time, out of order keys", this, i, currKey, prevKey );
					return;
				}

				prevKey = currKey;

			}

			return this;

		},

		// currently only removes equivalent sequential keys (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0), which are common in morph target animations
		optimize: function() {

			var newKeys = [];
			var prevKey = this.keys[0];
			newKeys.push( prevKey );

			var equalsFunc = THREE.AnimationUtils.getEqualsFunc( prevKey.value );

			for ( var i = 1; i < this.keys.length - 1; i ++ ) {
				var currKey = this.keys[i];
				var nextKey = this.keys[i+1];

				// if prevKey & currKey are the same time, remove currKey.  If you want immediate adjacent keys, use an epsilon offset
				// it is not possible to have two keys at the same time as we sort them.  The sort is not stable on keys with the same time.
				if ( ( prevKey.time === currKey.time ) ) {

					continue;

				}

				// remove completely unnecessary keyframes that are the same as their prev and next keys
				if ( this.compareValues( prevKey.value, currKey.value ) && this.compareValues( currKey.value, nextKey.value ) ) {

					continue;

				}

				// determine if interpolation is required
				prevKey.constantToNext = this.compareValues( prevKey.value, currKey.value );

				newKeys.push( currKey );
				prevKey = currKey;
			}
			newKeys.push( this.keys[ this.keys.length - 1 ] );

			this.keys = newKeys;

			return this;

		}

	};

	THREE.KeyframeTrack.keyComparer = function keyComparator(key0, key1) {
		return key0.time - key1.time;
	};

	THREE.KeyframeTrack.parse = function( json ) {

		if ( json.type === undefined ) throw new Error( "track type undefined, can not parse" );

		var trackType = THREE.KeyframeTrack.GetTrackTypeForTypeName( json.type );

		return trackType.parse( json );

	};

	THREE.KeyframeTrack.GetTrackTypeForTypeName = function( typeName ) {
		switch( typeName.toLowerCase() ) {
		 	case "vector":
		 	case "vector2":
		 	case "vector3":
		 	case "vector4":
				return THREE.VectorKeyframeTrack;

		 	case "quaternion":
				return THREE.QuaternionKeyframeTrack;

		 	case "integer":
		 	case "scalar":
		 	case "double":
		 	case "float":
		 	case "number":
				return THREE.NumberKeyframeTrack;

		 	case "bool":
		 	case "boolean":
				return THREE.BooleanKeyframeTrack;

		 	case "string":
		 		return THREE.StringKeyframeTrack;
		};

		throw new Error( "Unsupported typeName: " + typeName );
	};

	// File:src/animation/PropertyBinding.js

	/**
	 *
	 * A track bound to a real value in the scene graph.
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 */

	THREE.PropertyBinding = function ( rootNode, trackName ) {

		this.rootNode = rootNode;
		this.trackName = trackName;
		this.referenceCount = 0;
		this.originalValue = null; // the value of the property before it was controlled by this binding

		var parseResults = THREE.PropertyBinding.parseTrackName( trackName );

		this.directoryName = parseResults.directoryName;
		this.nodeName = parseResults.nodeName;
		this.objectName = parseResults.objectName;
		this.objectIndex = parseResults.objectIndex;
		this.propertyName = parseResults.propertyName;
		this.propertyIndex = parseResults.propertyIndex;

		this.node = THREE.PropertyBinding.findNode( rootNode, this.nodeName ) || rootNode;

		this.cumulativeValue = null;
		this.cumulativeWeight = 0;
	};

	THREE.PropertyBinding.prototype = {

		constructor: THREE.PropertyBinding,

		reset: function() {

			this.cumulativeValue = null;
			this.cumulativeWeight = 0;

		},

		accumulate: function( value, weight ) {

			if ( ! this.isBound ) this.bind();

			if ( this.cumulativeWeight === 0 ) {

				if ( weight > 0 ) {

					if ( this.cumulativeValue === null ) {
						this.cumulativeValue = THREE.AnimationUtils.clone( value );
					}
					this.cumulativeWeight = weight;

				}

			} else {

				var lerpAlpha = weight / ( this.cumulativeWeight + weight );
				this.cumulativeValue = this.lerpValue( this.cumulativeValue, value, lerpAlpha );
				this.cumulativeWeight += weight;

			}

		},

		unbind: function() {

			if ( ! this.isBound ) return;

			this.setValue( this.originalValue );

			this.setValue = null;
			this.getValue = null;
			this.lerpValue = null;
			this.equalsValue = null;
			this.triggerDirty = null;
			this.isBound = false;

		},

		// bind to the real property in the scene graph, remember original value, memorize various accessors for speed/inefficiency
		bind: function() {

			if ( this.isBound ) return;

			var targetObject = this.node;

	 		// ensure there is a value node
			if ( ! targetObject ) {
				console.error( "  trying to update node for track: " + this.trackName + " but it wasn't found." );
				return;
			}

			if ( this.objectName ) {
				// special case were we need to reach deeper into the hierarchy to get the face materials....
				if ( this.objectName === "materials" ) {
					if ( ! targetObject.material ) {
						console.error( '  can not bind to material as node does not have a material', this );
						return;
					}
					if ( ! targetObject.material.materials ) {
						console.error( '  can not bind to material.materials as node.material does not have a materials array', this );
						return;
					}
					targetObject = targetObject.material.materials;
				} else if ( this.objectName === "bones" ) {
					if ( ! targetObject.skeleton ) {
						console.error( '  can not bind to bones as node does not have a skeleton', this );
						return;
					}
					// potential future optimization: skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

					targetObject = targetObject.skeleton.bones;

					// support resolving morphTarget names into indices.
					for ( var i = 0; i < targetObject.length; i ++ ) {
						if ( targetObject[i].name === this.objectIndex ) {
							this.objectIndex = i;
							break;
						}
					}
				} else {

					if ( targetObject[ this.objectName ] === undefined ) {
						console.error( '  can not bind to objectName of node, undefined', this );
						return;
					}
					targetObject = targetObject[ this.objectName ];
				}

				if ( this.objectIndex !== undefined ) {
					if ( targetObject[ this.objectIndex ] === undefined ) {
						console.error( "  trying to bind to objectIndex of objectName, but is undefined:", this, targetObject );
						return;
					}

					targetObject = targetObject[ this.objectIndex ];
				}

			}

	 		// special case mappings
	 		var nodeProperty = targetObject[ this.propertyName ];
			if ( ! nodeProperty ) {
				console.error( "  trying to update property for track: " + this.nodeName + '.' + this.propertyName + " but it wasn't found.", targetObject );
				return;
			}

			// access a sub element of the property array (only primitives are supported right now)
			if ( this.propertyIndex !== undefined ) {

				if ( this.propertyName === "morphTargetInfluences" ) {
					// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

					// support resolving morphTarget names into indices.
					if ( ! targetObject.geometry ) {
						console.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry', this );
					}
					if ( ! targetObject.geometry.morphTargets ) {
						console.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets', this );
					}

					for ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {
						if ( targetObject.geometry.morphTargets[i].name === this.propertyIndex ) {
							this.propertyIndex = i;
							break;
						}
					}
				}

				this.setValue = function setValue_propertyIndexed( value ) {
					if ( ! this.equalsValue( nodeProperty[ this.propertyIndex ], value ) ) {
						nodeProperty[ this.propertyIndex ] = value;
						return true;
					}
					return false;
				};

				this.getValue = function getValue_propertyIndexed() {
					return nodeProperty[ this.propertyIndex ];
				};

			}
			// must use copy for Object3D.Euler/Quaternion
			else if ( nodeProperty.copy ) {

				this.setValue = function setValue_propertyObject( value ) {
					if ( ! this.equalsValue( nodeProperty, value ) ) {
						nodeProperty.copy( value );
						return true;
					}
					return false;
				}

				this.getValue = function getValue_propertyObject() {
					return nodeProperty;
				};

			}
			// otherwise just set the property directly on the node (do not use nodeProperty as it may not be a reference object)
			else {

				this.setValue = function setValue_property( value ) {
					if ( ! this.equalsValue( targetObject[ this.propertyName ], value ) ) {
						targetObject[ this.propertyName ] = value;
						return true;
					}
					return false;
				}

				this.getValue = function getValue_property() {
					return targetObject[ this.propertyName ];
				};

			}

			// trigger node dirty
			if ( targetObject.needsUpdate !== undefined ) { // material

				this.triggerDirty = function triggerDirty_needsUpdate() {
					this.node.needsUpdate = true;
				}

			} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform

				this.triggerDirty = function triggerDirty_matrixWorldNeedsUpdate() {
					targetObject.matrixWorldNeedsUpdate = true;
				}

			}

			this.originalValue = this.getValue();

			this.equalsValue = THREE.AnimationUtils.getEqualsFunc( this.originalValue );
			this.lerpValue = THREE.AnimationUtils.getLerpFunc( this.originalValue, true );

			this.isBound = true;

		},

		apply: function() {

			// for speed capture the setter pattern as a closure (sort of a memoization pattern: https://en.wikipedia.org/wiki/Memoization)
			if ( ! this.isBound ) this.bind();

			// early exit if there is nothing to apply.
			if ( this.cumulativeWeight > 0 ) {

				// blend with original value
				if ( this.cumulativeWeight < 1 ) {

					var remainingWeight = 1 - this.cumulativeWeight;
					var lerpAlpha = remainingWeight / ( this.cumulativeWeight + remainingWeight );
					this.cumulativeValue = this.lerpValue( this.cumulativeValue, this.originalValue, lerpAlpha );

				}

				var valueChanged = this.setValue( this.cumulativeValue );

				if ( valueChanged && this.triggerDirty ) {
					this.triggerDirty();
				}

				// reset accumulator
				this.cumulativeValue = null;
				this.cumulativeWeight = 0;

			}
		}

	};


	THREE.PropertyBinding.parseTrackName = function( trackName ) {

		// matches strings in the form of:
		//    nodeName.property
		//    nodeName.property[accessor]
		//    nodeName.material.property[accessor]
		//    uuid.property[accessor]
		//    uuid.objectName[objectIndex].propertyName[propertyIndex]
		//    parentName/nodeName.property
		//    parentName/parentName/nodeName.property[index]
		//	  .bone[Armature.DEF_cog].position
		// created and tested via https://regex101.com/#javascript

		var re = /^(([\w]+\/)*)([\w-\d]+)?(\.([\w]+)(\[([\w\d\[\]\_. ]+)\])?)?(\.([\w.]+)(\[([\w\d\[\]\_. ]+)\])?)$/;
		var matches = re.exec(trackName);

		if ( ! matches ) {
			throw new Error( "cannot parse trackName at all: " + trackName );
		}

	    if (matches.index === re.lastIndex) {
	        re.lastIndex++;
	    }

		var results = {
			directoryName: matches[1],
			nodeName: matches[3], 	// allowed to be null, specified root node.
			objectName: matches[5],
			objectIndex: matches[7],
			propertyName: matches[9],
			propertyIndex: matches[11]	// allowed to be null, specifies that the whole property is set.
		};

		if ( results.propertyName === null || results.propertyName.length === 0 ) {
			throw new Error( "can not parse propertyName from trackName: " + trackName );
		}

		return results;

	};

	THREE.PropertyBinding.findNode = function( root, nodeName ) {

		function searchSkeleton( skeleton ) {

			for ( var i = 0; i < skeleton.bones.length; i ++ ) {

				var bone = skeleton.bones[i];

				if ( bone.name === nodeName ) {

					return bone;

				}
			}

			return null;

		}

		function searchNodeSubtree( children ) {

			for ( var i = 0; i < children.length; i ++ ) {

				var childNode = children[i];

				if ( childNode.name === nodeName || childNode.uuid === nodeName ) {

					return childNode;

				}

				var result = searchNodeSubtree( childNode.children );

				if ( result ) return result;

			}

			return null;

		}

		//

		if ( ! nodeName || nodeName === "" || nodeName === "root" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid ) {

			return root;

		}

		// search into skeleton bones.
		if ( root.skeleton ) {

			var bone = searchSkeleton( root.skeleton );

			if ( bone ) {

				return bone;

			}
		}

		// search into node subtree.
		if ( root.children ) {

			var subTreeNode = searchNodeSubtree( root.children );

			if ( subTreeNode ) {

				return subTreeNode;

			}

		}

		return null;
	}

	// File:src/animation/tracks/VectorKeyframeTrack.js

	/**
	 *
	 * A Track that interpolates Vectors
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 */

	THREE.VectorKeyframeTrack = function ( name, keys ) {

		THREE.KeyframeTrack.call( this, name, keys );

		// local cache of value type to avoid allocations during runtime.
		this.result = this.keys[0].value.clone();

	};

	THREE.VectorKeyframeTrack.prototype = Object.create( THREE.KeyframeTrack.prototype );

	THREE.VectorKeyframeTrack.prototype.constructor = THREE.VectorKeyframeTrack;

	THREE.VectorKeyframeTrack.prototype.setResult = function( value ) {

		this.result.copy( value );

	};

	// memoization of the lerp function for speed.
	// NOTE: Do not optimize as a prototype initialization closure, as value0 will be different on a per class basis.
	THREE.VectorKeyframeTrack.prototype.lerpValues = function( value0, value1, alpha ) {

		return value0.lerp( value1, alpha );

	};

	THREE.VectorKeyframeTrack.prototype.compareValues = function( value0, value1 ) {

		return value0.equals( value1 );

	};

	THREE.VectorKeyframeTrack.prototype.clone = function() {

		var clonedKeys = [];

		for ( var i = 0; i < this.keys.length; i ++ ) {

			var key = this.keys[i];
			clonedKeys.push( {
				time: key.time,
				value: key.value.clone()
			} );
		}

		return new THREE.VectorKeyframeTrack( this.name, clonedKeys );

	};

	THREE.VectorKeyframeTrack.parse = function( json ) {

		var elementCount = json.keys[0].value.length;
		var valueType = THREE[ 'Vector' + elementCount ];

		var keys = [];

		for ( var i = 0; i < json.keys.length; i ++ ) {
			var jsonKey = json.keys[i];
			keys.push( {
				value: new valueType().fromArray( jsonKey.value ),
				time: jsonKey.time
			} );
		}

		return new THREE.VectorKeyframeTrack( json.name, keys );

	};

	// File:src/animation/tracks/QuaternionKeyframeTrack.js

	/**
	 *
	 * A Track that interpolates Quaternion
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 */

	THREE.QuaternionKeyframeTrack = function ( name, keys ) {

		THREE.KeyframeTrack.call( this, name, keys );

		// local cache of value type to avoid allocations during runtime.
		this.result = this.keys[0].value.clone();

	};

	THREE.QuaternionKeyframeTrack.prototype = Object.create( THREE.KeyframeTrack.prototype );

	THREE.QuaternionKeyframeTrack.prototype.constructor = THREE.QuaternionKeyframeTrack;

	THREE.QuaternionKeyframeTrack.prototype.setResult = function( value ) {

		this.result.copy( value );

	};

	// memoization of the lerp function for speed.
	// NOTE: Do not optimize as a prototype initialization closure, as value0 will be different on a per class basis.
	THREE.QuaternionKeyframeTrack.prototype.lerpValues = function( value0, value1, alpha ) {

		return value0.slerp( value1, alpha );

	};

	THREE.QuaternionKeyframeTrack.prototype.compareValues = function( value0, value1 ) {

		return value0.equals( value1 );

	};

	THREE.QuaternionKeyframeTrack.prototype.multiply = function( quat ) {

		for ( var i = 0; i < this.keys.length; i ++ ) {

			this.keys[i].value.multiply( quat );

		}

		return this;

	};

	THREE.QuaternionKeyframeTrack.prototype.clone = function() {

		var clonedKeys = [];

		for ( var i = 0; i < this.keys.length; i ++ ) {

			var key = this.keys[i];
			clonedKeys.push( {
				time: key.time,
				value: key.value.clone()
			} );
		}

		return new THREE.QuaternionKeyframeTrack( this.name, clonedKeys );

	};

	THREE.QuaternionKeyframeTrack.parse = function( json ) {

		var keys = [];

		for ( var i = 0; i < json.keys.length; i ++ ) {
			var jsonKey = json.keys[i];
			keys.push( {
				value: new THREE.Quaternion().fromArray( jsonKey.value ),
				time: jsonKey.time
			} );
		}

		return new THREE.QuaternionKeyframeTrack( json.name, keys );

	};

	// File:src/animation/tracks/StringKeyframeTrack.js

	/**
	 *
	 * A Track that interpolates Strings
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 */

	THREE.StringKeyframeTrack = function ( name, keys ) {

		THREE.KeyframeTrack.call( this, name, keys );

		// local cache of value type to avoid allocations during runtime.
		this.result = this.keys[0].value;

	};

	THREE.StringKeyframeTrack.prototype = Object.create( THREE.KeyframeTrack.prototype );

	THREE.StringKeyframeTrack.prototype.constructor = THREE.StringKeyframeTrack;

	THREE.StringKeyframeTrack.prototype.setResult = function( value ) {

		this.result = value;

	};

	// memoization of the lerp function for speed.
	// NOTE: Do not optimize as a prototype initialization closure, as value0 will be different on a per class basis.
	THREE.StringKeyframeTrack.prototype.lerpValues = function( value0, value1, alpha ) {

		return ( alpha < 1.0 ) ? value0 : value1;

	};

	THREE.StringKeyframeTrack.prototype.compareValues = function( value0, value1 ) {

		return ( value0 === value1 );

	};

	THREE.StringKeyframeTrack.prototype.clone = function() {

		var clonedKeys = [];

		for ( var i = 0; i < this.keys.length; i ++ ) {

			var key = this.keys[i];
			clonedKeys.push( {
				time: key.time,
				value: key.value
			} );
		}

		return new THREE.StringKeyframeTrack( this.name, clonedKeys );

	};

	THREE.StringKeyframeTrack.parse = function( json ) {

		return new THREE.StringKeyframeTrack( json.name, json.keys );

	};

	// File:src/animation/tracks/BooleanKeyframeTrack.js

	/**
	 *
	 * A Track that interpolates Boolean
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 */

	THREE.BooleanKeyframeTrack = function ( name, keys ) {

		THREE.KeyframeTrack.call( this, name, keys );

		// local cache of value type to avoid allocations during runtime.
		this.result = this.keys[0].value;

	};

	THREE.BooleanKeyframeTrack.prototype = Object.create( THREE.KeyframeTrack.prototype );

	THREE.BooleanKeyframeTrack.prototype.constructor = THREE.BooleanKeyframeTrack;

	THREE.BooleanKeyframeTrack.prototype.setResult = function( value ) {

		this.result = value;

	};

	// memoization of the lerp function for speed.
	// NOTE: Do not optimize as a prototype initialization closure, as value0 will be different on a per class basis.
	THREE.BooleanKeyframeTrack.prototype.lerpValues = function( value0, value1, alpha ) {

		return ( alpha < 1.0 ) ? value0 : value1;

	};

	THREE.BooleanKeyframeTrack.prototype.compareValues = function( value0, value1 ) {

		return ( value0 === value1 );

	};

	THREE.BooleanKeyframeTrack.prototype.clone = function() {

		var clonedKeys = [];

		for ( var i = 0; i < this.keys.length; i ++ ) {

			var key = this.keys[i];
			clonedKeys.push( {
				time: key.time,
				value: key.value
			} );
		}

		return new THREE.BooleanKeyframeTrack( this.name, clonedKeys );

	};

	THREE.BooleanKeyframeTrack.parse = function( json ) {

		return new THREE.BooleanKeyframeTrack( json.name, json.keys );

	};

	// File:src/animation/tracks/NumberKeyframeTrack.js

	/**
	 *
	 * A Track that interpolates Numbers
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 */

	THREE.NumberKeyframeTrack = function ( name, keys ) {

		THREE.KeyframeTrack.call( this, name, keys );

		// local cache of value type to avoid allocations during runtime.
		this.result = this.keys[0].value;

	};

	THREE.NumberKeyframeTrack.prototype = Object.create( THREE.KeyframeTrack.prototype );

	THREE.NumberKeyframeTrack.prototype.constructor = THREE.NumberKeyframeTrack;

	THREE.NumberKeyframeTrack.prototype.setResult = function( value ) {

		this.result = value;

	};

	// memoization of the lerp function for speed.
	// NOTE: Do not optimize as a prototype initialization closure, as value0 will be different on a per class basis.
	THREE.NumberKeyframeTrack.prototype.lerpValues = function( value0, value1, alpha ) {

		return value0 * ( 1 - alpha ) + value1 * alpha;

	};

	THREE.NumberKeyframeTrack.prototype.compareValues = function( value0, value1 ) {

		return ( value0 === value1 );

	};

	THREE.NumberKeyframeTrack.prototype.clone = function() {

		var clonedKeys = [];

		for ( var i = 0; i < this.keys.length; i ++ ) {

			var key = this.keys[i];
			clonedKeys.push( {
				time: key.time,
				value: key.value
			} );
		}

		return new THREE.NumberKeyframeTrack( this.name, clonedKeys );

	};

	THREE.NumberKeyframeTrack.parse = function( json ) {

		return new THREE.NumberKeyframeTrack( json.name, json.keys );

	};

	// File:src/cameras/Camera.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author WestLangley / http://github.com/WestLangley
	*/

	THREE.Camera = function () {

		THREE.Object3D.call( this );

		this.type = 'Camera';

		this.matrixWorldInverse = new THREE.Matrix4();
		this.projectionMatrix = new THREE.Matrix4();

	};

	THREE.Camera.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Camera.prototype.constructor = THREE.Camera;

	THREE.Camera.prototype.getWorldDirection = function () {

		var quaternion = new THREE.Quaternion();

		return function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();

			this.getWorldQuaternion( quaternion );

			return result.set( 0, 0, - 1 ).applyQuaternion( quaternion );

		};

	}();

	THREE.Camera.prototype.lookAt = function () {

		// This routine does not support cameras with rotated and/or translated parent(s)

		var m1 = new THREE.Matrix4();

		return function ( vector ) {

			m1.lookAt( this.position, vector, this.up );

			this.quaternion.setFromRotationMatrix( m1 );

		};

	}();

	THREE.Camera.prototype.clone = function () {

		return new this.constructor().copy( this );

	};

	THREE.Camera.prototype.copy = function ( source ) {

		THREE.Object3D.prototype.copy.call( this, source );

		this.matrixWorldInverse.copy( source.matrixWorldInverse );
		this.projectionMatrix.copy( source.projectionMatrix );

		return this;

	};

	// File:src/cameras/CubeCamera.js

	/**
	 * Camera for rendering cube maps
	 *	- renders scene into axis-aligned cube
	 *
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.CubeCamera = function ( near, far, cubeResolution ) {

		THREE.Object3D.call( this );

		this.type = 'CubeCamera';

		var fov = 90, aspect = 1;

		var cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraPX.up.set( 0, - 1, 0 );
		cameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );
		this.add( cameraPX );

		var cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraNX.up.set( 0, - 1, 0 );
		cameraNX.lookAt( new THREE.Vector3( - 1, 0, 0 ) );
		this.add( cameraNX );

		var cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraPY.up.set( 0, 0, 1 );
		cameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );
		this.add( cameraPY );

		var cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraNY.up.set( 0, 0, - 1 );
		cameraNY.lookAt( new THREE.Vector3( 0, - 1, 0 ) );
		this.add( cameraNY );

		var cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraPZ.up.set( 0, - 1, 0 );
		cameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );
		this.add( cameraPZ );

		var cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraNZ.up.set( 0, - 1, 0 );
		cameraNZ.lookAt( new THREE.Vector3( 0, 0, - 1 ) );
		this.add( cameraNZ );

		this.renderTarget = new THREE.WebGLRenderTargetCube( cubeResolution, cubeResolution, { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter } );

		this.updateCubeMap = function ( renderer, scene ) {

			if ( this.parent === null ) this.updateMatrixWorld();

			var renderTarget = this.renderTarget;
			var generateMipmaps = renderTarget.texture.generateMipmaps;

			renderTarget.texture.generateMipmaps = false;

			renderTarget.activeCubeFace = 0;
			renderer.render( scene, cameraPX, renderTarget );

			renderTarget.activeCubeFace = 1;
			renderer.render( scene, cameraNX, renderTarget );

			renderTarget.activeCubeFace = 2;
			renderer.render( scene, cameraPY, renderTarget );

			renderTarget.activeCubeFace = 3;
			renderer.render( scene, cameraNY, renderTarget );

			renderTarget.activeCubeFace = 4;
			renderer.render( scene, cameraPZ, renderTarget );

			renderTarget.texture.generateMipmaps = generateMipmaps;

			renderTarget.activeCubeFace = 5;
			renderer.render( scene, cameraNZ, renderTarget );

			renderer.setRenderTarget( null );

		};

	};

	THREE.CubeCamera.prototype = Object.create( THREE.Object3D.prototype );
	THREE.CubeCamera.prototype.constructor = THREE.CubeCamera;

	// File:src/cameras/OrthographicCamera.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.OrthographicCamera = function ( left, right, top, bottom, near, far ) {

		THREE.Camera.call( this );

		this.type = 'OrthographicCamera';

		this.zoom = 1;

		this.left = left;
		this.right = right;
		this.top = top;
		this.bottom = bottom;

		this.near = ( near !== undefined ) ? near : 0.1;
		this.far = ( far !== undefined ) ? far : 2000;

		this.updateProjectionMatrix();

	};

	THREE.OrthographicCamera.prototype = Object.create( THREE.Camera.prototype );
	THREE.OrthographicCamera.prototype.constructor = THREE.OrthographicCamera;

	THREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {

		var dx = ( this.right - this.left ) / ( 2 * this.zoom );
		var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
		var cx = ( this.right + this.left ) / 2;
		var cy = ( this.top + this.bottom ) / 2;

		this.projectionMatrix.makeOrthographic( cx - dx, cx + dx, cy + dy, cy - dy, this.near, this.far );

	};

	THREE.OrthographicCamera.prototype.copy = function ( source ) {
		
		THREE.Camera.prototype.copy.call( this, source );
		
		this.left = source.left;
		this.right = source.right;
		this.top = source.top;
		this.bottom = source.bottom;
		this.near = source.near;
		this.far = source.far;
		
		this.zoom = source.zoom;
		
		return this;
			
	};

	THREE.OrthographicCamera.prototype.toJSON = function ( meta ) {

		var data = THREE.Object3D.prototype.toJSON.call( this, meta );

		data.object.zoom = this.zoom;
		data.object.left = this.left;
		data.object.right = this.right;
		data.object.top = this.top;
		data.object.bottom = this.bottom;
		data.object.near = this.near;
		data.object.far = this.far;

		return data;

	};

	// File:src/cameras/PerspectiveCamera.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author greggman / http://games.greggman.com/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 */

	THREE.PerspectiveCamera = function ( fov, aspect, near, far ) {

		THREE.Camera.call( this );

		this.type = 'PerspectiveCamera';

		this.zoom = 1;

		this.fov = fov !== undefined ? fov : 50;
		this.aspect = aspect !== undefined ? aspect : 1;
		this.near = near !== undefined ? near : 0.1;
		this.far = far !== undefined ? far : 2000;

		this.updateProjectionMatrix();

	};

	THREE.PerspectiveCamera.prototype = Object.create( THREE.Camera.prototype );
	THREE.PerspectiveCamera.prototype.constructor = THREE.PerspectiveCamera;


	/**
	 * Uses Focal Length (in mm) to estimate and set FOV
	 * 35mm (full-frame) camera is used if frame size is not specified;
	 * Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html
	 */

	THREE.PerspectiveCamera.prototype.setLens = function ( focalLength, frameHeight ) {

		if ( frameHeight === undefined ) frameHeight = 24;

		this.fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );
		this.updateProjectionMatrix();

	};


	/**
	 * Sets an offset in a larger frustum. This is useful for multi-window or
	 * multi-monitor/multi-machine setups.
	 *
	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
	 * the monitors are in grid like this
	 *
	 *   +---+---+---+
	 *   | A | B | C |
	 *   +---+---+---+
	 *   | D | E | F |
	 *   +---+---+---+
	 *
	 * then for each monitor you would call it like this
	 *
	 *   var w = 1920;
	 *   var h = 1080;
	 *   var fullWidth = w * 3;
	 *   var fullHeight = h * 2;
	 *
	 *   --A--
	 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
	 *   --B--
	 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
	 *   --C--
	 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
	 *   --D--
	 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
	 *   --E--
	 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
	 *   --F--
	 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
	 *
	 *   Note there is no reason monitors have to be the same size or in a grid.
	 */

	THREE.PerspectiveCamera.prototype.setViewOffset = function ( fullWidth, fullHeight, x, y, width, height ) {

		this.fullWidth = fullWidth;
		this.fullHeight = fullHeight;
		this.x = x;
		this.y = y;
		this.width = width;
		this.height = height;

		this.updateProjectionMatrix();

	};


	THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {

		var fov = THREE.Math.radToDeg( 2 * Math.atan( Math.tan( THREE.Math.degToRad( this.fov ) * 0.5 ) / this.zoom ) );

		if ( this.fullWidth ) {

			var aspect = this.fullWidth / this.fullHeight;
			var top = Math.tan( THREE.Math.degToRad( fov * 0.5 ) ) * this.near;
			var bottom = - top;
			var left = aspect * bottom;
			var right = aspect * top;
			var width = Math.abs( right - left );
			var height = Math.abs( top - bottom );

			this.projectionMatrix.makeFrustum(
				left + this.x * width / this.fullWidth,
				left + ( this.x + this.width ) * width / this.fullWidth,
				top - ( this.y + this.height ) * height / this.fullHeight,
				top - this.y * height / this.fullHeight,
				this.near,
				this.far
			);

		} else {

			this.projectionMatrix.makePerspective( fov, this.aspect, this.near, this.far );

		}

	};

	THREE.PerspectiveCamera.prototype.copy = function ( source ) {
		
		THREE.Camera.prototype.copy.call( this, source );
		
		this.fov = source.fov;
		this.aspect = source.aspect;
		this.near = source.near;
		this.far = source.far;
		
		this.zoom = source.zoom;
		
		return this;
			
	};

	THREE.PerspectiveCamera.prototype.toJSON = function ( meta ) {

		var data = THREE.Object3D.prototype.toJSON.call( this, meta );

		data.object.zoom = this.zoom;
		data.object.fov = this.fov;
		data.object.aspect = this.aspect;
		data.object.near = this.near;
		data.object.far = this.far;

		return data;

	};

	// File:src/lights/Light.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Light = function ( color ) {

		THREE.Object3D.call( this );

		this.type = 'Light';

		this.color = new THREE.Color( color );

		this.receiveShadow = undefined;

	};

	THREE.Light.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Light.prototype.constructor = THREE.Light;

	Object.defineProperties( THREE.Light.prototype, {
		onlyShadow: {
			set: function ( value ) {
				console.warn( 'THREE.Light: .onlyShadow has been removed.' );
			}
		},
		shadowCameraFov: {
			set: function ( value ) {
				this.shadow.camera.fov = value;
			}
		},
		shadowCameraLeft: {
			set: function ( value ) {
				this.shadow.camera.left = value;
			}
		},
		shadowCameraRight: {
			set: function ( value ) {
				this.shadow.camera.right = value;
			}
		},
		shadowCameraTop: {
			set: function ( value ) {
				this.shadow.camera.top = value;
			}
		},
		shadowCameraBottom: {
			set: function ( value ) {
				this.shadow.camera.bottom = value;
			}
		},
		shadowCameraNear: {
			set: function ( value ) {
				this.shadow.camera.near = value;
			}
		},
		shadowCameraFar: {
			set: function ( value ) {
				this.shadow.camera.far = value;
			}
		},
		shadowCameraVisible: {
			set: function ( value ) {
				console.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow ) instead.' );
			}
		},
		shadowBias: {
			set: function ( value ) {
				this.shadow.bias = value;
			}
		},
		shadowDarkness: {
			set: function ( value ) {
				this.shadow.darkness = value;
			}
		},
		shadowMapWidth: {
			set: function ( value ) {
				this.shadow.mapSize.width = value;
			}
		},
		shadowMapHeight: {
			set: function ( value ) {
				this.shadow.mapSize.height = value;
			}
		}
	} );

	THREE.Light.prototype.copy = function ( source ) {

		THREE.Object3D.prototype.copy.call( this, source );

		this.color.copy( source.color );

		return this;

	};

	THREE.Light.prototype.toJSON = function ( meta ) {

		var data = THREE.Object3D.prototype.toJSON.call( this, meta );

		data.object.color = this.color.getHex();
		if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();

		if ( this.intensity !== undefined ) data.object.intensity = this.intensity;
		if ( this.distance !== undefined ) data.object.distance = this.distance;
		if ( this.angle !== undefined ) data.object.angle = this.angle;
		if ( this.decay !== undefined ) data.object.decay = this.decay;
		if ( this.exponent !== undefined ) data.object.exponent = this.exponent;

		return data;

	};

	// File:src/lights/LightShadow.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.LightShadow = function ( camera ) {

		this.camera = camera;

		this.bias = 0;
		this.darkness = 1;

		this.mapSize = new THREE.Vector2( 512, 512 );

		this.map = null;
		this.matrix = null;

	};

	THREE.LightShadow.prototype = {

		constructor: THREE.LightShadow,

		copy: function ( source ) {

			this.camera = source.camera.clone();

			this.bias = source.bias;
			this.darkness = source.darkness;

			this.mapSize.copy( source.mapSize );

		},

		clone: function () {

			return new this.constructor().copy( this );

		}

	};

	// File:src/lights/AmbientLight.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.AmbientLight = function ( color ) {

		THREE.Light.call( this, color );

		this.type = 'AmbientLight';

		this.castShadow = undefined;

	};

	THREE.AmbientLight.prototype = Object.create( THREE.Light.prototype );
	THREE.AmbientLight.prototype.constructor = THREE.AmbientLight;

	// File:src/lights/DirectionalLight.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.DirectionalLight = function ( color, intensity ) {

		THREE.Light.call( this, color );

		this.type = 'DirectionalLight';

		this.position.set( 0, 1, 0 );
		this.updateMatrix();

		this.target = new THREE.Object3D();

		this.intensity = ( intensity !== undefined ) ? intensity : 1;

		this.shadow = new THREE.LightShadow( new THREE.OrthographicCamera( - 500, 500, 500, - 500, 50, 5000 ) );

	};

	THREE.DirectionalLight.prototype = Object.create( THREE.Light.prototype );
	THREE.DirectionalLight.prototype.constructor = THREE.DirectionalLight;

	THREE.DirectionalLight.prototype.copy = function ( source ) {

		THREE.Light.prototype.copy.call( this, source );

		this.intensity = source.intensity;
		this.target = source.target.clone();

		this.shadow = source.shadow.clone();

		return this;

	};

	// File:src/lights/HemisphereLight.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.HemisphereLight = function ( skyColor, groundColor, intensity ) {

		THREE.Light.call( this, skyColor );

		this.type = 'HemisphereLight';

		this.castShadow = undefined;

		this.position.set( 0, 1, 0 );
		this.updateMatrix();

		this.groundColor = new THREE.Color( groundColor );
		this.intensity = ( intensity !== undefined ) ? intensity : 1;

	};

	THREE.HemisphereLight.prototype = Object.create( THREE.Light.prototype );
	THREE.HemisphereLight.prototype.constructor = THREE.HemisphereLight;

	THREE.HemisphereLight.prototype.copy = function ( source ) {

		THREE.Light.prototype.copy.call( this, source );

		this.groundColor.copy( source.groundColor );
		this.intensity = source.intensity;

		return this;

	};

	// File:src/lights/PointLight.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */


	THREE.PointLight = function ( color, intensity, distance, decay ) {

		THREE.Light.call( this, color );

		this.type = 'PointLight';

		this.intensity = ( intensity !== undefined ) ? intensity : 1;
		this.distance = ( distance !== undefined ) ? distance : 0;
		this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

		this.shadow = new THREE.LightShadow( new THREE.PerspectiveCamera( 90, 1, 1, 500 ) );

	};

	THREE.PointLight.prototype = Object.create( THREE.Light.prototype );
	THREE.PointLight.prototype.constructor = THREE.PointLight;

	THREE.PointLight.prototype.copy = function ( source ) {

		THREE.Light.prototype.copy.call( this, source );

		this.intensity = source.intensity;
		this.distance = source.distance;
		this.decay = source.decay;

		this.shadow = source.shadow.clone();

		return this;

	};

	// File:src/lights/SpotLight.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.SpotLight = function ( color, intensity, distance, angle, exponent, decay ) {

		THREE.Light.call( this, color );

		this.type = 'SpotLight';

		this.position.set( 0, 1, 0 );
		this.updateMatrix();

		this.target = new THREE.Object3D();

		this.intensity = ( intensity !== undefined ) ? intensity : 1;
		this.distance = ( distance !== undefined ) ? distance : 0;
		this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
		this.exponent = ( exponent !== undefined ) ? exponent : 10;
		this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

		this.shadow = new THREE.LightShadow( new THREE.PerspectiveCamera( 50, 1, 50, 5000 ) );

	};

	THREE.SpotLight.prototype = Object.create( THREE.Light.prototype );
	THREE.SpotLight.prototype.constructor = THREE.SpotLight;

	THREE.SpotLight.prototype.copy = function ( source ) {

		THREE.Light.prototype.copy.call( this, source );

		this.intensity = source.intensity;
		this.distance = source.distance;
		this.angle = source.angle;
		this.exponent = source.exponent;
		this.decay = source.decay;

		this.target = source.target.clone();

		this.shadow = source.shadow.clone();

		return this;

	};

	// File:src/loaders/Cache.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Cache = {

		enabled: false,

		files: {},

		add: function ( key, file ) {

			if ( this.enabled === false ) return;

			// console.log( 'THREE.Cache', 'Adding key:', key );

			this.files[ key ] = file;

		},

		get: function ( key ) {

			if ( this.enabled === false ) return;

			// console.log( 'THREE.Cache', 'Checking key:', key );

			return this.files[ key ];

		},

		remove: function ( key ) {

			delete this.files[ key ];

		},

		clear: function () {

			this.files = {};

		}

	};

	// File:src/loaders/Loader.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Loader = function () {

		this.onLoadStart = function () {};
		this.onLoadProgress = function () {};
		this.onLoadComplete = function () {};

	};

	THREE.Loader.prototype = {

		constructor: THREE.Loader,

		crossOrigin: undefined,

		extractUrlBase: function ( url ) {

			var parts = url.split( '/' );

			if ( parts.length === 1 ) return './';

			parts.pop();

			return parts.join( '/' ) + '/';

		},

		initMaterials: function ( materials, texturePath, crossOrigin ) {

			var array = [];

			for ( var i = 0; i < materials.length; ++ i ) {

				array[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );

			}

			return array;

		},

		createMaterial: ( function () {

			var color, textureLoader, materialLoader;

			return function ( m, texturePath, crossOrigin ) {

				if ( color === undefined ) color = new THREE.Color();
				if ( textureLoader === undefined ) textureLoader = new THREE.TextureLoader();
				if ( materialLoader === undefined ) materialLoader = new THREE.MaterialLoader();

				// convert from old material format

				var textures = {};

				function loadTexture( path, repeat, offset, wrap, anisotropy ) {

					var fullPath = texturePath + path;
					var loader = THREE.Loader.Handlers.get( fullPath );

					var texture;

					if ( loader !== null ) {

						texture = loader.load( fullPath );

					} else {

						textureLoader.setCrossOrigin( crossOrigin );
						texture = textureLoader.load( fullPath );

					}

					if ( repeat !== undefined ) {

						texture.repeat.fromArray( repeat );

						if ( repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;
						if ( repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;

					}

					if ( offset !== undefined ) {

						texture.offset.fromArray( offset );

					}

					if ( wrap !== undefined ) {

						if ( wrap[ 0 ] === 'repeat' ) texture.wrapS = THREE.RepeatWrapping;
						if ( wrap[ 0 ] === 'mirror' ) texture.wrapS = THREE.MirroredRepeatWrapping;

						if ( wrap[ 1 ] === 'repeat' ) texture.wrapT = THREE.RepeatWrapping;
						if ( wrap[ 1 ] === 'mirror' ) texture.wrapT = THREE.MirroredRepeatWrapping;

					}

					if ( anisotropy !== undefined ) {

						texture.anisotropy = anisotropy;

					}

					var uuid = THREE.Math.generateUUID();

					textures[ uuid ] = texture;

					return uuid;

				}

				//

				var json = {
					uuid: THREE.Math.generateUUID(),
					type: 'MeshLambertMaterial'
				};

				for ( var name in m ) {

					var value = m[ name ];

					switch ( name ) {
						case 'DbgColor':
							json.color = value;
							break;
						case 'DbgIndex':
						case 'opticalDensity':
						case 'illumination':
							// These were never supported
							break;
						case 'DbgName':
							json.name = value;
							break;
						case 'blending':
							json.blending = THREE[ value ];
							break;
						case 'colorDiffuse':
							json.color = color.fromArray( value ).getHex();
							break;
						case 'colorSpecular':
							json.specular = color.fromArray( value ).getHex();
							break;
						case 'colorEmissive':
							json.emissive = color.fromArray( value ).getHex();
							break;
						case 'specularCoef':
							json.shininess = value;
							break;
						case 'shading':
							if ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';
							if ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';
							break;
						case 'mapDiffuse':
							json.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );
							break;
						case 'mapDiffuseRepeat':
						case 'mapDiffuseOffset':
						case 'mapDiffuseWrap':
						case 'mapDiffuseAnisotropy':
							break;
						case 'mapLight':
							json.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );
							break;
						case 'mapLightRepeat':
						case 'mapLightOffset':
						case 'mapLightWrap':
						case 'mapLightAnisotropy':
							break;
						case 'mapAO':
							json.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );
							break;
						case 'mapAORepeat':
						case 'mapAOOffset':
						case 'mapAOWrap':
						case 'mapAOAnisotropy':
							break;
						case 'mapBump':
							json.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );
							break;
						case 'mapBumpScale':
							json.bumpScale = value;
							break;
						case 'mapBumpRepeat':
						case 'mapBumpOffset':
						case 'mapBumpWrap':
						case 'mapBumpAnisotropy':
							break;
						case 'mapNormal':
							json.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );
							break;
						case 'mapNormalFactor':
							json.normalScale = [ value, value ];
							break;
						case 'mapNormalRepeat':
						case 'mapNormalOffset':
						case 'mapNormalWrap':
						case 'mapNormalAnisotropy':
							break;
						case 'mapSpecular':
							json.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );
							break;
						case 'mapSpecularRepeat':
						case 'mapSpecularOffset':
						case 'mapSpecularWrap':
						case 'mapSpecularAnisotropy':
							break;
						case 'mapAlpha':
							json.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );
							break;
						case 'mapAlphaRepeat':
						case 'mapAlphaOffset':
						case 'mapAlphaWrap':
						case 'mapAlphaAnisotropy':
							break;
						case 'flipSided':
							json.side = THREE.BackSide;
							break;
						case 'doubleSided':
							json.side = THREE.DoubleSide;
							break;
						case 'transparency':
							console.warn( 'THREE.Loader: transparency has been renamed to opacity' );
							json.opacity = value;
							break;
						case 'opacity':
						case 'transparent':
						case 'depthTest':
						case 'depthWrite':
						case 'transparent':
						case 'visible':
						case 'wireframe':
							json[ name ] = value;
							break;
						case 'vertexColors':
							if ( value === true ) json.vertexColors = THREE.VertexColors;
							if ( value === 'face' ) json.vertexColors = THREE.FaceColors;
							break;
						default:
							console.error( 'Loader.createMaterial: Unsupported', name, value );
							break;
					}

				}

				if ( json.type !== 'MeshPhongMaterial' ) delete json.specular;
				if ( json.opacity < 1 ) json.transparent = true;

				materialLoader.setTextures( textures );

				return materialLoader.parse( json );

			};

		} )()

	};

	THREE.Loader.Handlers = {

		handlers: [],

		add: function ( regex, loader ) {

			this.handlers.push( regex, loader );

		},

		get: function ( file ) {

			var handlers = this.handlers;

			for ( var i = 0, l = handlers.length; i < l; i += 2 ) {

				var regex = handlers[ i ];
				var loader  = handlers[ i + 1 ];

				if ( regex.test( file ) ) {

					return loader;

				}

			}

			return null;

		}

	};

	// File:src/loaders/XHRLoader.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.XHRLoader = function ( manager ) {

		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

	};

	THREE.XHRLoader.prototype = {

		constructor: THREE.XHRLoader,

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var cached = THREE.Cache.get( url );

			if ( cached !== undefined ) {

				if ( onLoad ) {

					setTimeout( function () {

						onLoad( cached );

					}, 0 );

				}

				return cached;

			}

			var request = new XMLHttpRequest();
			request.open( 'GET', url, true );

			request.addEventListener( 'load', function ( event ) {

				var response = event.target.response;

				THREE.Cache.add( url, response );

				if ( onLoad ) onLoad( response );

				scope.manager.itemEnd( url );

			}, false );

			if ( onProgress !== undefined ) {

				request.addEventListener( 'progress', function ( event ) {

					onProgress( event );

				}, false );

			}

			request.addEventListener( 'error', function ( event ) {

				if ( onError ) onError( event );

				scope.manager.itemError( url );

			}, false );

			if ( this.crossOrigin !== undefined ) request.crossOrigin = this.crossOrigin;
			if ( this.responseType !== undefined ) request.responseType = this.responseType;
			if ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;

			request.send( null );

			scope.manager.itemStart( url );

			return request;

		},

		setResponseType: function ( value ) {

			this.responseType = value;

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;

		},

		setWithCredentials: function ( value ) {

			this.withCredentials = value;

		}

	};

	// File:src/loaders/ImageLoader.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.ImageLoader = function ( manager ) {

		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

	};

	THREE.ImageLoader.prototype = {

		constructor: THREE.ImageLoader,

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var cached = THREE.Cache.get( url );

			if ( cached !== undefined ) {

				scope.manager.itemStart( url );

				if ( onLoad ) {

					setTimeout( function () {

						onLoad( cached );

						scope.manager.itemEnd( url );

					}, 0 );

				} else {

					scope.manager.itemEnd( url );

				}

				return cached;

			}

			var image = document.createElement( 'img' );

			image.addEventListener( 'load', function ( event ) {

				THREE.Cache.add( url, this );

				if ( onLoad ) onLoad( this );

				scope.manager.itemEnd( url );

			}, false );

			if ( onProgress !== undefined ) {

				image.addEventListener( 'progress', function ( event ) {

					onProgress( event );

				}, false );

			}

			image.addEventListener( 'error', function ( event ) {

				if ( onError ) onError( event );

				scope.manager.itemError( url );

			}, false );

			if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

			scope.manager.itemStart( url );

			image.src = url;

			return image;

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;

		}

	};

	// File:src/loaders/JSONLoader.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.JSONLoader = function ( manager ) {

		if ( typeof manager === 'boolean' ) {

			console.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );
			manager = undefined;

		}

		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

		this.withCredentials = false;

	};

	THREE.JSONLoader.prototype = {

		constructor: THREE.JSONLoader,

		// Deprecated

		get statusDomElement () {

			if ( this._statusDomElement === undefined ) {

				this._statusDomElement = document.createElement( 'div' );

			}

			console.warn( 'THREE.JSONLoader: .statusDomElement has been removed.' );
			return this._statusDomElement;

		},

		load: function( url, onLoad, onProgress, onError ) {

			var scope = this;

			var texturePath = this.texturePath && ( typeof this.texturePath === "string" ) ? this.texturePath : THREE.Loader.prototype.extractUrlBase( url );

			var loader = new THREE.XHRLoader( this.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.setWithCredentials( this.withCredentials );
			loader.load( url, function ( text ) {

				var json = JSON.parse( text );
				var metadata = json.metadata;

				if ( metadata !== undefined ) {

					if ( metadata.type === 'object' ) {

						console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );
						return;

					}

					if ( metadata.type === 'scene' ) {

						console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );
						return;

					}

				}

				var object = scope.parse( json, texturePath );
				onLoad( object.geometry, object.materials );

			} );

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;

		},

		setTexturePath: function ( value ) {

			this.texturePath = value;

		},

		parse: function ( json, texturePath ) {

			var geometry = new THREE.Geometry(),
			scale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;

			parseModel( scale );

			parseSkin();
			parseMorphing( scale );
			parseAnimations();

			geometry.computeFaceNormals();
			geometry.computeBoundingSphere();

			function parseModel( scale ) {

				function isBitSet( value, position ) {

					return value & ( 1 << position );

				}

				var i, j, fi,

				offset, zLength,

			colorIndex, normalIndex, uvIndex, materialIndex,

				type,
				isQuad,
				hasMaterial,
				hasFaceVertexUv,
				hasFaceNormal, hasFaceVertexNormal,
				hasFaceColor, hasFaceVertexColor,

			vertex, face, faceA, faceB, hex, normal,

				uvLayer, uv, u, v,

				faces = json.faces,
				vertices = json.vertices,
				normals = json.normals,
				colors = json.colors,

				nUvLayers = 0;

				if ( json.uvs !== undefined ) {

					// disregard empty arrays

					for ( i = 0; i < json.uvs.length; i ++ ) {

						if ( json.uvs[ i ].length ) nUvLayers ++;

					}

					for ( i = 0; i < nUvLayers; i ++ ) {

						geometry.faceVertexUvs[ i ] = [];

					}

				}

				offset = 0;
				zLength = vertices.length;

				while ( offset < zLength ) {

					vertex = new THREE.Vector3();

					vertex.x = vertices[ offset ++ ] * scale;
					vertex.y = vertices[ offset ++ ] * scale;
					vertex.z = vertices[ offset ++ ] * scale;

					geometry.vertices.push( vertex );

				}

				offset = 0;
				zLength = faces.length;

				while ( offset < zLength ) {

					type = faces[ offset ++ ];


					isQuad              = isBitSet( type, 0 );
					hasMaterial         = isBitSet( type, 1 );
					hasFaceVertexUv     = isBitSet( type, 3 );
					hasFaceNormal       = isBitSet( type, 4 );
					hasFaceVertexNormal = isBitSet( type, 5 );
					hasFaceColor	     = isBitSet( type, 6 );
					hasFaceVertexColor  = isBitSet( type, 7 );

					// console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);

					if ( isQuad ) {

						faceA = new THREE.Face3();
						faceA.a = faces[ offset ];
						faceA.b = faces[ offset + 1 ];
						faceA.c = faces[ offset + 3 ];

						faceB = new THREE.Face3();
						faceB.a = faces[ offset + 1 ];
						faceB.b = faces[ offset + 2 ];
						faceB.c = faces[ offset + 3 ];

						offset += 4;

						if ( hasMaterial ) {

							materialIndex = faces[ offset ++ ];
							faceA.materialIndex = materialIndex;
							faceB.materialIndex = materialIndex;

						}

						// to get face <=> uv index correspondence

						fi = geometry.faces.length;

						if ( hasFaceVertexUv ) {

							for ( i = 0; i < nUvLayers; i ++ ) {

								uvLayer = json.uvs[ i ];

								geometry.faceVertexUvs[ i ][ fi ] = [];
								geometry.faceVertexUvs[ i ][ fi + 1 ] = [];

								for ( j = 0; j < 4; j ++ ) {

									uvIndex = faces[ offset ++ ];

									u = uvLayer[ uvIndex * 2 ];
									v = uvLayer[ uvIndex * 2 + 1 ];

									uv = new THREE.Vector2( u, v );

									if ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );
									if ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );

								}

							}

						}

						if ( hasFaceNormal ) {

							normalIndex = faces[ offset ++ ] * 3;

							faceA.normal.set(
								normals[ normalIndex ++ ],
								normals[ normalIndex ++ ],
								normals[ normalIndex ]
							);

							faceB.normal.copy( faceA.normal );

						}

						if ( hasFaceVertexNormal ) {

							for ( i = 0; i < 4; i ++ ) {

								normalIndex = faces[ offset ++ ] * 3;

								normal = new THREE.Vector3(
									normals[ normalIndex ++ ],
									normals[ normalIndex ++ ],
									normals[ normalIndex ]
								);


								if ( i !== 2 ) faceA.vertexNormals.push( normal );
								if ( i !== 0 ) faceB.vertexNormals.push( normal );

							}

						}


						if ( hasFaceColor ) {

							colorIndex = faces[ offset ++ ];
							hex = colors[ colorIndex ];

							faceA.color.setHex( hex );
							faceB.color.setHex( hex );

						}


						if ( hasFaceVertexColor ) {

							for ( i = 0; i < 4; i ++ ) {

								colorIndex = faces[ offset ++ ];
								hex = colors[ colorIndex ];

								if ( i !== 2 ) faceA.vertexColors.push( new THREE.Color( hex ) );
								if ( i !== 0 ) faceB.vertexColors.push( new THREE.Color( hex ) );

							}

						}

						geometry.faces.push( faceA );
						geometry.faces.push( faceB );

					} else {

						face = new THREE.Face3();
						face.a = faces[ offset ++ ];
						face.b = faces[ offset ++ ];
						face.c = faces[ offset ++ ];

						if ( hasMaterial ) {

							materialIndex = faces[ offset ++ ];
							face.materialIndex = materialIndex;

						}

						// to get face <=> uv index correspondence

						fi = geometry.faces.length;

						if ( hasFaceVertexUv ) {

							for ( i = 0; i < nUvLayers; i ++ ) {

								uvLayer = json.uvs[ i ];

								geometry.faceVertexUvs[ i ][ fi ] = [];

								for ( j = 0; j < 3; j ++ ) {

									uvIndex = faces[ offset ++ ];

									u = uvLayer[ uvIndex * 2 ];
									v = uvLayer[ uvIndex * 2 + 1 ];

									uv = new THREE.Vector2( u, v );

									geometry.faceVertexUvs[ i ][ fi ].push( uv );

								}

							}

						}

						if ( hasFaceNormal ) {

							normalIndex = faces[ offset ++ ] * 3;

							face.normal.set(
								normals[ normalIndex ++ ],
								normals[ normalIndex ++ ],
								normals[ normalIndex ]
							);

						}

						if ( hasFaceVertexNormal ) {

							for ( i = 0; i < 3; i ++ ) {

								normalIndex = faces[ offset ++ ] * 3;

								normal = new THREE.Vector3(
									normals[ normalIndex ++ ],
									normals[ normalIndex ++ ],
									normals[ normalIndex ]
								);

								face.vertexNormals.push( normal );

							}

						}


						if ( hasFaceColor ) {

							colorIndex = faces[ offset ++ ];
							face.color.setHex( colors[ colorIndex ] );

						}


						if ( hasFaceVertexColor ) {

							for ( i = 0; i < 3; i ++ ) {

								colorIndex = faces[ offset ++ ];
								face.vertexColors.push( new THREE.Color( colors[ colorIndex ] ) );

							}

						}

						geometry.faces.push( face );

					}

				}

			};

			function parseSkin() {

				var influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;

				if ( json.skinWeights ) {

					for ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {

						var x =                               json.skinWeights[ i ];
						var y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;
						var z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;
						var w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;

						geometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );

					}

				}

				if ( json.skinIndices ) {

					for ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {

						var a =                               json.skinIndices[ i ];
						var b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;
						var c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;
						var d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;

						geometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );

					}

				}

				geometry.bones = json.bones;

				if ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {

					console.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +
						geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );

				}

			};

			function parseMorphing( scale ) {

				if ( json.morphTargets !== undefined ) {

					for ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {

						geometry.morphTargets[ i ] = {};
						geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;
						geometry.morphTargets[ i ].vertices = [];

						var dstVertices = geometry.morphTargets[ i ].vertices;
						var srcVertices = json.morphTargets[ i ].vertices;

						for ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {

							var vertex = new THREE.Vector3();
							vertex.x = srcVertices[ v ] * scale;
							vertex.y = srcVertices[ v + 1 ] * scale;
							vertex.z = srcVertices[ v + 2 ] * scale;

							dstVertices.push( vertex );

						}

					}

				}

				if ( json.morphColors !== undefined && json.morphColors.length > 0 ) {

					console.warn( 'THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.' );

					var faces = geometry.faces;
					var morphColors = json.morphColors[ 0 ].colors;

					for ( var i = 0, l = faces.length; i < l; i ++ ) {

						faces[ i ].color.fromArray( morphColors, i * 3 );

					}

				}

			}

			function parseAnimations() {

				var outputAnimations = [];

				// parse old style Bone/Hierarchy animations
				var animations = [];
				if ( json.animation !== undefined ) {
					animations.push( json.animation );
				}
				if ( json.animations !== undefined ) {
					if ( json.animations.length ) {
						animations = animations.concat( json.animations );
					} else {
						animations.push( json.animations );
					}
				}

				for ( var i = 0; i < animations.length; i ++ ) {

					var clip = THREE.AnimationClip.parseAnimation( animations[i], geometry.bones );
					if ( clip ) outputAnimations.push( clip );

				}

				// parse implicit morph animations
				if ( geometry.morphTargets ) {

					// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.
					var morphAnimationClips = THREE.AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );
					outputAnimations = outputAnimations.concat( morphAnimationClips );

				}

				if ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;

			};

			if ( json.materials === undefined || json.materials.length === 0 ) {

				return { geometry: geometry };

			} else {

				var materials = THREE.Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );

				return { geometry: geometry, materials: materials };

			}

		}

	};

	// File:src/loaders/LoadingManager.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.LoadingManager = function ( onLoad, onProgress, onError ) {

		var scope = this;

		var isLoading = false, itemsLoaded = 0, itemsTotal = 0;

		this.onStart = undefined;
		this.onLoad = onLoad;
		this.onProgress = onProgress;
		this.onError = onError;

		this.itemStart = function ( url ) {

			itemsTotal ++;

			if ( isLoading === false ) {

				if ( scope.onStart !== undefined ) {

					scope.onStart( url, itemsLoaded, itemsTotal );

				}

			}

			isLoading = true;

		};

		this.itemEnd = function ( url ) {

			itemsLoaded ++;

			if ( scope.onProgress !== undefined ) {

				scope.onProgress( url, itemsLoaded, itemsTotal );

			}

			if ( itemsLoaded === itemsTotal ) {

				isLoading = false;

				if ( scope.onLoad !== undefined ) {

					scope.onLoad();

				}

			}

		};

		this.itemError = function ( url ) {

			if ( scope.onError !== undefined ) {

				scope.onError( url );

			}

		};

	};

	THREE.DefaultLoadingManager = new THREE.LoadingManager();

	// File:src/loaders/BufferGeometryLoader.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.BufferGeometryLoader = function ( manager ) {

		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

	};

	THREE.BufferGeometryLoader.prototype = {

		constructor: THREE.BufferGeometryLoader,

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var loader = new THREE.XHRLoader( scope.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.load( url, function ( text ) {

				onLoad( scope.parse( JSON.parse( text ) ) );

			}, onProgress, onError );

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;

		},

		parse: function ( json ) {

			var geometry = new THREE.BufferGeometry();

			var index = json.data.index;

			if ( index !== undefined ) {

				var typedArray = new self[ index.type ]( index.array );
				geometry.setIndex( new THREE.BufferAttribute( typedArray, 1 ) );

			}

			var attributes = json.data.attributes;

			for ( var key in attributes ) {

				var attribute = attributes[ key ];
				var typedArray = new self[ attribute.type ]( attribute.array );

				geometry.addAttribute( key, new THREE.BufferAttribute( typedArray, attribute.itemSize ) );

			}

			var groups = json.data.groups || json.data.drawcalls || json.data.offsets;

			if ( groups !== undefined ) {

				for ( var i = 0, n = groups.length; i !== n; ++ i ) {

					var group = groups[ i ];

					geometry.addGroup( group.start, group.count );

				}

			}

			var boundingSphere = json.data.boundingSphere;

			if ( boundingSphere !== undefined ) {

				var center = new THREE.Vector3();

				if ( boundingSphere.center !== undefined ) {

					center.fromArray( boundingSphere.center );

				}

				geometry.boundingSphere = new THREE.Sphere( center, boundingSphere.radius );

			}

			return geometry;

		}

	};

	// File:src/loaders/MaterialLoader.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.MaterialLoader = function ( manager ) {

		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
		this.textures = {};

	};

	THREE.MaterialLoader.prototype = {

		constructor: THREE.MaterialLoader,

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var loader = new THREE.XHRLoader( scope.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.load( url, function ( text ) {

				onLoad( scope.parse( JSON.parse( text ) ) );

			}, onProgress, onError );

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;

		},

		setTextures: function ( value ) {

			this.textures = value;

		},

		getTexture: function ( name ) {

			var textures = this.textures;

			if ( textures[ name ] === undefined ) {

				console.warn( 'THREE.MaterialLoader: Undefined texture', name );

			}

			return textures[ name ];

		},

		parse: function ( json ) {

			var material = new THREE[ json.type ];
			material.uuid = json.uuid;

			if ( json.name !== undefined ) material.name = json.name;
			if ( json.color !== undefined ) material.color.setHex( json.color );
			if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );
			if ( json.specular !== undefined ) material.specular.setHex( json.specular );
			if ( json.shininess !== undefined ) material.shininess = json.shininess;
			if ( json.uniforms !== undefined ) material.uniforms = json.uniforms;
			if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
			if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;
			if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;
			if ( json.shading !== undefined ) material.shading = json.shading;
			if ( json.blending !== undefined ) material.blending = json.blending;
			if ( json.side !== undefined ) material.side = json.side;
			if ( json.opacity !== undefined ) material.opacity = json.opacity;
			if ( json.transparent !== undefined ) material.transparent = json.transparent;
			if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;
			if ( json.depthTest !== undefined ) material.depthTest = json.depthTest;
			if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;
			if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
			if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;

			// for PointsMaterial
			if ( json.size !== undefined ) material.size = json.size;
			if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;

			// maps

			if ( json.map !== undefined ) material.map = this.getTexture( json.map );

			if ( json.alphaMap !== undefined ) {

				material.alphaMap = this.getTexture( json.alphaMap );
				material.transparent = true;

			}

			if ( json.bumpMap !== undefined ) material.bumpMap = this.getTexture( json.bumpMap );
			if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;

			if ( json.normalMap !== undefined ) material.normalMap = this.getTexture( json.normalMap );
			if ( json.normalScale )	material.normalScale = new THREE.Vector2( json.normalScale, json.normalScale );

			if ( json.displacementMap !== undefined ) material.displacementMap = this.getTexture( json.displacementMap );
			if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;
			if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;

			if ( json.specularMap !== undefined ) material.specularMap = this.getTexture( json.specularMap );

			if ( json.envMap !== undefined ) {

				material.envMap = this.getTexture( json.envMap );
				material.combine = THREE.MultiplyOperation;

			}

			if ( json.reflectivity ) material.reflectivity = json.reflectivity;

			if ( json.lightMap !== undefined ) material.lightMap = this.getTexture( json.lightMap );
			if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;

			if ( json.aoMap !== undefined ) material.aoMap = this.getTexture( json.aoMap );
			if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;

			// MeshFaceMaterial

			if ( json.materials !== undefined ) {

				for ( var i = 0, l = json.materials.length; i < l; i ++ ) {

					material.materials.push( this.parse( json.materials[ i ] ) );

				}

			}

			return material;

		}

	};

	// File:src/loaders/ObjectLoader.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.ObjectLoader = function ( manager ) {

		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
		this.texturePath = '';

	};

	THREE.ObjectLoader.prototype = {

		constructor: THREE.ObjectLoader,

		load: function ( url, onLoad, onProgress, onError ) {

			if ( this.texturePath === '' ) {

				this.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );

			}

			var scope = this;

			var loader = new THREE.XHRLoader( scope.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.load( url, function ( text ) {

				scope.parse( JSON.parse( text ), onLoad );

			}, onProgress, onError );

		},

		setTexturePath: function ( value ) {

			this.texturePath = value;

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;

		},

		parse: function ( json, onLoad ) {

			var geometries = this.parseGeometries( json.geometries );

			var images = this.parseImages( json.images, function () {

				if ( onLoad !== undefined ) onLoad( object );

			} );

			var textures  = this.parseTextures( json.textures, images );
			var materials = this.parseMaterials( json.materials, textures );

			var object = this.parseObject( json.object, geometries, materials );

			if ( json.animations ) {

				object.animations = this.parseAnimations( json.animations );

			}

			if ( json.images === undefined || json.images.length === 0 ) {

				if ( onLoad !== undefined ) onLoad( object );

			}

			return object;

		},

		parseGeometries: function ( json ) {

			var geometries = {};

			if ( json !== undefined ) {

				var geometryLoader = new THREE.JSONLoader();
				var bufferGeometryLoader = new THREE.BufferGeometryLoader();

				for ( var i = 0, l = json.length; i < l; i ++ ) {

					var geometry;
					var data = json[ i ];

					switch ( data.type ) {

						case 'PlaneGeometry':
						case 'PlaneBufferGeometry':

							geometry = new THREE[ data.type ](
								data.width,
								data.height,
								data.widthSegments,
								data.heightSegments
							);

							break;

						case 'BoxGeometry':
						case 'CubeGeometry': // backwards compatible

							geometry = new THREE.BoxGeometry(
								data.width,
								data.height,
								data.depth,
								data.widthSegments,
								data.heightSegments,
								data.depthSegments
							);

							break;

						case 'CircleBufferGeometry':

							geometry = new THREE.CircleBufferGeometry(
								data.radius,
								data.segments,
								data.thetaStart,
								data.thetaLength
							);

							break;

						case 'CircleGeometry':

							geometry = new THREE.CircleGeometry(
								data.radius,
								data.segments,
								data.thetaStart,
								data.thetaLength
							);

							break;

						case 'CylinderGeometry':

							geometry = new THREE.CylinderGeometry(
								data.radiusTop,
								data.radiusBottom,
								data.height,
								data.radialSegments,
								data.heightSegments,
								data.openEnded,
								data.thetaStart,
								data.thetaLength
							);

							break;

						case 'SphereGeometry':

							geometry = new THREE.SphereGeometry(
								data.radius,
								data.widthSegments,
								data.heightSegments,
								data.phiStart,
								data.phiLength,
								data.thetaStart,
								data.thetaLength
							);

							break;

						case 'SphereBufferGeometry':

							geometry = new THREE.SphereBufferGeometry(
								data.radius,
								data.widthSegments,
								data.heightSegments,
								data.phiStart,
								data.phiLength,
								data.thetaStart,
								data.thetaLength
							);

							break;

						case 'DodecahedronGeometry':

							geometry = new THREE.DodecahedronGeometry(
								data.radius,
								data.detail
							);

							break;

						case 'IcosahedronGeometry':

							geometry = new THREE.IcosahedronGeometry(
								data.radius,
								data.detail
							);

							break;

						case 'OctahedronGeometry':

							geometry = new THREE.OctahedronGeometry(
								data.radius,
								data.detail
							);

							break;

						case 'TetrahedronGeometry':

							geometry = new THREE.TetrahedronGeometry(
								data.radius,
								data.detail
							);

							break;

						case 'RingGeometry':

							geometry = new THREE.RingGeometry(
								data.innerRadius,
								data.outerRadius,
								data.thetaSegments,
								data.phiSegments,
								data.thetaStart,
								data.thetaLength
							);

							break;

						case 'TorusGeometry':

							geometry = new THREE.TorusGeometry(
								data.radius,
								data.tube,
								data.radialSegments,
								data.tubularSegments,
								data.arc
							);

							break;

						case 'TorusKnotGeometry':

							geometry = new THREE.TorusKnotGeometry(
								data.radius,
								data.tube,
								data.radialSegments,
								data.tubularSegments,
								data.p,
								data.q,
								data.heightScale
							);

							break;

						case 'BufferGeometry':

							geometry = bufferGeometryLoader.parse( data );

							break;

						case 'Geometry':

							geometry = geometryLoader.parse( data.data, this.texturePath ).geometry;

							break;

						default:

							console.warn( 'THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"' );

							continue;

					}

					geometry.uuid = data.uuid;

					if ( data.name !== undefined ) geometry.name = data.name;

					geometries[ data.uuid ] = geometry;

				}

			}

			return geometries;

		},

		parseMaterials: function ( json, textures ) {

			var materials = {};

			if ( json !== undefined ) {

				var loader = new THREE.MaterialLoader();
				loader.setTextures( textures );

				for ( var i = 0, l = json.length; i < l; i ++ ) {

					var material = loader.parse( json[ i ] );
					materials[ material.uuid ] = material;

				}

			}

			return materials;

		},

		parseAnimations: function ( json ) {

			var animations = [];

			for ( var i = 0; i < json.length; i ++ ) {

				var clip = THREE.AnimationClip.parse( json[i] );

				animations.push( clip );

			}

			return animations;

		},

		parseImages: function ( json, onLoad ) {

			var scope = this;
			var images = {};

			function loadImage( url ) {

				scope.manager.itemStart( url );

				return loader.load( url, function () {

					scope.manager.itemEnd( url );

				} );

			}

			if ( json !== undefined && json.length > 0 ) {

				var manager = new THREE.LoadingManager( onLoad );

				var loader = new THREE.ImageLoader( manager );
				loader.setCrossOrigin( this.crossOrigin );

				for ( var i = 0, l = json.length; i < l; i ++ ) {

					var image = json[ i ];
					var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;

					images[ image.uuid ] = loadImage( path );

				}

			}

			return images;

		},

		parseTextures: function ( json, images ) {

			function parseConstant( value ) {

				if ( typeof( value ) === 'number' ) return value;

				console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );

				return THREE[ value ];

			}

			var textures = {};

			if ( json !== undefined ) {

				for ( var i = 0, l = json.length; i < l; i ++ ) {

					var data = json[ i ];

					if ( data.image === undefined ) {

						console.warn( 'THREE.ObjectLoader: No "image" specified for', data.uuid );

					}

					if ( images[ data.image ] === undefined ) {

						console.warn( 'THREE.ObjectLoader: Undefined image', data.image );

					}

					var texture = new THREE.Texture( images[ data.image ] );
					texture.needsUpdate = true;

					texture.uuid = data.uuid;

					if ( data.name !== undefined ) texture.name = data.name;
					if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping );
					if ( data.offset !== undefined ) texture.offset = new THREE.Vector2( data.offset[ 0 ], data.offset[ 1 ] );
					if ( data.repeat !== undefined ) texture.repeat = new THREE.Vector2( data.repeat[ 0 ], data.repeat[ 1 ] );
					if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter );
					if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter );
					if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;
					if ( Array.isArray( data.wrap ) ) {

						texture.wrapS = parseConstant( data.wrap[ 0 ] );
						texture.wrapT = parseConstant( data.wrap[ 1 ] );

					}

					textures[ data.uuid ] = texture;

				}

			}

			return textures;

		},

		parseObject: function () {

			var matrix = new THREE.Matrix4();

			return function ( data, geometries, materials ) {

				var object;

				function getGeometry( name ) {

					if ( geometries[ name ] === undefined ) {

						console.warn( 'THREE.ObjectLoader: Undefined geometry', name );

					}

					return geometries[ name ];

				}

				function getMaterial( name ) {

					if ( name === undefined ) return undefined;

					if ( materials[ name ] === undefined ) {

						console.warn( 'THREE.ObjectLoader: Undefined material', name );

					}

					return materials[ name ];

				}

				switch ( data.type ) {

					case 'Scene':

						object = new THREE.Scene();

						break;

					case 'PerspectiveCamera':

						object = new THREE.PerspectiveCamera( data.fov, data.aspect, data.near, data.far );

						break;

					case 'OrthographicCamera':

						object = new THREE.OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );

						break;

					case 'AmbientLight':

						object = new THREE.AmbientLight( data.color );

						break;

					case 'DirectionalLight':

						object = new THREE.DirectionalLight( data.color, data.intensity );

						break;

					case 'PointLight':

						object = new THREE.PointLight( data.color, data.intensity, data.distance, data.decay );

						break;

					case 'SpotLight':

						object = new THREE.SpotLight( data.color, data.intensity, data.distance, data.angle, data.exponent, data.decay );

						break;

					case 'HemisphereLight':

						object = new THREE.HemisphereLight( data.color, data.groundColor, data.intensity );

						break;

					case 'Mesh':

						object = new THREE.Mesh( getGeometry( data.geometry ), getMaterial( data.material ) );

						break;

					case 'LOD':

						object = new THREE.LOD();

						break;

					case 'Line':

						object = new THREE.Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );

						break;

					case 'PointCloud':
					case 'Points':

						object = new THREE.Points( getGeometry( data.geometry ), getMaterial( data.material ) );

						break;

					case 'Sprite':

						object = new THREE.Sprite( getMaterial( data.material ) );

						break;

					case 'Group':

						object = new THREE.Group();

						break;

					default:

						object = new THREE.Object3D();

				}

				object.uuid = data.uuid;

				if ( data.name !== undefined ) object.name = data.name;
				if ( data.matrix !== undefined ) {

					matrix.fromArray( data.matrix );
					matrix.decompose( object.position, object.quaternion, object.scale );

				} else {

					if ( data.position !== undefined ) object.position.fromArray( data.position );
					if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
					if ( data.scale !== undefined ) object.scale.fromArray( data.scale );

				}

				if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;
				if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;

				if ( data.visible !== undefined ) object.visible = data.visible;
				if ( data.userData !== undefined ) object.userData = data.userData;

				if ( data.children !== undefined ) {

					for ( var child in data.children ) {

						object.add( this.parseObject( data.children[ child ], geometries, materials ) );

					}

				}

				if ( data.type === 'LOD' ) {

					var levels = data.levels;

					for ( var l = 0; l < levels.length; l ++ ) {

						var level = levels[ l ];
						var child = object.getObjectByProperty( 'uuid', level.object );

						if ( child !== undefined ) {

							object.addLevel( child, level.distance );

						}

					}

				}

				return object;

			}

		}()

	};

	// File:src/loaders/TextureLoader.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.TextureLoader = function ( manager ) {

		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

	};

	THREE.TextureLoader.prototype = {

		constructor: THREE.TextureLoader,

		load: function ( url, onLoad, onProgress, onError ) {

			var texture = new THREE.Texture();

			var loader = new THREE.ImageLoader( this.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.load( url, function ( image ) {

				texture.image = image;
				texture.needsUpdate = true;

				if ( onLoad !== undefined ) {

					onLoad( texture );

				}

			}, onProgress, onError );

			return texture;

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;

		}

	};

	// File:src/loaders/CubeTextureLoader.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.CubeTextureLoader = function ( manager ) {

		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

	};

	THREE.CubeTextureLoader.prototype = {

		constructor: THREE.CubeTextureLoader,

		load: function ( urls, onLoad, onProgress, onError ) {

			var texture = new THREE.CubeTexture( [] );

			var loader = new THREE.ImageLoader();
			loader.setCrossOrigin( this.crossOrigin );

			var loaded = 0;

			function loadTexture( i ) {

				loader.load( urls[ i ], function ( image ) {

					texture.images[ i ] = image;

					loaded ++;

					if ( loaded === 6 ) {

						texture.needsUpdate = true;

						if ( onLoad ) onLoad( texture );

					}

				}, undefined, onError );

			}

			for ( var i = 0; i < urls.length; ++ i ) {

				loadTexture( i );

			}

			return texture;

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;

		}

	};

	// File:src/loaders/BinaryTextureLoader.js

	/**
	 * @author Nikos M. / https://github.com/foo123/
	 *
	 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
	 */

	THREE.DataTextureLoader = THREE.BinaryTextureLoader = function ( manager ) {

		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

		// override in sub classes
		this._parser = null;

	};

	THREE.BinaryTextureLoader.prototype = {

		constructor: THREE.BinaryTextureLoader,

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var texture = new THREE.DataTexture();

			var loader = new THREE.XHRLoader( this.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.setResponseType( 'arraybuffer' );

			loader.load( url, function ( buffer ) {

				var texData = scope._parser( buffer );

				if ( ! texData ) return;

				if ( undefined !== texData.image ) {

					texture.image = texData.image;

				} else if ( undefined !== texData.data ) {

					texture.image.width = texData.width;
					texture.image.height = texData.height;
					texture.image.data = texData.data;

				}

				texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : THREE.ClampToEdgeWrapping;
				texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : THREE.ClampToEdgeWrapping;

				texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : THREE.LinearFilter;
				texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : THREE.LinearMipMapLinearFilter;

				texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;

				if ( undefined !== texData.format ) {

					texture.format = texData.format;

				}
				if ( undefined !== texData.type ) {

					texture.type = texData.type;

				}

				if ( undefined !== texData.mipmaps ) {

					texture.mipmaps = texData.mipmaps;

				}

				if ( 1 === texData.mipmapCount ) {

					texture.minFilter = THREE.LinearFilter;

				}

				texture.needsUpdate = true;

				if ( onLoad ) onLoad( texture, texData );

			}, onProgress, onError );


			return texture;

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;

		}

	};

	// File:src/loaders/CompressedTextureLoader.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 *
	 * Abstract Base class to block based textures loader (dds, pvr, ...)
	 */

	THREE.CompressedTextureLoader = function ( manager ) {

		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

		// override in sub classes
		this._parser = null;

	};


	THREE.CompressedTextureLoader.prototype = {

		constructor: THREE.CompressedTextureLoader,

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var images = [];

			var texture = new THREE.CompressedTexture();
			texture.image = images;

			var loader = new THREE.XHRLoader( this.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.setResponseType( 'arraybuffer' );

			if ( Array.isArray( url ) ) {

				var loaded = 0;

				var loadTexture = function ( i ) {

					loader.load( url[ i ], function ( buffer ) {

						var texDatas = scope._parser( buffer, true );

						images[ i ] = {
							width: texDatas.width,
							height: texDatas.height,
							format: texDatas.format,
							mipmaps: texDatas.mipmaps
						};

						loaded += 1;

						if ( loaded === 6 ) {

							if ( texDatas.mipmapCount === 1 )
	 							texture.minFilter = THREE.LinearFilter;

							texture.format = texDatas.format;
							texture.needsUpdate = true;

							if ( onLoad ) onLoad( texture );

						}

					}, onProgress, onError );

				};

				for ( var i = 0, il = url.length; i < il; ++ i ) {

					loadTexture( i );

				}

			} else {

				// compressed cubemap texture stored in a single DDS file

				loader.load( url, function ( buffer ) {

					var texDatas = scope._parser( buffer, true );

					if ( texDatas.isCubemap ) {

						var faces = texDatas.mipmaps.length / texDatas.mipmapCount;

						for ( var f = 0; f < faces; f ++ ) {

							images[ f ] = { mipmaps : [] };

							for ( var i = 0; i < texDatas.mipmapCount; i ++ ) {

								images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
								images[ f ].format = texDatas.format;
								images[ f ].width = texDatas.width;
								images[ f ].height = texDatas.height;

							}

						}

					} else {

						texture.image.width = texDatas.width;
						texture.image.height = texDatas.height;
						texture.mipmaps = texDatas.mipmaps;

					}

					if ( texDatas.mipmapCount === 1 ) {

						texture.minFilter = THREE.LinearFilter;

					}

					texture.format = texDatas.format;
					texture.needsUpdate = true;

					if ( onLoad ) onLoad( texture );

				}, onProgress, onError );

			}

			return texture;

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;

		}

	};

	// File:src/materials/Material.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Material = function () {

		Object.defineProperty( this, 'id', { value: THREE.MaterialIdCount ++ } );

		this.uuid = THREE.Math.generateUUID();

		this.name = '';
		this.type = 'Material';

		this.side = THREE.FrontSide;

		this.opacity = 1;
		this.transparent = false;

		this.blending = THREE.NormalBlending;

		this.blendSrc = THREE.SrcAlphaFactor;
		this.blendDst = THREE.OneMinusSrcAlphaFactor;
		this.blendEquation = THREE.AddEquation;
		this.blendSrcAlpha = null;
		this.blendDstAlpha = null;
		this.blendEquationAlpha = null;

		this.depthFunc = THREE.LessEqualDepth;
		this.depthTest = true;
		this.depthWrite = true;

		this.colorWrite = true;

		this.precision = null; // override the renderer's default precision for this material

		this.polygonOffset = false;
		this.polygonOffsetFactor = 0;
		this.polygonOffsetUnits = 0;

		this.alphaTest = 0;

		this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer

		this.visible = true;

		this._needsUpdate = true;

	};

	THREE.Material.prototype = {

		constructor: THREE.Material,

		get needsUpdate () {

			return this._needsUpdate;

		},

		set needsUpdate ( value ) {

			if ( value === true ) this.update();

			this._needsUpdate = value;

		},

		setValues: function ( values ) {

			if ( values === undefined ) return;

			for ( var key in values ) {

				var newValue = values[ key ];

				if ( newValue === undefined ) {

					console.warn( "THREE.Material: '" + key + "' parameter is undefined." );
					continue;

				}

				var currentValue = this[ key ];

				if ( currentValue === undefined ) {

					console.warn( "THREE." + this.type + ": '" + key + "' is not a property of this material." );
					continue;

				}

				if ( currentValue instanceof THREE.Color ) {

					currentValue.set( newValue );

				} else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {

					currentValue.copy( newValue );

				} else if ( key === 'overdraw' ) {

					// ensure overdraw is backwards-compatible with legacy boolean type
					this[ key ] = Number( newValue );

				} else {

					this[ key ] = newValue;

				}

			}

		},

		toJSON: function ( meta ) {

			var data = {
				metadata: {
					version: 4.4,
					type: 'Material',
					generator: 'Material.toJSON'
				}
			};

			// standard Material serialization
			data.uuid = this.uuid;
			data.type = this.type;
			if ( this.name !== '' ) data.name = this.name;

			if ( this.color instanceof THREE.Color ) data.color = this.color.getHex();
			if ( this.emissive instanceof THREE.Color ) data.emissive = this.emissive.getHex();
			if ( this.specular instanceof THREE.Color ) data.specular = this.specular.getHex();
			if ( this.shininess !== undefined ) data.shininess = this.shininess;

			if ( this.map instanceof THREE.Texture ) data.map = this.map.toJSON( meta ).uuid;
			if ( this.alphaMap instanceof THREE.Texture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;
			if ( this.lightMap instanceof THREE.Texture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;
			if ( this.bumpMap instanceof THREE.Texture ) {

				data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
				data.bumpScale = this.bumpScale;

			}
			if ( this.normalMap instanceof THREE.Texture ) {

				data.normalMap = this.normalMap.toJSON( meta ).uuid;
				data.normalScale = this.normalScale; // Removed for now, causes issue in editor ui.js

			}
			if ( this.displacementMap instanceof THREE.Texture ) {

				data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
				data.displacementScale = this.displacementScale;
				data.displacementBias = this.displacementBias;

			}
			if ( this.specularMap instanceof THREE.Texture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;
			if ( this.envMap instanceof THREE.Texture ) {

				data.envMap = this.envMap.toJSON( meta ).uuid;
				data.reflectivity = this.reflectivity; // Scale behind envMap

			}

			if ( this.size !== undefined ) data.size = this.size;
			if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

			if ( this.vertexColors !== undefined && this.vertexColors !== THREE.NoColors ) data.vertexColors = this.vertexColors;
			if ( this.shading !== undefined && this.shading !== THREE.SmoothShading ) data.shading = this.shading;
			if ( this.blending !== undefined && this.blending !== THREE.NormalBlending ) data.blending = this.blending;
			if ( this.side !== undefined && this.side !== THREE.FrontSide ) data.side = this.side;

			if ( this.opacity < 1 ) data.opacity = this.opacity;
			if ( this.transparent === true ) data.transparent = this.transparent;
			if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
			if ( this.wireframe === true ) data.wireframe = this.wireframe;
			if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;

			return data;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( source ) {

			this.name = source.name;

			this.side = source.side;

			this.opacity = source.opacity;
			this.transparent = source.transparent;

			this.blending = source.blending;

			this.blendSrc = source.blendSrc;
			this.blendDst = source.blendDst;
			this.blendEquation = source.blendEquation;
			this.blendSrcAlpha = source.blendSrcAlpha;
			this.blendDstAlpha = source.blendDstAlpha;
			this.blendEquationAlpha = source.blendEquationAlpha;

			this.depthFunc = source.depthFunc;
			this.depthTest = source.depthTest;
			this.depthWrite = source.depthWrite;

			this.precision = source.precision;

			this.polygonOffset = source.polygonOffset;
			this.polygonOffsetFactor = source.polygonOffsetFactor;
			this.polygonOffsetUnits = source.polygonOffsetUnits;

			this.alphaTest = source.alphaTest;

			this.overdraw = source.overdraw;

			this.visible = source.visible;

			return this;

		},

		update: function () {

			this.dispatchEvent( { type: 'update' } );

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		},

		// Deprecated

		get wrapAround () {

			console.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );

		},

		set wrapAround ( boolean ) {

			console.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );

		},

		get wrapRGB () {

			console.warn( 'THREE.' + this.type + ': .wrapRGB has been removed.' );
			return new THREE.Color();

		}

	};

	THREE.EventDispatcher.prototype.apply( THREE.Material.prototype );

	THREE.MaterialIdCount = 0;

	// File:src/materials/LineBasicMaterial.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  linewidth: <float>,
	 *  linecap: "round",
	 *  linejoin: "round",
	 *
	 *  vertexColors: <bool>
	 *
	 *  fog: <bool>
	 * }
	 */

	THREE.LineBasicMaterial = function ( parameters ) {

		THREE.Material.call( this );

		this.type = 'LineBasicMaterial';

		this.color = new THREE.Color( 0xffffff );

		this.linewidth = 1;
		this.linecap = 'round';
		this.linejoin = 'round';

		this.vertexColors = THREE.NoColors;

		this.fog = true;

		this.setValues( parameters );

	};

	THREE.LineBasicMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial;

	THREE.LineBasicMaterial.prototype.copy = function ( source ) {

		THREE.Material.prototype.copy.call( this, source );

		this.color.copy( source.color );

		this.linewidth = source.linewidth;
		this.linecap = source.linecap;
		this.linejoin = source.linejoin;

		this.vertexColors = source.vertexColors;

		this.fog = source.fog;

		return this;

	};

	// File:src/materials/LineDashedMaterial.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  linewidth: <float>,
	 *
	 *  scale: <float>,
	 *  dashSize: <float>,
	 *  gapSize: <float>,
	 *
	 *  vertexColors: <bool>
	 *
	 *  fog: <bool>
	 * }
	 */

	THREE.LineDashedMaterial = function ( parameters ) {

		THREE.Material.call( this );

		this.type = 'LineDashedMaterial';

		this.color = new THREE.Color( 0xffffff );

		this.linewidth = 1;

		this.scale = 1;
		this.dashSize = 3;
		this.gapSize = 1;

		this.vertexColors = false;

		this.fog = true;

		this.setValues( parameters );

	};

	THREE.LineDashedMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial;

	THREE.LineDashedMaterial.prototype.copy = function ( source ) {

		THREE.Material.prototype.copy.call( this, source );

		this.color.copy( source.color );
		
		this.linewidth = source.linewidth;

		this.scale = source.scale;
		this.dashSize = source.dashSize;
		this.gapSize = source.gapSize;

		this.vertexColors = source.vertexColors;

		this.fog = source.fog;

		return this;

	};

	// File:src/materials/MeshBasicMaterial.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  shading: THREE.SmoothShading,
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *
	 *  fog: <bool>
	 * }
	 */

	THREE.MeshBasicMaterial = function ( parameters ) {

		THREE.Material.call( this );

		this.type = 'MeshBasicMaterial';

		this.color = new THREE.Color( 0xffffff ); // emissive

		this.map = null;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = THREE.MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.fog = true;

		this.shading = THREE.SmoothShading;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.vertexColors = THREE.NoColors;

		this.skinning = false;
		this.morphTargets = false;

		this.setValues( parameters );

	};

	THREE.MeshBasicMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial;

	THREE.MeshBasicMaterial.prototype.copy = function ( source ) {
		
		THREE.Material.prototype.copy.call( this, source );

		this.color.copy( source.color );

		this.map = source.map;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.fog = source.fog;

		this.shading = source.shading;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.vertexColors = source.vertexColors;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		
		return this;

	};

	// File:src/materials/MeshLambertMaterial.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  emissive: <hex>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>,
	 *
	 *	fog: <bool>
	 * }
	 */

	THREE.MeshLambertMaterial = function ( parameters ) {

		THREE.Material.call( this );

		this.type = 'MeshLambertMaterial';

		this.color = new THREE.Color( 0xffffff ); // diffuse
		this.emissive = new THREE.Color( 0x000000 );

		this.map = null;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = THREE.MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.fog = true;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.vertexColors = THREE.NoColors;

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.setValues( parameters );

	};

	THREE.MeshLambertMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial;

	THREE.MeshLambertMaterial.prototype.copy = function ( source ) {

		THREE.Material.prototype.copy.call( this, source );

		this.color.copy( source.color );
		this.emissive.copy( source.emissive );

		this.map = source.map;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.fog = source.fog;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.vertexColors = source.vertexColors;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		return this;

	};

	// File:src/materials/MeshPhongMaterial.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  emissive: <hex>,
	 *  specular: <hex>,
	 *  shininess: <float>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalScale: <Vector2>,
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  shading: THREE.SmoothShading,
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>,
	 *
	 *	fog: <bool>
	 * }
	 */

	THREE.MeshPhongMaterial = function ( parameters ) {

		THREE.Material.call( this );

		this.type = 'MeshPhongMaterial';

		this.color = new THREE.Color( 0xffffff ); // diffuse
		this.emissive = new THREE.Color( 0x000000 );
		this.specular = new THREE.Color( 0x111111 );
		this.shininess = 30;

		this.metal = false;

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissiveMap = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalScale = new THREE.Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = THREE.MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.fog = true;

		this.shading = THREE.SmoothShading;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.vertexColors = THREE.NoColors;

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.setValues( parameters );

	};

	THREE.MeshPhongMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial;

	THREE.MeshPhongMaterial.prototype.copy = function ( source ) {

		THREE.Material.prototype.copy.call( this, source );

		this.color.copy( source.color );
		this.emissive.copy( source.emissive );
		this.specular.copy( source.specular );
		this.shininess = source.shininess;

		this.metal = source.metal;

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissiveMap = source.emissiveMap;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.fog = source.fog;

		this.shading = source.shading;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.vertexColors = source.vertexColors;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		return this;

	};

	// File:src/materials/MeshDepthMaterial.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  opacity: <float>,
	 *
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>
	 * }
	 */

	THREE.MeshDepthMaterial = function ( parameters ) {

		THREE.Material.call( this );

		this.type = 'MeshDepthMaterial';

		this.morphTargets = false;
		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.setValues( parameters );

	};

	THREE.MeshDepthMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial;

	THREE.MeshDepthMaterial.prototype.copy = function ( source ) {

		THREE.Material.prototype.copy.call( this, source );

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		return this;

	};

	// File:src/materials/MeshNormalMaterial.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 *
	 * parameters = {
	 *  opacity: <float>,
	 *
	 *  shading: THREE.FlatShading,
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>
	 * }
	 */

	THREE.MeshNormalMaterial = function ( parameters ) {

		THREE.Material.call( this, parameters );

		this.type = 'MeshNormalMaterial';

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.morphTargets = false;

		this.setValues( parameters );

	};

	THREE.MeshNormalMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial;

	THREE.MeshNormalMaterial.prototype.copy = function ( source ) {

		THREE.Material.prototype.copy.call( this, source );

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		return this;

	};

	// File:src/materials/MultiMaterial.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.MultiMaterial = function ( materials ) {

		this.uuid = THREE.Math.generateUUID();

		this.type = 'MultiMaterial';

		this.materials = materials instanceof Array ? materials : [];

		this.visible = true;

	};

	THREE.MultiMaterial.prototype = {

		constructor: THREE.MultiMaterial,

		toJSON: function () {

			var output = {
				metadata: {
					version: 4.2,
					type: 'material',
					generator: 'MaterialExporter'
				},
				uuid: this.uuid,
				type: this.type,
				materials: []
			};

			for ( var i = 0, l = this.materials.length; i < l; i ++ ) {

				output.materials.push( this.materials[ i ].toJSON() );

			}

			output.visible = this.visible;

			return output;

		},

		clone: function () {

			var material = new this.constructor();

			for ( var i = 0; i < this.materials.length; i ++ ) {

				material.materials.push( this.materials[ i ].clone() );

			}

			material.visible = this.visible;

			return material;

		}

	};

	// backwards compatibility

	THREE.MeshFaceMaterial = THREE.MultiMaterial;

	// File:src/materials/PointsMaterial.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  size: <float>,
	 *  sizeAttenuation: <bool>,
	 *
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  vertexColors: <bool>,
	 *
	 *  fog: <bool>
	 * }
	 */

	THREE.PointsMaterial = function ( parameters ) {

		THREE.Material.call( this );

		this.type = 'PointsMaterial';

		this.color = new THREE.Color( 0xffffff );

		this.map = null;

		this.size = 1;
		this.sizeAttenuation = true;

		this.vertexColors = THREE.NoColors;

		this.fog = true;

		this.setValues( parameters );

	};

	THREE.PointsMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.PointsMaterial.prototype.constructor = THREE.PointsMaterial;

	THREE.PointsMaterial.prototype.copy = function ( source ) {

		THREE.Material.prototype.copy.call( this, source );

		this.color.copy( source.color );

		this.map = source.map;

		this.size = source.size;
		this.sizeAttenuation = source.sizeAttenuation;

		this.vertexColors = source.vertexColors;

		this.fog = source.fog;

		return this;

	};

	// backwards compatibility

	THREE.PointCloudMaterial = function ( parameters ) {

		console.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );
		return new THREE.PointsMaterial( parameters );

	};

	THREE.ParticleBasicMaterial = function ( parameters ) {

		console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );
		return new THREE.PointsMaterial( parameters );

	};

	THREE.ParticleSystemMaterial = function ( parameters ) {

		console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );
		return new THREE.PointsMaterial( parameters );

	};

	// File:src/materials/ShaderMaterial.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  defines: { "label" : "value" },
	 *  uniforms: { "parameter1": { type: "f", value: 1.0 }, "parameter2": { type: "i" value2: 2 } },
	 *
	 *  fragmentShader: <string>,
	 *  vertexShader: <string>,
	 *
	 *  shading: THREE.SmoothShading,
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  lights: <bool>,
	 *
	 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>,
	 *
	 *	fog: <bool>
	 * }
	 */

	THREE.ShaderMaterial = function ( parameters ) {

		THREE.Material.call( this );

		this.type = 'ShaderMaterial';

		this.defines = {};
		this.uniforms = {};

		this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
		this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';

		this.shading = THREE.SmoothShading;

		this.linewidth = 1;

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.fog = false; // set to use scene fog

		this.lights = false; // set to use scene lights

		this.vertexColors = THREE.NoColors; // set to use "color" attribute stream

		this.skinning = false; // set to use skinning attribute streams

		this.morphTargets = false; // set to use morph targets
		this.morphNormals = false; // set to use morph normals

		this.derivatives = false; // set to use derivatives

		// When rendered geometry doesn't include these attributes but the material does,
		// use these default values in WebGL. This avoids errors when buffer data is missing.
		this.defaultAttributeValues = {
			'color': [ 1, 1, 1 ],
			'uv': [ 0, 0 ],
			'uv2': [ 0, 0 ]
		};

		this.index0AttributeName = undefined;

		if ( parameters !== undefined ) {

			if ( parameters.attributes !== undefined ) {

				console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );

			}

			this.setValues( parameters );

		}

	};

	THREE.ShaderMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial;

	THREE.ShaderMaterial.prototype.copy = function ( source ) {

		THREE.Material.prototype.copy.call( this, source );

		this.fragmentShader = source.fragmentShader;
		this.vertexShader = source.vertexShader;

		this.uniforms = THREE.UniformsUtils.clone( source.uniforms );

		this.attributes = source.attributes;
		this.defines = source.defines;

		this.shading = source.shading;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		this.fog = source.fog;

		this.lights = source.lights;

		this.vertexColors = source.vertexColors;

		this.skinning = source.skinning;

		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		this.derivatives = source.derivatives;

		return this;

	};

	THREE.ShaderMaterial.prototype.toJSON = function ( meta ) {

		var data = THREE.Material.prototype.toJSON.call( this, meta );

		data.uniforms = this.uniforms;
		data.attributes = this.attributes;
		data.vertexShader = this.vertexShader;
		data.fragmentShader = this.fragmentShader;

		return data;

	};

	// File:src/materials/RawShaderMaterial.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.RawShaderMaterial = function ( parameters ) {

		THREE.ShaderMaterial.call( this, parameters );

		this.type = 'RawShaderMaterial';

	};

	THREE.RawShaderMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );
	THREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial;
	// File:src/materials/SpriteMaterial.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *	uvOffset: new THREE.Vector2(),
	 *	uvScale: new THREE.Vector2(),
	 *
	 *  fog: <bool>
	 * }
	 */

	THREE.SpriteMaterial = function ( parameters ) {

		THREE.Material.call( this );

		this.type = 'SpriteMaterial';

		this.color = new THREE.Color( 0xffffff );
		this.map = null;

		this.rotation = 0;

		this.fog = false;

		// set parameters

		this.setValues( parameters );

	};

	THREE.SpriteMaterial.prototype = Object.create( THREE.Material.prototype );
	THREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial;

	THREE.SpriteMaterial.prototype.copy = function ( source ) {

		THREE.Material.prototype.copy.call( this, source );

		this.color.copy( source.color );
		this.map = source.map;

		this.rotation = source.rotation;

		this.fog = source.fog;

		return this;

	};

	// File:src/textures/Texture.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author szimek / https://github.com/szimek/
	 */

	THREE.Texture = function ( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

		Object.defineProperty( this, 'id', { value: THREE.TextureIdCount ++ } );

		this.uuid = THREE.Math.generateUUID();

		this.name = '';
		this.sourceFile = '';

		this.image = image !== undefined ? image : THREE.Texture.DEFAULT_IMAGE;
		this.mipmaps = [];

		this.mapping = mapping !== undefined ? mapping : THREE.Texture.DEFAULT_MAPPING;

		this.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;
		this.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;

		this.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;
		this.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;

		this.anisotropy = anisotropy !== undefined ? anisotropy : 1;

		this.format = format !== undefined ? format : THREE.RGBAFormat;
		this.type = type !== undefined ? type : THREE.UnsignedByteType;

		this.offset = new THREE.Vector2( 0, 0 );
		this.repeat = new THREE.Vector2( 1, 1 );

		this.generateMipmaps = true;
		this.premultiplyAlpha = false;
		this.flipY = true;
		this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

		this.version = 0;
		this.onUpdate = null;

	};

	THREE.Texture.DEFAULT_IMAGE = undefined;
	THREE.Texture.DEFAULT_MAPPING = THREE.UVMapping;

	THREE.Texture.prototype = {

		constructor: THREE.Texture,

		set needsUpdate ( value ) {

			if ( value === true ) this.version ++;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( source ) {

			this.image = source.image;
			this.mipmaps = source.mipmaps.slice( 0 );

			this.mapping = source.mapping;

			this.wrapS = source.wrapS;
			this.wrapT = source.wrapT;

			this.magFilter = source.magFilter;
			this.minFilter = source.minFilter;

			this.anisotropy = source.anisotropy;

			this.format = source.format;
			this.type = source.type;

			this.offset.copy( source.offset );
			this.repeat.copy( source.repeat );

			this.generateMipmaps = source.generateMipmaps;
			this.premultiplyAlpha = source.premultiplyAlpha;
			this.flipY = source.flipY;
			this.unpackAlignment = source.unpackAlignment;

			return this;

		},

		toJSON: function ( meta ) {

			if ( meta.textures[ this.uuid ] !== undefined ) {

				return meta.textures[ this.uuid ];

			}

			function getDataURL( image ) {

				var canvas;

				if ( image.toDataURL !== undefined ) {

					canvas = image;

				} else {

					canvas = document.createElement( 'canvas' );
					canvas.width = image.width;
					canvas.height = image.height;

					canvas.getContext( '2d' ).drawImage( image, 0, 0, image.width, image.height );

				}

				if ( canvas.width > 2048 || canvas.height > 2048 ) {

					return canvas.toDataURL( 'image/jpeg', 0.6 );

				} else {

					return canvas.toDataURL( 'image/png' );

				}

			}

			var output = {
				metadata: {
					version: 4.4,
					type: 'Texture',
					generator: 'Texture.toJSON'
				},

				uuid: this.uuid,
				name: this.name,

				mapping: this.mapping,

				repeat: [ this.repeat.x, this.repeat.y ],
				offset: [ this.offset.x, this.offset.y ],
				wrap: [ this.wrapS, this.wrapT ],

				minFilter: this.minFilter,
				magFilter: this.magFilter,
				anisotropy: this.anisotropy
			};

			if ( this.image !== undefined ) {

				// TODO: Move to THREE.Image

				var image = this.image;

				if ( image.uuid === undefined ) {

					image.uuid = THREE.Math.generateUUID(); // UGH

				}

				if ( meta.images[ image.uuid ] === undefined ) {

					meta.images[ image.uuid ] = {
						uuid: image.uuid,
						url: getDataURL( image )
					};

				}

				output.image = image.uuid;

			}

			meta.textures[ this.uuid ] = output;

			return output;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		},

		transformUv: function ( uv ) {

			if ( this.mapping !== THREE.UVMapping )  return;

			uv.multiply( this.repeat );
			uv.add( this.offset );

			if ( uv.x < 0 || uv.x > 1 ) {

				switch ( this.wrapS ) {

					case THREE.RepeatWrapping:

						uv.x = uv.x - Math.floor( uv.x );
						break;

					case THREE.ClampToEdgeWrapping:

						uv.x = uv.x < 0 ? 0 : 1;
						break;

					case THREE.MirroredRepeatWrapping:

						if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

							uv.x = Math.ceil( uv.x ) - uv.x;

						} else {

							uv.x = uv.x - Math.floor( uv.x );

						}
						break;

				}

			}

			if ( uv.y < 0 || uv.y > 1 ) {

				switch ( this.wrapT ) {

					case THREE.RepeatWrapping:

						uv.y = uv.y - Math.floor( uv.y );
						break;

					case THREE.ClampToEdgeWrapping:

						uv.y = uv.y < 0 ? 0 : 1;
						break;

					case THREE.MirroredRepeatWrapping:

						if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

							uv.y = Math.ceil( uv.y ) - uv.y;

						} else {

							uv.y = uv.y - Math.floor( uv.y );

						}
						break;

				}

			}

			if ( this.flipY ) {

				uv.y = 1 - uv.y;

			}

		}

	};

	THREE.EventDispatcher.prototype.apply( THREE.Texture.prototype );

	THREE.TextureIdCount = 0;

	// File:src/textures/CanvasTexture.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.CanvasTexture = function ( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

		THREE.Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.needsUpdate = true;

	};

	THREE.CanvasTexture.prototype = Object.create( THREE.Texture.prototype );
	THREE.CanvasTexture.prototype.constructor = THREE.CanvasTexture;

	// File:src/textures/CubeTexture.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.CubeTexture = function ( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

		mapping = mapping !== undefined ? mapping : THREE.CubeReflectionMapping;

		THREE.Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.images = images;
		this.flipY = false;

	};

	THREE.CubeTexture.prototype = Object.create( THREE.Texture.prototype );
	THREE.CubeTexture.prototype.constructor = THREE.CubeTexture;

	THREE.CubeTexture.prototype.copy = function ( source ) {

		THREE.Texture.prototype.copy.call( this, source );
		
		this.images = source.images;
		
		return this;

	};
	// File:src/textures/CompressedTexture.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.CompressedTexture = function ( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {

		THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.image = { width: width, height: height };
		this.mipmaps = mipmaps;

		// no flipping for cube textures
		// (also flipping doesn't work for compressed textures )

		this.flipY = false;

		// can't generate mipmaps for compressed textures
		// mips must be embedded in DDS files

		this.generateMipmaps = false;

	};

	THREE.CompressedTexture.prototype = Object.create( THREE.Texture.prototype );
	THREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture;

	// File:src/textures/DataTexture.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.DataTexture = function ( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {

		THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.image = { data: data, width: width, height: height };

		this.magFilter = magFilter !== undefined ? magFilter : THREE.NearestFilter;
		this.minFilter = minFilter !== undefined ? minFilter : THREE.NearestFilter;
		
		this.flipY = false;
		this.generateMipmaps  = false;

	};

	THREE.DataTexture.prototype = Object.create( THREE.Texture.prototype );
	THREE.DataTexture.prototype.constructor = THREE.DataTexture;

	// File:src/textures/VideoTexture.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.VideoTexture = function ( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

		THREE.Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.generateMipmaps = false;

		var scope = this;

		function update() {

			requestAnimationFrame( update );

			if ( video.readyState === video.HAVE_ENOUGH_DATA ) {

				scope.needsUpdate = true;

			}

		}

		update();

	};

	THREE.VideoTexture.prototype = Object.create( THREE.Texture.prototype );
	THREE.VideoTexture.prototype.constructor = THREE.VideoTexture;

	// File:src/objects/Group.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Group = function () {

		THREE.Object3D.call( this );

		this.type = 'Group';

	};

	THREE.Group.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Group.prototype.constructor = THREE.Group;
	// File:src/objects/Points.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Points = function ( geometry, material ) {

		THREE.Object3D.call( this );

		this.type = 'Points';

		this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
		this.material = material !== undefined ? material : new THREE.PointsMaterial( { color: Math.random() * 0xffffff } );

	};

	THREE.Points.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Points.prototype.constructor = THREE.Points;

	THREE.Points.prototype.raycast = ( function () {

		var inverseMatrix = new THREE.Matrix4();
		var ray = new THREE.Ray();

		return function raycast( raycaster, intersects ) {

			var object = this;
			var geometry = object.geometry;
			var threshold = raycaster.params.Points.threshold;

			inverseMatrix.getInverse( this.matrixWorld );
			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

			if ( geometry.boundingBox !== null ) {

				if ( ray.isIntersectionBox( geometry.boundingBox ) === false ) {

					return;

				}

			}

			var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
			var localThresholdSq = localThreshold * localThreshold;
			var position = new THREE.Vector3();

			function testPoint( point, index ) {

				var rayPointDistanceSq = ray.distanceSqToPoint( point );

				if ( rayPointDistanceSq < localThresholdSq ) {

					var intersectPoint = ray.closestPointToPoint( point );
					intersectPoint.applyMatrix4( object.matrixWorld );

					var distance = raycaster.ray.origin.distanceTo( intersectPoint );

					if ( distance < raycaster.near || distance > raycaster.far ) return;

					intersects.push( {

						distance: distance,
						distanceToRay: Math.sqrt( rayPointDistanceSq ),
						point: intersectPoint.clone(),
						index: index,
						face: null,
						object: object

					} );

				}

			}

			if ( geometry instanceof THREE.BufferGeometry ) {

				var index = geometry.index;
				var attributes = geometry.attributes;
				var positions = attributes.position.array;

				if ( index !== null ) {

					var indices = index.array;

					for ( var i = 0, il = indices.length; i < il; i ++ ) {

						var a = indices[ i ];

						position.fromArray( positions, a * 3 );

						testPoint( position, a );

					}

				} else {

					for ( var i = 0, l = positions.length / 3; i < l; i ++ ) {

						position.fromArray( positions, i * 3 );

						testPoint( position, i );

					}

				}

			} else {

				var vertices = geometry.vertices;

				for ( var i = 0, l = vertices.length; i < l; i ++ ) {

					testPoint( vertices[ i ], i );

				}

			}

		};

	}() );

	THREE.Points.prototype.clone = function () {

		return new this.constructor( this.geometry, this.material ).copy( this );

	};

	// Backwards compatibility

	THREE.PointCloud = function ( geometry, material ) {

		console.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );
		return new THREE.Points( geometry, material );

	};

	THREE.ParticleSystem = function ( geometry, material ) {

		console.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );
		return new THREE.Points( geometry, material );

	};

	// File:src/objects/Line.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Line = function ( geometry, material, mode ) {

		if ( mode === 1 ) {

			console.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );
			return new THREE.LineSegments( geometry, material );

		}

		THREE.Object3D.call( this );

		this.type = 'Line';

		this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
		this.material = material !== undefined ? material : new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff } );

	};

	THREE.Line.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Line.prototype.constructor = THREE.Line;

	THREE.Line.prototype.raycast = ( function () {

		var inverseMatrix = new THREE.Matrix4();
		var ray = new THREE.Ray();
		var sphere = new THREE.Sphere();

		return function raycast( raycaster, intersects ) {

			var precision = raycaster.linePrecision;
			var precisionSq = precision * precision;

			var geometry = this.geometry;

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			// Checking boundingSphere distance to ray

			sphere.copy( geometry.boundingSphere );
			sphere.applyMatrix4( this.matrixWorld );

			if ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {

				return;

			}

			inverseMatrix.getInverse( this.matrixWorld );
			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

			var vStart = new THREE.Vector3();
			var vEnd = new THREE.Vector3();
			var interSegment = new THREE.Vector3();
			var interRay = new THREE.Vector3();
			var step = this instanceof THREE.LineSegments ? 2 : 1;

			if ( geometry instanceof THREE.BufferGeometry ) {

				var index = geometry.index;
				var attributes = geometry.attributes;

				if ( index !== null ) {

					var indices = index.array;
					var positions = attributes.position.array;

					for ( var i = 0, l = indices.length - 1; i < l; i += step ) {

						var a = indices[ i ];
						var b = indices[ i + 1 ];

						vStart.fromArray( positions, a * 3 );
						vEnd.fromArray( positions, b * 3 );

						var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

						if ( distSq > precisionSq ) continue;

						interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

						var distance = raycaster.ray.origin.distanceTo( interRay );

						if ( distance < raycaster.near || distance > raycaster.far ) continue;

						intersects.push( {

							distance: distance,
							// What do we want? intersection point on the ray or on the segment??
							// point: raycaster.ray.at( distance ),
							point: interSegment.clone().applyMatrix4( this.matrixWorld ),
							index: i,
							face: null,
							faceIndex: null,
							object: this

						} );

					}

				} else {

					var positions = attributes.position.array;

					for ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {

						vStart.fromArray( positions, 3 * i );
						vEnd.fromArray( positions, 3 * i + 3 );

						var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

						if ( distSq > precisionSq ) continue;

						interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

						var distance = raycaster.ray.origin.distanceTo( interRay );

						if ( distance < raycaster.near || distance > raycaster.far ) continue;

						intersects.push( {

							distance: distance,
							// What do we want? intersection point on the ray or on the segment??
							// point: raycaster.ray.at( distance ),
							point: interSegment.clone().applyMatrix4( this.matrixWorld ),
							index: i,
							face: null,
							faceIndex: null,
							object: this

						} );

					}

				}

			} else if ( geometry instanceof THREE.Geometry ) {

				var vertices = geometry.vertices;
				var nbVertices = vertices.length;

				for ( var i = 0; i < nbVertices - 1; i += step ) {

					var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );

					if ( distSq > precisionSq ) continue;

					interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

					var distance = raycaster.ray.origin.distanceTo( interRay );

					if ( distance < raycaster.near || distance > raycaster.far ) continue;

					intersects.push( {

						distance: distance,
						// What do we want? intersection point on the ray or on the segment??
						// point: raycaster.ray.at( distance ),
						point: interSegment.clone().applyMatrix4( this.matrixWorld ),
						index: i,
						face: null,
						faceIndex: null,
						object: this

					} );

				}

			}

		};

	}() );

	THREE.Line.prototype.clone = function () {

		return new this.constructor( this.geometry, this.material ).copy( this );

	};

	// DEPRECATED

	THREE.LineStrip = 0;
	THREE.LinePieces = 1;

	// File:src/objects/LineSegments.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.LineSegments = function ( geometry, material ) {

		THREE.Line.call( this, geometry, material );

		this.type = 'LineSegments';

	};

	THREE.LineSegments.prototype = Object.create( THREE.Line.prototype );
	THREE.LineSegments.prototype.constructor = THREE.LineSegments;

	// File:src/objects/Mesh.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author jonobr1 / http://jonobr1.com/
	 */

	THREE.Mesh = function ( geometry, material ) {

		THREE.Object3D.call( this );

		this.type = 'Mesh';

		this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
		this.material = material !== undefined ? material : new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } );

		this.updateMorphTargets();

	};

	THREE.Mesh.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Mesh.prototype.constructor = THREE.Mesh;

	THREE.Mesh.prototype.updateMorphTargets = function () {

		if ( this.geometry.morphTargets !== undefined && this.geometry.morphTargets.length > 0 ) {

			this.morphTargetBase = - 1;
			this.morphTargetInfluences = [];
			this.morphTargetDictionary = {};

			for ( var m = 0, ml = this.geometry.morphTargets.length; m < ml; m ++ ) {

				this.morphTargetInfluences.push( 0 );
				this.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;

			}

		}

	};

	THREE.Mesh.prototype.getMorphTargetIndexByName = function ( name ) {

		if ( this.morphTargetDictionary[ name ] !== undefined ) {

			return this.morphTargetDictionary[ name ];

		}

		console.warn( 'THREE.Mesh.getMorphTargetIndexByName: morph target ' + name + ' does not exist. Returning 0.' );

		return 0;

	};


	THREE.Mesh.prototype.raycast = ( function () {

		var inverseMatrix = new THREE.Matrix4();
		var ray = new THREE.Ray();
		var sphere = new THREE.Sphere();

		var vA = new THREE.Vector3();
		var vB = new THREE.Vector3();
		var vC = new THREE.Vector3();

		var tempA = new THREE.Vector3();
		var tempB = new THREE.Vector3();
		var tempC = new THREE.Vector3();

		var uvA = new THREE.Vector2();
		var uvB = new THREE.Vector2();
		var uvC = new THREE.Vector2();

		var barycoord = new THREE.Vector3();

		var intersectionPoint = new THREE.Vector3();
		var intersectionPointWorld = new THREE.Vector3();

		function uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {

			THREE.Triangle.barycoordFromPoint( point, p1, p2, p3, barycoord );

			uv1.multiplyScalar( barycoord.x );
			uv2.multiplyScalar( barycoord.y );
			uv3.multiplyScalar( barycoord.z );

			uv1.add( uv2 ).add( uv3 );

			return uv1.clone();

		}

		function checkIntersection( object, raycaster, ray, pA, pB, pC, point ){

			var intersect;
			var material = object.material;

			if ( material.side === THREE.BackSide ) {

				intersect = ray.intersectTriangle( pC, pB, pA, true, point );

			} else {

				intersect = ray.intersectTriangle( pA, pB, pC, material.side !== THREE.DoubleSide, point );

			}

			if ( intersect === null ) return null;

			intersectionPointWorld.copy( point );
			intersectionPointWorld.applyMatrix4( object.matrixWorld );

			var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );

			if ( distance < raycaster.near || distance > raycaster.far ) return null;

			return {
				distance: distance,
				point: intersectionPointWorld.clone(),
				object: object
			};

		}

		function checkBufferGeometryIntersection( object, raycaster, ray, positions, uvs, a, b, c ) {

			vA.fromArray( positions, a * 3 );
			vB.fromArray( positions, b * 3 );
			vC.fromArray( positions, c * 3 );

			var intersection = checkIntersection( object, raycaster, ray, vA, vB, vC, intersectionPoint );

			if ( intersection ) {

				if ( uvs ) {

					uvA.fromArray( uvs, a * 2 );
					uvB.fromArray( uvs, b * 2 );
					uvC.fromArray( uvs, c * 2 );

					intersection.uv = uvIntersection( intersectionPoint,  vA, vB, vC,  uvA, uvB, uvC );

				}

				intersection.face = new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) );
				intersection.faceIndex = a;

			}

			return intersection;

		}

		return function raycast( raycaster, intersects ) {

			var geometry = this.geometry;
			var material = this.material;

			if ( material === undefined ) return;

			// Checking boundingSphere distance to ray

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			var matrixWorld = this.matrixWorld;

			sphere.copy( geometry.boundingSphere );
			sphere.applyMatrix4( matrixWorld );

			if ( raycaster.ray.isIntersectionSphere( sphere ) === false ) return;

			// Check boundingBox before continuing

			inverseMatrix.getInverse( matrixWorld );
			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

			if ( geometry.boundingBox !== null ) {

				if ( ray.isIntersectionBox( geometry.boundingBox ) === false ) return;

			}

			var uvs, intersection;

			if ( geometry instanceof THREE.BufferGeometry ) {

				var a, b, c;
				var index = geometry.index;
				var attributes = geometry.attributes;
				var positions = attributes.position.array;

				if ( attributes.uv !== undefined ){

					uvs = attributes.uv.array;

				}

				if ( index !== null ) {

					var indices = index.array;

					for ( var i = 0, l = indices.length; i < l; i += 3 ) {

						a = indices[ i ];
						b = indices[ i + 1 ];
						c = indices[ i + 2 ];

						intersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );

						if ( intersection ) {

							intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indices buffer semantics
							intersects.push( intersection );

						}

					}

				} else {


					for ( var i = 0, l = positions.length; i < l; i += 9 ) {

						a = i / 3;
						b = a + 1;
						c = a + 2;

						intersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );

						if ( intersection ) {

							intersection.index = a; // triangle number in positions buffer semantics
							intersects.push( intersection );

						}

					}

				}

			} else if ( geometry instanceof THREE.Geometry ) {

				var fvA, fvB, fvC;
				var isFaceMaterial = material instanceof THREE.MeshFaceMaterial;
				var materials = isFaceMaterial === true ? material.materials : null;

				var vertices = geometry.vertices;
				var faces = geometry.faces;
				var faceVertexUvs = geometry.faceVertexUvs[ 0 ];
				if ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;

				for ( var f = 0, fl = faces.length; f < fl; f ++ ) {

					var face = faces[ f ];
					var faceMaterial = isFaceMaterial === true ? materials[ face.materialIndex ] : material;

					if ( faceMaterial === undefined ) continue;

					fvA = vertices[ face.a ];
					fvB = vertices[ face.b ];
					fvC = vertices[ face.c ];

					if ( faceMaterial.morphTargets === true ) {

						var morphTargets = geometry.morphTargets;
						var morphInfluences = this.morphTargetInfluences;

						vA.set( 0, 0, 0 );
						vB.set( 0, 0, 0 );
						vC.set( 0, 0, 0 );

						for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {

							var influence = morphInfluences[ t ];

							if ( influence === 0 ) continue;

							var targets = morphTargets[ t ].vertices;

							vA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );
							vB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );
							vC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );

						}

						vA.add( fvA );
						vB.add( fvB );
						vC.add( fvC );

						fvA = vA;
						fvB = vB;
						fvC = vC;

					}

					intersection = checkIntersection( this, raycaster, ray, fvA, fvB, fvC, intersectionPoint );

					if ( intersection ) {

						if ( uvs ) {

							var uvs_f = uvs[ f ];
							uvA.copy( uvs_f[ 0 ] );
							uvB.copy( uvs_f[ 1 ] );
							uvC.copy( uvs_f[ 2 ] );

							intersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );

						}

						intersection.face = face;
						intersection.faceIndex = f;
						intersects.push( intersection );

					}

				}

			}

		};

	}() );

	THREE.Mesh.prototype.clone = function () {

		return new this.constructor( this.geometry, this.material ).copy( this );

	};

	// File:src/objects/Bone.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author ikerr / http://verold.com
	 */

	THREE.Bone = function ( skin ) {

		THREE.Object3D.call( this );

		this.type = 'Bone';

		this.skin = skin;

	};

	THREE.Bone.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Bone.prototype.constructor = THREE.Bone;

	THREE.Bone.prototype.copy = function ( source ) {
		
		THREE.Object3D.prototype.copy.call( this, source );
		
		this.skin = source.skin;
		
		return this;

	};

	// File:src/objects/Skeleton.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author michael guerrero / http://realitymeltdown.com
	 * @author ikerr / http://verold.com
	 */

	THREE.Skeleton = function ( bones, boneInverses, useVertexTexture ) {

		this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;

		this.identityMatrix = new THREE.Matrix4();

		// copy the bone array

		bones = bones || [];

		this.bones = bones.slice( 0 );

		// create a bone texture or an array of floats

		if ( this.useVertexTexture ) {

			// layout (1 matrix = 4 pixels)
			//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
			//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
			//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
			//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
			//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)

			
			var size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix
			size = THREE.Math.nextPowerOfTwo( Math.ceil( size ) );
			size = Math.max( size, 4 );

			this.boneTextureWidth = size;
			this.boneTextureHeight = size;

			this.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel
			this.boneTexture = new THREE.DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType );

		} else {

			this.boneMatrices = new Float32Array( 16 * this.bones.length );

		}

		// use the supplied bone inverses or calculate the inverses

		if ( boneInverses === undefined ) {

			this.calculateInverses();

		} else {

			if ( this.bones.length === boneInverses.length ) {

				this.boneInverses = boneInverses.slice( 0 );

			} else {

				console.warn( 'THREE.Skeleton bonInverses is the wrong length.' );

				this.boneInverses = [];

				for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

					this.boneInverses.push( new THREE.Matrix4() );

				}

			}

		}

	};

	THREE.Skeleton.prototype.calculateInverses = function () {

		this.boneInverses = [];

		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

			var inverse = new THREE.Matrix4();

			if ( this.bones[ b ] ) {

				inverse.getInverse( this.bones[ b ].matrixWorld );

			}

			this.boneInverses.push( inverse );

		}

	};

	THREE.Skeleton.prototype.pose = function () {

		var bone;

		// recover the bind-time world matrices

		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

			bone = this.bones[ b ];

			if ( bone ) {

				bone.matrixWorld.getInverse( this.boneInverses[ b ] );

			}

		}

		// compute the local matrices, positions, rotations and scales

		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

			bone = this.bones[ b ];

			if ( bone ) {

				if ( bone.parent ) {

					bone.matrix.getInverse( bone.parent.matrixWorld );
					bone.matrix.multiply( bone.matrixWorld );

				} else {

					bone.matrix.copy( bone.matrixWorld );

				}

				bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

			}

		}

	};

	THREE.Skeleton.prototype.update = ( function () {

		var offsetMatrix = new THREE.Matrix4();

		return function update() {

			// flatten bone matrices to array

			for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

				// compute the offset between the current and the original transform

				var matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;

				offsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );
				offsetMatrix.flattenToArrayOffset( this.boneMatrices, b * 16 );

			}

			if ( this.useVertexTexture ) {

				this.boneTexture.needsUpdate = true;

			}

		};

	} )();

	THREE.Skeleton.prototype.clone = function () {

		return new THREE.Skeleton( this.bones, this.boneInverses, this.useVertexTexture );

	};

	// File:src/objects/SkinnedMesh.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author ikerr / http://verold.com
	 */

	THREE.SkinnedMesh = function ( geometry, material, useVertexTexture ) {

		THREE.Mesh.call( this, geometry, material );

		this.type = 'SkinnedMesh';

		this.bindMode = "attached";
		this.bindMatrix = new THREE.Matrix4();
		this.bindMatrixInverse = new THREE.Matrix4();

		// init bones

		// TODO: remove bone creation as there is no reason (other than
		// convenience) for THREE.SkinnedMesh to do this.

		var bones = [];

		if ( this.geometry && this.geometry.bones !== undefined ) {

			var bone, gbone;

			for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {

				gbone = this.geometry.bones[ b ];

				bone = new THREE.Bone( this );
				bones.push( bone );

				bone.name = gbone.name;
				bone.position.fromArray( gbone.pos );
				bone.quaternion.fromArray( gbone.rotq );
				if ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );

			}

			for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {

				gbone = this.geometry.bones[ b ];

				if ( gbone.parent !== - 1 && gbone.parent !== null) {

					bones[ gbone.parent ].add( bones[ b ] );

				} else {

					this.add( bones[ b ] );

				}

			}

		}

		this.normalizeSkinWeights();

		this.updateMatrixWorld( true );
		this.bind( new THREE.Skeleton( bones, undefined, useVertexTexture ), this.matrixWorld );

	};


	THREE.SkinnedMesh.prototype = Object.create( THREE.Mesh.prototype );
	THREE.SkinnedMesh.prototype.constructor = THREE.SkinnedMesh;

	THREE.SkinnedMesh.prototype.bind = function( skeleton, bindMatrix ) {

		this.skeleton = skeleton;

		if ( bindMatrix === undefined ) {

			this.updateMatrixWorld( true );
			
			this.skeleton.calculateInverses();

			bindMatrix = this.matrixWorld;

		}

		this.bindMatrix.copy( bindMatrix );
		this.bindMatrixInverse.getInverse( bindMatrix );

	};

	THREE.SkinnedMesh.prototype.pose = function () {

		this.skeleton.pose();

	};

	THREE.SkinnedMesh.prototype.normalizeSkinWeights = function () {

		if ( this.geometry instanceof THREE.Geometry ) {

			for ( var i = 0; i < this.geometry.skinIndices.length; i ++ ) {

				var sw = this.geometry.skinWeights[ i ];

				var scale = 1.0 / sw.lengthManhattan();

				if ( scale !== Infinity ) {

					sw.multiplyScalar( scale );

				} else {

					sw.set( 1 ); // this will be normalized by the shader anyway

				}

			}

		} else {

			// skinning weights assumed to be normalized for THREE.BufferGeometry

		}

	};

	THREE.SkinnedMesh.prototype.updateMatrixWorld = function( force ) {

		THREE.Mesh.prototype.updateMatrixWorld.call( this, true );

		if ( this.bindMode === "attached" ) {

			this.bindMatrixInverse.getInverse( this.matrixWorld );

		} else if ( this.bindMode === "detached" ) {

			this.bindMatrixInverse.getInverse( this.bindMatrix );

		} else {

			console.warn( 'THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode );

		}

	};

	THREE.SkinnedMesh.prototype.clone = function() {

		return new this.constructor( this.geometry, this.material, this.useVertexTexture ).copy( this );

	};

	// File:src/objects/LOD.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.LOD = function () {

		THREE.Object3D.call( this );

		this.type = 'LOD';

		Object.defineProperties( this, {
			levels: {
				enumerable: true,
				value: []
			},
			objects: {
				get: function () {

					console.warn( 'THREE.LOD: .objects has been renamed to .levels.' );
					return this.levels;

				}
			}
		} );

	};


	THREE.LOD.prototype = Object.create( THREE.Object3D.prototype );
	THREE.LOD.prototype.constructor = THREE.LOD;

	THREE.LOD.prototype.addLevel = function ( object, distance ) {

		if ( distance === undefined ) distance = 0;

		distance = Math.abs( distance );

		var levels = this.levels;

		for ( var l = 0; l < levels.length; l ++ ) {

			if ( distance < levels[ l ].distance ) {

				break;

			}

		}

		levels.splice( l, 0, { distance: distance, object: object } );

		this.add( object );

	};

	THREE.LOD.prototype.getObjectForDistance = function ( distance ) {

		var levels = this.levels;

		for ( var i = 1, l = levels.length; i < l; i ++ ) {

			if ( distance < levels[ i ].distance ) {

				break;

			}

		}

		return levels[ i - 1 ].object;

	};

	THREE.LOD.prototype.raycast = ( function () {

		var matrixPosition = new THREE.Vector3();

		return function raycast( raycaster, intersects ) {

			matrixPosition.setFromMatrixPosition( this.matrixWorld );

			var distance = raycaster.ray.origin.distanceTo( matrixPosition );

			this.getObjectForDistance( distance ).raycast( raycaster, intersects );

		};

	}() );

	THREE.LOD.prototype.update = function () {

		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();

		return function update( camera ) {

			var levels = this.levels;

			if ( levels.length > 1 ) {

				v1.setFromMatrixPosition( camera.matrixWorld );
				v2.setFromMatrixPosition( this.matrixWorld );

				var distance = v1.distanceTo( v2 );

				levels[ 0 ].object.visible = true;

				for ( var i = 1, l = levels.length; i < l; i ++ ) {

					if ( distance >= levels[ i ].distance ) {

						levels[ i - 1 ].object.visible = false;
						levels[ i ].object.visible = true;

					} else {

						break;

					}

				}

				for ( ; i < l; i ++ ) {

					levels[ i ].object.visible = false;

				}

			}

		};

	}();

	THREE.LOD.prototype.copy = function ( source ) {

		THREE.Object3D.prototype.copy.call( this, source, false );

		var levels = source.levels;

		for ( var i = 0, l = levels.length; i < l; i ++ ) {

			var level = levels[ i ];

			this.addLevel( level.object.clone(), level.distance );

		}

		return this;

	};

	THREE.LOD.prototype.toJSON = function ( meta ) {

		var data = THREE.Object3D.prototype.toJSON.call( this, meta );

		data.object.levels = [];

		var levels = this.levels;

		for ( var i = 0, l = levels.length; i < l; i ++ ) {

			var level = levels[ i ];

			data.object.levels.push( {
				object: level.object.uuid,
				distance: level.distance
			} );

		}

		return data;

	};

	// File:src/objects/Sprite.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Sprite = ( function () {

		var indices = new Uint16Array( [ 0, 1, 2,  0, 2, 3 ] );
		var vertices = new Float32Array( [ - 0.5, - 0.5, 0,   0.5, - 0.5, 0,   0.5, 0.5, 0,   - 0.5, 0.5, 0 ] );
		var uvs = new Float32Array( [ 0, 0,   1, 0,   1, 1,   0, 1 ] );

		var geometry = new THREE.BufferGeometry();
		geometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );
		geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
		geometry.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

		return function Sprite( material ) {

			THREE.Object3D.call( this );

			this.type = 'Sprite';

			this.geometry = geometry;
			this.material = ( material !== undefined ) ? material : new THREE.SpriteMaterial();

		};

	} )();

	THREE.Sprite.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Sprite.prototype.constructor = THREE.Sprite;

	THREE.Sprite.prototype.raycast = ( function () {

		var matrixPosition = new THREE.Vector3();

		return function raycast( raycaster, intersects ) {

			matrixPosition.setFromMatrixPosition( this.matrixWorld );

			var distanceSq = raycaster.ray.distanceSqToPoint( matrixPosition );
			var guessSizeSq = this.scale.x * this.scale.y;

			if ( distanceSq > guessSizeSq ) {

				return;

			}

			intersects.push( {

				distance: Math.sqrt( distanceSq ),
				point: this.position,
				face: null,
				object: this

			} );

		};

	}() );

	THREE.Sprite.prototype.clone = function () {

		return new this.constructor( this.material ).copy( this );

	};

	// Backwards compatibility

	THREE.Particle = THREE.Sprite;

	// File:src/objects/LensFlare.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.LensFlare = function ( texture, size, distance, blending, color ) {

		THREE.Object3D.call( this );

		this.lensFlares = [];

		this.positionScreen = new THREE.Vector3();
		this.customUpdateCallback = undefined;

		if ( texture !== undefined ) {

			this.add( texture, size, distance, blending, color );

		}

	};

	THREE.LensFlare.prototype = Object.create( THREE.Object3D.prototype );
	THREE.LensFlare.prototype.constructor = THREE.LensFlare;


	/*
	 * Add: adds another flare
	 */

	THREE.LensFlare.prototype.add = function ( texture, size, distance, blending, color, opacity ) {

		if ( size === undefined ) size = - 1;
		if ( distance === undefined ) distance = 0;
		if ( opacity === undefined ) opacity = 1;
		if ( color === undefined ) color = new THREE.Color( 0xffffff );
		if ( blending === undefined ) blending = THREE.NormalBlending;

		distance = Math.min( distance, Math.max( 0, distance ) );

		this.lensFlares.push( {
			texture: texture,	// THREE.Texture
			size: size, 		// size in pixels (-1 = use texture.width)
			distance: distance, 	// distance (0-1) from light source (0=at light source)
			x: 0, y: 0, z: 0,	// screen position (-1 => 1) z = 0 is in front z = 1 is back
			scale: 1, 		// scale
			rotation: 0, 		// rotation
			opacity: opacity,	// opacity
			color: color,		// color
			blending: blending	// blending
		} );

	};

	/*
	 * Update lens flares update positions on all flares based on the screen position
	 * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.
	 */

	THREE.LensFlare.prototype.updateLensFlares = function () {

		var f, fl = this.lensFlares.length;
		var flare;
		var vecX = - this.positionScreen.x * 2;
		var vecY = - this.positionScreen.y * 2;

		for ( f = 0; f < fl; f ++ ) {

			flare = this.lensFlares[ f ];

			flare.x = this.positionScreen.x + vecX * flare.distance;
			flare.y = this.positionScreen.y + vecY * flare.distance;

			flare.wantedRotation = flare.x * Math.PI * 0.25;
			flare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;

		}

	};

	THREE.LensFlare.prototype.copy = function ( source ) {

		THREE.Object3D.prototype.copy.call( this, source );

		this.positionScreen.copy( source.positionScreen );
		this.customUpdateCallback = source.customUpdateCallback;

		for ( var i = 0, l = source.lensFlares.length; i < l; i ++ ) {

			this.lensFlares.push( source.lensFlares[ i ] );

		}

		return this;

	};

	// File:src/scenes/Scene.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Scene = function () {

		THREE.Object3D.call( this );

		this.type = 'Scene';

		this.fog = null;
		this.overrideMaterial = null;

		this.autoUpdate = true; // checked by the renderer

	};

	THREE.Scene.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Scene.prototype.constructor = THREE.Scene;

	THREE.Scene.prototype.copy = function ( source ) {

		THREE.Object3D.prototype.copy.call( this, source );

		if ( source.fog !== null ) this.fog = source.fog.clone();
		if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();

		this.autoUpdate = source.autoUpdate;
		this.matrixAutoUpdate = source.matrixAutoUpdate;

		return this;

	};

	// File:src/scenes/Fog.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.Fog = function ( color, near, far ) {

		this.name = '';

		this.color = new THREE.Color( color );

		this.near = ( near !== undefined ) ? near : 1;
		this.far = ( far !== undefined ) ? far : 1000;

	};

	THREE.Fog.prototype.clone = function () {

		return new THREE.Fog( this.color.getHex(), this.near, this.far );

	};

	// File:src/scenes/FogExp2.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.FogExp2 = function ( color, density ) {

		this.name = '';

		this.color = new THREE.Color( color );
		this.density = ( density !== undefined ) ? density : 0.00025;

	};

	THREE.FogExp2.prototype.clone = function () {

		return new THREE.FogExp2( this.color.getHex(), this.density );

	};

	// File:src/renderers/shaders/ShaderChunk.js

	THREE.ShaderChunk = {};

	// File:src/renderers/shaders/ShaderChunk/alphamap_fragment.glsl

	THREE.ShaderChunk[ 'alphamap_fragment'] = "#ifdef USE_ALPHAMAP\n\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/alphamap_pars_fragment.glsl

	THREE.ShaderChunk[ 'alphamap_pars_fragment'] = "#ifdef USE_ALPHAMAP\n\n	uniform sampler2D alphaMap;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/alphatest_fragment.glsl

	THREE.ShaderChunk[ 'alphatest_fragment'] = "#ifdef ALPHATEST\n\n	if ( diffuseColor.a < ALPHATEST ) discard;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/aomap_fragment.glsl

	THREE.ShaderChunk[ 'aomap_fragment'] = "#ifdef USE_AOMAP\n\n	totalAmbientLight *= ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/aomap_pars_fragment.glsl

	THREE.ShaderChunk[ 'aomap_pars_fragment'] = "#ifdef USE_AOMAP\n\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/begin_vertex.glsl

	THREE.ShaderChunk[ 'begin_vertex'] = "\nvec3 transformed = vec3( position );\n";

	// File:src/renderers/shaders/ShaderChunk/beginnormal_vertex.glsl

	THREE.ShaderChunk[ 'beginnormal_vertex'] = "\nvec3 objectNormal = vec3( normal );\n";

	// File:src/renderers/shaders/ShaderChunk/bumpmap_pars_fragment.glsl

	THREE.ShaderChunk[ 'bumpmap_pars_fragment'] = "#ifdef USE_BUMPMAP\n\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n\n\n\n	vec2 dHdxy_fwd() {\n\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n		return vec2( dBx, dBy );\n\n	}\n\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\n		vec3 vSigmaX = dFdx( surf_pos );\n		vec3 vSigmaY = dFdy( surf_pos );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n\n		float fDet = dot( vSigmaX, R1 );\n\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n\n	}\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/color_fragment.glsl

	THREE.ShaderChunk[ 'color_fragment'] = "#ifdef USE_COLOR\n\n	diffuseColor.rgb *= vColor;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/color_pars_fragment.glsl

	THREE.ShaderChunk[ 'color_pars_fragment'] = "#ifdef USE_COLOR\n\n	varying vec3 vColor;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/color_pars_vertex.glsl

	THREE.ShaderChunk[ 'color_pars_vertex'] = "#ifdef USE_COLOR\n\n	varying vec3 vColor;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/color_vertex.glsl

	THREE.ShaderChunk[ 'color_vertex'] = "#ifdef USE_COLOR\n\n	vColor.xyz = color.xyz;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/common.glsl

	THREE.ShaderChunk[ 'common'] = "#define PI 3.14159\n#define PI2 6.28318\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\n\nvec3 transformDirection( in vec3 normal, in mat4 matrix ) {\n\n	return normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );\n\n}\n\nvec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\n\n	return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\n\n}\n\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n	float distance = dot( planeNormal, point - pointOnPlane );\n\n	return - distance * planeNormal + point;\n\n}\n\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n	return sign( dot( point - pointOnPlane, planeNormal ) );\n\n}\n\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n\n}\n\nfloat calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {\n\n	if ( decayExponent > 0.0 ) {\n\n	  return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\n	}\n\n	return 1.0;\n\n}\n\nvec3 F_Schlick( in vec3 specularColor, in float dotLH ) {\n\n\n	float fresnel = exp2( ( -5.55437 * dotLH - 6.98316 ) * dotLH );\n\n	return ( 1.0 - specularColor ) * fresnel + specularColor;\n\n}\n\nfloat G_BlinnPhong_Implicit( /* in float dotNL, in float dotNV */ ) {\n\n\n	return 0.25;\n\n}\n\nfloat D_BlinnPhong( in float shininess, in float dotNH ) {\n\n\n	return ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n\n}\n\nvec3 BRDF_BlinnPhong( in vec3 specularColor, in float shininess, in vec3 normal, in vec3 lightDir, in vec3 viewDir ) {\n\n	vec3 halfDir = normalize( lightDir + viewDir );\n\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotLH = saturate( dot( lightDir, halfDir ) );\n\n	vec3 F = F_Schlick( specularColor, dotLH );\n\n	float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );\n\n	float D = D_BlinnPhong( shininess, dotNH );\n\n	return F * G * D;\n\n}\n\nvec3 inputToLinear( in vec3 a ) {\n\n	#ifdef GAMMA_INPUT\n\n		return pow( a, vec3( float( GAMMA_FACTOR ) ) );\n\n	#else\n\n		return a;\n\n	#endif\n\n}\n\nvec3 linearToOutput( in vec3 a ) {\n\n	#ifdef GAMMA_OUTPUT\n\n		return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\n\n	#else\n\n		return a;\n\n	#endif\n\n}\n";

	// File:src/renderers/shaders/ShaderChunk/defaultnormal_vertex.glsl

	THREE.ShaderChunk[ 'defaultnormal_vertex'] = "#ifdef FLIP_SIDED\n\n	objectNormal = -objectNormal;\n\n#endif\n\nvec3 transformedNormal = normalMatrix * objectNormal;\n";

	// File:src/renderers/shaders/ShaderChunk/displacementmap_vertex.glsl

	THREE.ShaderChunk[ 'displacementmap_vertex'] = "#ifdef USE_DISPLACEMENTMAP\n\n	transformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/displacementmap_pars_vertex.glsl

	THREE.ShaderChunk[ 'displacementmap_pars_vertex'] = "#ifdef USE_DISPLACEMENTMAP\n\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/emissivemap_fragment.glsl

	THREE.ShaderChunk[ 'emissivemap_fragment'] = "#ifdef USE_EMISSIVEMAP\n\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n\n	emissiveColor.rgb = inputToLinear( emissiveColor.rgb );\n\n	totalEmissiveLight *= emissiveColor.rgb;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/emissivemap_pars_fragment.glsl

	THREE.ShaderChunk[ 'emissivemap_pars_fragment'] = "#ifdef USE_EMISSIVEMAP\n\n	uniform sampler2D emissiveMap;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/envmap_fragment.glsl

	THREE.ShaderChunk[ 'envmap_fragment'] = "#ifdef USE_ENVMAP\n\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n		#ifdef ENVMAP_MODE_REFLECTION\n\n			vec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\n		#else\n\n			vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\n		#endif\n\n	#else\n\n		vec3 reflectVec = vReflect;\n\n	#endif\n\n	#ifdef DOUBLE_SIDED\n		float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n	#else\n		float flipNormal = 1.0;\n	#endif\n\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n	#elif defined( ENVMAP_TYPE_EQUIREC )\n		vec2 sampleUV;\n		sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n		sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n		vec4 envColor = texture2D( envMap, sampleUV );\n\n	#elif defined( ENVMAP_TYPE_SPHERE )\n		vec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n		vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n	#endif\n\n	envColor.xyz = inputToLinear( envColor.xyz );\n\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\n	#elif defined( ENVMAP_BLENDING_MIX )\n\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\n	#elif defined( ENVMAP_BLENDING_ADD )\n\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n\n	#endif\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/envmap_pars_fragment.glsl

	THREE.ShaderChunk[ 'envmap_pars_fragment'] = "#ifdef USE_ENVMAP\n\n	uniform float reflectivity;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	uniform float flipEnvMap;\n\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n		uniform float refractionRatio;\n\n	#else\n\n		varying vec3 vReflect;\n\n	#endif\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/envmap_pars_vertex.glsl

	THREE.ShaderChunk[ 'envmap_pars_vertex'] = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n	varying vec3 vReflect;\n\n	uniform float refractionRatio;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/envmap_vertex.glsl

	THREE.ShaderChunk[ 'envmap_vertex'] = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n	vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n	vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\n	#ifdef ENVMAP_MODE_REFLECTION\n\n		vReflect = reflect( cameraToVertex, worldNormal );\n\n	#else\n\n		vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n	#endif\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/fog_fragment.glsl

	THREE.ShaderChunk[ 'fog_fragment'] = "#ifdef USE_FOG\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		float depth = gl_FragDepthEXT / gl_FragCoord.w;\n\n	#else\n\n		float depth = gl_FragCoord.z / gl_FragCoord.w;\n\n	#endif\n\n	#ifdef FOG_EXP2\n\n		float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\n\n	#else\n\n		float fogFactor = smoothstep( fogNear, fogFar, depth );\n\n	#endif\n	\n	outgoingLight = mix( outgoingLight, fogColor, fogFactor );\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/fog_pars_fragment.glsl

	THREE.ShaderChunk[ 'fog_pars_fragment'] = "#ifdef USE_FOG\n\n	uniform vec3 fogColor;\n\n	#ifdef FOG_EXP2\n\n		uniform float fogDensity;\n\n	#else\n\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/hemilight_fragment.glsl

	THREE.ShaderChunk[ 'hemilight_fragment'] = "#if MAX_HEMI_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n		vec3 lightDir = hemisphereLightDirection[ i ];\n\n		float dotProduct = dot( normal, lightDir );\n\n		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\n		vec3 lightColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n		totalAmbientLight += lightColor;\n\n	}\n\n#endif\n\n";

	// File:src/renderers/shaders/ShaderChunk/lightmap_fragment.glsl

	THREE.ShaderChunk[ 'lightmap_fragment'] = "#ifdef USE_LIGHTMAP\n\n	totalAmbientLight += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/lightmap_pars_fragment.glsl

	THREE.ShaderChunk[ 'lightmap_pars_fragment'] = "#ifdef USE_LIGHTMAP\n\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/lights_lambert_pars_vertex.glsl

	THREE.ShaderChunk[ 'lights_lambert_pars_vertex'] = "#if MAX_DIR_LIGHTS > 0\n\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDecay[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/lights_lambert_vertex.glsl

	THREE.ShaderChunk[ 'lights_lambert_vertex'] = "vLightFront = vec3( 0.0 );\n\n#ifdef DOUBLE_SIDED\n\n	vLightBack = vec3( 0.0 );\n\n#endif\n\nvec3 normal = normalize( transformedNormal );\n\n#if MAX_POINT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n		vec3 lightColor = pointLightColor[ i ];\n\n		vec3 lVector = pointLightPosition[ i ] - mvPosition.xyz;\n		vec3 lightDir = normalize( lVector );\n\n\n		float attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\n\n\n		float dotProduct = dot( normal, lightDir );\n\n		vLightFront += lightColor * attenuation * saturate( dotProduct );\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += lightColor * attenuation * saturate( - dotProduct );\n\n		#endif\n\n	}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n		vec3 lightColor = spotLightColor[ i ];\n\n		vec3 lightPosition = spotLightPosition[ i ];\n		vec3 lVector = lightPosition - mvPosition.xyz;\n		vec3 lightDir = normalize( lVector );\n\n		float spotEffect = dot( spotLightDirection[ i ], lightDir );\n\n		if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n			spotEffect = saturate( pow( saturate( spotEffect ), spotLightExponent[ i ] ) );\n\n\n			float attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\n\n			attenuation *= spotEffect;\n\n\n			float dotProduct = dot( normal, lightDir );\n\n			vLightFront += lightColor * attenuation * saturate( dotProduct );\n\n			#ifdef DOUBLE_SIDED\n\n				vLightBack += lightColor * attenuation * saturate( - dotProduct );\n\n			#endif\n\n		}\n\n	}\n\n#endif\n\n#if MAX_DIR_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n		vec3 lightColor = directionalLightColor[ i ];\n\n		vec3 lightDir = directionalLightDirection[ i ];\n\n\n		float dotProduct = dot( normal, lightDir );\n\n		vLightFront += lightColor * saturate( dotProduct );\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += lightColor * saturate( - dotProduct );\n\n		#endif\n\n	}\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n		vec3 lightDir = hemisphereLightDirection[ i ];\n\n\n		float dotProduct = dot( normal, lightDir );\n\n		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\n		vLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n		#ifdef DOUBLE_SIDED\n\n			float hemiDiffuseWeightBack = - 0.5 * dotProduct + 0.5;\n\n			vLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\n\n		#endif\n\n	}\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/lights_phong_fragment.glsl

	THREE.ShaderChunk[ 'lights_phong_fragment'] = "vec3 viewDir = normalize( vViewPosition );\n\nvec3 totalDiffuseLight = vec3( 0.0 );\nvec3 totalSpecularLight = vec3( 0.0 );\n\n#if MAX_POINT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n		vec3 lightColor = pointLightColor[ i ];\n\n		vec3 lightPosition = pointLightPosition[ i ];\n		vec3 lVector = lightPosition + vViewPosition.xyz;\n		vec3 lightDir = normalize( lVector );\n\n\n		float attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\n\n\n		float cosineTerm = saturate( dot( normal, lightDir ) );\n\n		totalDiffuseLight += lightColor * attenuation * cosineTerm;\n\n\n		vec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\n\n		totalSpecularLight += brdf * specularStrength * lightColor * attenuation * cosineTerm;\n\n\n	}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n		vec3 lightColor = spotLightColor[ i ];\n\n		vec3 lightPosition = spotLightPosition[ i ];\n		vec3 lVector = lightPosition + vViewPosition.xyz;\n		vec3 lightDir = normalize( lVector );\n\n		float spotEffect = dot( spotLightDirection[ i ], lightDir );\n\n		if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n			spotEffect = saturate( pow( saturate( spotEffect ), spotLightExponent[ i ] ) );\n\n\n			float attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\n\n			attenuation *= spotEffect;\n\n\n			float cosineTerm = saturate( dot( normal, lightDir ) );\n\n			totalDiffuseLight += lightColor * attenuation * cosineTerm;\n\n\n			vec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\n\n			totalSpecularLight += brdf * specularStrength * lightColor * attenuation * cosineTerm;\n\n		}\n\n	}\n\n#endif\n\n#if MAX_DIR_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n		vec3 lightColor = directionalLightColor[ i ];\n\n		vec3 lightDir = directionalLightDirection[ i ];\n\n\n		float cosineTerm = saturate( dot( normal, lightDir ) );\n\n		totalDiffuseLight += lightColor * cosineTerm;\n\n\n		vec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\n\n		totalSpecularLight += brdf * specularStrength * lightColor * cosineTerm;\n\n	}\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_fragment.glsl

	THREE.ShaderChunk[ 'lights_phong_pars_fragment'] = "uniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDecay[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_ENVMAP )\n\n	varying vec3 vWorldPosition;\n\n#endif\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n	varying vec3 vNormal;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_vertex.glsl

	THREE.ShaderChunk[ 'lights_phong_pars_vertex'] = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_ENVMAP )\n\n	varying vec3 vWorldPosition;\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/lights_phong_vertex.glsl

	THREE.ShaderChunk[ 'lights_phong_vertex'] = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_ENVMAP )\n\n	vWorldPosition = worldPosition.xyz;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/linear_to_gamma_fragment.glsl

	THREE.ShaderChunk[ 'linear_to_gamma_fragment'] = "\n	outgoingLight = linearToOutput( outgoingLight );\n";

	// File:src/renderers/shaders/ShaderChunk/logdepthbuf_fragment.glsl

	THREE.ShaderChunk[ 'logdepthbuf_fragment'] = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n	gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_fragment.glsl

	THREE.ShaderChunk[ 'logdepthbuf_pars_fragment'] = "#ifdef USE_LOGDEPTHBUF\n\n	uniform float logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		varying float vFragDepth;\n\n	#endif\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_vertex.glsl

	THREE.ShaderChunk[ 'logdepthbuf_pars_vertex'] = "#ifdef USE_LOGDEPTHBUF\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		varying float vFragDepth;\n\n	#endif\n\n	uniform float logDepthBufFC;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/logdepthbuf_vertex.glsl

	THREE.ShaderChunk[ 'logdepthbuf_vertex'] = "#ifdef USE_LOGDEPTHBUF\n\n	gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		vFragDepth = 1.0 + gl_Position.w;\n\n#else\n\n		gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n	#endif\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/map_fragment.glsl

	THREE.ShaderChunk[ 'map_fragment'] = "#ifdef USE_MAP\n\n	vec4 texelColor = texture2D( map, vUv );\n\n	texelColor.xyz = inputToLinear( texelColor.xyz );\n\n	diffuseColor *= texelColor;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/map_pars_fragment.glsl

	THREE.ShaderChunk[ 'map_pars_fragment'] = "#ifdef USE_MAP\n\n	uniform sampler2D map;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/map_particle_fragment.glsl

	THREE.ShaderChunk[ 'map_particle_fragment'] = "#ifdef USE_MAP\n\n	diffuseColor *= texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/map_particle_pars_fragment.glsl

	THREE.ShaderChunk[ 'map_particle_pars_fragment'] = "#ifdef USE_MAP\n\n	uniform vec4 offsetRepeat;\n	uniform sampler2D map;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/morphnormal_vertex.glsl

	THREE.ShaderChunk[ 'morphnormal_vertex'] = "#ifdef USE_MORPHNORMALS\n\n	objectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n	objectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n	objectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n	objectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/morphtarget_pars_vertex.glsl

	THREE.ShaderChunk[ 'morphtarget_pars_vertex'] = "#ifdef USE_MORPHTARGETS\n\n	#ifndef USE_MORPHNORMALS\n\n	uniform float morphTargetInfluences[ 8 ];\n\n	#else\n\n	uniform float morphTargetInfluences[ 4 ];\n\n	#endif\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/morphtarget_vertex.glsl

	THREE.ShaderChunk[ 'morphtarget_vertex'] = "#ifdef USE_MORPHTARGETS\n\n	transformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n	transformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n	transformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n	transformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\n	#ifndef USE_MORPHNORMALS\n\n	transformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n	transformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n	transformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n	transformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\n	#endif\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/normal_phong_fragment.glsl

	THREE.ShaderChunk[ 'normal_phong_fragment'] = "#ifndef FLAT_SHADED\n\n	vec3 normal = normalize( vNormal );\n\n	#ifdef DOUBLE_SIDED\n\n		normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n\n	#endif\n\n#else\n\n	vec3 fdx = dFdx( vViewPosition );\n	vec3 fdy = dFdy( vViewPosition );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n\n#endif\n\n#ifdef USE_NORMALMAP\n\n	normal = perturbNormal2Arb( -vViewPosition, normal );\n\n#elif defined( USE_BUMPMAP )\n\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n\n#endif\n\n";

	// File:src/renderers/shaders/ShaderChunk/normalmap_pars_fragment.glsl

	THREE.ShaderChunk[ 'normalmap_pars_fragment'] = "#ifdef USE_NORMALMAP\n\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n\n\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n\n		vec3 S = normalize( q0 * st1.t - q1 * st0.t );\n		vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n		vec3 N = normalize( surf_norm );\n\n		vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n		mapN.xy = normalScale * mapN.xy;\n		mat3 tsn = mat3( S, T, N );\n		return normalize( tsn * mapN );\n\n	}\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/project_vertex.glsl

	THREE.ShaderChunk[ 'project_vertex'] = "#ifdef USE_SKINNING\n\n	vec4 mvPosition = modelViewMatrix * skinned;\n\n#else\n\n	vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n\n#endif\n\ngl_Position = projectionMatrix * mvPosition;\n";

	// File:src/renderers/shaders/ShaderChunk/shadowmap_fragment.glsl

	THREE.ShaderChunk[ 'shadowmap_fragment'] = "#ifdef USE_SHADOWMAP\n\n	for ( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n		float texelSizeY =  1.0 / shadowMapSize[ i ].y;\n\n		float shadow = 0.0;\n\n#if defined( POINT_LIGHT_SHADOWS )\n\n		bool isPointLight = shadowDarkness[ i ] < 0.0;\n\n		if ( isPointLight ) {\n\n			float realShadowDarkness = abs( shadowDarkness[ i ] );\n\n			vec3 lightToPosition = vShadowCoord[ i ].xyz;\n\n	#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n			vec3 bd3D = normalize( lightToPosition );\n			float dp = length( lightToPosition );\n\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D, texelSizeY ) ), shadowBias[ i ], shadow );\n\n\n	#if defined( SHADOWMAP_TYPE_PCF )\n			const float Dr = 1.25;\n	#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			const float Dr = 2.25;\n	#endif\n\n			float os = Dr *  2.0 * texelSizeY;\n\n			const vec3 Gsd = vec3( - 1, 0, 1 );\n\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zzz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zxz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xxz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xzz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zzx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zxx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xxx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xzx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zzy * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zxy * os, texelSizeY ) ), shadowBias[ i ], shadow );\n\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xxy * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xzy * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zyz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xyz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zyx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xyx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.yzz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.yxz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.yxx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.yzx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n\n			shadow *= realShadowDarkness * ( 1.0 / 21.0 );\n\n	#else \n			vec3 bd3D = normalize( lightToPosition );\n			float dp = length( lightToPosition );\n\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D, texelSizeY ) ), shadowBias[ i ], shadow );\n\n			shadow *= realShadowDarkness;\n\n	#endif\n\n		} else {\n\n#endif \n			float texelSizeX =  1.0 / shadowMapSize[ i ].x;\n\n			vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\n\n\n			bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n			bool inFrustum = all( inFrustumVec );\n\n			bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n			bool frustumTest = all( frustumTestVec );\n\n			if ( frustumTest ) {\n\n	#if defined( SHADOWMAP_TYPE_PCF )\n\n\n				/*\n					for ( float y = -1.25; y <= 1.25; y += 1.25 )\n						for ( float x = -1.25; x <= 1.25; x += 1.25 ) {\n							vec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\n							float fDepth = unpackDepth( rgbaDepth );\n							if ( fDepth < shadowCoord.z )\n								shadow += 1.0;\n					}\n					shadow /= 9.0;\n				*/\n\n				shadowCoord.z += shadowBias[ i ];\n\n				const float ShadowDelta = 1.0 / 9.0;\n\n				float xPixelOffset = texelSizeX;\n				float yPixelOffset = texelSizeY;\n\n				float dx0 = - 1.25 * xPixelOffset;\n				float dy0 = - 1.25 * yPixelOffset;\n				float dx1 = 1.25 * xPixelOffset;\n				float dy1 = 1.25 * yPixelOffset;\n\n				float fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				shadow *= shadowDarkness[ i ];\n\n	#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n\n				shadowCoord.z += shadowBias[ i ];\n\n				float xPixelOffset = texelSizeX;\n				float yPixelOffset = texelSizeY;\n\n				float dx0 = - 1.0 * xPixelOffset;\n				float dy0 = - 1.0 * yPixelOffset;\n				float dx1 = 1.0 * xPixelOffset;\n				float dy1 = 1.0 * yPixelOffset;\n\n				mat3 shadowKernel;\n				mat3 depthKernel;\n\n				depthKernel[ 0 ][ 0 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n				depthKernel[ 0 ][ 1 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n				depthKernel[ 0 ][ 2 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n				depthKernel[ 1 ][ 0 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n				depthKernel[ 1 ][ 1 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n				depthKernel[ 1 ][ 2 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n				depthKernel[ 2 ][ 0 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n				depthKernel[ 2 ][ 1 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n				depthKernel[ 2 ][ 2 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n\n				vec3 shadowZ = vec3( shadowCoord.z );\n				shadowKernel[ 0 ] = vec3( lessThan( depthKernel[ 0 ], shadowZ ) );\n				shadowKernel[ 0 ] *= vec3( 0.25 );\n\n				shadowKernel[ 1 ] = vec3( lessThan( depthKernel[ 1 ], shadowZ ) );\n				shadowKernel[ 1 ] *= vec3( 0.25 );\n\n				shadowKernel[ 2 ] = vec3( lessThan( depthKernel[ 2 ], shadowZ ) );\n				shadowKernel[ 2 ] *= vec3( 0.25 );\n\n				vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[ i ].xy );\n\n				shadowKernel[ 0 ] = mix( shadowKernel[ 1 ], shadowKernel[ 0 ], fractionalCoord.x );\n				shadowKernel[ 1 ] = mix( shadowKernel[ 2 ], shadowKernel[ 1 ], fractionalCoord.x );\n\n				vec4 shadowValues;\n				shadowValues.x = mix( shadowKernel[ 0 ][ 1 ], shadowKernel[ 0 ][ 0 ], fractionalCoord.y );\n				shadowValues.y = mix( shadowKernel[ 0 ][ 2 ], shadowKernel[ 0 ][ 1 ], fractionalCoord.y );\n				shadowValues.z = mix( shadowKernel[ 1 ][ 1 ], shadowKernel[ 1 ][ 0 ], fractionalCoord.y );\n				shadowValues.w = mix( shadowKernel[ 1 ][ 2 ], shadowKernel[ 1 ][ 1 ], fractionalCoord.y );\n\n				shadow = dot( shadowValues, vec4( 1.0 ) ) * shadowDarkness[ i ];\n\n	#else \n				shadowCoord.z += shadowBias[ i ];\n\n				vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\n				float fDepth = unpackDepth( rgbaDepth );\n\n				if ( fDepth < shadowCoord.z )\n					shadow = shadowDarkness[ i ];\n\n	#endif\n\n			}\n\n#ifdef SHADOWMAP_DEBUG\n\n			if ( inFrustum ) {\n\n				if ( i == 0 ) {\n\n					outgoingLight *= vec3( 1.0, 0.5, 0.0 );\n\n				} else if ( i == 1 ) {\n\n					outgoingLight *= vec3( 0.0, 1.0, 0.8 );\n\n				} else {\n\n					outgoingLight *= vec3( 0.0, 0.5, 1.0 );\n\n				}\n\n			}\n\n#endif\n\n#if defined( POINT_LIGHT_SHADOWS )\n\n		}\n\n#endif\n\n		shadowMask = shadowMask * vec3( 1.0 - shadow );\n\n	}\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl

	THREE.ShaderChunk[ 'shadowmap_pars_fragment'] = "#ifdef USE_SHADOWMAP\n\n	uniform sampler2D shadowMap[ MAX_SHADOWS ];\n	uniform vec2 shadowMapSize[ MAX_SHADOWS ];\n\n	uniform float shadowDarkness[ MAX_SHADOWS ];\n	uniform float shadowBias[ MAX_SHADOWS ];\n\n	varying vec4 vShadowCoord[ MAX_SHADOWS ];\n\n	float unpackDepth( const in vec4 rgba_depth ) {\n\n		const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n		float depth = dot( rgba_depth, bit_shift );\n		return depth;\n\n	}\n\n	#if defined(POINT_LIGHT_SHADOWS)\n\n\n		void adjustShadowValue1K( const float testDepth, const vec4 textureData, const float bias, inout float shadowValue ) {\n\n			const vec4 bitSh = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n			if ( testDepth >= dot( textureData, bitSh ) * 1000.0 + bias )\n				shadowValue += 1.0;\n\n		}\n\n\n		vec2 cubeToUV( vec3 v, float texelSizeY ) {\n\n\n			vec3 absV = abs( v );\n\n\n			float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n			absV *= scaleToCube;\n\n\n			v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\n\n\n			vec2 planar = v.xy;\n\n			float almostATexel = 1.5 * texelSizeY;\n			float almostOne = 1.0 - almostATexel;\n\n			if ( absV.z >= almostOne ) {\n\n				if ( v.z > 0.0 )\n					planar.x = 4.0 - v.x;\n\n			} else if ( absV.x >= almostOne ) {\n\n				float signX = sign( v.x );\n				planar.x = v.z * signX + 2.0 * signX;\n\n			} else if ( absV.y >= almostOne ) {\n\n				float signY = sign( v.y );\n				planar.x = v.x + 2.0 * signY + 2.0;\n				planar.y = v.z * signY - 2.0;\n\n			}\n\n\n			return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\n		}\n\n	#endif\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_vertex.glsl

	THREE.ShaderChunk[ 'shadowmap_pars_vertex'] = "#ifdef USE_SHADOWMAP\n\n	uniform float shadowDarkness[ MAX_SHADOWS ];\n	uniform mat4 shadowMatrix[ MAX_SHADOWS ];\n	varying vec4 vShadowCoord[ MAX_SHADOWS ];\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/shadowmap_vertex.glsl

	THREE.ShaderChunk[ 'shadowmap_vertex'] = "#ifdef USE_SHADOWMAP\n\n	for ( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n			vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n\n	}\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/skinbase_vertex.glsl

	THREE.ShaderChunk[ 'skinbase_vertex'] = "#ifdef USE_SKINNING\n\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/skinning_pars_vertex.glsl

	THREE.ShaderChunk[ 'skinning_pars_vertex'] = "#ifdef USE_SKINNING\n\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n\n	#ifdef BONE_TEXTURE\n\n		uniform sampler2D boneTexture;\n		uniform int boneTextureWidth;\n		uniform int boneTextureHeight;\n\n		mat4 getBoneMatrix( const in float i ) {\n\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureWidth ) );\n			float y = floor( j / float( boneTextureWidth ) );\n\n			float dx = 1.0 / float( boneTextureWidth );\n			float dy = 1.0 / float( boneTextureHeight );\n\n			y = dy * ( y + 0.5 );\n\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n			mat4 bone = mat4( v1, v2, v3, v4 );\n\n			return bone;\n\n		}\n\n	#else\n\n		uniform mat4 boneGlobalMatrices[ MAX_BONES ];\n\n		mat4 getBoneMatrix( const in float i ) {\n\n			mat4 bone = boneGlobalMatrices[ int(i) ];\n			return bone;\n\n		}\n\n	#endif\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/skinning_vertex.glsl

	THREE.ShaderChunk[ 'skinning_vertex'] = "#ifdef USE_SKINNING\n\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	skinned  = bindMatrixInverse * skinned;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/skinnormal_vertex.glsl

	THREE.ShaderChunk[ 'skinnormal_vertex'] = "#ifdef USE_SKINNING\n\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/specularmap_fragment.glsl

	THREE.ShaderChunk[ 'specularmap_fragment'] = "float specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n\n#else\n\n	specularStrength = 1.0;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/specularmap_pars_fragment.glsl

	THREE.ShaderChunk[ 'specularmap_pars_fragment'] = "#ifdef USE_SPECULARMAP\n\n	uniform sampler2D specularMap;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/uv2_pars_fragment.glsl

	THREE.ShaderChunk[ 'uv2_pars_fragment'] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n	varying vec2 vUv2;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/uv2_pars_vertex.glsl

	THREE.ShaderChunk[ 'uv2_pars_vertex'] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/uv2_vertex.glsl

	THREE.ShaderChunk[ 'uv2_vertex'] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n	vUv2 = uv2;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/uv_pars_fragment.glsl

	THREE.ShaderChunk[ 'uv_pars_fragment'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP )\n\n	varying vec2 vUv;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/uv_pars_vertex.glsl

	THREE.ShaderChunk[ 'uv_pars_vertex'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP )\n\n	varying vec2 vUv;\n	uniform vec4 offsetRepeat;\n\n#endif\n";

	// File:src/renderers/shaders/ShaderChunk/uv_vertex.glsl

	THREE.ShaderChunk[ 'uv_vertex'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP )\n\n	vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n\n#endif";

	// File:src/renderers/shaders/ShaderChunk/worldpos_vertex.glsl

	THREE.ShaderChunk[ 'worldpos_vertex'] = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\n	#ifdef USE_SKINNING\n\n		vec4 worldPosition = modelMatrix * skinned;\n\n	#else\n\n		vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\n	#endif\n\n#endif\n";

	// File:src/renderers/shaders/UniformsUtils.js

	/**
	 * Uniform Utilities
	 */

	THREE.UniformsUtils = {

		merge: function ( uniforms ) {

			var merged = {};

			for ( var u = 0; u < uniforms.length; u ++ ) {

				var tmp = this.clone( uniforms[ u ] );

				for ( var p in tmp ) {

					merged[ p ] = tmp[ p ];

				}

			}

			return merged;

		},

		clone: function ( uniforms_src ) {

			var uniforms_dst = {};

			for ( var u in uniforms_src ) {

				uniforms_dst[ u ] = {};

				for ( var p in uniforms_src[ u ] ) {

					var parameter_src = uniforms_src[ u ][ p ];

					if ( parameter_src instanceof THREE.Color ||
						 parameter_src instanceof THREE.Vector2 ||
						 parameter_src instanceof THREE.Vector3 ||
						 parameter_src instanceof THREE.Vector4 ||
						 parameter_src instanceof THREE.Matrix3 ||
						 parameter_src instanceof THREE.Matrix4 ||
						 parameter_src instanceof THREE.Texture ) {

						uniforms_dst[ u ][ p ] = parameter_src.clone();

					} else if ( Array.isArray( parameter_src ) ) {

						uniforms_dst[ u ][ p ] = parameter_src.slice();

					} else {

						uniforms_dst[ u ][ p ] = parameter_src;

					}

				}

			}

			return uniforms_dst;

		}

	};

	// File:src/renderers/shaders/UniformsLib.js

	/**
	 * Uniforms library for shared webgl shaders
	 */

	THREE.UniformsLib = {

		common: {

			"diffuse" : { type: "c", value: new THREE.Color( 0xeeeeee ) },
			"opacity" : { type: "f", value: 1.0 },

			"map" : { type: "t", value: null },
			"offsetRepeat" : { type: "v4", value: new THREE.Vector4( 0, 0, 1, 1 ) },

			"specularMap" : { type: "t", value: null },
			"alphaMap" : { type: "t", value: null },

			"envMap" : { type: "t", value: null },
			"flipEnvMap" : { type: "f", value: - 1 },
			"reflectivity" : { type: "f", value: 1.0 },
			"refractionRatio" : { type: "f", value: 0.98 }

		},

		aomap: {

			"aoMap" : { type: "t", value: null },
			"aoMapIntensity" : { type: "f", value: 1 },

		},

		lightmap: {

			"lightMap" : { type: "t", value: null },
			"lightMapIntensity" : { type: "f", value: 1 },

		},

		emissivemap: {

			"emissiveMap" : { type: "t", value: null },

		},

		bumpmap: {

			"bumpMap" : { type: "t", value: null },
			"bumpScale" : { type: "f", value: 1 }

		},

		normalmap: {

			"normalMap" : { type: "t", value: null },
			"normalScale" : { type: "v2", value: new THREE.Vector2( 1, 1 ) }

		},

		displacementmap: {

			"displacementMap" : { type: "t", value: null },
			"displacementScale" : { type: "f", value: 1 },
			"displacementBias" : { type: "f", value: 0 }

		},

		fog : {

			"fogDensity" : { type: "f", value: 0.00025 },
			"fogNear" : { type: "f", value: 1 },
			"fogFar" : { type: "f", value: 2000 },
			"fogColor" : { type: "c", value: new THREE.Color( 0xffffff ) }

		},

		lights: {

			"ambientLightColor" : { type: "fv", value: [] },

			"directionalLightDirection" : { type: "fv", value: [] },
			"directionalLightColor" : { type: "fv", value: [] },

			"hemisphereLightDirection" : { type: "fv", value: [] },
			"hemisphereLightSkyColor" : { type: "fv", value: [] },
			"hemisphereLightGroundColor" : { type: "fv", value: [] },

			"pointLightColor" : { type: "fv", value: [] },
			"pointLightPosition" : { type: "fv", value: [] },
			"pointLightDistance" : { type: "fv1", value: [] },
			"pointLightDecay" : { type: "fv1", value: [] },

			"spotLightColor" : { type: "fv", value: [] },
			"spotLightPosition" : { type: "fv", value: [] },
			"spotLightDirection" : { type: "fv", value: [] },
			"spotLightDistance" : { type: "fv1", value: [] },
			"spotLightAngleCos" : { type: "fv1", value: [] },
			"spotLightExponent" : { type: "fv1", value: [] },
			"spotLightDecay" : { type: "fv1", value: [] }

		},

		points: {

			"psColor" : { type: "c", value: new THREE.Color( 0xeeeeee ) },
			"opacity" : { type: "f", value: 1.0 },
			"size" : { type: "f", value: 1.0 },
			"scale" : { type: "f", value: 1.0 },
			"map" : { type: "t", value: null },
			"offsetRepeat" : { type: "v4", value: new THREE.Vector4( 0, 0, 1, 1 ) },

			"fogDensity" : { type: "f", value: 0.00025 },
			"fogNear" : { type: "f", value: 1 },
			"fogFar" : { type: "f", value: 2000 },
			"fogColor" : { type: "c", value: new THREE.Color( 0xffffff ) }

		},

		shadowmap: {

			"shadowMap": { type: "tv", value: [] },
			"shadowMapSize": { type: "v2v", value: [] },

			"shadowBias" : { type: "fv1", value: [] },
			"shadowDarkness": { type: "fv1", value: [] },

			"shadowMatrix" : { type: "m4v", value: [] }

		}

	};

	// File:src/renderers/shaders/ShaderLib.js

	/**
	 * Webgl Shader Library for three.js
	 *
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 */


	THREE.ShaderLib = {

		'basic': {

			uniforms: THREE.UniformsUtils.merge( [

				THREE.UniformsLib[ "common" ],
				THREE.UniformsLib[ "aomap" ],
				THREE.UniformsLib[ "fog" ],
				THREE.UniformsLib[ "shadowmap" ]

			] ),

			vertexShader: [

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "uv_pars_vertex" ],
				THREE.ShaderChunk[ "uv2_pars_vertex" ],
				THREE.ShaderChunk[ "envmap_pars_vertex" ],
				THREE.ShaderChunk[ "color_pars_vertex" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "skinning_pars_vertex" ],
				THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

				"void main() {",

					THREE.ShaderChunk[ "uv_vertex" ],
					THREE.ShaderChunk[ "uv2_vertex" ],
					THREE.ShaderChunk[ "color_vertex" ],
					THREE.ShaderChunk[ "skinbase_vertex" ],

				"	#ifdef USE_ENVMAP",

					THREE.ShaderChunk[ "beginnormal_vertex" ],
					THREE.ShaderChunk[ "morphnormal_vertex" ],
					THREE.ShaderChunk[ "skinnormal_vertex" ],
					THREE.ShaderChunk[ "defaultnormal_vertex" ],

				"	#endif",

					THREE.ShaderChunk[ "begin_vertex" ],
					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "skinning_vertex" ],
					THREE.ShaderChunk[ "project_vertex" ],
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],

					THREE.ShaderChunk[ "worldpos_vertex" ],
					THREE.ShaderChunk[ "envmap_vertex" ],
					THREE.ShaderChunk[ "shadowmap_vertex" ],

				"}"

			].join( "\n" ),

			fragmentShader: [

				"uniform vec3 diffuse;",
				"uniform float opacity;",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "color_pars_fragment" ],
				THREE.ShaderChunk[ "uv_pars_fragment" ],
				THREE.ShaderChunk[ "uv2_pars_fragment" ],
				THREE.ShaderChunk[ "map_pars_fragment" ],
				THREE.ShaderChunk[ "alphamap_pars_fragment" ],
				THREE.ShaderChunk[ "aomap_pars_fragment" ],
				THREE.ShaderChunk[ "envmap_pars_fragment" ],
				THREE.ShaderChunk[ "fog_pars_fragment" ],
				THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
				THREE.ShaderChunk[ "specularmap_pars_fragment" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

				"void main() {",

				"	vec3 outgoingLight = vec3( 0.0 );",
				"	vec4 diffuseColor = vec4( diffuse, opacity );",
				"	vec3 totalAmbientLight = vec3( 1.0 );", // hardwired
				"	vec3 shadowMask = vec3( 1.0 );",

					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
					THREE.ShaderChunk[ "map_fragment" ],
					THREE.ShaderChunk[ "color_fragment" ],
					THREE.ShaderChunk[ "alphamap_fragment" ],
					THREE.ShaderChunk[ "alphatest_fragment" ],
					THREE.ShaderChunk[ "specularmap_fragment" ],
					THREE.ShaderChunk[ "aomap_fragment" ],
					THREE.ShaderChunk[ "shadowmap_fragment" ],

				"	outgoingLight = diffuseColor.rgb * totalAmbientLight * shadowMask;",

					THREE.ShaderChunk[ "envmap_fragment" ],

					THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

					THREE.ShaderChunk[ "fog_fragment" ],

				"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

				"}"

			].join( "\n" )

		},

		'lambert': {

			uniforms: THREE.UniformsUtils.merge( [

				THREE.UniformsLib[ "common" ],
				THREE.UniformsLib[ "fog" ],
				THREE.UniformsLib[ "lights" ],
				THREE.UniformsLib[ "shadowmap" ],

				{
					"emissive" : { type: "c", value: new THREE.Color( 0x000000 ) }
				}

			] ),

			vertexShader: [

				"#define LAMBERT",

				"varying vec3 vLightFront;",

				"#ifdef DOUBLE_SIDED",

				"	varying vec3 vLightBack;",

				"#endif",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "uv_pars_vertex" ],
				THREE.ShaderChunk[ "uv2_pars_vertex" ],
				THREE.ShaderChunk[ "envmap_pars_vertex" ],
				THREE.ShaderChunk[ "lights_lambert_pars_vertex" ],
				THREE.ShaderChunk[ "color_pars_vertex" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "skinning_pars_vertex" ],
				THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

				"void main() {",

					THREE.ShaderChunk[ "uv_vertex" ],
					THREE.ShaderChunk[ "uv2_vertex" ],
					THREE.ShaderChunk[ "color_vertex" ],

					THREE.ShaderChunk[ "beginnormal_vertex" ],
					THREE.ShaderChunk[ "morphnormal_vertex" ],
					THREE.ShaderChunk[ "skinbase_vertex" ],
					THREE.ShaderChunk[ "skinnormal_vertex" ],
					THREE.ShaderChunk[ "defaultnormal_vertex" ],

					THREE.ShaderChunk[ "begin_vertex" ],
					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "skinning_vertex" ],
					THREE.ShaderChunk[ "project_vertex" ],
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],

					THREE.ShaderChunk[ "worldpos_vertex" ],
					THREE.ShaderChunk[ "envmap_vertex" ],
					THREE.ShaderChunk[ "lights_lambert_vertex" ],
					THREE.ShaderChunk[ "shadowmap_vertex" ],

				"}"

			].join( "\n" ),

			fragmentShader: [

				"uniform vec3 diffuse;",
				"uniform vec3 emissive;",
				"uniform float opacity;",

				"uniform vec3 ambientLightColor;",

				"varying vec3 vLightFront;",

				"#ifdef DOUBLE_SIDED",

				"	varying vec3 vLightBack;",

				"#endif",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "color_pars_fragment" ],
				THREE.ShaderChunk[ "uv_pars_fragment" ],
				THREE.ShaderChunk[ "uv2_pars_fragment" ],
				THREE.ShaderChunk[ "map_pars_fragment" ],
				THREE.ShaderChunk[ "alphamap_pars_fragment" ],
				THREE.ShaderChunk[ "envmap_pars_fragment" ],
				THREE.ShaderChunk[ "fog_pars_fragment" ],
				THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
				THREE.ShaderChunk[ "specularmap_pars_fragment" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

				"void main() {",

				"	vec3 outgoingLight = vec3( 0.0 );",	// outgoing light does not have an alpha, the surface does
				"	vec4 diffuseColor = vec4( diffuse, opacity );",
				"	vec3 totalAmbientLight = ambientLightColor;",
				"	vec3 shadowMask = vec3( 1.0 );",

					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
					THREE.ShaderChunk[ "map_fragment" ],
					THREE.ShaderChunk[ "color_fragment" ],
					THREE.ShaderChunk[ "alphamap_fragment" ],
					THREE.ShaderChunk[ "alphatest_fragment" ],
					THREE.ShaderChunk[ "specularmap_fragment" ],
					THREE.ShaderChunk[ "shadowmap_fragment" ],

				"	#ifdef DOUBLE_SIDED",

				"		if ( gl_FrontFacing )",
				"			outgoingLight += diffuseColor.rgb * ( vLightFront * shadowMask + totalAmbientLight ) + emissive;",
				"		else",
				"			outgoingLight += diffuseColor.rgb * ( vLightBack * shadowMask + totalAmbientLight ) + emissive;",

				"	#else",

				"		outgoingLight += diffuseColor.rgb * ( vLightFront * shadowMask + totalAmbientLight ) + emissive;",

				"	#endif",

					THREE.ShaderChunk[ "envmap_fragment" ],

					THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

					THREE.ShaderChunk[ "fog_fragment" ],

				"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

				"}"

			].join( "\n" )

		},

		'phong': {

			uniforms: THREE.UniformsUtils.merge( [

				THREE.UniformsLib[ "common" ],
				THREE.UniformsLib[ "aomap" ],
				THREE.UniformsLib[ "lightmap" ],
				THREE.UniformsLib[ "emissivemap" ],
				THREE.UniformsLib[ "bumpmap" ],
				THREE.UniformsLib[ "normalmap" ],
				THREE.UniformsLib[ "displacementmap" ],
				THREE.UniformsLib[ "fog" ],
				THREE.UniformsLib[ "lights" ],
				THREE.UniformsLib[ "shadowmap" ],

				{
					"emissive" : { type: "c", value: new THREE.Color( 0x000000 ) },
					"specular" : { type: "c", value: new THREE.Color( 0x111111 ) },
					"shininess": { type: "f", value: 30 }
				}

			] ),

			vertexShader: [

				"#define PHONG",

				"varying vec3 vViewPosition;",

				"#ifndef FLAT_SHADED",

				"	varying vec3 vNormal;",

				"#endif",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "uv_pars_vertex" ],
				THREE.ShaderChunk[ "uv2_pars_vertex" ],
				THREE.ShaderChunk[ "displacementmap_pars_vertex" ],
				THREE.ShaderChunk[ "envmap_pars_vertex" ],
				THREE.ShaderChunk[ "lights_phong_pars_vertex" ],
				THREE.ShaderChunk[ "color_pars_vertex" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "skinning_pars_vertex" ],
				THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

				"void main() {",

					THREE.ShaderChunk[ "uv_vertex" ],
					THREE.ShaderChunk[ "uv2_vertex" ],
					THREE.ShaderChunk[ "color_vertex" ],

					THREE.ShaderChunk[ "beginnormal_vertex" ],
					THREE.ShaderChunk[ "morphnormal_vertex" ],
					THREE.ShaderChunk[ "skinbase_vertex" ],
					THREE.ShaderChunk[ "skinnormal_vertex" ],
					THREE.ShaderChunk[ "defaultnormal_vertex" ],

				"#ifndef FLAT_SHADED", // Normal computed with derivatives when FLAT_SHADED

				"	vNormal = normalize( transformedNormal );",

				"#endif",

					THREE.ShaderChunk[ "begin_vertex" ],
					THREE.ShaderChunk[ "displacementmap_vertex" ],
					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "skinning_vertex" ],
					THREE.ShaderChunk[ "project_vertex" ],
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],

				"	vViewPosition = - mvPosition.xyz;",

					THREE.ShaderChunk[ "worldpos_vertex" ],
					THREE.ShaderChunk[ "envmap_vertex" ],
					THREE.ShaderChunk[ "lights_phong_vertex" ],
					THREE.ShaderChunk[ "shadowmap_vertex" ],

				"}"

			].join( "\n" ),

			fragmentShader: [

				"#define PHONG",

				"uniform vec3 diffuse;",
				"uniform vec3 emissive;",
				"uniform vec3 specular;",
				"uniform float shininess;",
				"uniform float opacity;",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "color_pars_fragment" ],
				THREE.ShaderChunk[ "uv_pars_fragment" ],
				THREE.ShaderChunk[ "uv2_pars_fragment" ],
				THREE.ShaderChunk[ "map_pars_fragment" ],
				THREE.ShaderChunk[ "alphamap_pars_fragment" ],
				THREE.ShaderChunk[ "aomap_pars_fragment" ],
				THREE.ShaderChunk[ "lightmap_pars_fragment" ],
				THREE.ShaderChunk[ "emissivemap_pars_fragment" ],
				THREE.ShaderChunk[ "envmap_pars_fragment" ],
				THREE.ShaderChunk[ "fog_pars_fragment" ],
				THREE.ShaderChunk[ "lights_phong_pars_fragment" ],
				THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
				THREE.ShaderChunk[ "bumpmap_pars_fragment" ],
				THREE.ShaderChunk[ "normalmap_pars_fragment" ],
				THREE.ShaderChunk[ "specularmap_pars_fragment" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

				"void main() {",

				"	vec3 outgoingLight = vec3( 0.0 );",
				"	vec4 diffuseColor = vec4( diffuse, opacity );",
				"	vec3 totalAmbientLight = ambientLightColor;",
				"	vec3 totalEmissiveLight = emissive;",
				"	vec3 shadowMask = vec3( 1.0 );",

					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
					THREE.ShaderChunk[ "map_fragment" ],
					THREE.ShaderChunk[ "color_fragment" ],
					THREE.ShaderChunk[ "alphamap_fragment" ],
					THREE.ShaderChunk[ "alphatest_fragment" ],
					THREE.ShaderChunk[ "specularmap_fragment" ],
					THREE.ShaderChunk[ "normal_phong_fragment" ],
					THREE.ShaderChunk[ "lightmap_fragment" ],
					THREE.ShaderChunk[ "hemilight_fragment" ],
					THREE.ShaderChunk[ "aomap_fragment" ],
					THREE.ShaderChunk[ "emissivemap_fragment" ],

					THREE.ShaderChunk[ "lights_phong_fragment" ],
					THREE.ShaderChunk[ "shadowmap_fragment" ],

					"totalDiffuseLight *= shadowMask;",
					"totalSpecularLight *= shadowMask;",

					"#ifdef METAL",

					"	outgoingLight += diffuseColor.rgb * ( totalDiffuseLight + totalAmbientLight ) * specular + totalSpecularLight + totalEmissiveLight;",

					"#else",

					"	outgoingLight += diffuseColor.rgb * ( totalDiffuseLight + totalAmbientLight ) + totalSpecularLight + totalEmissiveLight;",

					"#endif",

					THREE.ShaderChunk[ "envmap_fragment" ],

					THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

					THREE.ShaderChunk[ "fog_fragment" ],

				"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

				"}"

			].join( "\n" )

		},

		'points': {

			uniforms: THREE.UniformsUtils.merge( [

				THREE.UniformsLib[ "points" ],
				THREE.UniformsLib[ "shadowmap" ]

			] ),

			vertexShader: [

				"uniform float size;",
				"uniform float scale;",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "color_pars_vertex" ],
				THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

				"void main() {",

					THREE.ShaderChunk[ "color_vertex" ],

				"	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",

				"	#ifdef USE_SIZEATTENUATION",
				"		gl_PointSize = size * ( scale / length( mvPosition.xyz ) );",
				"	#else",
				"		gl_PointSize = size;",
				"	#endif",

				"	gl_Position = projectionMatrix * mvPosition;",

					THREE.ShaderChunk[ "logdepthbuf_vertex" ],
					THREE.ShaderChunk[ "worldpos_vertex" ],
					THREE.ShaderChunk[ "shadowmap_vertex" ],

				"}"

			].join( "\n" ),

			fragmentShader: [

				"uniform vec3 psColor;",
				"uniform float opacity;",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "color_pars_fragment" ],
				THREE.ShaderChunk[ "map_particle_pars_fragment" ],
				THREE.ShaderChunk[ "fog_pars_fragment" ],
				THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

				"void main() {",

				"	vec3 outgoingLight = vec3( 0.0 );",
				"	vec4 diffuseColor = vec4( psColor, opacity );",
				"	vec3 shadowMask = vec3( 1.0 );",

					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
					THREE.ShaderChunk[ "map_particle_fragment" ],
					THREE.ShaderChunk[ "color_fragment" ],
					THREE.ShaderChunk[ "alphatest_fragment" ],
					THREE.ShaderChunk[ "shadowmap_fragment" ],

				"	outgoingLight = diffuseColor.rgb * shadowMask;",

					THREE.ShaderChunk[ "fog_fragment" ],

				"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

				"}"

			].join( "\n" )

		},

		'dashed': {

			uniforms: THREE.UniformsUtils.merge( [

				THREE.UniformsLib[ "common" ],
				THREE.UniformsLib[ "fog" ],

				{
					"scale"    : { type: "f", value: 1 },
					"dashSize" : { type: "f", value: 1 },
					"totalSize": { type: "f", value: 2 }
				}

			] ),

			vertexShader: [

				"uniform float scale;",
				"attribute float lineDistance;",

				"varying float vLineDistance;",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "color_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

				"void main() {",

					THREE.ShaderChunk[ "color_vertex" ],

				"	vLineDistance = scale * lineDistance;",

				"	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
				"	gl_Position = projectionMatrix * mvPosition;",

					THREE.ShaderChunk[ "logdepthbuf_vertex" ],

				"}"

			].join( "\n" ),

			fragmentShader: [

				"uniform vec3 diffuse;",
				"uniform float opacity;",

				"uniform float dashSize;",
				"uniform float totalSize;",

				"varying float vLineDistance;",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "color_pars_fragment" ],
				THREE.ShaderChunk[ "fog_pars_fragment" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

				"void main() {",

				"	if ( mod( vLineDistance, totalSize ) > dashSize ) {",

				"		discard;",

				"	}",

				"	vec3 outgoingLight = vec3( 0.0 );",
				"	vec4 diffuseColor = vec4( diffuse, opacity );",

					THREE.ShaderChunk[ "logdepthbuf_fragment" ],
					THREE.ShaderChunk[ "color_fragment" ],

				"	outgoingLight = diffuseColor.rgb;", // simple shader

					THREE.ShaderChunk[ "fog_fragment" ],

				"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

				"}"

			].join( "\n" )

		},

		'depth': {

			uniforms: {

				"mNear": { type: "f", value: 1.0 },
				"mFar" : { type: "f", value: 2000.0 },
				"opacity" : { type: "f", value: 1.0 }

			},

			vertexShader: [

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

				"void main() {",

					THREE.ShaderChunk[ "begin_vertex" ],
					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "project_vertex" ],
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],

				"}"

			].join( "\n" ),

			fragmentShader: [

				"uniform float mNear;",
				"uniform float mFar;",
				"uniform float opacity;",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

				"void main() {",

					THREE.ShaderChunk[ "logdepthbuf_fragment" ],

				"	#ifdef USE_LOGDEPTHBUF_EXT",

				"		float depth = gl_FragDepthEXT / gl_FragCoord.w;",

				"	#else",

				"		float depth = gl_FragCoord.z / gl_FragCoord.w;",

				"	#endif",

				"	float color = 1.0 - smoothstep( mNear, mFar, depth );",
				"	gl_FragColor = vec4( vec3( color ), opacity );",

				"}"

			].join( "\n" )

		},

		'normal': {

			uniforms: {

				"opacity" : { type: "f", value: 1.0 }

			},

			vertexShader: [

				"varying vec3 vNormal;",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

				"void main() {",

				"	vNormal = normalize( normalMatrix * normal );",

					THREE.ShaderChunk[ "begin_vertex" ],
					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "project_vertex" ],
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],

				"}"

			].join( "\n" ),

			fragmentShader: [

				"uniform float opacity;",
				"varying vec3 vNormal;",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

				"void main() {",

				"	gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );",

					THREE.ShaderChunk[ "logdepthbuf_fragment" ],

				"}"

			].join( "\n" )

		},

		/* -------------------------------------------------------------------------
		//	Cube map shader
		 ------------------------------------------------------------------------- */

		'cube': {

			uniforms: { "tCube": { type: "t", value: null },
						"tFlip": { type: "f", value: - 1 } },

			vertexShader: [

				"varying vec3 vWorldPosition;",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

				"void main() {",

				"	vWorldPosition = transformDirection( position, modelMatrix );",

				"	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

					THREE.ShaderChunk[ "logdepthbuf_vertex" ],

				"}"

			].join( "\n" ),

			fragmentShader: [

				"uniform samplerCube tCube;",
				"uniform float tFlip;",

				"varying vec3 vWorldPosition;",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

				"void main() {",

				"	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",

					THREE.ShaderChunk[ "logdepthbuf_fragment" ],

				"}"

			].join( "\n" )

		},

		/* -------------------------------------------------------------------------
		//	Cube map shader
		 ------------------------------------------------------------------------- */

		'equirect': {

			uniforms: { "tEquirect": { type: "t", value: null },
						"tFlip": { type: "f", value: - 1 } },

			vertexShader: [

				"varying vec3 vWorldPosition;",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

				"void main() {",

				"	vWorldPosition = transformDirection( position, modelMatrix );",

				"	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

					THREE.ShaderChunk[ "logdepthbuf_vertex" ],

				"}"

			].join( "\n" ),

			fragmentShader: [

				"uniform sampler2D tEquirect;",
				"uniform float tFlip;",

				"varying vec3 vWorldPosition;",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

				"void main() {",

					// "	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",
					"vec3 direction = normalize( vWorldPosition );",
					"vec2 sampleUV;",
					"sampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );",
					"sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;",
					"gl_FragColor = texture2D( tEquirect, sampleUV );",

					THREE.ShaderChunk[ "logdepthbuf_fragment" ],

				"}"

			].join( "\n" )

		},

		/* Depth encoding into RGBA texture
		 *
		 * based on SpiderGL shadow map example
		 * http://spidergl.org/example.php?id=6
		 *
		 * originally from
		 * http://www.gamedev.net/topic/442138-packing-a-float-into-a-a8r8g8b8-texture-shader/page__whichpage__1%25EF%25BF%25BD
		 *
		 * see also
		 * http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/
		 */

		'depthRGBA': {

			uniforms: {},

			vertexShader: [

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "skinning_pars_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

				"void main() {",

					THREE.ShaderChunk[ "skinbase_vertex" ],

					THREE.ShaderChunk[ "begin_vertex" ],
					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "skinning_vertex" ],
					THREE.ShaderChunk[ "project_vertex" ],
					THREE.ShaderChunk[ "logdepthbuf_vertex" ],

				"}"

			].join( "\n" ),

			fragmentShader: [

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

				"vec4 pack_depth( const in float depth ) {",

				"	const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );",
				"	const vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );",
				"	vec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );", // "	vec4 res = fract( depth * bit_shift );",
				"	res -= res.xxyz * bit_mask;",
				"	return res;",

				"}",

				"void main() {",

					THREE.ShaderChunk[ "logdepthbuf_fragment" ],

				"	#ifdef USE_LOGDEPTHBUF_EXT",

				"		gl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );",

				"	#else",

				"		gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );",

				"	#endif",

					//"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z / gl_FragCoord.w );",
					//"float z = ( ( gl_FragCoord.z / gl_FragCoord.w ) - 3.0 ) / ( 4000.0 - 3.0 );",
					//"gl_FragData[ 0 ] = pack_depth( z );",
					//"gl_FragData[ 0 ] = vec4( z, z, z, 1.0 );",

				"}"

			].join( "\n" )

		},


		'distanceRGBA': {

			uniforms: {

				"lightPos": { type: "v3", value: new THREE.Vector3( 0, 0, 0 ) }

			},

			vertexShader: [

				"varying vec4 vWorldPosition;",

				THREE.ShaderChunk[ "common" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "skinning_pars_vertex" ],

				"void main() {",

					THREE.ShaderChunk[ "skinbase_vertex" ],
					THREE.ShaderChunk[ "begin_vertex" ],
					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "skinning_vertex" ],
					THREE.ShaderChunk[ "project_vertex" ],
					THREE.ShaderChunk[ "worldpos_vertex" ],

					"vWorldPosition = worldPosition;",

				"}"

			].join( "\n" ),

			fragmentShader: [

				"uniform vec3 lightPos;",
				"varying vec4 vWorldPosition;",

				THREE.ShaderChunk[ "common" ],

				"vec4 pack1K ( float depth ) {",

				"   depth /= 1000.0;",
				"   const vec4 bitSh = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );",
	  			"	const vec4 bitMsk = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );",
	   			"	vec4 res = fract( depth * bitSh );",
	   			"	res -= res.xxyz * bitMsk;",
	   			"	return res; ",

				"}",

				"float unpack1K ( vec4 color ) {",

				"	const vec4 bitSh = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );",
				"	return dot( color, bitSh ) * 1000.0;",

				"}",

				"void main () {",

				"	gl_FragColor = pack1K( length( vWorldPosition.xyz - lightPos.xyz ) );",

				"}"

			].join( "\n" )

		}

	};

	// File:src/renderers/WebGLRenderer.js

	/**
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author szimek / https://github.com/szimek/
	 */

	THREE.WebGLRenderer = function ( parameters ) {

		console.log( 'THREE.WebGLRenderer', THREE.REVISION );

		parameters = parameters || {};

		var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement( 'canvas' ),
		_context = parameters.context !== undefined ? parameters.context : null,

		_width = _canvas.width,
		_height = _canvas.height,

		pixelRatio = 1,

		_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
		_depth = parameters.depth !== undefined ? parameters.depth : true,
		_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
		_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
		_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
		_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,

		_clearColor = new THREE.Color( 0x000000 ),
		_clearAlpha = 0;

		var lights = [];

		var opaqueObjects = [];
		var opaqueObjectsLastIndex = - 1;
		var transparentObjects = [];
		var transparentObjectsLastIndex = - 1;

		var morphInfluences = new Float32Array( 8 );


		var sprites = [];
		var lensFlares = [];

		// public properties

		this.domElement = _canvas;
		this.context = null;

		// clearing

		this.autoClear = true;
		this.autoClearColor = true;
		this.autoClearDepth = true;
		this.autoClearStencil = true;

		// scene graph

		this.sortObjects = true;

		// physically based shading

		this.gammaFactor = 2.0;	// for backwards compatibility
		this.gammaInput = false;
		this.gammaOutput = false;

		// morphs

		this.maxMorphTargets = 8;
		this.maxMorphNormals = 4;

		// flags

		this.autoScaleCubemaps = true;

		// internal properties

		var _this = this,

		// internal state cache

		_currentProgram = null,
		_currentFramebuffer = null,
		_currentMaterialId = - 1,
		_currentGeometryProgram = '',
		_currentCamera = null,

		_usedTextureUnits = 0,

		_viewportX = 0,
		_viewportY = 0,
		_viewportWidth = _canvas.width,
		_viewportHeight = _canvas.height,
		_currentWidth = 0,
		_currentHeight = 0,

		// frustum

		_frustum = new THREE.Frustum(),

		 // camera matrices cache

		_projScreenMatrix = new THREE.Matrix4(),

		_vector3 = new THREE.Vector3(),

		// light arrays cache

		_direction = new THREE.Vector3(),

		_lightsNeedUpdate = true,

		_lights = {

			ambient: [ 0, 0, 0 ],
			directional: { length: 0, colors: [], positions: [] },
			point: { length: 0, colors: [], positions: [], distances: [], decays: [] },
			spot: { length: 0, colors: [], positions: [], distances: [], directions: [], anglesCos: [], exponents: [], decays: [] },
			hemi: { length: 0, skyColors: [], groundColors: [], positions: [] }

		},

		// info

		_infoMemory = {

			geometries: 0,
			textures: 0

		},

		_infoRender = {

			calls: 0,
			vertices: 0,
			faces: 0,
			points: 0

		};

		this.info = {

			render: _infoRender,
			memory: _infoMemory,
			programs: null

		};


		// initialize

		var _gl;

		try {

			var attributes = {
				alpha: _alpha,
				depth: _depth,
				stencil: _stencil,
				antialias: _antialias,
				premultipliedAlpha: _premultipliedAlpha,
				preserveDrawingBuffer: _preserveDrawingBuffer
			};

			_gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );

			if ( _gl === null ) {

				if ( _canvas.getContext( 'webgl' ) !== null ) {

					throw 'Error creating WebGL context with your selected attributes.';

				} else {

					throw 'Error creating WebGL context.';

				}

			}

			_canvas.addEventListener( 'webglcontextlost', onContextLost, false );

		} catch ( error ) {

			console.error( 'THREE.WebGLRenderer: ' + error );

		}

		var extensions = new THREE.WebGLExtensions( _gl );

		extensions.get( 'OES_texture_float' );
		extensions.get( 'OES_texture_float_linear' );
		extensions.get( 'OES_texture_half_float' );
		extensions.get( 'OES_texture_half_float_linear' );
		extensions.get( 'OES_standard_derivatives' );
		extensions.get( 'ANGLE_instanced_arrays' );

		if ( extensions.get( 'OES_element_index_uint' ) ) {

			THREE.BufferGeometry.MaxIndex = 4294967296;

		}

		var capabilities = new THREE.WebGLCapabilities( _gl, extensions, parameters );

		var state = new THREE.WebGLState( _gl, extensions, paramThreeToGL );
		var properties = new THREE.WebGLProperties();
		var objects = new THREE.WebGLObjects( _gl, properties, this.info );
		var programCache = new THREE.WebGLPrograms( this, capabilities );

		this.info.programs = programCache.programs;

		var bufferRenderer = new THREE.WebGLBufferRenderer( _gl, extensions, _infoRender );
		var indexedBufferRenderer = new THREE.WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );

		//

		function glClearColor( r, g, b, a ) {

			if ( _premultipliedAlpha === true ) {

				r *= a; g *= a; b *= a;

			}

			_gl.clearColor( r, g, b, a );

		}

		function setDefaultGLState() {

			state.init();

			_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );

			glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

		}

		function resetGLState() {

			_currentProgram = null;
			_currentCamera = null;

			_currentGeometryProgram = '';
			_currentMaterialId = - 1;

			_lightsNeedUpdate = true;

			state.reset();

		}

		setDefaultGLState();

		this.context = _gl;
		this.capabilities = capabilities;
		this.extensions = extensions;
		this.state = state;

		// shadow map

		var shadowMap = new THREE.WebGLShadowMap( this, lights, objects );

		this.shadowMap = shadowMap;


		// Plugins

		var spritePlugin = new THREE.SpritePlugin( this, sprites );
		var lensFlarePlugin = new THREE.LensFlarePlugin( this, lensFlares );

		// API

		this.getContext = function () {

			return _gl;

		};

		this.getContextAttributes = function () {

			return _gl.getContextAttributes();

		};

		this.forceContextLoss = function () {

			extensions.get( 'WEBGL_lose_context' ).loseContext();

		};

		this.getMaxAnisotropy = ( function () {

			var value;

			return function getMaxAnisotropy() {

				if ( value !== undefined ) return value;

				var extension = extensions.get( 'EXT_texture_filter_anisotropic' );

				if ( extension !== null ) {

					value = _gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

				} else {

					value = 0;

				}

				return value;

			}

		} )();

		this.getPrecision = function () {

			return capabilities.precision;

		};

		this.getPixelRatio = function () {

			return pixelRatio;

		};

		this.setPixelRatio = function ( value ) {

			if ( value !== undefined ) pixelRatio = value;

		};

		this.getSize = function () {

			return {
				width: _width,
				height: _height
			};

		};

		this.setSize = function ( width, height, updateStyle ) {

			_width = width;
			_height = height;

			_canvas.width = width * pixelRatio;
			_canvas.height = height * pixelRatio;

			if ( updateStyle !== false ) {

				_canvas.style.width = width + 'px';
				_canvas.style.height = height + 'px';

			}

			this.setViewport( 0, 0, width, height );

		};

		this.setViewport = function ( x, y, width, height ) {

			_viewportX = x * pixelRatio;
			_viewportY = y * pixelRatio;

			_viewportWidth = width * pixelRatio;
			_viewportHeight = height * pixelRatio;

			_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );

		};

		this.getViewport = function ( dimensions ) {

			dimensions.x = _viewportX / pixelRatio;
			dimensions.y = _viewportY / pixelRatio;

			dimensions.z = _viewportWidth / pixelRatio;
			dimensions.w = _viewportHeight / pixelRatio;

		};

		this.setScissor = function ( x, y, width, height ) {

			_gl.scissor(
				x * pixelRatio,
				y * pixelRatio,
				width * pixelRatio,
				height * pixelRatio
			);

		};

		this.enableScissorTest = function ( boolean ) {

			state.setScissorTest( boolean );

		};

		// Clearing

		this.getClearColor = function () {

			return _clearColor;

		};

		this.setClearColor = function ( color, alpha ) {

			_clearColor.set( color );

			_clearAlpha = alpha !== undefined ? alpha : 1;

			glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

		};

		this.getClearAlpha = function () {

			return _clearAlpha;

		};

		this.setClearAlpha = function ( alpha ) {

			_clearAlpha = alpha;

			glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

		};

		this.clear = function ( color, depth, stencil ) {

			var bits = 0;

			if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;
			if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;
			if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;

			_gl.clear( bits );

		};

		this.clearColor = function () {

			_gl.clear( _gl.COLOR_BUFFER_BIT );

		};

		this.clearDepth = function () {

			_gl.clear( _gl.DEPTH_BUFFER_BIT );

		};

		this.clearStencil = function () {

			_gl.clear( _gl.STENCIL_BUFFER_BIT );

		};

		this.clearTarget = function ( renderTarget, color, depth, stencil ) {

			this.setRenderTarget( renderTarget );
			this.clear( color, depth, stencil );

		};

		// Reset

		this.resetGLState = resetGLState;

		this.dispose = function() {

			_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );

		};

		// Events

		function onContextLost( event ) {

			event.preventDefault();

			resetGLState();
			setDefaultGLState();

			properties.clear();

		};

		function onTextureDispose( event ) {

			var texture = event.target;

			texture.removeEventListener( 'dispose', onTextureDispose );

			deallocateTexture( texture );

			_infoMemory.textures --;


		}

		function onRenderTargetDispose( event ) {

			var renderTarget = event.target;

			renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

			deallocateRenderTarget( renderTarget );

			_infoMemory.textures --;

		}

		function onMaterialDispose( event ) {

			var material = event.target;

			material.removeEventListener( 'dispose', onMaterialDispose );

			deallocateMaterial( material );

		}

		// Buffer deallocation

		function deallocateTexture( texture ) {

			var textureProperties = properties.get( texture );

			if ( texture.image && textureProperties.__image__webglTextureCube ) {

				// cube texture

				_gl.deleteTexture( textureProperties.__image__webglTextureCube );

			} else {

				// 2D texture

				if ( textureProperties.__webglInit === undefined ) return;

				_gl.deleteTexture( textureProperties.__webglTexture );

			}

			// remove all webgl properties
			properties.delete( texture );

		}

		function deallocateRenderTarget( renderTarget ) {

			var renderTargetProperties = properties.get( renderTarget );
			var textureProperties = properties.get( renderTarget.texture );

			if ( ! renderTarget || textureProperties.__webglTexture === undefined ) return;

			_gl.deleteTexture( textureProperties.__webglTexture );

			if ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {

				for ( var i = 0; i < 6; i ++ ) {

					_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
					_gl.deleteRenderbuffer( renderTargetProperties.__webglRenderbuffer[ i ] );

				}

			} else {

				_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
				_gl.deleteRenderbuffer( renderTargetProperties.__webglRenderbuffer );

			}

			properties.delete( renderTarget.texture );
			properties.delete( renderTarget );

		}

		function deallocateMaterial( material ) {

			releaseMaterialProgramReference( material );

			properties.delete( material );

		}


		function releaseMaterialProgramReference( material ) {

			var programInfo = properties.get( material ).program;

			material.program = undefined;

			if ( programInfo !== undefined ) {

				programCache.releaseProgram( programInfo );

			}

		}

		// Buffer rendering

		this.renderBufferImmediate = function ( object, program, material ) {

			state.initAttributes();

			var buffers = properties.get( object );

			if ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();
			if ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();
			if ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();
			if ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();

			var attributes = program.getAttributes();

			if ( object.hasPositions ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );
				_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );

				state.enableAttribute( attributes.position );
				_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

			}

			if ( object.hasNormals ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );

				if ( material.type !== 'MeshPhongMaterial' && material.shading === THREE.FlatShading ) {

					for ( var i = 0, l = object.count * 3; i < l; i += 9 ) {

						var array = object.normalArray;

						var nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;
						var ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;
						var nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;

						array[ i + 0 ] = nx;
						array[ i + 1 ] = ny;
						array[ i + 2 ] = nz;

						array[ i + 3 ] = nx;
						array[ i + 4 ] = ny;
						array[ i + 5 ] = nz;

						array[ i + 6 ] = nx;
						array[ i + 7 ] = ny;
						array[ i + 8 ] = nz;

					}

				}

				_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );

				state.enableAttribute( attributes.normal );

				_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );

			}

			if ( object.hasUvs && material.map ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );
				_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );

				state.enableAttribute( attributes.uv );

				_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );

			}

			if ( object.hasColors && material.vertexColors !== THREE.NoColors ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );
				_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );

				state.enableAttribute( attributes.color );

				_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );

			}

			state.disableUnusedAttributes();

			_gl.drawArrays( _gl.TRIANGLES, 0, object.count );

			object.count = 0;

		};

		this.renderBufferDirect = function ( camera, lights, fog, geometry, material, object, group ) {

			setMaterial( material );

			var program = setProgram( camera, lights, fog, material, object );

			var updateBuffers = false;
			var geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;

			if ( geometryProgram !== _currentGeometryProgram ) {

				_currentGeometryProgram = geometryProgram;
				updateBuffers = true;

			}

			// morph targets

			var morphTargetInfluences = object.morphTargetInfluences;

			if ( morphTargetInfluences !== undefined ) {

				var activeInfluences = [];

				for ( var i = 0, l = morphTargetInfluences.length; i < l; i ++ ) {

					var influence = morphTargetInfluences[ i ];
					activeInfluences.push( [ influence, i ] );

				}

				activeInfluences.sort( numericalSort );

				if ( activeInfluences.length > 8 ) {

					activeInfluences.length = 8;

				}

				var morphAttributes = geometry.morphAttributes;

				for ( var i = 0, l = activeInfluences.length; i < l; i ++ ) {

					var influence = activeInfluences[ i ];
					morphInfluences[ i ] = influence[ 0 ];

					if ( influence[ 0 ] !== 0 ) {

						var index = influence[ 1 ];

						if ( material.morphTargets === true && morphAttributes.position ) geometry.addAttribute( 'morphTarget' + i, morphAttributes.position[ index ] );
						if ( material.morphNormals === true && morphAttributes.normal ) geometry.addAttribute( 'morphNormal' + i, morphAttributes.normal[ index ] );

					} else {

						if ( material.morphTargets === true ) geometry.removeAttribute( 'morphTarget' + i );
						if ( material.morphNormals === true ) geometry.removeAttribute( 'morphNormal' + i );

					}

				}

				var uniforms = program.getUniforms();

				if ( uniforms.morphTargetInfluences !== null ) {

					_gl.uniform1fv( uniforms.morphTargetInfluences, morphInfluences );

				}

				updateBuffers = true;

			}

			//

			var index = geometry.index;
			var position = geometry.attributes.position;

			if ( material.wireframe === true ) {

				index = objects.getWireframeAttribute( geometry );

			}

			var renderer;

			if ( index !== null ) {

				renderer = indexedBufferRenderer;
				renderer.setIndex( index );

			} else {

				renderer = bufferRenderer;

			}

			if ( updateBuffers ) {

				setupVertexAttributes( material, program, geometry );

				if ( index !== null ) {

					_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer( index ) );

				}

			}

			//

			var dataStart = 0;
			var dataCount = Infinity;

			if ( index !== null ) {

				dataCount = index.count

			} else if ( position !== undefined ) {

				dataCount = position.count;

			}

			var rangeStart = geometry.drawRange.start;
			var rangeCount = geometry.drawRange.count;

			var groupStart = group !== null ? group.start : 0;
			var groupCount = group !== null ? group.count : Infinity;

			var drawStart = Math.max( dataStart, rangeStart, groupStart );
			var drawEnd = Math.min( dataStart + dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;

			var drawCount = Math.max( 0, drawEnd - drawStart + 1 );

			//

			if ( object instanceof THREE.Mesh ) {

				if ( material.wireframe === true ) {

					state.setLineWidth( material.wireframeLinewidth * pixelRatio );
					renderer.setMode( _gl.LINES );

				} else {

					renderer.setMode( _gl.TRIANGLES );

				}

				if ( geometry instanceof THREE.InstancedBufferGeometry && geometry.maxInstancedCount > 0 ) {

					renderer.renderInstances( geometry );

				} else {

					renderer.render( drawStart, drawCount );

				}

			} else if ( object instanceof THREE.Line ) {

				var lineWidth = material.linewidth;

				if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material

				state.setLineWidth( lineWidth * pixelRatio );

				if ( object instanceof THREE.LineSegments ) {

					renderer.setMode( _gl.LINES );

				} else {

					renderer.setMode( _gl.LINE_STRIP );

				}

				renderer.render( drawStart, drawCount );

			} else if ( object instanceof THREE.Points ) {

				renderer.setMode( _gl.POINTS );
				renderer.render( drawStart, drawCount );

			}

		};

		function setupVertexAttributes( material, program, geometry, startIndex ) {

			var extension;

			if ( geometry instanceof THREE.InstancedBufferGeometry ) {

				extension = extensions.get( 'ANGLE_instanced_arrays' );

				if ( extension === null ) {

					console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
					return;

				}

			}

			if ( startIndex === undefined ) startIndex = 0;

			state.initAttributes();

			var geometryAttributes = geometry.attributes;

			var programAttributes = program.getAttributes();

			var materialDefaultAttributeValues = material.defaultAttributeValues;

			for ( var name in programAttributes ) {

				var programAttribute = programAttributes[ name ];

				if ( programAttribute >= 0 ) {

					var geometryAttribute = geometryAttributes[ name ];

					if ( geometryAttribute !== undefined ) {

						var size = geometryAttribute.itemSize;
						var buffer = objects.getAttributeBuffer( geometryAttribute );

						if ( geometryAttribute instanceof THREE.InterleavedBufferAttribute ) {

							var data = geometryAttribute.data;
							var stride = data.stride;
							var offset = geometryAttribute.offset;

							if ( data instanceof THREE.InstancedInterleavedBuffer ) {

								state.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute, extension );

								if ( geometry.maxInstancedCount === undefined ) {

									geometry.maxInstancedCount = data.meshPerAttribute * data.count;

								}

							} else {

								state.enableAttribute( programAttribute );

							}

							_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
							_gl.vertexAttribPointer( programAttribute, size, _gl.FLOAT, false, stride * data.array.BYTES_PER_ELEMENT, ( startIndex * stride + offset ) * data.array.BYTES_PER_ELEMENT );

						} else {

							if ( geometryAttribute instanceof THREE.InstancedBufferAttribute ) {

								state.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute, extension );

								if ( geometry.maxInstancedCount === undefined ) {

									geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

								}

							} else {

								state.enableAttribute( programAttribute );

							}

							_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
							_gl.vertexAttribPointer( programAttribute, size, _gl.FLOAT, false, 0, startIndex * size * 4 ); // 4 bytes per Float32

						}

					} else if ( materialDefaultAttributeValues !== undefined ) {

						var value = materialDefaultAttributeValues[ name ];

						if ( value !== undefined ) {

							switch ( value.length ) {

								case 2:
									_gl.vertexAttrib2fv( programAttribute, value );
									break;

								case 3:
									_gl.vertexAttrib3fv( programAttribute, value );
									break;

								case 4:
									_gl.vertexAttrib4fv( programAttribute, value );
									break;

								default:
									_gl.vertexAttrib1fv( programAttribute, value );

							}

						}

					}

				}

			}

			state.disableUnusedAttributes();

		}

		// Sorting

		function numericalSort ( a, b ) {

			return b[ 0 ] - a[ 0 ];

		}

		function painterSortStable ( a, b ) {

			if ( a.object.renderOrder !== b.object.renderOrder ) {

				return a.object.renderOrder - b.object.renderOrder;

			} else if ( a.material.id !== b.material.id ) {

				return a.material.id - b.material.id;

			} else if ( a.z !== b.z ) {

				return a.z - b.z;

			} else {

				return a.id - b.id;

			}

		}

		function reversePainterSortStable ( a, b ) {

			if ( a.object.renderOrder !== b.object.renderOrder ) {

				return a.object.renderOrder - b.object.renderOrder;

			} if ( a.z !== b.z ) {

				return b.z - a.z;

			} else {

				return a.id - b.id;

			}

		}

		// Rendering

		this.render = function ( scene, camera, renderTarget, forceClear ) {

			if ( camera instanceof THREE.Camera === false ) {

				console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
				return;

			}

			var fog = scene.fog;

			// reset caching for this frame

			_currentGeometryProgram = '';
			_currentMaterialId = - 1;
			_currentCamera = null;
			_lightsNeedUpdate = true;

			// update scene graph

			if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

			// update camera matrices and frustum

			if ( camera.parent === null ) camera.updateMatrixWorld();

			camera.matrixWorldInverse.getInverse( camera.matrixWorld );

			_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
			_frustum.setFromMatrix( _projScreenMatrix );

			lights.length = 0;

			opaqueObjectsLastIndex = - 1;
			transparentObjectsLastIndex = - 1;

			sprites.length = 0;
			lensFlares.length = 0;

			projectObject( scene, camera );

			opaqueObjects.length = opaqueObjectsLastIndex + 1;
			transparentObjects.length = transparentObjectsLastIndex + 1;

			if ( _this.sortObjects === true ) {

				opaqueObjects.sort( painterSortStable );
				transparentObjects.sort( reversePainterSortStable );

			}

			//

			shadowMap.render( scene );

			//

			_infoRender.calls = 0;
			_infoRender.vertices = 0;
			_infoRender.faces = 0;
			_infoRender.points = 0;

			this.setRenderTarget( renderTarget );

			if ( this.autoClear || forceClear ) {

				this.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );

			}

			//

			if ( scene.overrideMaterial ) {

				var overrideMaterial = scene.overrideMaterial;

				renderObjects( opaqueObjects, camera, lights, fog, overrideMaterial );
				renderObjects( transparentObjects, camera, lights, fog, overrideMaterial );

			} else {

				// opaque pass (front-to-back order)

				state.setBlending( THREE.NoBlending );
				renderObjects( opaqueObjects, camera, lights, fog );

				// transparent pass (back-to-front order)

				renderObjects( transparentObjects, camera, lights, fog );

			}

			// custom render plugins (post pass)

			spritePlugin.render( scene, camera );
			lensFlarePlugin.render( scene, camera, _currentWidth, _currentHeight );

			// Generate mipmap if we're using any kind of mipmap filtering

			if ( renderTarget ) {

				var texture = renderTarget.texture;
				var isTargetPowerOfTwo = isPowerOfTwo( renderTarget );
				if ( texture.generateMipmaps && isTargetPowerOfTwo && texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) {

					 updateRenderTargetMipmap( renderTarget );

				}

			}

			// Ensure depth buffer writing is enabled so it can be cleared on next render

			state.setDepthTest( true );
			state.setDepthWrite( true );
			state.setColorWrite( true );

			// _gl.finish();

		};

		function pushRenderItem( object, geometry, material, z, group ) {

			var array, index;

			// allocate the next position in the appropriate array

			if ( material.transparent ) {

				array = transparentObjects;
				index = ++ transparentObjectsLastIndex;

			} else {

				array = opaqueObjects;
				index = ++ opaqueObjectsLastIndex;

			}

			// recycle existing render item or grow the array

			var renderItem = array[ index ];

			if ( renderItem !== undefined ) {

				renderItem.id = object.id;
				renderItem.object = object;
				renderItem.geometry = geometry;
				renderItem.material = material;
				renderItem.z = _vector3.z;
				renderItem.group = group;

			} else {

				renderItem = {
					id: object.id,
					object: object,
					geometry: geometry,
					material: material,
					z: _vector3.z,
					group: group
				};

				// assert( index === array.length );
				array.push( renderItem );

			}

		}

		function projectObject( object, camera ) {

			if ( object.visible === false ) return;

			if ( ( object.channels.mask & camera.channels.mask ) !== 0 ) {

				if ( object instanceof THREE.Light ) {

					lights.push( object );

				} else if ( object instanceof THREE.Sprite ) {

					sprites.push( object );

				} else if ( object instanceof THREE.LensFlare ) {

					lensFlares.push( object );

				} else if ( object instanceof THREE.ImmediateRenderObject ) {

					if ( _this.sortObjects === true ) {

						_vector3.setFromMatrixPosition( object.matrixWorld );
						_vector3.applyProjection( _projScreenMatrix );

					}

					pushRenderItem( object, null, object.material, _vector3.z, null );

				} else if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) {

					if ( object instanceof THREE.SkinnedMesh ) {

						object.skeleton.update();

					}

					if ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) {

						var material = object.material;

						if ( material.visible === true ) {

							if ( _this.sortObjects === true ) {

								_vector3.setFromMatrixPosition( object.matrixWorld );
								_vector3.applyProjection( _projScreenMatrix );

							}

							var geometry = objects.update( object );

							if ( material instanceof THREE.MeshFaceMaterial ) {

								var groups = geometry.groups;
								var materials = material.materials;

								for ( var i = 0, l = groups.length; i < l; i ++ ) {

									var group = groups[ i ];
									var groupMaterial = materials[ group.materialIndex ];

									if ( groupMaterial.visible === true ) {

										pushRenderItem( object, geometry, groupMaterial, _vector3.z, group );

									}

								}

							} else {

								pushRenderItem( object, geometry, material, _vector3.z, null );

							}

						}

					}

				}

			}

			var children = object.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				projectObject( children[ i ], camera );

			}

		}

		function renderObjects( renderList, camera, lights, fog, overrideMaterial ) {

			for ( var i = 0, l = renderList.length; i < l; i ++ ) {

				var renderItem = renderList[ i ];

				var object = renderItem.object;
				var geometry = renderItem.geometry;
				var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
				var group = renderItem.group;

				object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
				object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

				if ( object instanceof THREE.ImmediateRenderObject ) {

					setMaterial( material );

					var program = setProgram( camera, lights, fog, material, object );

					_currentGeometryProgram = '';

					object.render( function ( object ) {

						_this.renderBufferImmediate( object, program, material );

					} );

				} else {

					_this.renderBufferDirect( camera, lights, fog, geometry, material, object, group );

				}

			}

		}

		function initMaterial( material, lights, fog, object ) {

			var materialProperties = properties.get( material );

			var parameters = programCache.getParameters( material, lights, fog, object );
			var code = programCache.getProgramCode( material, parameters );

			var program = materialProperties.program;
			var programChange = true;

			if ( program === undefined ) {

				// new material
				material.addEventListener( 'dispose', onMaterialDispose );

			} else if ( program.code !== code ) {

				// changed glsl or parameters
				releaseMaterialProgramReference( material );

			} else if ( parameters.shaderID !== undefined ) {

				// same glsl and uniform list
				return;

			} else {

				// only rebuild uniform list
				programChange = false;

			}

			if ( programChange ) {

				if ( parameters.shaderID ) {

					var shader = THREE.ShaderLib[ parameters.shaderID ];

					materialProperties.__webglShader = {
						name: material.type,
						uniforms: THREE.UniformsUtils.clone( shader.uniforms ),
						vertexShader: shader.vertexShader,
						fragmentShader: shader.fragmentShader
					};

				} else {

					materialProperties.__webglShader = {
						name: material.type,
						uniforms: material.uniforms,
						vertexShader: material.vertexShader,
						fragmentShader: material.fragmentShader
					};

				}

				material.__webglShader = materialProperties.__webglShader;

				program = programCache.acquireProgram( material, parameters, code );

				materialProperties.program = program;
				material.program = program;

			}

			var attributes = program.getAttributes();

			if ( material.morphTargets ) {

				material.numSupportedMorphTargets = 0;

				for ( var i = 0; i < _this.maxMorphTargets; i ++ ) {

					if ( attributes[ 'morphTarget' + i ] >= 0 ) {

						material.numSupportedMorphTargets ++;

					}

				}

			}

			if ( material.morphNormals ) {

				material.numSupportedMorphNormals = 0;

				for ( i = 0; i < _this.maxMorphNormals; i ++ ) {

					if ( attributes[ 'morphNormal' + i ] >= 0 ) {

						material.numSupportedMorphNormals ++;

					}

				}

			}

			materialProperties.uniformsList = [];

			var uniformLocations = materialProperties.program.getUniforms();

			for ( var u in materialProperties.__webglShader.uniforms ) {

				var location = uniformLocations[ u ];

				if ( location ) {

					materialProperties.uniformsList.push( [ materialProperties.__webglShader.uniforms[ u ], location ] );

				}

			}

		}

		function setMaterial( material ) {

			setMaterialFaces( material );

			if ( material.transparent === true ) {

				state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha );

			} else {

				state.setBlending( THREE.NoBlending );

			}

			state.setDepthFunc( material.depthFunc );
			state.setDepthTest( material.depthTest );
			state.setDepthWrite( material.depthWrite );
			state.setColorWrite( material.colorWrite );
			state.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

		}

		function setMaterialFaces( material ) {

			material.side !== THREE.DoubleSide ? state.enable( _gl.CULL_FACE ) : state.disable( _gl.CULL_FACE );
			state.setFlipSided( material.side === THREE.BackSide );

		}

		function setProgram( camera, lights, fog, material, object ) {

			_usedTextureUnits = 0;

			var materialProperties = properties.get( material );

			if ( material.needsUpdate || ! materialProperties.program ) {

				initMaterial( material, lights, fog, object );
				material.needsUpdate = false;

			}

			var refreshProgram = false;
			var refreshMaterial = false;
			var refreshLights = false;

			var program = materialProperties.program,
				p_uniforms = program.getUniforms(),
				m_uniforms = materialProperties.__webglShader.uniforms;

			if ( program.id !== _currentProgram ) {

				_gl.useProgram( program.program );
				_currentProgram = program.id;

				refreshProgram = true;
				refreshMaterial = true;
				refreshLights = true;

			}

			if ( material.id !== _currentMaterialId ) {

				if ( _currentMaterialId === - 1 ) refreshLights = true;
				_currentMaterialId = material.id;

				refreshMaterial = true;

			}

			if ( refreshProgram || camera !== _currentCamera ) {

				_gl.uniformMatrix4fv( p_uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

				if ( capabilities.logarithmicDepthBuffer ) {

					_gl.uniform1f( p_uniforms.logDepthBufFC, 2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

				}


				if ( camera !== _currentCamera ) _currentCamera = camera;

				// load material specific uniforms
				// (shader material also gets them for the sake of genericity)

				if ( material instanceof THREE.ShaderMaterial ||
					 material instanceof THREE.MeshPhongMaterial ||
					 material.envMap ) {

					if ( p_uniforms.cameraPosition !== undefined ) {

						_vector3.setFromMatrixPosition( camera.matrixWorld );
						_gl.uniform3f( p_uniforms.cameraPosition, _vector3.x, _vector3.y, _vector3.z );

					}

				}

				if ( material instanceof THREE.MeshPhongMaterial ||
					 material instanceof THREE.MeshLambertMaterial ||
					 material instanceof THREE.MeshBasicMaterial ||
					 material instanceof THREE.ShaderMaterial ||
					 material.skinning ) {

					if ( p_uniforms.viewMatrix !== undefined ) {

						_gl.uniformMatrix4fv( p_uniforms.viewMatrix, false, camera.matrixWorldInverse.elements );

					}

				}

			}

			// skinning uniforms must be set even if material didn't change
			// auto-setting of texture unit for bone texture must go before other textures
			// not sure why, but otherwise weird things happen

			if ( material.skinning ) {

				if ( object.bindMatrix && p_uniforms.bindMatrix !== undefined ) {

					_gl.uniformMatrix4fv( p_uniforms.bindMatrix, false, object.bindMatrix.elements );

				}

				if ( object.bindMatrixInverse && p_uniforms.bindMatrixInverse !== undefined ) {

					_gl.uniformMatrix4fv( p_uniforms.bindMatrixInverse, false, object.bindMatrixInverse.elements );

				}

				if ( capabilities.floatVertexTextures && object.skeleton && object.skeleton.useVertexTexture ) {

					if ( p_uniforms.boneTexture !== undefined ) {

						var textureUnit = getTextureUnit();

						_gl.uniform1i( p_uniforms.boneTexture, textureUnit );
						_this.setTexture( object.skeleton.boneTexture, textureUnit );

					}

					if ( p_uniforms.boneTextureWidth !== undefined ) {

						_gl.uniform1i( p_uniforms.boneTextureWidth, object.skeleton.boneTextureWidth );

					}

					if ( p_uniforms.boneTextureHeight !== undefined ) {

						_gl.uniform1i( p_uniforms.boneTextureHeight, object.skeleton.boneTextureHeight );

					}

				} else if ( object.skeleton && object.skeleton.boneMatrices ) {

					if ( p_uniforms.boneGlobalMatrices !== undefined ) {

						_gl.uniformMatrix4fv( p_uniforms.boneGlobalMatrices, false, object.skeleton.boneMatrices );

					}

				}

			}

			if ( refreshMaterial ) {

				// refresh uniforms common to several materials

				if ( fog && material.fog ) {

					refreshUniformsFog( m_uniforms, fog );

				}

				if ( material instanceof THREE.MeshPhongMaterial ||
					 material instanceof THREE.MeshLambertMaterial ||
					 material.lights ) {

					if ( _lightsNeedUpdate ) {

						refreshLights = true;
						setupLights( lights, camera );
						_lightsNeedUpdate = false;

					}

					if ( refreshLights ) {

						refreshUniformsLights( m_uniforms, _lights );
						markUniformsLightsNeedsUpdate( m_uniforms, true );

					} else {

						markUniformsLightsNeedsUpdate( m_uniforms, false );

					}

				}

				if ( material instanceof THREE.MeshBasicMaterial ||
					 material instanceof THREE.MeshLambertMaterial ||
					 material instanceof THREE.MeshPhongMaterial ) {

					refreshUniformsCommon( m_uniforms, material );

				}

				// refresh single material specific uniforms

				if ( material instanceof THREE.LineBasicMaterial ) {

					refreshUniformsLine( m_uniforms, material );

				} else if ( material instanceof THREE.LineDashedMaterial ) {

					refreshUniformsLine( m_uniforms, material );
					refreshUniformsDash( m_uniforms, material );

				} else if ( material instanceof THREE.PointsMaterial ) {

					refreshUniformsParticle( m_uniforms, material );

				} else if ( material instanceof THREE.MeshPhongMaterial ) {

					refreshUniformsPhong( m_uniforms, material );

				} else if ( material instanceof THREE.MeshDepthMaterial ) {

					m_uniforms.mNear.value = camera.near;
					m_uniforms.mFar.value = camera.far;
					m_uniforms.opacity.value = material.opacity;

				} else if ( material instanceof THREE.MeshNormalMaterial ) {

					m_uniforms.opacity.value = material.opacity;

				}

				if ( object.receiveShadow && ! material._shadowPass ) {

					refreshUniformsShadow( m_uniforms, lights, camera );

				}

				// load common uniforms

				loadUniformsGeneric( materialProperties.uniformsList );

			}

			loadUniformsMatrices( p_uniforms, object );

			if ( p_uniforms.modelMatrix !== undefined ) {

				_gl.uniformMatrix4fv( p_uniforms.modelMatrix, false, object.matrixWorld.elements );

			}

			return program;

		}

		// Uniforms (refresh uniforms objects)

		function refreshUniformsCommon ( uniforms, material ) {

			uniforms.opacity.value = material.opacity;

			uniforms.diffuse.value = material.color;

			if ( material.emissive ) {

				uniforms.emissive.value = material.emissive;

			}

			uniforms.map.value = material.map;
			uniforms.specularMap.value = material.specularMap;
			uniforms.alphaMap.value = material.alphaMap;

			if ( material.aoMap ) {

				uniforms.aoMap.value = material.aoMap;
				uniforms.aoMapIntensity.value = material.aoMapIntensity;

			}

			// uv repeat and offset setting priorities
			// 1. color map
			// 2. specular map
			// 3. normal map
			// 4. bump map
			// 5. alpha map
			// 6. emissive map

			var uvScaleMap;

			if ( material.map ) {

				uvScaleMap = material.map;

			} else if ( material.specularMap ) {

				uvScaleMap = material.specularMap;

			} else if ( material.displacementMap ) {

				uvScaleMap = material.displacementMap;

			} else if ( material.normalMap ) {

				uvScaleMap = material.normalMap;

			} else if ( material.bumpMap ) {

				uvScaleMap = material.bumpMap;

			} else if ( material.alphaMap ) {

				uvScaleMap = material.alphaMap;

			} else if ( material.emissiveMap ) {

				uvScaleMap = material.emissiveMap;

			}

			if ( uvScaleMap !== undefined ) {

				if ( uvScaleMap instanceof THREE.WebGLRenderTarget ) uvScaleMap = uvScaleMap.texture;
				var offset = uvScaleMap.offset;
				var repeat = uvScaleMap.repeat;

				uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

			}

			uniforms.envMap.value = material.envMap;
			uniforms.flipEnvMap.value = ( material.envMap instanceof THREE.WebGLRenderTargetCube ) ? 1 : - 1;

			uniforms.reflectivity.value = material.reflectivity;
			uniforms.refractionRatio.value = material.refractionRatio;

		}

		function refreshUniformsLine ( uniforms, material ) {

			uniforms.diffuse.value = material.color;
			uniforms.opacity.value = material.opacity;

		}

		function refreshUniformsDash ( uniforms, material ) {

			uniforms.dashSize.value = material.dashSize;
			uniforms.totalSize.value = material.dashSize + material.gapSize;
			uniforms.scale.value = material.scale;

		}

		function refreshUniformsParticle ( uniforms, material ) {

			uniforms.psColor.value = material.color;
			uniforms.opacity.value = material.opacity;
			uniforms.size.value = material.size;
			uniforms.scale.value = _canvas.height / 2.0; // TODO: Cache this.

			uniforms.map.value = material.map;

			if ( material.map !== null ) {

				var offset = material.map.offset;
				var repeat = material.map.repeat;

				uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

			}

		}

		function refreshUniformsFog ( uniforms, fog ) {

			uniforms.fogColor.value = fog.color;

			if ( fog instanceof THREE.Fog ) {

				uniforms.fogNear.value = fog.near;
				uniforms.fogFar.value = fog.far;

			} else if ( fog instanceof THREE.FogExp2 ) {

				uniforms.fogDensity.value = fog.density;

			}

		}

		function refreshUniformsPhong ( uniforms, material ) {

			uniforms.specular.value = material.specular;
			uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )

			if ( material.lightMap ) {

				uniforms.lightMap.value = material.lightMap;
				uniforms.lightMapIntensity.value = material.lightMapIntensity;

			}

			if ( material.emissiveMap ) {

				uniforms.emissiveMap.value = material.emissiveMap;

			}

			if ( material.bumpMap ) {

				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;

			}

			if ( material.normalMap ) {

				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy( material.normalScale );

			}

			if ( material.displacementMap ) {

				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

			}

		}

		function refreshUniformsLights ( uniforms, lights ) {

			uniforms.ambientLightColor.value = lights.ambient;

			uniforms.directionalLightColor.value = lights.directional.colors;
			uniforms.directionalLightDirection.value = lights.directional.positions;

			uniforms.pointLightColor.value = lights.point.colors;
			uniforms.pointLightPosition.value = lights.point.positions;
			uniforms.pointLightDistance.value = lights.point.distances;
			uniforms.pointLightDecay.value = lights.point.decays;

			uniforms.spotLightColor.value = lights.spot.colors;
			uniforms.spotLightPosition.value = lights.spot.positions;
			uniforms.spotLightDistance.value = lights.spot.distances;
			uniforms.spotLightDirection.value = lights.spot.directions;
			uniforms.spotLightAngleCos.value = lights.spot.anglesCos;
			uniforms.spotLightExponent.value = lights.spot.exponents;
			uniforms.spotLightDecay.value = lights.spot.decays;

			uniforms.hemisphereLightSkyColor.value = lights.hemi.skyColors;
			uniforms.hemisphereLightGroundColor.value = lights.hemi.groundColors;
			uniforms.hemisphereLightDirection.value = lights.hemi.positions;

		}

		// If uniforms are marked as clean, they don't need to be loaded to the GPU.

		function markUniformsLightsNeedsUpdate ( uniforms, value ) {

			uniforms.ambientLightColor.needsUpdate = value;

			uniforms.directionalLightColor.needsUpdate = value;
			uniforms.directionalLightDirection.needsUpdate = value;

			uniforms.pointLightColor.needsUpdate = value;
			uniforms.pointLightPosition.needsUpdate = value;
			uniforms.pointLightDistance.needsUpdate = value;
			uniforms.pointLightDecay.needsUpdate = value;

			uniforms.spotLightColor.needsUpdate = value;
			uniforms.spotLightPosition.needsUpdate = value;
			uniforms.spotLightDistance.needsUpdate = value;
			uniforms.spotLightDirection.needsUpdate = value;
			uniforms.spotLightAngleCos.needsUpdate = value;
			uniforms.spotLightExponent.needsUpdate = value;
			uniforms.spotLightDecay.needsUpdate = value;

			uniforms.hemisphereLightSkyColor.needsUpdate = value;
			uniforms.hemisphereLightGroundColor.needsUpdate = value;
			uniforms.hemisphereLightDirection.needsUpdate = value;

		}

		function refreshUniformsShadow ( uniforms, lights, camera ) {

			if ( uniforms.shadowMatrix ) {

				var j = 0;

				for ( var i = 0, il = lights.length; i < il; i ++ ) {

					var light = lights[ i ];

					if ( light.castShadow === true ) {

						if ( light instanceof THREE.PointLight || light instanceof THREE.SpotLight || light instanceof THREE.DirectionalLight ) {

							var shadow = light.shadow;

							if ( light instanceof THREE.PointLight ) {

								// for point lights we set the shadow matrix to be a translation-only matrix
								// equal to inverse of the light's position
								_vector3.setFromMatrixPosition( light.matrixWorld ).negate();
								shadow.matrix.identity().setPosition( _vector3 );

								// for point lights we set the sign of the shadowDarkness uniform to be negative
								uniforms.shadowDarkness.value[ j ] = - shadow.darkness;

							} else {

								uniforms.shadowDarkness.value[ j ] = shadow.darkness;

							}

							uniforms.shadowMatrix.value[ j ] = shadow.matrix;
							uniforms.shadowMap.value[ j ] = shadow.map;
							uniforms.shadowMapSize.value[ j ] = shadow.mapSize;
							uniforms.shadowBias.value[ j ] = shadow.bias;

							j ++;

						}

					}

				}

			}

		}

		// Uniforms (load to GPU)

		function loadUniformsMatrices ( uniforms, object ) {

			_gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, object.modelViewMatrix.elements );

			if ( uniforms.normalMatrix ) {

				_gl.uniformMatrix3fv( uniforms.normalMatrix, false, object.normalMatrix.elements );

			}

		}

		function getTextureUnit() {

			var textureUnit = _usedTextureUnits;

			if ( textureUnit >= capabilities.maxTextures ) {

				console.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );

			}

			_usedTextureUnits += 1;

			return textureUnit;

		}

		function loadUniformsGeneric ( uniforms ) {

			var texture, textureUnit;

			for ( var j = 0, jl = uniforms.length; j < jl; j ++ ) {

				var uniform = uniforms[ j ][ 0 ];

				// needsUpdate property is not added to all uniforms.
				if ( uniform.needsUpdate === false ) continue;

				var type = uniform.type;
				var value = uniform.value;
				var location = uniforms[ j ][ 1 ];

				switch ( type ) {

					case '1i':
						_gl.uniform1i( location, value );
						break;

					case '1f':
						_gl.uniform1f( location, value );
						break;

					case '2f':
						_gl.uniform2f( location, value[ 0 ], value[ 1 ] );
						break;

					case '3f':
						_gl.uniform3f( location, value[ 0 ], value[ 1 ], value[ 2 ] );
						break;

					case '4f':
						_gl.uniform4f( location, value[ 0 ], value[ 1 ], value[ 2 ], value[ 3 ] );
						break;

					case '1iv':
						_gl.uniform1iv( location, value );
						break;

					case '3iv':
						_gl.uniform3iv( location, value );
						break;

					case '1fv':
						_gl.uniform1fv( location, value );
						break;

					case '2fv':
						_gl.uniform2fv( location, value );
						break;

					case '3fv':
						_gl.uniform3fv( location, value );
						break;

					case '4fv':
						_gl.uniform4fv( location, value );
						break;

					case 'Matrix3fv':
						_gl.uniformMatrix3fv( location, false, value );
						break;

					case 'Matrix4fv':
						_gl.uniformMatrix4fv( location, false, value );
						break;

					//

					case 'i':

						// single integer
						_gl.uniform1i( location, value );

						break;

					case 'f':

						// single float
						_gl.uniform1f( location, value );

						break;

					case 'v2':

						// single THREE.Vector2
						_gl.uniform2f( location, value.x, value.y );

						break;

					case 'v3':

						// single THREE.Vector3
						_gl.uniform3f( location, value.x, value.y, value.z );

						break;

					case 'v4':

						// single THREE.Vector4
						_gl.uniform4f( location, value.x, value.y, value.z, value.w );

						break;

					case 'c':

						// single THREE.Color
						_gl.uniform3f( location, value.r, value.g, value.b );

						break;

					case 'iv1':

						// flat array of integers (JS or typed array)
						_gl.uniform1iv( location, value );

						break;

					case 'iv':

						// flat array of integers with 3 x N size (JS or typed array)
						_gl.uniform3iv( location, value );

						break;

					case 'fv1':

						// flat array of floats (JS or typed array)
						_gl.uniform1fv( location, value );

						break;

					case 'fv':

						// flat array of floats with 3 x N size (JS or typed array)
						_gl.uniform3fv( location, value );

						break;

					case 'v2v':

						// array of THREE.Vector2

						if ( uniform._array === undefined ) {

							uniform._array = new Float32Array( 2 * value.length );

						}

						for ( var i = 0, i2 = 0, il = value.length; i < il; i ++, i2 += 2 ) {

							uniform._array[ i2 + 0 ] = value[ i ].x;
							uniform._array[ i2 + 1 ] = value[ i ].y;

						}

						_gl.uniform2fv( location, uniform._array );

						break;

					case 'v3v':

						// array of THREE.Vector3

						if ( uniform._array === undefined ) {

							uniform._array = new Float32Array( 3 * value.length );

						}

						for ( var i = 0, i3 = 0, il = value.length; i < il; i ++, i3 += 3 ) {

							uniform._array[ i3 + 0 ] = value[ i ].x;
							uniform._array[ i3 + 1 ] = value[ i ].y;
							uniform._array[ i3 + 2 ] = value[ i ].z;

						}

						_gl.uniform3fv( location, uniform._array );

						break;

					case 'v4v':

						// array of THREE.Vector4

						if ( uniform._array === undefined ) {

							uniform._array = new Float32Array( 4 * value.length );

						}

						for ( var i = 0, i4 = 0, il = value.length; i < il; i ++, i4 += 4 ) {

							uniform._array[ i4 + 0 ] = value[ i ].x;
							uniform._array[ i4 + 1 ] = value[ i ].y;
							uniform._array[ i4 + 2 ] = value[ i ].z;
							uniform._array[ i4 + 3 ] = value[ i ].w;

						}

						_gl.uniform4fv( location, uniform._array );

						break;

					case 'm3':

						// single THREE.Matrix3
						_gl.uniformMatrix3fv( location, false, value.elements );

						break;

					case 'm3v':

						// array of THREE.Matrix3

						if ( uniform._array === undefined ) {

							uniform._array = new Float32Array( 9 * value.length );

						}

						for ( var i = 0, il = value.length; i < il; i ++ ) {

							value[ i ].flattenToArrayOffset( uniform._array, i * 9 );

						}

						_gl.uniformMatrix3fv( location, false, uniform._array );

						break;

					case 'm4':

						// single THREE.Matrix4
						_gl.uniformMatrix4fv( location, false, value.elements );

						break;

					case 'm4v':

						// array of THREE.Matrix4

						if ( uniform._array === undefined ) {

							uniform._array = new Float32Array( 16 * value.length );

						}

						for ( var i = 0, il = value.length; i < il; i ++ ) {

							value[ i ].flattenToArrayOffset( uniform._array, i * 16 );

						}

						_gl.uniformMatrix4fv( location, false, uniform._array );

						break;

					case 't':

						// single THREE.Texture (2d or cube)

						texture = value;
						textureUnit = getTextureUnit();

						_gl.uniform1i( location, textureUnit );

						if ( ! texture ) continue;

						if ( texture instanceof THREE.CubeTexture ||
							 ( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {

							// CompressedTexture can have Array in image :/

							setCubeTexture( texture, textureUnit );

						} else if ( texture instanceof THREE.WebGLRenderTargetCube ) {

							setCubeTextureDynamic( texture.texture, textureUnit );

						} else if ( texture instanceof THREE.WebGLRenderTarget ) {

							_this.setTexture( texture.texture, textureUnit );

						} else {

							_this.setTexture( texture, textureUnit );

						}

						break;

					case 'tv':

						// array of THREE.Texture (2d or cube)

						if ( uniform._array === undefined ) {

							uniform._array = [];

						}

						for ( var i = 0, il = uniform.value.length; i < il; i ++ ) {

							uniform._array[ i ] = getTextureUnit();

						}

						_gl.uniform1iv( location, uniform._array );

						for ( var i = 0, il = uniform.value.length; i < il; i ++ ) {

							texture = uniform.value[ i ];
							textureUnit = uniform._array[ i ];

							if ( ! texture ) continue;

							if ( texture instanceof THREE.CubeTexture ||
								 ( texture.image instanceof Array && texture.image.length === 6 ) ) {

								// CompressedTexture can have Array in image :/

								setCubeTexture( texture, textureUnit );

							} else if ( texture instanceof THREE.WebGLRenderTarget ) {

								_this.setTexture( texture.texture, textureUnit );

							} else if ( texture instanceof THREE.WebGLRenderTargetCube ) {

								setCubeTextureDynamic( texture.texture, textureUnit );

							} else {

								_this.setTexture( texture, textureUnit );

							}

						}

						break;

					default:

						console.warn( 'THREE.WebGLRenderer: Unknown uniform type: ' + type );

				}

			}

		}

		function setColorLinear( array, offset, color, intensity ) {

			array[ offset + 0 ] = color.r * intensity;
			array[ offset + 1 ] = color.g * intensity;
			array[ offset + 2 ] = color.b * intensity;

		}

		function setupLights ( lights, camera ) {

			var l, ll, light,
			r = 0, g = 0, b = 0,
			color, skyColor, groundColor,
			intensity,
			distance,

			zlights = _lights,

			viewMatrix = camera.matrixWorldInverse,

			dirColors = zlights.directional.colors,
			dirPositions = zlights.directional.positions,

			pointColors = zlights.point.colors,
			pointPositions = zlights.point.positions,
			pointDistances = zlights.point.distances,
			pointDecays = zlights.point.decays,

			spotColors = zlights.spot.colors,
			spotPositions = zlights.spot.positions,
			spotDistances = zlights.spot.distances,
			spotDirections = zlights.spot.directions,
			spotAnglesCos = zlights.spot.anglesCos,
			spotExponents = zlights.spot.exponents,
			spotDecays = zlights.spot.decays,

			hemiSkyColors = zlights.hemi.skyColors,
			hemiGroundColors = zlights.hemi.groundColors,
			hemiPositions = zlights.hemi.positions,

			dirLength = 0,
			pointLength = 0,
			spotLength = 0,
			hemiLength = 0,

			dirCount = 0,
			pointCount = 0,
			spotCount = 0,
			hemiCount = 0,

			dirOffset = 0,
			pointOffset = 0,
			spotOffset = 0,
			hemiOffset = 0;

			for ( l = 0, ll = lights.length; l < ll; l ++ ) {

				light = lights[ l ];

				color = light.color;
				intensity = light.intensity;
				distance = light.distance;

				if ( light instanceof THREE.AmbientLight ) {

					if ( ! light.visible ) continue;

					r += color.r;
					g += color.g;
					b += color.b;

				} else if ( light instanceof THREE.DirectionalLight ) {

					dirCount += 1;

					if ( ! light.visible ) continue;

					_direction.setFromMatrixPosition( light.matrixWorld );
					_vector3.setFromMatrixPosition( light.target.matrixWorld );
					_direction.sub( _vector3 );
					_direction.transformDirection( viewMatrix );

					dirOffset = dirLength * 3;

					dirPositions[ dirOffset + 0 ] = _direction.x;
					dirPositions[ dirOffset + 1 ] = _direction.y;
					dirPositions[ dirOffset + 2 ] = _direction.z;

					setColorLinear( dirColors, dirOffset, color, intensity );

					dirLength += 1;

				} else if ( light instanceof THREE.PointLight ) {

					pointCount += 1;

					if ( ! light.visible ) continue;

					pointOffset = pointLength * 3;

					setColorLinear( pointColors, pointOffset, color, intensity );

					_vector3.setFromMatrixPosition( light.matrixWorld );
					_vector3.applyMatrix4( viewMatrix );

					pointPositions[ pointOffset + 0 ] = _vector3.x;
					pointPositions[ pointOffset + 1 ] = _vector3.y;
					pointPositions[ pointOffset + 2 ] = _vector3.z;

					// distance is 0 if decay is 0, because there is no attenuation at all.
					pointDistances[ pointLength ] = distance;
					pointDecays[ pointLength ] = ( light.distance === 0 ) ? 0.0 : light.decay;

					pointLength += 1;

				} else if ( light instanceof THREE.SpotLight ) {

					spotCount += 1;

					if ( ! light.visible ) continue;

					spotOffset = spotLength * 3;

					setColorLinear( spotColors, spotOffset, color, intensity );

					_direction.setFromMatrixPosition( light.matrixWorld );
					_vector3.copy( _direction ).applyMatrix4( viewMatrix );

					spotPositions[ spotOffset + 0 ] = _vector3.x;
					spotPositions[ spotOffset + 1 ] = _vector3.y;
					spotPositions[ spotOffset + 2 ] = _vector3.z;

					spotDistances[ spotLength ] = distance;

					_vector3.setFromMatrixPosition( light.target.matrixWorld );
					_direction.sub( _vector3 );
					_direction.transformDirection( viewMatrix );

					spotDirections[ spotOffset + 0 ] = _direction.x;
					spotDirections[ spotOffset + 1 ] = _direction.y;
					spotDirections[ spotOffset + 2 ] = _direction.z;

					spotAnglesCos[ spotLength ] = Math.cos( light.angle );
					spotExponents[ spotLength ] = light.exponent;
					spotDecays[ spotLength ] = ( light.distance === 0 ) ? 0.0 : light.decay;

					spotLength += 1;

				} else if ( light instanceof THREE.HemisphereLight ) {

					hemiCount += 1;

					if ( ! light.visible ) continue;

					_direction.setFromMatrixPosition( light.matrixWorld );
					_direction.transformDirection( viewMatrix );

					hemiOffset = hemiLength * 3;

					hemiPositions[ hemiOffset + 0 ] = _direction.x;
					hemiPositions[ hemiOffset + 1 ] = _direction.y;
					hemiPositions[ hemiOffset + 2 ] = _direction.z;

					skyColor = light.color;
					groundColor = light.groundColor;

					setColorLinear( hemiSkyColors, hemiOffset, skyColor, intensity );
					setColorLinear( hemiGroundColors, hemiOffset, groundColor, intensity );

					hemiLength += 1;

				}

			}

			// null eventual remains from removed lights
			// (this is to avoid if in shader)

			for ( l = dirLength * 3, ll = Math.max( dirColors.length, dirCount * 3 ); l < ll; l ++ ) dirColors[ l ] = 0.0;
			for ( l = pointLength * 3, ll = Math.max( pointColors.length, pointCount * 3 ); l < ll; l ++ ) pointColors[ l ] = 0.0;
			for ( l = spotLength * 3, ll = Math.max( spotColors.length, spotCount * 3 ); l < ll; l ++ ) spotColors[ l ] = 0.0;
			for ( l = hemiLength * 3, ll = Math.max( hemiSkyColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiSkyColors[ l ] = 0.0;
			for ( l = hemiLength * 3, ll = Math.max( hemiGroundColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiGroundColors[ l ] = 0.0;

			zlights.directional.length = dirLength;
			zlights.point.length = pointLength;
			zlights.spot.length = spotLength;
			zlights.hemi.length = hemiLength;

			zlights.ambient[ 0 ] = r;
			zlights.ambient[ 1 ] = g;
			zlights.ambient[ 2 ] = b;

		}

		// GL state setting

		this.setFaceCulling = function ( cullFace, frontFaceDirection ) {

			if ( cullFace === THREE.CullFaceNone ) {

				state.disable( _gl.CULL_FACE );

			} else {

				if ( frontFaceDirection === THREE.FrontFaceDirectionCW ) {

					_gl.frontFace( _gl.CW );

				} else {

					_gl.frontFace( _gl.CCW );

				}

				if ( cullFace === THREE.CullFaceBack ) {

					_gl.cullFace( _gl.BACK );

				} else if ( cullFace === THREE.CullFaceFront ) {

					_gl.cullFace( _gl.FRONT );

				} else {

					_gl.cullFace( _gl.FRONT_AND_BACK );

				}

				state.enable( _gl.CULL_FACE );

			}

		};

		// Textures

		function setTextureParameters ( textureType, texture, isImagePowerOfTwo ) {

			var extension;

			if ( isImagePowerOfTwo ) {

				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );
				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );

				_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );
				_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );

			} else {

				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );

				if ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) {

					console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture );

				}

				_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
				_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );

				if ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) {

					console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture );

				}

			}

			extension = extensions.get( 'EXT_texture_filter_anisotropic' );

			if ( extension ) {

				if ( texture.type === THREE.FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;
				if ( texture.type === THREE.HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;

				if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {

					_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, _this.getMaxAnisotropy() ) );
					properties.get( texture ).__currentAnisotropy = texture.anisotropy;

				}

			}

		}

		function uploadTexture( textureProperties, texture, slot ) {

			if ( textureProperties.__webglInit === undefined ) {

				textureProperties.__webglInit = true;

				texture.addEventListener( 'dispose', onTextureDispose );

				textureProperties.__webglTexture = _gl.createTexture();

				_infoMemory.textures ++;

			}

			state.activeTexture( _gl.TEXTURE0 + slot );
			state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

			_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
			_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
			_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );

			texture.image = clampToMaxSize( texture.image, capabilities.maxTextureSize );

			if ( textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( texture.image ) === false ) {

				texture.image = makePowerOfTwo( texture.image );

			}

			var image = texture.image,
			isImagePowerOfTwo = isPowerOfTwo( image ),
			glFormat = paramThreeToGL( texture.format ),
			glType = paramThreeToGL( texture.type );

			setTextureParameters( _gl.TEXTURE_2D, texture, isImagePowerOfTwo );

			var mipmap, mipmaps = texture.mipmaps;

			if ( texture instanceof THREE.DataTexture ) {

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if ( mipmaps.length > 0 && isImagePowerOfTwo ) {

					for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];
						state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

					}

					texture.generateMipmaps = false;

				} else {

					state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );

				}

			} else if ( texture instanceof THREE.CompressedTexture ) {

				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

					mipmap = mipmaps[ i ];

					if ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {

						if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

							state.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

						} else {

							console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()" );

						}

					} else {

						state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

					}

				}

			} else {

				// regular Texture (image, video, canvas)

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if ( mipmaps.length > 0 && isImagePowerOfTwo ) {

					for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];
						state.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );

					}

					texture.generateMipmaps = false;

				} else {

					state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image );

				}

			}

			if ( texture.generateMipmaps && isImagePowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );

			textureProperties.__version = texture.version;

			if ( texture.onUpdate ) texture.onUpdate( texture );

		}

		this.setTexture = function ( texture, slot ) {

			var textureProperties = properties.get( texture );

			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

				var image = texture.image;

				if ( image === undefined ) {

					console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );
					return;

				}

				if ( image.complete === false ) {

					console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );
					return;

				}

				uploadTexture( textureProperties, texture, slot );

				return;

			}

			state.activeTexture( _gl.TEXTURE0 + slot );
			state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

		};

		function clampToMaxSize ( image, maxSize ) {

			if ( image.width > maxSize || image.height > maxSize ) {

				// Warning: Scaling through the canvas will only work with images that use
				// premultiplied alpha.

				var scale = maxSize / Math.max( image.width, image.height );

				var canvas = document.createElement( 'canvas' );
				canvas.width = Math.floor( image.width * scale );
				canvas.height = Math.floor( image.height * scale );

				var context = canvas.getContext( '2d' );
				context.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );

				console.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );

				return canvas;

			}

			return image;

		}

		function isPowerOfTwo( image ) {

			return THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height );

		}

		function textureNeedsPowerOfTwo( texture ) {

			if ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) return true;
			if ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) return true;

			return false;

		}

		function makePowerOfTwo( image ) {

			if ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement ) {

				var canvas = document.createElement( 'canvas' );
				canvas.width = THREE.Math.nearestPowerOfTwo( image.width );
				canvas.height = THREE.Math.nearestPowerOfTwo( image.height );

				var context = canvas.getContext( '2d' );
				context.drawImage( image, 0, 0, canvas.width, canvas.height );

				console.warn( 'THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );

				return canvas;

			}

			return image;

		}

		function setCubeTexture ( texture, slot ) {

			var textureProperties = properties.get( texture );

			if ( texture.image.length === 6 ) {

				if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

					if ( ! textureProperties.__image__webglTextureCube ) {

						texture.addEventListener( 'dispose', onTextureDispose );

						textureProperties.__image__webglTextureCube = _gl.createTexture();

						_infoMemory.textures ++;

					}

					state.activeTexture( _gl.TEXTURE0 + slot );
					state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );

					_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );

					var isCompressed = texture instanceof THREE.CompressedTexture;
					var isDataTexture = texture.image[ 0 ] instanceof THREE.DataTexture;

					var cubeImage = [];

					for ( var i = 0; i < 6; i ++ ) {

						if ( _this.autoScaleCubemaps && ! isCompressed && ! isDataTexture ) {

							cubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );

						} else {

							cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

						}

					}

					var image = cubeImage[ 0 ],
					isImagePowerOfTwo = isPowerOfTwo( image ),
					glFormat = paramThreeToGL( texture.format ),
					glType = paramThreeToGL( texture.type );

					setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isImagePowerOfTwo );

					for ( var i = 0; i < 6; i ++ ) {

						if ( ! isCompressed ) {

							if ( isDataTexture ) {

								state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

							} else {

								state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );

							}

						} else {

							var mipmap, mipmaps = cubeImage[ i ].mipmaps;

							for ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {

								mipmap = mipmaps[ j ];

								if ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {

									if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

										state.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

									} else {

										console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setCubeTexture()" );

									}

								} else {

									state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

								}

							}

						}

					}

					if ( texture.generateMipmaps && isImagePowerOfTwo ) {

						_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

					}

					textureProperties.__version = texture.version;

					if ( texture.onUpdate ) texture.onUpdate( texture );

				} else {

					state.activeTexture( _gl.TEXTURE0 + slot );
					state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );

				}

			}

		}

		function setCubeTextureDynamic ( texture, slot ) {

			state.activeTexture( _gl.TEXTURE0 + slot );
			state.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );

		}

		// Render targets

		function setupFrameBuffer ( framebuffer, renderTarget, textureTarget ) {

			_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );

		}

		function setupRenderBuffer ( renderbuffer, renderTarget ) {

			_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );

			if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );
				_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

			/* For some reason this is not working. Defaulting to RGBA4.
			} else if ( ! renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.STENCIL_INDEX8, renderTarget.width, renderTarget.height );
				_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );
			*/

			} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );
				_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

			} else {

				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );

			}

		}

		this.setRenderTarget = function ( renderTarget ) {

			var isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );

			if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {

				var renderTargetProperties = properties.get( renderTarget );
				var textureProperties = properties.get( renderTarget.texture );

				if ( renderTarget.depthBuffer === undefined ) renderTarget.depthBuffer = true;
				if ( renderTarget.stencilBuffer === undefined ) renderTarget.stencilBuffer = true;

				renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

				textureProperties.__webglTexture = _gl.createTexture();

				_infoMemory.textures ++;

				// Setup texture, create render and frame buffers

				var isTargetPowerOfTwo = isPowerOfTwo( renderTarget ),
					glFormat = paramThreeToGL( renderTarget.texture.format ),
					glType = paramThreeToGL( renderTarget.texture.type );

				if ( isCube ) {

					renderTargetProperties.__webglFramebuffer = [];
					renderTargetProperties.__webglRenderbuffer = [];

					state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );

					setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );

					for ( var i = 0; i < 6; i ++ ) {

						renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();
						renderTargetProperties.__webglRenderbuffer[ i ] = _gl.createRenderbuffer();
						state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

						setupFrameBuffer( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );
						setupRenderBuffer( renderTargetProperties.__webglRenderbuffer[ i ], renderTarget );

					}

					if ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

				} else {

					renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

					if ( renderTarget.shareDepthFrom ) {

						renderTargetProperties.__webglRenderbuffer = renderTarget.shareDepthFrom.__webglRenderbuffer;

					} else {

						renderTargetProperties.__webglRenderbuffer = _gl.createRenderbuffer();

					}

					state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );
					setTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );

					state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

					setupFrameBuffer( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.TEXTURE_2D );

					if ( renderTarget.shareDepthFrom ) {

						if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

							_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderTargetProperties.__webglRenderbuffer );

						} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

							_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderTargetProperties.__webglRenderbuffer );

						}

					} else {

						setupRenderBuffer( renderTargetProperties.__webglRenderbuffer, renderTarget );

					}

					if ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );

				}

				// Release everything

				if ( isCube ) {

					state.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

				} else {

					state.bindTexture( _gl.TEXTURE_2D, null );

				}

				_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );
				_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

			}

			var framebuffer, width, height, vx, vy;

			if ( renderTarget ) {

				var renderTargetProperties = properties.get( renderTarget );

				if ( isCube ) {

					framebuffer = renderTargetProperties.__webglFramebuffer[ renderTarget.activeCubeFace ];

				} else {

					framebuffer = renderTargetProperties.__webglFramebuffer;

				}

				width = renderTarget.width;
				height = renderTarget.height;

				vx = 0;
				vy = 0;

			} else {

				framebuffer = null;

				width = _viewportWidth;
				height = _viewportHeight;

				vx = _viewportX;
				vy = _viewportY;

			}

			if ( framebuffer !== _currentFramebuffer ) {

				_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
				_gl.viewport( vx, vy, width, height );

				_currentFramebuffer = framebuffer;

			}

			if ( isCube ) {

				var textureProperties = properties.get( renderTarget.texture );
				_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, 0 );

			}

			_currentWidth = width;
			_currentHeight = height;

		};

		this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {

			if ( renderTarget instanceof THREE.WebGLRenderTarget === false ) {

				console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
				return;

			}

			var framebuffer = properties.get( renderTarget ).__webglFramebuffer;

			if ( framebuffer ) {

				var restore = false;

				if ( framebuffer !== _currentFramebuffer ) {

					_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

					restore = true;

				}

				try {

					var texture = renderTarget.texture;

					if ( texture.format !== THREE.RGBAFormat
						&& paramThreeToGL( texture.format ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {

						console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
						return;

					}

					if ( texture.type !== THREE.UnsignedByteType
						&& paramThreeToGL( texture.type ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE )
						&& ! ( texture.type === THREE.FloatType && extensions.get( 'WEBGL_color_buffer_float' ) )
						&& ! ( texture.type === THREE.HalfFloatType && extensions.get( 'EXT_color_buffer_half_float' ) ) ) {

						console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
						return;

					}

					if ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {

						_gl.readPixels( x, y, width, height, paramThreeToGL( texture.format ), paramThreeToGL( texture.type ), buffer );

					} else {

						console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );

					}

				} finally {

					if ( restore ) {

						_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );

					}

				}

			}

		};

		function updateRenderTargetMipmap( renderTarget ) {

			var target = renderTarget instanceof THREE.WebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
			var texture = properties.get( renderTarget.texture ).__webglTexture;

			state.bindTexture( target, texture );
			_gl.generateMipmap( target );
			state.bindTexture( target, null );

		}

		// Fallback filters for non-power-of-2 textures

		function filterFallback ( f ) {

			if ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {

				return _gl.NEAREST;

			}

			return _gl.LINEAR;

		}

		// Map three.js constants to WebGL constants

		function paramThreeToGL ( p ) {

			var extension;

			if ( p === THREE.RepeatWrapping ) return _gl.REPEAT;
			if ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;
			if ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;

			if ( p === THREE.NearestFilter ) return _gl.NEAREST;
			if ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;
			if ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;

			if ( p === THREE.LinearFilter ) return _gl.LINEAR;
			if ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;
			if ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;

			if ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;
			if ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;
			if ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;
			if ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;

			if ( p === THREE.ByteType ) return _gl.BYTE;
			if ( p === THREE.ShortType ) return _gl.SHORT;
			if ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;
			if ( p === THREE.IntType ) return _gl.INT;
			if ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;
			if ( p === THREE.FloatType ) return _gl.FLOAT;

			extension = extensions.get( 'OES_texture_half_float' );

			if ( extension !== null ) {

				if ( p === THREE.HalfFloatType ) return extension.HALF_FLOAT_OES;

			}

			if ( p === THREE.AlphaFormat ) return _gl.ALPHA;
			if ( p === THREE.RGBFormat ) return _gl.RGB;
			if ( p === THREE.RGBAFormat ) return _gl.RGBA;
			if ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;
			if ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;

			if ( p === THREE.AddEquation ) return _gl.FUNC_ADD;
			if ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;
			if ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;

			if ( p === THREE.ZeroFactor ) return _gl.ZERO;
			if ( p === THREE.OneFactor ) return _gl.ONE;
			if ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;
			if ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;
			if ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;
			if ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;
			if ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;
			if ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;

			if ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;
			if ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;
			if ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;

			extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

			if ( extension !== null ) {

				if ( p === THREE.RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
				if ( p === THREE.RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
				if ( p === THREE.RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
				if ( p === THREE.RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

			}

			extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

			if ( extension !== null ) {

				if ( p === THREE.RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
				if ( p === THREE.RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
				if ( p === THREE.RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
				if ( p === THREE.RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

			}

			extension = extensions.get( 'EXT_blend_minmax' );

			if ( extension !== null ) {

				if ( p === THREE.MinEquation ) return extension.MIN_EXT;
				if ( p === THREE.MaxEquation ) return extension.MAX_EXT;

			}

			return 0;

		}

		// DEPRECATED

		this.supportsFloatTextures = function () {

			console.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).' );
			return extensions.get( 'OES_texture_float' );

		};

		this.supportsHalfFloatTextures = function () {

			console.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).' );
			return extensions.get( 'OES_texture_half_float' );

		};

		this.supportsStandardDerivatives = function () {

			console.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).' );
			return extensions.get( 'OES_standard_derivatives' );

		};

		this.supportsCompressedTextureS3TC = function () {

			console.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).' );
			return extensions.get( 'WEBGL_compressed_texture_s3tc' );

		};

		this.supportsCompressedTexturePVRTC = function () {

			console.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).' );
			return extensions.get( 'WEBGL_compressed_texture_pvrtc' );

		};

		this.supportsBlendMinMax = function () {

			console.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).' );
			return extensions.get( 'EXT_blend_minmax' );

		};

		this.supportsVertexTextures = function () {

			return capabilities.vertexTextures;

		};

		this.supportsInstancedArrays = function () {

			console.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).' );
			return extensions.get( 'ANGLE_instanced_arrays' );

		};

		//

		this.initMaterial = function () {

			console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );

		};

		this.addPrePlugin = function () {

			console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );

		};

		this.addPostPlugin = function () {

			console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );

		};

		this.updateShadowMap = function () {

			console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );

		};

		Object.defineProperties( this, {
			shadowMapEnabled: {
				get: function () {

					return shadowMap.enabled;

				},
				set: function ( value ) {

					console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );
					shadowMap.enabled = value;

				}
			},
			shadowMapType: {
				get: function () {

					return shadowMap.type;

				},
				set: function ( value ) {

					console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );
					shadowMap.type = value;

				}
			},
			shadowMapCullFace: {
				get: function () {

					return shadowMap.cullFace;

				},
				set: function ( value ) {

					console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );
					shadowMap.cullFace = value;

				}
			},
			shadowMapDebug: {
				get: function () {

					return shadowMap.debug;

				},
				set: function ( value ) {

					console.warn( 'THREE.WebGLRenderer: .shadowMapDebug is now .shadowMap.debug.' );
					shadowMap.debug = value;

				}
			}
		} );

	};

	// File:src/renderers/WebGLRenderTarget.js

	/**
	 * @author szimek / https://github.com/szimek/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.WebGLRenderTarget = function ( width, height, options ) {

		this.uuid = THREE.Math.generateUUID();

		this.width = width;
		this.height = height;

		options = options || {};

		if ( options.minFilter === undefined ) options.minFilter = THREE.LinearFilter;

		this.texture = new THREE.Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy );

		this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
		this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;

		this.shareDepthFrom = options.shareDepthFrom !== undefined ? options.shareDepthFrom : null;

	};

	THREE.WebGLRenderTarget.prototype = {

		constructor: THREE.WebGLRenderTarget,

		get wrapS() {

			console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );

			return this.texture.wrapS;

		},

		set wrapS( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );

			this.texture.wrapS = value;

		},

		get wrapT() {

			console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );

			return this.texture.wrapT;

		},

		set wrapT( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );

			this.texture.wrapT = value;

		},

		get magFilter() {

			console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );

			return this.texture.magFilter;

		},

		set magFilter( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );

			this.texture.magFilter = value;

		},

		get minFilter() {

			console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );

			return this.texture.minFilter;

		},

		set minFilter( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );

			this.texture.minFilter = value;

		},

		get anisotropy() {

			console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );

			return this.texture.anisotropy;

		},

		set anisotropy( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );

			this.texture.anisotropy = value;

		},

		get offset() {

			console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );

			return this.texture.offset;

		},

		set offset( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );

			this.texture.offset = value;

		},

		get repeat() {

			console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );

			return this.texture.repeat;

		},

		set repeat( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );

			this.texture.repeat = value;

		},

		get format() {

			console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );

			return this.texture.format;

		},

		set format( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );

			this.texture.format = value;

		},

		get type() {

			console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );

			return this.texture.type;

		},

		set type( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );

			this.texture.type = value;

		},

		get generateMipmaps() {

			console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );

			return this.texture.generateMipmaps;

		},

		set generateMipmaps( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );

			this.texture.generateMipmaps = value;

		},

		//

		setSize: function ( width, height ) {

			if ( this.width !== width || this.height !== height ) {

				this.width = width;
				this.height = height;

				this.dispose();

			}

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( source ) {

			this.width = source.width;
			this.height = source.height;

			this.texture = source.texture.clone();

			this.depthBuffer = source.depthBuffer;
			this.stencilBuffer = source.stencilBuffer;

			this.shareDepthFrom = source.shareDepthFrom;

			return this;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	};

	THREE.EventDispatcher.prototype.apply( THREE.WebGLRenderTarget.prototype );

	// File:src/renderers/WebGLRenderTargetCube.js

	/**
	 * @author alteredq / http://alteredqualia.com
	 */

	THREE.WebGLRenderTargetCube = function ( width, height, options ) {

		THREE.WebGLRenderTarget.call( this, width, height, options );

		this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5

	};

	THREE.WebGLRenderTargetCube.prototype = Object.create( THREE.WebGLRenderTarget.prototype );
	THREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube;

	// File:src/renderers/webgl/WebGLBufferRenderer.js

	/**
	* @author mrdoob / http://mrdoob.com/
	*/

	THREE.WebGLBufferRenderer = function ( _gl, extensions, _infoRender ) {

		var mode;

		function setMode( value ) {

			mode = value;

		}

		function render( start, count ) {

			_gl.drawArrays( mode, start, count );

			_infoRender.calls ++;
			_infoRender.vertices += count;
			if ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;

		}

		function renderInstances( geometry ) {

			var extension = extensions.get( 'ANGLE_instanced_arrays' );

			if ( extension === null ) {

				console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
				return;

			}

			var position = geometry.attributes.position;

			if ( position instanceof THREE.InterleavedBufferAttribute ) {

				extension.drawArraysInstancedANGLE( mode, 0, position.data.count, geometry.maxInstancedCount );

			} else {

				extension.drawArraysInstancedANGLE( mode, 0, position.count, geometry.maxInstancedCount );

			}

		}

		this.setMode = setMode;
		this.render = render;
		this.renderInstances = renderInstances;

	};

	// File:src/renderers/webgl/WebGLIndexedBufferRenderer.js

	/**
	* @author mrdoob / http://mrdoob.com/
	*/

	THREE.WebGLIndexedBufferRenderer = function ( _gl, extensions, _infoRender ) {

		var mode;

		function setMode( value ) {

			mode = value;

		}

		var type, size;

		function setIndex( index ) {

			if ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {

				type = _gl.UNSIGNED_INT;
				size = 4;

			} else {

				type = _gl.UNSIGNED_SHORT;
				size = 2;

			}

		}

		function render( start, count ) {

			_gl.drawElements( mode, count, type, start * size );

			_infoRender.calls ++;
			_infoRender.vertices += count;
			if ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;

		}

		function renderInstances( geometry ) {

			var extension = extensions.get( 'ANGLE_instanced_arrays' );

			if ( extension === null ) {

				console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
				return;

			}

			var index = geometry.index;

			extension.drawElementsInstancedANGLE( mode, index.array.length, type, 0, geometry.maxInstancedCount );

		}

		this.setMode = setMode;
		this.setIndex = setIndex;
		this.render = render;
		this.renderInstances = renderInstances;

	};

	// File:src/renderers/webgl/WebGLExtensions.js

	/**
	* @author mrdoob / http://mrdoob.com/
	*/

	THREE.WebGLExtensions = function ( gl ) {

		var extensions = {};

		this.get = function ( name ) {

			if ( extensions[ name ] !== undefined ) {

				return extensions[ name ];

			}

			var extension;

			switch ( name ) {

				case 'EXT_texture_filter_anisotropic':
					extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
					break;

				case 'WEBGL_compressed_texture_s3tc':
					extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
					break;

				case 'WEBGL_compressed_texture_pvrtc':
					extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
					break;

				default:
					extension = gl.getExtension( name );

			}

			if ( extension === null ) {

				console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

			}

			extensions[ name ] = extension;

			return extension;

		};

	};

	// File:src/renderers/webgl/WebGLCapabilities.js

	THREE.WebGLCapabilities = function ( gl, extensions, parameters ) {

		function getMaxPrecision( precision ) {

			if ( precision === 'highp' ) {

				if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&
				     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {

					return 'highp';

				}

				precision = 'mediump';

			}

			if ( precision === 'mediump' ) {

				if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&
				     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {

					return 'mediump';

				}

			}

			return 'lowp';

		}

		this.getMaxPrecision = getMaxPrecision;

		this.precision = parameters.precision !== undefined ? parameters.precision : 'highp',
		this.logarithmicDepthBuffer = parameters.logarithmicDepthBuffer !== undefined ? parameters.logarithmicDepthBuffer : false;

		this.maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );
		this.maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
		this.maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );
		this.maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );

		this.maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
		this.maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );
		this.maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );
		this.maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );

		this.vertexTextures = this.maxVertexTextures > 0;
		this.floatFragmentTextures = !! extensions.get( 'OES_texture_float' );
		this.floatVertexTextures = this.vertexTextures && this.floatFragmentTextures;

		var _maxPrecision = getMaxPrecision( this.precision );

		if ( _maxPrecision !== this.precision ) {

			console.warn( 'THREE.WebGLRenderer:', this.precision, 'not supported, using', _maxPrecision, 'instead.' );
			this.precision = _maxPrecision;

		}

		if ( this.logarithmicDepthBuffer ) {

			this.logarithmicDepthBuffer = !! extensions.get( 'EXT_frag_depth' );

		}

	};

	// File:src/renderers/webgl/WebGLGeometries.js

	/**
	* @author mrdoob / http://mrdoob.com/
	*/

	THREE.WebGLGeometries = function ( gl, properties, info ) {

		var geometries = {};

		function get( object ) {

			var geometry = object.geometry;

			if ( geometries[ geometry.id ] !== undefined ) {

				return geometries[ geometry.id ];

			}

			geometry.addEventListener( 'dispose', onGeometryDispose );

			var buffergeometry;

			if ( geometry instanceof THREE.BufferGeometry ) {

				buffergeometry = geometry;

			} else if ( geometry instanceof THREE.Geometry ) {

				if ( geometry._bufferGeometry === undefined ) {

					geometry._bufferGeometry = new THREE.BufferGeometry().setFromObject( object );

				}

				buffergeometry = geometry._bufferGeometry;

			}

			geometries[ geometry.id ] = buffergeometry;

			info.memory.geometries ++;

			return buffergeometry;

		}

		function onGeometryDispose( event ) {

			var geometry = event.target;
			var buffergeometry = geometries[ geometry.id ];

			deleteAttributes( buffergeometry.attributes );

			geometry.removeEventListener( 'dispose', onGeometryDispose );

			delete geometries[ geometry.id ];

			var property = properties.get( geometry );
			if ( property.wireframe ) deleteAttribute( property.wireframe );

			info.memory.geometries --;

		}

		function getAttributeBuffer( attribute ) {

			if ( attribute instanceof THREE.InterleavedBufferAttribute ) {

				return properties.get( attribute.data ).__webglBuffer;

			}

			return properties.get( attribute ).__webglBuffer;

		}

		function deleteAttribute( attribute ) {

			var buffer = getAttributeBuffer( attribute );

			if ( buffer !== undefined ) {

				gl.deleteBuffer( buffer );
				removeAttributeBuffer( attribute );

			}

		}

		function deleteAttributes( attributes ) {

			for ( var name in attributes ) {

				deleteAttribute( attributes[ name ] );

			}

		}

		function removeAttributeBuffer( attribute ) {

			if ( attribute instanceof THREE.InterleavedBufferAttribute ) {

				properties.delete( attribute.data );

			} else {

				properties.delete( attribute );

			}

		}

		this.get = get;

	};

	// File:src/renderers/webgl/WebGLObjects.js

	/**
	* @author mrdoob / http://mrdoob.com/
	*/

	THREE.WebGLObjects = function ( gl, properties, info ) {

		var geometries = new THREE.WebGLGeometries( gl, properties, info );

		//

		function update( object ) {

			// TODO: Avoid updating twice (when using shadowMap). Maybe add frame counter.

			var geometry = geometries.get( object );

			if ( object.geometry instanceof THREE.Geometry ) {

				geometry.updateFromObject( object );

			}

			var index = geometry.index;
			var attributes = geometry.attributes;

			if ( index !== null ) {

				updateAttribute( index, gl.ELEMENT_ARRAY_BUFFER );

			}

			for ( var name in attributes ) {

				updateAttribute( attributes[ name ], gl.ARRAY_BUFFER );

			}

			// morph targets

			var morphAttributes = geometry.morphAttributes;

			for ( var name in morphAttributes ) {

				var array = morphAttributes[ name ];

				for ( var i = 0, l = array.length; i < l; i ++ ) {

					updateAttribute( array[ i ], gl.ARRAY_BUFFER );

				}

			}

			return geometry;

		}

		function updateAttribute( attribute, bufferType ) {

			var data = ( attribute instanceof THREE.InterleavedBufferAttribute ) ? attribute.data : attribute;

			var attributeProperties = properties.get( data );

			if ( attributeProperties.__webglBuffer === undefined ) {

				createBuffer( attributeProperties, data, bufferType );

			} else if ( attributeProperties.version !== data.version ) {

				updateBuffer( attributeProperties, data, bufferType );

			}

		}

		function createBuffer( attributeProperties, data, bufferType ) {

			attributeProperties.__webglBuffer = gl.createBuffer();
			gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );

			var usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;

			gl.bufferData( bufferType, data.array, usage );

			attributeProperties.version = data.version;

		}

		function updateBuffer( attributeProperties, data, bufferType ) {

			gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );

			if ( data.dynamic === false || data.updateRange.count === - 1 ) {

				// Not using update ranges

				gl.bufferSubData( bufferType, 0, data.array );

			} else if ( data.updateRange.count === 0 ) {

				console.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );

			} else {

				gl.bufferSubData( bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT,
								  data.array.subarray( data.updateRange.offset, data.updateRange.offset + data.updateRange.count ) );

				data.updateRange.count = 0; // reset range

			}

			attributeProperties.version = data.version;

		}

		function getAttributeBuffer( attribute ) {

			if ( attribute instanceof THREE.InterleavedBufferAttribute ) {

				return properties.get( attribute.data ).__webglBuffer;

			}

			return properties.get( attribute ).__webglBuffer;

		}

		function getWireframeAttribute( geometry ) {

			var property = properties.get( geometry );

			if ( property.wireframe !== undefined ) {

				return property.wireframe;

			}

			var indices = [];

			var index = geometry.index;
			var attributes = geometry.attributes;
			var position = attributes.position;

			// console.time( 'wireframe' );

			if ( index !== null ) {

				var edges = {};
				var array = index.array;

				for ( var i = 0, l = array.length; i < l; i += 3 ) {

					var a = array[ i + 0 ];
					var b = array[ i + 1 ];
					var c = array[ i + 2 ];

					if ( checkEdge( edges, a, b ) ) indices.push( a, b );
					if ( checkEdge( edges, b, c ) ) indices.push( b, c );
					if ( checkEdge( edges, c, a ) ) indices.push( c, a );

				}

			} else {

				var array = attributes.position.array;

				for ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

					var a = i + 0;
					var b = i + 1;
					var c = i + 2;

					indices.push( a, b, b, c, c, a );

				}

			}

			// console.timeEnd( 'wireframe' );

			var TypeArray = position.count > 65535 ? Uint32Array : Uint16Array;
			var attribute = new THREE.BufferAttribute( new TypeArray( indices ), 1 );

			updateAttribute( attribute, gl.ELEMENT_ARRAY_BUFFER );

			property.wireframe = attribute;

			return attribute;

		}

		function checkEdge( edges, a, b ) {

			if ( a > b ) {

				var tmp = a;
				a = b;
				b = tmp;

			}

			var list = edges[ a ];

			if ( list === undefined ) {

				edges[ a ] = [ b ];
				return true;

			} else if ( list.indexOf( b ) === -1 ) {

				list.push( b );
				return true;

			}

			return false;

		}

		this.getAttributeBuffer = getAttributeBuffer;
		this.getWireframeAttribute = getWireframeAttribute;

		this.update = update;

	};

	// File:src/renderers/webgl/WebGLProgram.js

	THREE.WebGLProgram = ( function () {

		var programIdCount = 0;

		function generateDefines( defines ) {

			var chunks = [];

			for ( var name in defines ) {

				var value = defines[ name ];

				if ( value === false ) continue;

				chunks.push( '#define ' + name + ' ' + value );

			}

			return chunks.join( '\n' );

		}

		function fetchUniformLocations( gl, program, identifiers ) {

			var uniforms = {};

			var n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );

			for ( var i = 0; i < n; i ++ ) {

				var info = gl.getActiveUniform( program, i );
				var name = info.name;
				var location = gl.getUniformLocation( program, name );

				// console.log("THREE.WebGLProgram: ACTIVE UNIFORM:", name);

				var suffixPos = name.lastIndexOf( '[0]' );
				if ( suffixPos !== - 1 && suffixPos === name.length - 3 ) {

					uniforms[ name.substr( 0, suffixPos ) ] = location;

				}

				uniforms[ name ] = location;

			}

			return uniforms;

		}

		function fetchAttributeLocations( gl, program, identifiers ) {

			var attributes = {};

			var n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );

			for ( var i = 0; i < n; i ++ ) {

				var info = gl.getActiveAttrib( program, i );
				var name = info.name;

				// console.log("THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:", name, i );

				attributes[ name ] = gl.getAttribLocation( program, name );

			}

			return attributes;

		}

		function filterEmptyLine( string ) {

			return string !== '';

		}

		return function WebGLProgram( renderer, code, material, parameters ) {

			var gl = renderer.context;

			var defines = material.defines;

			var vertexShader = material.__webglShader.vertexShader;
			var fragmentShader = material.__webglShader.fragmentShader;

			var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

			if ( parameters.shadowMapType === THREE.PCFShadowMap ) {

				shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

			} else if ( parameters.shadowMapType === THREE.PCFSoftShadowMap ) {

				shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

			}

			var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
			var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
			var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';

			if ( parameters.envMap ) {

				switch ( material.envMap.mapping ) {

					case THREE.CubeReflectionMapping:
					case THREE.CubeRefractionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
						break;

					case THREE.EquirectangularReflectionMapping:
					case THREE.EquirectangularRefractionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
						break;

					case THREE.SphericalReflectionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
						break;

				}

				switch ( material.envMap.mapping ) {

					case THREE.CubeRefractionMapping:
					case THREE.EquirectangularRefractionMapping:
						envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
						break;

				}

				switch ( material.combine ) {

					case THREE.MultiplyOperation:
						envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
						break;

					case THREE.MixOperation:
						envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
						break;

					case THREE.AddOperation:
						envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
						break;

				}

			}

			var gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;

			// console.log( 'building new program ' );

			//

			var customDefines = generateDefines( defines );

			//

			var program = gl.createProgram();

			var prefixVertex, prefixFragment;

			if ( material instanceof THREE.RawShaderMaterial ) {

				prefixVertex = '';
				prefixFragment = '';

			} else {

				prefixVertex = [

					'precision ' + parameters.precision + ' float;',
					'precision ' + parameters.precision + ' int;',

					'#define SHADER_NAME ' + material.__webglShader.name,

					customDefines,

					parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

					renderer.gammaInput ? '#define GAMMA_INPUT' : '',
					renderer.gammaOutput ? '#define GAMMA_OUTPUT' : '',
					'#define GAMMA_FACTOR ' + gammaFactorDefine,

					'#define MAX_DIR_LIGHTS ' + parameters.maxDirLights,
					'#define MAX_POINT_LIGHTS ' + parameters.maxPointLights,
					'#define MAX_SPOT_LIGHTS ' + parameters.maxSpotLights,
					'#define MAX_HEMI_LIGHTS ' + parameters.maxHemiLights,

					'#define MAX_SHADOWS ' + parameters.maxShadows,

					'#define MAX_BONES ' + parameters.maxBones,

					parameters.map ? '#define USE_MAP' : '',
					parameters.envMap ? '#define USE_ENVMAP' : '',
					parameters.envMap ? '#define ' + envMapModeDefine : '',
					parameters.lightMap ? '#define USE_LIGHTMAP' : '',
					parameters.aoMap ? '#define USE_AOMAP' : '',
					parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
					parameters.bumpMap ? '#define USE_BUMPMAP' : '',
					parameters.normalMap ? '#define USE_NORMALMAP' : '',
					parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
					parameters.specularMap ? '#define USE_SPECULARMAP' : '',
					parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
					parameters.vertexColors ? '#define USE_COLOR' : '',

					parameters.flatShading ? '#define FLAT_SHADED' : '',

					parameters.skinning ? '#define USE_SKINNING' : '',
					parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',

					parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
					parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
					parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
					parameters.flipSided ? '#define FLIP_SIDED' : '',

					parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
					parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
					parameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '',
					parameters.pointLightShadows > 0 ? '#define POINT_LIGHT_SHADOWS' : '',

					parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

					parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
					parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',


					'uniform mat4 modelMatrix;',
					'uniform mat4 modelViewMatrix;',
					'uniform mat4 projectionMatrix;',
					'uniform mat4 viewMatrix;',
					'uniform mat3 normalMatrix;',
					'uniform vec3 cameraPosition;',

					'attribute vec3 position;',
					'attribute vec3 normal;',
					'attribute vec2 uv;',

					'#ifdef USE_COLOR',

					'	attribute vec3 color;',

					'#endif',

					'#ifdef USE_MORPHTARGETS',

					'	attribute vec3 morphTarget0;',
					'	attribute vec3 morphTarget1;',
					'	attribute vec3 morphTarget2;',
					'	attribute vec3 morphTarget3;',

					'	#ifdef USE_MORPHNORMALS',

					'		attribute vec3 morphNormal0;',
					'		attribute vec3 morphNormal1;',
					'		attribute vec3 morphNormal2;',
					'		attribute vec3 morphNormal3;',

					'	#else',

					'		attribute vec3 morphTarget4;',
					'		attribute vec3 morphTarget5;',
					'		attribute vec3 morphTarget6;',
					'		attribute vec3 morphTarget7;',

					'	#endif',

					'#endif',

					'#ifdef USE_SKINNING',

					'	attribute vec4 skinIndex;',
					'	attribute vec4 skinWeight;',

					'#endif',

					'\n'

				].filter( filterEmptyLine ).join( '\n' );

				prefixFragment = [

					parameters.bumpMap || parameters.normalMap || parameters.flatShading || material.derivatives ? '#extension GL_OES_standard_derivatives : enable' : '',
					parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',

					'precision ' + parameters.precision + ' float;',
					'precision ' + parameters.precision + ' int;',

					'#define SHADER_NAME ' + material.__webglShader.name,

					customDefines,

					'#define MAX_DIR_LIGHTS ' + parameters.maxDirLights,
					'#define MAX_POINT_LIGHTS ' + parameters.maxPointLights,
					'#define MAX_SPOT_LIGHTS ' + parameters.maxSpotLights,
					'#define MAX_HEMI_LIGHTS ' + parameters.maxHemiLights,

					'#define MAX_SHADOWS ' + parameters.maxShadows,

					parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',

					renderer.gammaInput ? '#define GAMMA_INPUT' : '',
					renderer.gammaOutput ? '#define GAMMA_OUTPUT' : '',
					'#define GAMMA_FACTOR ' + gammaFactorDefine,

					( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
					( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',

					parameters.map ? '#define USE_MAP' : '',
					parameters.envMap ? '#define USE_ENVMAP' : '',
					parameters.envMap ? '#define ' + envMapTypeDefine : '',
					parameters.envMap ? '#define ' + envMapModeDefine : '',
					parameters.envMap ? '#define ' + envMapBlendingDefine : '',
					parameters.lightMap ? '#define USE_LIGHTMAP' : '',
					parameters.aoMap ? '#define USE_AOMAP' : '',
					parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
					parameters.bumpMap ? '#define USE_BUMPMAP' : '',
					parameters.normalMap ? '#define USE_NORMALMAP' : '',
					parameters.specularMap ? '#define USE_SPECULARMAP' : '',
					parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
					parameters.vertexColors ? '#define USE_COLOR' : '',

					parameters.flatShading ? '#define FLAT_SHADED' : '',

					parameters.metal ? '#define METAL' : '',
					parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
					parameters.flipSided ? '#define FLIP_SIDED' : '',

					parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
					parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
					parameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '',
					parameters.pointLightShadows > 0 ? '#define POINT_LIGHT_SHADOWS' : '',

					parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
					parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

					'uniform mat4 viewMatrix;',
					'uniform vec3 cameraPosition;',

					'\n'

				].filter( filterEmptyLine ).join( '\n' );

			}

			var vertexGlsl = prefixVertex + vertexShader;
			var fragmentGlsl = prefixFragment + fragmentShader;

			var glVertexShader = THREE.WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );
			var glFragmentShader = THREE.WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );

			gl.attachShader( program, glVertexShader );
			gl.attachShader( program, glFragmentShader );

			// Force a particular attribute to index 0.

			if ( material.index0AttributeName !== undefined ) {

				gl.bindAttribLocation( program, 0, material.index0AttributeName );

			} else if ( parameters.morphTargets === true ) {

				// programs with morphTargets displace position out of attribute 0
				gl.bindAttribLocation( program, 0, 'position' );

			}

			gl.linkProgram( program );

			var programLog = gl.getProgramInfoLog( program );
			var vertexLog = gl.getShaderInfoLog( glVertexShader );
			var fragmentLog = gl.getShaderInfoLog( glFragmentShader );

			var runnable = true;
			var haveDiagnostics = true;

			if ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {

				runnable = false;

				console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );

			} else if ( programLog !== '' ) {

				console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );

			} else if ( vertexLog === '' || fragmentLog === '' ) {

				haveDiagnostics = false;

			}

			if ( haveDiagnostics ) {

				this.diagnostics = {

					runnable: runnable,
					material: material,

					programLog: programLog,

					vertexShader: {

						log: vertexLog,
						prefix: prefixVertex

					},

					fragmentShader: {

						log: fragmentLog,
						prefix: prefixFragment

					}

				};

			}

			// clean up

			gl.deleteShader( glVertexShader );
			gl.deleteShader( glFragmentShader );

			// set up caching for uniform locations

			var cachedUniforms;

			this.getUniforms = function() {

				if ( cachedUniforms === undefined ) {

					cachedUniforms = fetchUniformLocations( gl, program );

				}

				return cachedUniforms;

			};

			// set up caching for attribute locations

			var cachedAttributes;

			this.getAttributes = function() {

				if ( cachedAttributes === undefined ) {

					cachedAttributes = fetchAttributeLocations( gl, program );

				}

				return cachedAttributes;

			};

			// free resource

			this.destroy = function() {

				gl.deleteProgram( program );
				this.program = undefined;

			};

			// DEPRECATED

			Object.defineProperties( this, {

				uniforms: {
					get: function() {

						console.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );
						return this.getUniforms();

					}
				},

				attributes: {
					get: function() {

						console.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );
						return this.getAttributes();

					}
				}

			} );


			//

			this.id = programIdCount ++;
			this.code = code;
			this.usedTimes = 1;
			this.program = program;
			this.vertexShader = glVertexShader;
			this.fragmentShader = glFragmentShader;

			return this;

		};

	} )();

	// File:src/renderers/webgl/WebGLPrograms.js

	THREE.WebGLPrograms = function ( renderer, capabilities ) {

		var programs = [];

		var shaderIDs = {
			MeshDepthMaterial: 'depth',
			MeshNormalMaterial: 'normal',
			MeshBasicMaterial: 'basic',
			MeshLambertMaterial: 'lambert',
			MeshPhongMaterial: 'phong',
			LineBasicMaterial: 'basic',
			LineDashedMaterial: 'dashed',
			PointsMaterial: 'points'
		};

		var parameterNames = [
			"precision", "supportsVertexTextures", "map", "envMap", "envMapMode",
			"lightMap", "aoMap", "emissiveMap", "bumpMap", "normalMap", "displacementMap", "specularMap",
			"alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp",
			"flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning",
			"maxBones", "useVertexTexture", "morphTargets", "morphNormals",
			"maxMorphTargets", "maxMorphNormals", "maxDirLights", "maxPointLights",
			"maxSpotLights", "maxHemiLights", "maxShadows", "shadowMapEnabled", "pointLightShadows",
			"shadowMapType", "shadowMapDebug", "alphaTest", "metal", "doubleSided",
			"flipSided"
		];


		function allocateBones ( object ) {

			if ( capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {

				return 1024;

			} else {

				// default for when object is not specified
				// ( for example when prebuilding shader to be used with multiple objects )
				//
				//  - leave some extra space for other uniforms
				//  - limit here is ANGLE's 254 max uniform vectors
				//    (up to 54 should be safe)

				var nVertexUniforms = capabilities.maxVertexUniforms;
				var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

				var maxBones = nVertexMatrices;

				if ( object !== undefined && object instanceof THREE.SkinnedMesh ) {

					maxBones = Math.min( object.skeleton.bones.length, maxBones );

					if ( maxBones < object.skeleton.bones.length ) {

						console.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );

					}

				}

				return maxBones;

			}

		}

		function allocateLights( lights ) {

			var dirLights = 0;
			var pointLights = 0;
			var spotLights = 0;
			var hemiLights = 0;

			for ( var l = 0, ll = lights.length; l < ll; l ++ ) {

				var light = lights[ l ];

				if ( light.visible === false ) continue;

				if ( light instanceof THREE.DirectionalLight ) dirLights ++;
				if ( light instanceof THREE.PointLight ) pointLights ++;
				if ( light instanceof THREE.SpotLight ) spotLights ++;
				if ( light instanceof THREE.HemisphereLight ) hemiLights ++;

			}

			return { 'directional': dirLights, 'point': pointLights, 'spot': spotLights, 'hemi': hemiLights };

		}

		function allocateShadows( lights ) {

			var maxShadows = 0;
			var pointLightShadows = 0;

			for ( var l = 0, ll = lights.length; l < ll; l ++ ) {

				var light = lights[ l ];

				if ( ! light.castShadow ) continue;

				if ( light instanceof THREE.SpotLight || light instanceof THREE.DirectionalLight ) maxShadows ++;
				if ( light instanceof THREE.PointLight ) {

					maxShadows ++;
					pointLightShadows ++;

				}

			}

			return { 'maxShadows': maxShadows, 'pointLightShadows': pointLightShadows };

		}

		this.getParameters = function ( material, lights, fog, object ) {

			var shaderID = shaderIDs[ material.type ];
			// heuristics to create shader parameters according to lights in the scene
			// (not to blow over maxLights budget)

			var maxLightCount = allocateLights( lights );
			var allocatedShadows = allocateShadows( lights );
			var maxBones = allocateBones( object );
			var precision = renderer.getPrecision();

			if ( material.precision !== null ) {

				precision = capabilities.getMaxPrecision( material.precision );

				if ( precision !== material.precision ) {

					console.warn( 'THREE.WebGLRenderer.initMaterial:', material.precision, 'not supported, using', precision, 'instead.' );

				}

			}

			var parameters = {

				shaderID: shaderID,

				precision: precision,
				supportsVertexTextures: capabilities.vertexTextures,

				map: !! material.map,
				envMap: !! material.envMap,
				envMapMode: material.envMap && material.envMap.mapping,
				lightMap: !! material.lightMap,
				aoMap: !! material.aoMap,
				emissiveMap: !! material.emissiveMap,
				bumpMap: !! material.bumpMap,
				normalMap: !! material.normalMap,
				displacementMap: !! material.displacementMap,
				specularMap: !! material.specularMap,
				alphaMap: !! material.alphaMap,

				combine: material.combine,

				vertexColors: material.vertexColors,

				fog: fog,
				useFog: material.fog,
				fogExp: fog instanceof THREE.FogExp2,

				flatShading: material.shading === THREE.FlatShading,

				sizeAttenuation: material.sizeAttenuation,
				logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,

				skinning: material.skinning,
				maxBones: maxBones,
				useVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,

				morphTargets: material.morphTargets,
				morphNormals: material.morphNormals,
				maxMorphTargets: renderer.maxMorphTargets,
				maxMorphNormals: renderer.maxMorphNormals,

				maxDirLights: maxLightCount.directional,
				maxPointLights: maxLightCount.point,
				maxSpotLights: maxLightCount.spot,
				maxHemiLights: maxLightCount.hemi,

				maxShadows: allocatedShadows.maxShadows,
				pointLightShadows: allocatedShadows.pointLightShadows,
				shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && allocatedShadows.maxShadows > 0,
				shadowMapType: renderer.shadowMap.type,
				shadowMapDebug: renderer.shadowMap.debug,

				alphaTest: material.alphaTest,
				metal: material.metal,
				doubleSided: material.side === THREE.DoubleSide,
				flipSided: material.side === THREE.BackSide

			};

			return parameters;

		};

		this.getProgramCode = function ( material, parameters ) {

			var chunks = [];

			if ( parameters.shaderID ) {

				chunks.push( parameters.shaderID );

			} else {

				chunks.push( material.fragmentShader );
				chunks.push( material.vertexShader );

			}

			if ( material.defines !== undefined ) {

				for ( var name in material.defines ) {

					chunks.push( name );
					chunks.push( material.defines[ name ] );

				}

			}

			for ( var i = 0; i < parameterNames.length; i ++ ) {

				var parameterName = parameterNames[ i ];
				chunks.push( parameterName );
				chunks.push( parameters[ parameterName ] );

			}

			return chunks.join();

		};

		this.acquireProgram = function ( material, parameters, code ) {

			var program;

			// Check if code has been already compiled
			for ( var p = 0, pl = programs.length; p < pl; p ++ ) {

				var programInfo = programs[ p ];

				if ( programInfo.code === code ) {

					program = programInfo;
					++ program.usedTimes;

					break;

				}

			}

			if ( program === undefined ) {

				program = new THREE.WebGLProgram( renderer, code, material, parameters );
				programs.push( program );

			}

			return program;

		};

		this.releaseProgram = function( program ) {

			if ( -- program.usedTimes === 0 ) {

				// Remove from unordered set
				var i = programs.indexOf( program );
				programs[ i ] = programs[ programs.length - 1 ];
				programs.pop();

				// Free WebGL resources
				program.destroy();

			}

		};

		// Exposed for resource monitoring & error feedback via renderer.info:
		this.programs = programs;

	};

	// File:src/renderers/webgl/WebGLProperties.js

	/**
	* @author fordacious / fordacious.github.io
	*/

	THREE.WebGLProperties = function () {

		var properties = {};

		this.get = function ( object ) {

			var uuid = object.uuid;
			var map = properties[ uuid ];

			if ( map === undefined ) {

				map = {};
				properties[ uuid ] = map;

			}

			return map;

		};

		this.delete = function ( object ) {

			delete properties[ object.uuid ];

		};

		this.clear = function () {

			properties = {};

		};

	};

	// File:src/renderers/webgl/WebGLShader.js

	THREE.WebGLShader = ( function () {

		function addLineNumbers( string ) {

			var lines = string.split( '\n' );

			for ( var i = 0; i < lines.length; i ++ ) {

				lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];

			}

			return lines.join( '\n' );

		}

		return function WebGLShader( gl, type, string ) {

			var shader = gl.createShader( type );

			gl.shaderSource( shader, string );
			gl.compileShader( shader );

			if ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {

				console.error( 'THREE.WebGLShader: Shader couldn\'t compile.' );

			}

			if ( gl.getShaderInfoLog( shader ) !== '' ) {

				console.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );

			}

			// --enable-privileged-webgl-extension
			// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

			return shader;

		};

	} )();

	// File:src/renderers/webgl/WebGLShadowMap.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.WebGLShadowMap = function ( _renderer, _lights, _objects ) {

		var _gl = _renderer.context,
		_state = _renderer.state,
		_frustum = new THREE.Frustum(),
		_projScreenMatrix = new THREE.Matrix4(),

		_min = new THREE.Vector3(),
		_max = new THREE.Vector3(),

		_lookTarget = new THREE.Vector3(),
		_lightPositionWorld = new THREE.Vector3(),

		_renderList = [],

		_MorphingFlag = 1,
		_SkinningFlag = 2,

		_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,

		_depthMaterials = new Array( _NumberOfMaterialVariants ),
		_distanceMaterials = new Array( _NumberOfMaterialVariants );

		var cubeDirections = [
			new THREE.Vector3( 1, 0, 0 ), new THREE.Vector3( - 1, 0, 0 ), new THREE.Vector3( 0, 0, 1 ),
			new THREE.Vector3( 0, 0, - 1 ), new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, - 1, 0 )
		];

		var cubeUps = [
			new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 1, 0 ),
			new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 0, 1 ),	new THREE.Vector3( 0, 0, - 1 )
		];

		var cube2DViewPorts = [
			new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4(),
			new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4()
		];

		var _vector4 = new THREE.Vector4();

		// init

		var depthShader = THREE.ShaderLib[ "depthRGBA" ];
		var depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );

		var distanceShader = THREE.ShaderLib[ "distanceRGBA" ];
		var distanceUniforms = THREE.UniformsUtils.clone( distanceShader.uniforms );

		for ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {

			var useMorphing = ( i & _MorphingFlag ) !== 0;
			var useSkinning = ( i & _SkinningFlag ) !== 0;

			var depthMaterial = new THREE.ShaderMaterial( {
				uniforms: depthUniforms,
				vertexShader: depthShader.vertexShader,
				fragmentShader: depthShader.fragmentShader,
				morphTargets: useMorphing,
				skinning: useSkinning
			} );

			depthMaterial._shadowPass = true;

			_depthMaterials[ i ] = depthMaterial;

			var distanceMaterial = new THREE.ShaderMaterial( {
				uniforms: distanceUniforms,
				vertexShader: distanceShader.vertexShader,
				fragmentShader: distanceShader.fragmentShader,
				morphTargets: useMorphing,
				skinning: useSkinning
			} );

			distanceMaterial._shadowPass = true;

			_distanceMaterials[ i ] = distanceMaterial;

		}

		//

		var scope = this;

		this.enabled = false;

		this.autoUpdate = true;
		this.needsUpdate = false;

		this.type = THREE.PCFShadowMap;
		this.cullFace = THREE.CullFaceFront;

		this.render = function ( scene ) {

			var faceCount, isPointLight;

			if ( scope.enabled === false ) return;
			if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;

			// Set GL state for depth map.
			_gl.clearColor( 1, 1, 1, 1 );
			_state.disable( _gl.BLEND );
			_state.enable( _gl.CULL_FACE );
			_gl.frontFace( _gl.CCW );
			_gl.cullFace( scope.cullFace === THREE.CullFaceFront ? _gl.FRONT : _gl.BACK );
			_state.setDepthTest( true );

			// save the existing viewport so it can be restored later
			_renderer.getViewport( _vector4 );

			// render depth map

			for ( var i = 0, il = _lights.length; i < il; i ++ ) {

				var light = _lights[ i ];

				if ( light.castShadow === true ) {

					var shadow = light.shadow;
					var shadowCamera = shadow.camera;
					var shadowMapSize = shadow.mapSize;

					if ( light instanceof THREE.PointLight ) {

						faceCount = 6;
						isPointLight = true;

						var vpWidth = shadowMapSize.x / 4.0;
						var vpHeight = shadowMapSize.y / 2.0;

						// These viewports map a cube-map onto a 2D texture with the
						// following orientation:
						//
						//  xzXZ
						//   y Y
						//
						// X - Positive x direction
						// x - Negative x direction
						// Y - Positive y direction
						// y - Negative y direction
						// Z - Positive z direction
						// z - Negative z direction

						// positive X
						cube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );
						// negative X
						cube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );
						// positive Z
						cube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );
						// negative Z
						cube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );
						// positive Y
						cube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );
						// negative Y
						cube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );

					} else {

						faceCount = 1;
						isPointLight = false;

					}

					if ( shadow.map === null ) {

						var shadowFilter = THREE.LinearFilter;

						if ( scope.type === THREE.PCFSoftShadowMap ) {

							shadowFilter = THREE.NearestFilter;

						}

						var pars = { minFilter: shadowFilter, magFilter: shadowFilter, format: THREE.RGBAFormat };

						shadow.map = new THREE.WebGLRenderTarget( shadowMapSize.x, shadowMapSize.y, pars );
						shadow.matrix = new THREE.Matrix4();

						//

						if ( light instanceof THREE.SpotLight ) {

							shadowCamera.aspect = shadowMapSize.x / shadowMapSize.y;

						}

						shadowCamera.updateProjectionMatrix();

					}

					var shadowMap = shadow.map;
					var shadowMatrix = shadow.matrix;

					_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
					shadowCamera.position.copy( _lightPositionWorld );

					_renderer.setRenderTarget( shadowMap );
					_renderer.clear();

					// render shadow map for each cube face (if omni-directional) or
					// run a single pass if not

					for ( var face = 0; face < faceCount; face ++ ) {

						if ( isPointLight ) {

							_lookTarget.copy( shadowCamera.position );
							_lookTarget.add( cubeDirections[ face ] );
							shadowCamera.up.copy( cubeUps[ face ] );
							shadowCamera.lookAt( _lookTarget );
							var vpDimensions = cube2DViewPorts[ face ];
							_renderer.setViewport( vpDimensions.x, vpDimensions.y, vpDimensions.z, vpDimensions.w );

						} else {

							_lookTarget.setFromMatrixPosition( light.target.matrixWorld );
							shadowCamera.lookAt( _lookTarget );

						}

						shadowCamera.updateMatrixWorld();
						shadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );

						// compute shadow matrix

						shadowMatrix.set(
							0.5, 0.0, 0.0, 0.5,
							0.0, 0.5, 0.0, 0.5,
							0.0, 0.0, 0.5, 0.5,
							0.0, 0.0, 0.0, 1.0
						);

						shadowMatrix.multiply( shadowCamera.projectionMatrix );
						shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

						// update camera matrices and frustum

						_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
						_frustum.setFromMatrix( _projScreenMatrix );

						// set object matrices & frustum culling

						_renderList.length = 0;

						projectObject( scene, shadowCamera );

						// render shadow map
						// render regular objects

						for ( var j = 0, jl = _renderList.length; j < jl; j ++ ) {

							var object = _renderList[ j ];
							var geometry = _objects.update( object );
							var material = object.material;

							if ( material instanceof THREE.MeshFaceMaterial ) {

								var groups = geometry.groups;
								var materials = material.materials;

								for ( var k = 0, kl = groups.length; k < kl; k ++ ) {

									var group = groups[ k ];
									var groupMaterial = materials[ group.materialIndex ];

									if ( groupMaterial.visible === true ) {

										var depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld );
										_renderer.renderBufferDirect( shadowCamera, _lights, null, geometry, depthMaterial, object, group );

									}

								}

							} else {

								var depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld );
								_renderer.renderBufferDirect( shadowCamera, _lights, null, geometry, depthMaterial, object, null );

							}

						}

					}

					// We must call _renderer.resetGLState() at the end of each iteration of
					// the light loop in order to force material updates for each light.
					_renderer.resetGLState();

				}

			}

			_renderer.setViewport( _vector4.x, _vector4.y, _vector4.z, _vector4.w );

			// Restore GL state.
			var clearColor = _renderer.getClearColor(),
			clearAlpha = _renderer.getClearAlpha();
			_renderer.setClearColor( clearColor, clearAlpha );
			_state.enable( _gl.BLEND );

			if ( scope.cullFace === THREE.CullFaceFront ) {

				_gl.cullFace( _gl.BACK );

			}

			_renderer.resetGLState();

			scope.needsUpdate = false;

		};

		function getDepthMaterial( object, material, isPointLight, lightPositionWorld ) {

			var geometry = object.geometry;

			var newMaterial = null;

			var materialVariants = _depthMaterials;
			var customMaterial = object.customDepthMaterial;

			if ( isPointLight ) {

				materialVariants = _distanceMaterials;
				customMaterial = object.customDistanceMaterial;

			}

			if ( ! customMaterial ) {

				var useMorphing = geometry.morphTargets !== undefined &&
						geometry.morphTargets.length > 0 && material.morphTargets;

				var useSkinning = object instanceof THREE.SkinnedMesh && material.skinning;

				var variantIndex = 0;

				if ( useMorphing ) variantIndex |= _MorphingFlag;
				if ( useSkinning ) variantIndex |= _SkinningFlag;

				newMaterial = materialVariants[ variantIndex ];

			} else {

				newMaterial = customMaterial;

			}

			newMaterial.visible = material.visible;
			newMaterial.wireframe = material.wireframe;
			newMaterial.wireframeLinewidth = material.wireframeLinewidth;

			if ( isPointLight && newMaterial.uniforms.lightPos !== undefined ) {

				newMaterial.uniforms.lightPos.value.copy( lightPositionWorld );

			}

			return newMaterial;

		}

		function projectObject( object, camera ) {

			if ( object.visible === false ) return;

			if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) {

				if ( object.castShadow && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {

					var material = object.material;

					if ( material.visible === true ) {

						object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
						_renderList.push( object );

					}

				}

			}

			var children = object.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				projectObject( children[ i ], camera );

			}

		}

	};

	// File:src/renderers/webgl/WebGLState.js

	/**
	* @author mrdoob / http://mrdoob.com/
	*/

	THREE.WebGLState = function ( gl, extensions, paramThreeToGL ) {

		var _this = this;

		var newAttributes = new Uint8Array( 16 );
		var enabledAttributes = new Uint8Array( 16 );
		var attributeDivisors = new Uint8Array( 16 );

		var capabilities = {};

		var compressedTextureFormats = null;

		var currentBlending = null;
		var currentBlendEquation = null;
		var currentBlendSrc = null;
		var currentBlendDst = null;
		var currentBlendEquationAlpha = null;
		var currentBlendSrcAlpha = null;
		var currentBlendDstAlpha = null;

		var currentDepthFunc = null;
		var currentDepthWrite = null;

		var currentColorWrite = null;

		var currentFlipSided = null;

		var currentLineWidth = null;

		var currentPolygonOffsetFactor = null;
		var currentPolygonOffsetUnits = null;

		var maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );

		var currentTextureSlot = undefined;
		var currentBoundTextures = {};

		this.init = function () {

			gl.clearColor( 0, 0, 0, 1 );
			gl.clearDepth( 1 );
			gl.clearStencil( 0 );

			this.enable( gl.DEPTH_TEST );
			gl.depthFunc( gl.LEQUAL );

			gl.frontFace( gl.CCW );
			gl.cullFace( gl.BACK );
			this.enable( gl.CULL_FACE );

			this.enable( gl.BLEND );
			gl.blendEquation( gl.FUNC_ADD );
			gl.blendFunc( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA );

		};

		this.initAttributes = function () {

			for ( var i = 0, l = newAttributes.length; i < l; i ++ ) {

				newAttributes[ i ] = 0;

			}

		};

		this.enableAttribute = function ( attribute ) {

			newAttributes[ attribute ] = 1;

			if ( enabledAttributes[ attribute ] === 0 ) {

				gl.enableVertexAttribArray( attribute );
				enabledAttributes[ attribute ] = 1;

			}

			if ( attributeDivisors[ attribute ] !== 0 ) {

				var extension = extensions.get( 'ANGLE_instanced_arrays' );

				extension.vertexAttribDivisorANGLE( attribute, 0 );
				attributeDivisors[ attribute ] = 0;

			}

		};

		this.enableAttributeAndDivisor = function ( attribute, meshPerAttribute, extension ) {

			newAttributes[ attribute ] = 1;

			if ( enabledAttributes[ attribute ] === 0 ) {

				gl.enableVertexAttribArray( attribute );
				enabledAttributes[ attribute ] = 1;

			}

			if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {

				extension.vertexAttribDivisorANGLE( attribute, meshPerAttribute );
				attributeDivisors[ attribute ] = meshPerAttribute;

			}

		};

		this.disableUnusedAttributes = function () {

			for ( var i = 0, l = enabledAttributes.length; i < l; i ++ ) {

				if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

					gl.disableVertexAttribArray( i );
					enabledAttributes[ i ] = 0;

				}

			}

		};

		this.enable = function ( id ) {

			if ( capabilities[ id ] !== true ) {

				gl.enable( id );
				capabilities[ id ] = true;

			}

		};

		this.disable = function ( id ) {

			if ( capabilities[ id ] !== false ) {

				gl.disable( id );
				capabilities[ id ] = false;

			}

		};

		this.getCompressedTextureFormats = function () {

			if ( compressedTextureFormats === null ) {

				compressedTextureFormats = [];

				if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||
				     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ) {

					var formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );

					for ( var i = 0; i < formats.length; i ++ ) {

						compressedTextureFormats.push( formats[ i ] );

					}

				}

			}

			return compressedTextureFormats;

		};

		this.setBlending = function ( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha ) {

			if ( blending !== currentBlending ) {

				if ( blending === THREE.NoBlending ) {

					this.disable( gl.BLEND );

				} else if ( blending === THREE.AdditiveBlending ) {

					this.enable( gl.BLEND );
					gl.blendEquation( gl.FUNC_ADD );
					gl.blendFunc( gl.SRC_ALPHA, gl.ONE );

				} else if ( blending === THREE.SubtractiveBlending ) {

					// TODO: Find blendFuncSeparate() combination

					this.enable( gl.BLEND );
					gl.blendEquation( gl.FUNC_ADD );
					gl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );

				} else if ( blending === THREE.MultiplyBlending ) {

					// TODO: Find blendFuncSeparate() combination

					this.enable( gl.BLEND );
					gl.blendEquation( gl.FUNC_ADD );
					gl.blendFunc( gl.ZERO, gl.SRC_COLOR );

				} else if ( blending === THREE.CustomBlending ) {

					this.enable( gl.BLEND );

				} else {

					this.enable( gl.BLEND );
					gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
					gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );

				}

				currentBlending = blending;

			}

			if ( blending === THREE.CustomBlending ) {

				blendEquationAlpha = blendEquationAlpha || blendEquation;
				blendSrcAlpha = blendSrcAlpha || blendSrc;
				blendDstAlpha = blendDstAlpha || blendDst;

				if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

					gl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );

					currentBlendEquation = blendEquation;
					currentBlendEquationAlpha = blendEquationAlpha;

				}

				if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

					gl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );

					currentBlendSrc = blendSrc;
					currentBlendDst = blendDst;
					currentBlendSrcAlpha = blendSrcAlpha;
					currentBlendDstAlpha = blendDstAlpha;

				}

			} else {

				currentBlendEquation = null;
				currentBlendSrc = null;
				currentBlendDst = null;
				currentBlendEquationAlpha = null;
				currentBlendSrcAlpha = null;
				currentBlendDstAlpha = null;

			}

		};

		this.setDepthFunc = function ( depthFunc ) {

			if ( currentDepthFunc !== depthFunc ) {

				if ( depthFunc ) {

					switch ( depthFunc ) {

						case THREE.NeverDepth:

							gl.depthFunc( gl.NEVER );
							break;

						case THREE.AlwaysDepth:

							gl.depthFunc( gl.ALWAYS );
							break;

						case THREE.LessDepth:

							gl.depthFunc( gl.LESS );
							break;

						case THREE.LessEqualDepth:

							gl.depthFunc( gl.LEQUAL );
							break;

						case THREE.EqualDepth:

							gl.depthFunc( gl.EQUAL );
							break;

						case THREE.GreaterEqualDepth:

							gl.depthFunc( gl.GEQUAL );
							break;

						case THREE.GreaterDepth:

							gl.depthFunc( gl.GREATER );
							break;

						case THREE.NotEqualDepth:

							gl.depthFunc( gl.NOTEQUAL );
							break;

						default:

							gl.depthFunc( gl.LEQUAL );

					}

				} else {

					gl.depthFunc( gl.LEQUAL );

				}

				currentDepthFunc = depthFunc;

			}

		};

		this.setDepthTest = function ( depthTest ) {

			if ( depthTest ) {

				this.enable( gl.DEPTH_TEST );

			} else {

				this.disable( gl.DEPTH_TEST );

			}

		};

		this.setDepthWrite = function ( depthWrite ) {

			if ( currentDepthWrite !== depthWrite ) {

				gl.depthMask( depthWrite );
				currentDepthWrite = depthWrite;

			}

		};

		this.setColorWrite = function ( colorWrite ) {

			if ( currentColorWrite !== colorWrite ) {

				gl.colorMask( colorWrite, colorWrite, colorWrite, colorWrite );
				currentColorWrite = colorWrite;

			}

		};

		this.setFlipSided = function ( flipSided ) {

			if ( currentFlipSided !== flipSided ) {

				if ( flipSided ) {

					gl.frontFace( gl.CW );

				} else {

					gl.frontFace( gl.CCW );

				}

				currentFlipSided = flipSided;

			}

		};

		this.setLineWidth = function ( width ) {

			if ( width !== currentLineWidth ) {

				gl.lineWidth( width );

				currentLineWidth = width;

			}

		};

		this.setPolygonOffset = function ( polygonOffset, factor, units ) {

			if ( polygonOffset ) {

				this.enable( gl.POLYGON_OFFSET_FILL );

			} else {

				this.disable( gl.POLYGON_OFFSET_FILL );

			}

			if ( polygonOffset && ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) ) {

				gl.polygonOffset( factor, units );

				currentPolygonOffsetFactor = factor;
				currentPolygonOffsetUnits = units;

			}

		};

		this.setScissorTest = function ( scissorTest ) {

			if ( scissorTest ) {

				this.enable( gl.SCISSOR_TEST );

			} else {

				this.disable( gl.SCISSOR_TEST );

			}

		};

		// texture

		this.activeTexture = function ( webglSlot ) {

			if ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;

			if ( currentTextureSlot !== webglSlot ) {

				gl.activeTexture( webglSlot );
				currentTextureSlot = webglSlot;

			}

		}

		this.bindTexture = function ( webglType, webglTexture ) {

			if ( currentTextureSlot === undefined ) {

				_this.activeTexture();

			}

			var boundTexture = currentBoundTextures[ currentTextureSlot ];

			if ( boundTexture === undefined ) {

				boundTexture = { type: undefined, texture: undefined };
				currentBoundTextures[ currentTextureSlot ] = boundTexture;

			}

			if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

				gl.bindTexture( webglType, webglTexture );

				boundTexture.type = webglType;
				boundTexture.texture = webglTexture;

			}

		};

		this.compressedTexImage2D = function () {

			try {

				gl.compressedTexImage2D.apply( gl, arguments );

			} catch ( error ) {

				console.error( error );

			}

		};

		this.texImage2D = function () {

			try {

				gl.texImage2D.apply( gl, arguments );

			} catch ( error ) {

				console.error( error );

			}

		};

		//

		this.reset = function () {

			for ( var i = 0; i < enabledAttributes.length; i ++ ) {

				if ( enabledAttributes[ i ] === 1 ) {

					gl.disableVertexAttribArray( i );
					enabledAttributes[ i ] = 0;

				}

			}

			capabilities = {};

			compressedTextureFormats = null;

			currentBlending = null;

			currentDepthWrite = null;
			currentColorWrite = null;

			currentFlipSided = null;

		};

	};

	// File:src/renderers/webgl/plugins/LensFlarePlugin.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.LensFlarePlugin = function ( renderer, flares ) {

		var gl = renderer.context;
		var state = renderer.state;

		var vertexBuffer, elementBuffer;
		var program, attributes, uniforms;
		var hasVertexTexture;

		var tempTexture, occlusionTexture;

		function init() {

			var vertices = new Float32Array( [
				- 1, - 1,  0, 0,
				 1, - 1,  1, 0,
				 1,  1,  1, 1,
				- 1,  1,  0, 1
			] );

			var faces = new Uint16Array( [
				0, 1, 2,
				0, 2, 3
			] );

			// buffers

			vertexBuffer     = gl.createBuffer();
			elementBuffer    = gl.createBuffer();

			gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
			gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

			gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
			gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

			// textures

			tempTexture      = gl.createTexture();
			occlusionTexture = gl.createTexture();

			state.bindTexture( gl.TEXTURE_2D, tempTexture );
			gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

			state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
			gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

			hasVertexTexture = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS ) > 0;

			var shader;

			if ( hasVertexTexture ) {

				shader = {

					vertexShader: [

						"uniform lowp int renderType;",

						"uniform vec3 screenPosition;",
						"uniform vec2 scale;",
						"uniform float rotation;",

						"uniform sampler2D occlusionMap;",

						"attribute vec2 position;",
						"attribute vec2 uv;",

						"varying vec2 vUV;",
						"varying float vVisibility;",

						"void main() {",

							"vUV = uv;",

							"vec2 pos = position;",

							"if ( renderType == 2 ) {",

								"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );",

								"vVisibility =        visibility.r / 9.0;",
								"vVisibility *= 1.0 - visibility.g / 9.0;",
								"vVisibility *=       visibility.b / 9.0;",
								"vVisibility *= 1.0 - visibility.a / 9.0;",

								"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
								"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

							"}",

							"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

						"}"

					].join( "\n" ),

					fragmentShader: [

						"uniform lowp int renderType;",

						"uniform sampler2D map;",
						"uniform float opacity;",
						"uniform vec3 color;",

						"varying vec2 vUV;",
						"varying float vVisibility;",

						"void main() {",

							// pink square

							"if ( renderType == 0 ) {",

								"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );",

							// restore

							"} else if ( renderType == 1 ) {",

								"gl_FragColor = texture2D( map, vUV );",

							// flare

							"} else {",

								"vec4 texture = texture2D( map, vUV );",
								"texture.a *= opacity * vVisibility;",
								"gl_FragColor = texture;",
								"gl_FragColor.rgb *= color;",

							"}",

						"}"

					].join( "\n" )

				};

			} else {

				shader = {

					vertexShader: [

						"uniform lowp int renderType;",

						"uniform vec3 screenPosition;",
						"uniform vec2 scale;",
						"uniform float rotation;",

						"attribute vec2 position;",
						"attribute vec2 uv;",

						"varying vec2 vUV;",

						"void main() {",

							"vUV = uv;",

							"vec2 pos = position;",

							"if ( renderType == 2 ) {",

								"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
								"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

							"}",

							"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

						"}"

					].join( "\n" ),

					fragmentShader: [

						"precision mediump float;",

						"uniform lowp int renderType;",

						"uniform sampler2D map;",
						"uniform sampler2D occlusionMap;",
						"uniform float opacity;",
						"uniform vec3 color;",

						"varying vec2 vUV;",

						"void main() {",

							// pink square

							"if ( renderType == 0 ) {",

								"gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );",

							// restore

							"} else if ( renderType == 1 ) {",

								"gl_FragColor = texture2D( map, vUV );",

							// flare

							"} else {",

								"float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;",
								"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;",
								"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;",
								"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;",
								"visibility = ( 1.0 - visibility / 4.0 );",

								"vec4 texture = texture2D( map, vUV );",
								"texture.a *= opacity * visibility;",
								"gl_FragColor = texture;",
								"gl_FragColor.rgb *= color;",

							"}",

						"}"

					].join( "\n" )

				};

			}

			program = createProgram( shader );

			attributes = {
				vertex: gl.getAttribLocation ( program, "position" ),
				uv:     gl.getAttribLocation ( program, "uv" )
			};

			uniforms = {
				renderType:     gl.getUniformLocation( program, "renderType" ),
				map:            gl.getUniformLocation( program, "map" ),
				occlusionMap:   gl.getUniformLocation( program, "occlusionMap" ),
				opacity:        gl.getUniformLocation( program, "opacity" ),
				color:          gl.getUniformLocation( program, "color" ),
				scale:          gl.getUniformLocation( program, "scale" ),
				rotation:       gl.getUniformLocation( program, "rotation" ),
				screenPosition: gl.getUniformLocation( program, "screenPosition" )
			};

		}

		/*
		 * Render lens flares
		 * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,
		 *         reads these back and calculates occlusion.
		 */

		this.render = function ( scene, camera, viewportWidth, viewportHeight ) {

			if ( flares.length === 0 ) return;

			var tempPosition = new THREE.Vector3();

			var invAspect = viewportHeight / viewportWidth,
				halfViewportWidth = viewportWidth * 0.5,
				halfViewportHeight = viewportHeight * 0.5;

			var size = 16 / viewportHeight,
				scale = new THREE.Vector2( size * invAspect, size );

			var screenPosition = new THREE.Vector3( 1, 1, 0 ),
				screenPositionPixels = new THREE.Vector2( 1, 1 );

			if ( program === undefined ) {

				init();

			}

			gl.useProgram( program );

			state.initAttributes();
			state.enableAttribute( attributes.vertex );
			state.enableAttribute( attributes.uv );
			state.disableUnusedAttributes();

			// loop through all lens flares to update their occlusion and positions
			// setup gl and common used attribs/uniforms

			gl.uniform1i( uniforms.occlusionMap, 0 );
			gl.uniform1i( uniforms.map, 1 );

			gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
			gl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );
			gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

			gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

			state.disable( gl.CULL_FACE );
			gl.depthMask( false );

			for ( var i = 0, l = flares.length; i < l; i ++ ) {

				size = 16 / viewportHeight;
				scale.set( size * invAspect, size );

				// calc object screen position

				var flare = flares[ i ];

				tempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );

				tempPosition.applyMatrix4( camera.matrixWorldInverse );
				tempPosition.applyProjection( camera.projectionMatrix );

				// setup arrays for gl programs

				screenPosition.copy( tempPosition );

				screenPositionPixels.x = screenPosition.x * halfViewportWidth + halfViewportWidth;
				screenPositionPixels.y = screenPosition.y * halfViewportHeight + halfViewportHeight;

				// screen cull

				if ( hasVertexTexture || (
					screenPositionPixels.x > 0 &&
					screenPositionPixels.x < viewportWidth &&
					screenPositionPixels.y > 0 &&
					screenPositionPixels.y < viewportHeight ) ) {

					// save current RGB to temp texture

					state.activeTexture( gl.TEXTURE0 );
					state.bindTexture( gl.TEXTURE_2D, null );
					state.activeTexture( gl.TEXTURE1 );
					state.bindTexture( gl.TEXTURE_2D, tempTexture );
					gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );


					// render pink quad

					gl.uniform1i( uniforms.renderType, 0 );
					gl.uniform2f( uniforms.scale, scale.x, scale.y );
					gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );

					state.disable( gl.BLEND );
					state.enable( gl.DEPTH_TEST );

					gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


					// copy result to occlusionMap

					state.activeTexture( gl.TEXTURE0 );
					state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
					gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );


					// restore graphics

					gl.uniform1i( uniforms.renderType, 1 );
					state.disable( gl.DEPTH_TEST );

					state.activeTexture( gl.TEXTURE1 );
					state.bindTexture( gl.TEXTURE_2D, tempTexture );
					gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


					// update object positions

					flare.positionScreen.copy( screenPosition );

					if ( flare.customUpdateCallback ) {

						flare.customUpdateCallback( flare );

					} else {

						flare.updateLensFlares();

					}

					// render flares

					gl.uniform1i( uniforms.renderType, 2 );
					state.enable( gl.BLEND );

					for ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {

						var sprite = flare.lensFlares[ j ];

						if ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {

							screenPosition.x = sprite.x;
							screenPosition.y = sprite.y;
							screenPosition.z = sprite.z;

							size = sprite.size * sprite.scale / viewportHeight;

							scale.x = size * invAspect;
							scale.y = size;

							gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
							gl.uniform2f( uniforms.scale, scale.x, scale.y );
							gl.uniform1f( uniforms.rotation, sprite.rotation );

							gl.uniform1f( uniforms.opacity, sprite.opacity );
							gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );

							state.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );
							renderer.setTexture( sprite.texture, 1 );

							gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

						}

					}

				}

			}

			// restore gl

			state.enable( gl.CULL_FACE );
			state.enable( gl.DEPTH_TEST );
			gl.depthMask( true );

			renderer.resetGLState();

		};

		function createProgram ( shader ) {

			var program = gl.createProgram();

			var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );
			var vertexShader = gl.createShader( gl.VERTEX_SHADER );

			var prefix = "precision " + renderer.getPrecision() + " float;\n";

			gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );
			gl.shaderSource( vertexShader, prefix + shader.vertexShader );

			gl.compileShader( fragmentShader );
			gl.compileShader( vertexShader );

			gl.attachShader( program, fragmentShader );
			gl.attachShader( program, vertexShader );

			gl.linkProgram( program );

			return program;

		}

	};

	// File:src/renderers/webgl/plugins/SpritePlugin.js

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.SpritePlugin = function ( renderer, sprites ) {

		var gl = renderer.context;
		var state = renderer.state;

		var vertexBuffer, elementBuffer;
		var program, attributes, uniforms;

		var texture;

		// decompose matrixWorld

		var spritePosition = new THREE.Vector3();
		var spriteRotation = new THREE.Quaternion();
		var spriteScale = new THREE.Vector3();

		function init() {

			var vertices = new Float32Array( [
				- 0.5, - 0.5,  0, 0,
				  0.5, - 0.5,  1, 0,
				  0.5,   0.5,  1, 1,
				- 0.5,   0.5,  0, 1
			] );

			var faces = new Uint16Array( [
				0, 1, 2,
				0, 2, 3
			] );

			vertexBuffer  = gl.createBuffer();
			elementBuffer = gl.createBuffer();

			gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
			gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

			gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
			gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

			program = createProgram();

			attributes = {
				position:			gl.getAttribLocation ( program, 'position' ),
				uv:					gl.getAttribLocation ( program, 'uv' )
			};

			uniforms = {
				uvOffset:			gl.getUniformLocation( program, 'uvOffset' ),
				uvScale:			gl.getUniformLocation( program, 'uvScale' ),

				rotation:			gl.getUniformLocation( program, 'rotation' ),
				scale:				gl.getUniformLocation( program, 'scale' ),

				color:				gl.getUniformLocation( program, 'color' ),
				map:				gl.getUniformLocation( program, 'map' ),
				opacity:			gl.getUniformLocation( program, 'opacity' ),

				modelViewMatrix: 	gl.getUniformLocation( program, 'modelViewMatrix' ),
				projectionMatrix:	gl.getUniformLocation( program, 'projectionMatrix' ),

				fogType:			gl.getUniformLocation( program, 'fogType' ),
				fogDensity:			gl.getUniformLocation( program, 'fogDensity' ),
				fogNear:			gl.getUniformLocation( program, 'fogNear' ),
				fogFar:				gl.getUniformLocation( program, 'fogFar' ),
				fogColor:			gl.getUniformLocation( program, 'fogColor' ),

				alphaTest:			gl.getUniformLocation( program, 'alphaTest' )
			};

			var canvas = document.createElement( 'canvas' );
			canvas.width = 8;
			canvas.height = 8;

			var context = canvas.getContext( '2d' );
			context.fillStyle = 'white';
			context.fillRect( 0, 0, 8, 8 );

			texture = new THREE.Texture( canvas );
			texture.needsUpdate = true;

		}

		this.render = function ( scene, camera ) {

			if ( sprites.length === 0 ) return;

			// setup gl

			if ( program === undefined ) {

				init();

			}

			gl.useProgram( program );

			state.initAttributes();
			state.enableAttribute( attributes.position );
			state.enableAttribute( attributes.uv );
			state.disableUnusedAttributes();

			state.disable( gl.CULL_FACE );
			state.enable( gl.BLEND );

			gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
			gl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );
			gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

			gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

			gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

			state.activeTexture( gl.TEXTURE0 );
			gl.uniform1i( uniforms.map, 0 );

			var oldFogType = 0;
			var sceneFogType = 0;
			var fog = scene.fog;

			if ( fog ) {

				gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );

				if ( fog instanceof THREE.Fog ) {

					gl.uniform1f( uniforms.fogNear, fog.near );
					gl.uniform1f( uniforms.fogFar, fog.far );

					gl.uniform1i( uniforms.fogType, 1 );
					oldFogType = 1;
					sceneFogType = 1;

				} else if ( fog instanceof THREE.FogExp2 ) {

					gl.uniform1f( uniforms.fogDensity, fog.density );

					gl.uniform1i( uniforms.fogType, 2 );
					oldFogType = 2;
					sceneFogType = 2;

				}

			} else {

				gl.uniform1i( uniforms.fogType, 0 );
				oldFogType = 0;
				sceneFogType = 0;

			}


			// update positions and sort

			for ( var i = 0, l = sprites.length; i < l; i ++ ) {

				var sprite = sprites[ i ];

				sprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );
				sprite.z = - sprite.modelViewMatrix.elements[ 14 ];

			}

			sprites.sort( painterSortStable );

			// render all sprites

			var scale = [];

			for ( var i = 0, l = sprites.length; i < l; i ++ ) {

				var sprite = sprites[ i ];
				var material = sprite.material;

				gl.uniform1f( uniforms.alphaTest, material.alphaTest );
				gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );

				sprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );

				scale[ 0 ] = spriteScale.x;
				scale[ 1 ] = spriteScale.y;

				var fogType = 0;

				if ( scene.fog && material.fog ) {

					fogType = sceneFogType;

				}

				if ( oldFogType !== fogType ) {

					gl.uniform1i( uniforms.fogType, fogType );
					oldFogType = fogType;

				}

				if ( material.map !== null ) {

					gl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );
					gl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );

				} else {

					gl.uniform2f( uniforms.uvOffset, 0, 0 );
					gl.uniform2f( uniforms.uvScale, 1, 1 );

				}

				gl.uniform1f( uniforms.opacity, material.opacity );
				gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );

				gl.uniform1f( uniforms.rotation, material.rotation );
				gl.uniform2fv( uniforms.scale, scale );

				state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
				state.setDepthTest( material.depthTest );
				state.setDepthWrite( material.depthWrite );

				if ( material.map && material.map.image && material.map.image.width ) {

					renderer.setTexture( material.map, 0 );

				} else {

					renderer.setTexture( texture, 0 );

				}

				gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

			}

			// restore gl

			state.enable( gl.CULL_FACE );

			renderer.resetGLState();

		};

		function createProgram () {

			var program = gl.createProgram();

			var vertexShader = gl.createShader( gl.VERTEX_SHADER );
			var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );

			gl.shaderSource( vertexShader, [

				'precision ' + renderer.getPrecision() + ' float;',

				'uniform mat4 modelViewMatrix;',
				'uniform mat4 projectionMatrix;',
				'uniform float rotation;',
				'uniform vec2 scale;',
				'uniform vec2 uvOffset;',
				'uniform vec2 uvScale;',

				'attribute vec2 position;',
				'attribute vec2 uv;',

				'varying vec2 vUV;',

				'void main() {',

					'vUV = uvOffset + uv * uvScale;',

					'vec2 alignedPosition = position * scale;',

					'vec2 rotatedPosition;',
					'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
					'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',

					'vec4 finalPosition;',

					'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
					'finalPosition.xy += rotatedPosition;',
					'finalPosition = projectionMatrix * finalPosition;',

					'gl_Position = finalPosition;',

				'}'

			].join( '\n' ) );

			gl.shaderSource( fragmentShader, [

				'precision ' + renderer.getPrecision() + ' float;',

				'uniform vec3 color;',
				'uniform sampler2D map;',
				'uniform float opacity;',

				'uniform int fogType;',
				'uniform vec3 fogColor;',
				'uniform float fogDensity;',
				'uniform float fogNear;',
				'uniform float fogFar;',
				'uniform float alphaTest;',

				'varying vec2 vUV;',

				'void main() {',

					'vec4 texture = texture2D( map, vUV );',

					'if ( texture.a < alphaTest ) discard;',

					'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',

					'if ( fogType > 0 ) {',

						'float depth = gl_FragCoord.z / gl_FragCoord.w;',
						'float fogFactor = 0.0;',

						'if ( fogType == 1 ) {',

							'fogFactor = smoothstep( fogNear, fogFar, depth );',

						'} else {',

							'const float LOG2 = 1.442695;',
							'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
							'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',

						'}',

						'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',

					'}',

				'}'

			].join( '\n' ) );

			gl.compileShader( vertexShader );
			gl.compileShader( fragmentShader );

			gl.attachShader( program, vertexShader );
			gl.attachShader( program, fragmentShader );

			gl.linkProgram( program );

			return program;

		}

		function painterSortStable ( a, b ) {

			if ( a.z !== b.z ) {

				return b.z - a.z;

			} else {

				return b.id - a.id;

			}

		}

	};

	// File:src/extras/CurveUtils.js

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 */

	THREE.CurveUtils = {

		tangentQuadraticBezier: function ( t, p0, p1, p2 ) {

			return 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );

		},

		// Puay Bing, thanks for helping with this derivative!

		tangentCubicBezier: function ( t, p0, p1, p2, p3 ) {

			return - 3 * p0 * ( 1 - t ) * ( 1 - t )  +
				3 * p1 * ( 1 - t ) * ( 1 - t ) - 6 * t * p1 * ( 1 - t ) +
				6 * t *  p2 * ( 1 - t ) - 3 * t * t * p2 +
				3 * t * t * p3;

		},

		tangentSpline: function ( t, p0, p1, p2, p3 ) {

			// To check if my formulas are correct

			var h00 = 6 * t * t - 6 * t; 	// derived from 2t^3 â 3t^2 + 1
			var h10 = 3 * t * t - 4 * t + 1; // t^3 â 2t^2 + t
			var h01 = - 6 * t * t + 6 * t; 	// â 2t3 + 3t2
			var h11 = 3 * t * t - 2 * t;	// t3 â t2

			return h00 + h10 + h01 + h11;

		},

		// Catmull-Rom

		interpolate: function( p0, p1, p2, p3, t ) {

			var v0 = ( p2 - p0 ) * 0.5;
			var v1 = ( p3 - p1 ) * 0.5;
			var t2 = t * t;
			var t3 = t * t2;
			return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

		}

	};

	// File:src/extras/GeometryUtils.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.GeometryUtils = {

		merge: function ( geometry1, geometry2, materialIndexOffset ) {

			console.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );

			var matrix;

			if ( geometry2 instanceof THREE.Mesh ) {

				geometry2.matrixAutoUpdate && geometry2.updateMatrix();

				matrix = geometry2.matrix;
				geometry2 = geometry2.geometry;

			}

			geometry1.merge( geometry2, matrix, materialIndexOffset );

		},

		center: function ( geometry ) {

			console.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );
			return geometry.center();

		}

	};

	// File:src/extras/ImageUtils.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author Daosheng Mu / https://github.com/DaoshengMu/
	 */

	THREE.ImageUtils = {

		crossOrigin: undefined,

		loadTexture: function ( url, mapping, onLoad, onError ) {

			console.warn( 'THREE.ImageUtils.loadTexture is being deprecated. Use THREE.TextureLoader() instead.' );

			var loader = new THREE.TextureLoader();
			loader.setCrossOrigin( this.crossOrigin );

			var texture = loader.load( url, onLoad, undefined, onError );

			if ( mapping ) texture.mapping = mapping;

			return texture;

		},

		loadTextureCube: function ( urls, mapping, onLoad, onError ) {

			console.warn( 'THREE.ImageUtils.loadTextureCube is being deprecated. Use THREE.CubeTextureLoader() instead.' );

			var loader = new THREE.CubeTextureLoader();
			loader.setCrossOrigin( this.crossOrigin );

			var texture = loader.load( urls, onLoad, undefined, onError );

			if ( mapping ) texture.mapping = mapping;

			return texture;

		},

		loadCompressedTexture: function () {

			console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' )

		},

		loadCompressedTextureCube: function () {

			console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' )

		}

	};

	// File:src/extras/SceneUtils.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.SceneUtils = {

		createMultiMaterialObject: function ( geometry, materials ) {

			var group = new THREE.Group();

			for ( var i = 0, l = materials.length; i < l; i ++ ) {

				group.add( new THREE.Mesh( geometry, materials[ i ] ) );

			}

			return group;

		},

		detach: function ( child, parent, scene ) {

			child.applyMatrix( parent.matrixWorld );
			parent.remove( child );
			scene.add( child );

		},

		attach: function ( child, scene, parent ) {

			var matrixWorldInverse = new THREE.Matrix4();
			matrixWorldInverse.getInverse( parent.matrixWorld );
			child.applyMatrix( matrixWorldInverse );

			scene.remove( child );
			parent.add( child );

		}

	};

	// File:src/extras/ShapeUtils.js

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 */

	THREE.ShapeUtils = {

		// calculate area of the contour polygon

		area: function ( contour ) {

			var n = contour.length;
			var a = 0.0;

			for ( var p = n - 1, q = 0; q < n; p = q ++ ) {

				a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

			}

			return a * 0.5;

		},

		triangulate: ( function () {

			/**
			 * This code is a quick port of code written in C++ which was submitted to
			 * flipcode.com by John W. Ratcliff  // July 22, 2000
			 * See original code and more information here:
			 * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
			 *
			 * ported to actionscript by Zevan Rosser
			 * www.actionsnippet.com
			 *
			 * ported to javascript by Joshua Koo
			 * http://www.lab4games.net/zz85/blog
			 *
			 */

			function snip( contour, u, v, w, n, verts ) {

				var p;
				var ax, ay, bx, by;
				var cx, cy, px, py;

				ax = contour[ verts[ u ] ].x;
				ay = contour[ verts[ u ] ].y;

				bx = contour[ verts[ v ] ].x;
				by = contour[ verts[ v ] ].y;

				cx = contour[ verts[ w ] ].x;
				cy = contour[ verts[ w ] ].y;

				if ( Number.EPSILON > ( ( ( bx - ax ) * ( cy - ay ) ) - ( ( by - ay ) * ( cx - ax ) ) ) ) return false;

				var aX, aY, bX, bY, cX, cY;
				var apx, apy, bpx, bpy, cpx, cpy;
				var cCROSSap, bCROSScp, aCROSSbp;

				aX = cx - bx;  aY = cy - by;
				bX = ax - cx;  bY = ay - cy;
				cX = bx - ax;  cY = by - ay;

				for ( p = 0; p < n; p ++ ) {

					px = contour[ verts[ p ] ].x;
					py = contour[ verts[ p ] ].y;

					if ( ( ( px === ax ) && ( py === ay ) ) ||
						 ( ( px === bx ) && ( py === by ) ) ||
						 ( ( px === cx ) && ( py === cy ) ) )	continue;

					apx = px - ax;  apy = py - ay;
					bpx = px - bx;  bpy = py - by;
					cpx = px - cx;  cpy = py - cy;

					// see if p is inside triangle abc

					aCROSSbp = aX * bpy - aY * bpx;
					cCROSSap = cX * apy - cY * apx;
					bCROSScp = bX * cpy - bY * cpx;

					if ( ( aCROSSbp >= - Number.EPSILON ) && ( bCROSScp >= - Number.EPSILON ) && ( cCROSSap >= - Number.EPSILON ) ) return false;

				}

				return true;

			}

			// takes in an contour array and returns

			return function ( contour, indices ) {

				var n = contour.length;

				if ( n < 3 ) return null;

				var result = [],
					verts = [],
					vertIndices = [];

				/* we want a counter-clockwise polygon in verts */

				var u, v, w;

				if ( THREE.ShapeUtils.area( contour ) > 0.0 ) {

					for ( v = 0; v < n; v ++ ) verts[ v ] = v;

				} else {

					for ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;

				}

				var nv = n;

				/*  remove nv - 2 vertices, creating 1 triangle every time */

				var count = 2 * nv;   /* error detection */

				for ( v = nv - 1; nv > 2; ) {

					/* if we loop, it is probably a non-simple polygon */

					if ( ( count -- ) <= 0 ) {

						//** Triangulate: ERROR - probable bad polygon!

						//throw ( "Warning, unable to triangulate polygon!" );
						//return null;
						// Sometimes warning is fine, especially polygons are triangulated in reverse.
						console.warn( 'THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()' );

						if ( indices ) return vertIndices;
						return result;

					}

					/* three consecutive vertices in current polygon, <u,v,w> */

					u = v; 	 	if ( nv <= u ) u = 0;     /* previous */
					v = u + 1;  if ( nv <= v ) v = 0;     /* new v    */
					w = v + 1;  if ( nv <= w ) w = 0;     /* next     */

					if ( snip( contour, u, v, w, nv, verts ) ) {

						var a, b, c, s, t;

						/* true names of the vertices */

						a = verts[ u ];
						b = verts[ v ];
						c = verts[ w ];

						/* output Triangle */

						result.push( [ contour[ a ],
							contour[ b ],
							contour[ c ] ] );


						vertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );

						/* remove v from the remaining polygon */

						for ( s = v, t = v + 1; t < nv; s ++, t ++ ) {

							verts[ s ] = verts[ t ];

						}

						nv --;

						/* reset error detection counter */

						count = 2 * nv;

					}

				}

				if ( indices ) return vertIndices;
				return result;

			}

		} )(),

		triangulateShape: function ( contour, holes ) {

			function point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {

				// inOtherPt needs to be collinear to the inSegment
				if ( inSegPt1.x !== inSegPt2.x ) {

					if ( inSegPt1.x < inSegPt2.x ) {

						return	( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );

					} else {

						return	( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );

					}

				} else {

					if ( inSegPt1.y < inSegPt2.y ) {

						return	( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );

					} else {

						return	( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );

					}

				}

			}

			function intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {

				var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
				var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;

				var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
				var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;

				var limit		= seg1dy * seg2dx - seg1dx * seg2dy;
				var perpSeg1	= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;

				if ( Math.abs( limit ) > Number.EPSILON ) {

					// not parallel

					var perpSeg2;
					if ( limit > 0 ) {

						if ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) 		return [];
						perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
						if ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) 		return [];

					} else {

						if ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) 		return [];
						perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
						if ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) 		return [];

					}

					// i.e. to reduce rounding errors
					// intersection at endpoint of segment#1?
					if ( perpSeg2 === 0 ) {

						if ( ( inExcludeAdjacentSegs ) &&
							 ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		return [];
						return [ inSeg1Pt1 ];

					}
					if ( perpSeg2 === limit ) {

						if ( ( inExcludeAdjacentSegs ) &&
							 ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		return [];
						return [ inSeg1Pt2 ];

					}
					// intersection at endpoint of segment#2?
					if ( perpSeg1 === 0 )		return [ inSeg2Pt1 ];
					if ( perpSeg1 === limit )	return [ inSeg2Pt2 ];

					// return real intersection point
					var factorSeg1 = perpSeg2 / limit;
					return	[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,
								y: inSeg1Pt1.y + factorSeg1 * seg1dy } ];

				} else {

					// parallel or collinear
					if ( ( perpSeg1 !== 0 ) ||
						 ( seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy ) ) 			return [];

					// they are collinear or degenerate
					var seg1Pt = ( ( seg1dx === 0 ) && ( seg1dy === 0 ) );	// segment1 is just a point?
					var seg2Pt = ( ( seg2dx === 0 ) && ( seg2dy === 0 ) );	// segment2 is just a point?
					// both segments are points
					if ( seg1Pt && seg2Pt ) {

						if ( ( inSeg1Pt1.x !== inSeg2Pt1.x ) ||
							 ( inSeg1Pt1.y !== inSeg2Pt1.y ) )		return [];	// they are distinct  points
						return [ inSeg1Pt1 ];                 						// they are the same point

					}
					// segment#1  is a single point
					if ( seg1Pt ) {

						if ( ! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )		return [];		// but not in segment#2
						return [ inSeg1Pt1 ];

					}
					// segment#2  is a single point
					if ( seg2Pt ) {

						if ( ! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )		return [];		// but not in segment#1
						return [ inSeg2Pt1 ];

					}

					// they are collinear segments, which might overlap
					var seg1min, seg1max, seg1minVal, seg1maxVal;
					var seg2min, seg2max, seg2minVal, seg2maxVal;
					if ( seg1dx !== 0 ) {

						// the segments are NOT on a vertical line
						if ( inSeg1Pt1.x < inSeg1Pt2.x ) {

							seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;
							seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;

						} else {

							seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;
							seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;

						}
						if ( inSeg2Pt1.x < inSeg2Pt2.x ) {

							seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;
							seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;

						} else {

							seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;
							seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;

						}

					} else {

						// the segments are on a vertical line
						if ( inSeg1Pt1.y < inSeg1Pt2.y ) {

							seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;
							seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;

						} else {

							seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;
							seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;

						}
						if ( inSeg2Pt1.y < inSeg2Pt2.y ) {

							seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;
							seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;

						} else {

							seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;
							seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;

						}

					}
					if ( seg1minVal <= seg2minVal ) {

						if ( seg1maxVal <  seg2minVal )	return [];
						if ( seg1maxVal === seg2minVal )	{

							if ( inExcludeAdjacentSegs )		return [];
							return [ seg2min ];

						}
						if ( seg1maxVal <= seg2maxVal )	return [ seg2min, seg1max ];
						return	[ seg2min, seg2max ];

					} else {

						if ( seg1minVal >  seg2maxVal )	return [];
						if ( seg1minVal === seg2maxVal )	{

							if ( inExcludeAdjacentSegs )		return [];
							return [ seg1min ];

						}
						if ( seg1maxVal <= seg2maxVal )	return [ seg1min, seg1max ];
						return	[ seg1min, seg2max ];

					}

				}

			}

			function isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {

				// The order of legs is important

				// translation of all points, so that Vertex is at (0,0)
				var legFromPtX	= inLegFromPt.x - inVertex.x,  legFromPtY	= inLegFromPt.y - inVertex.y;
				var legToPtX	= inLegToPt.x	- inVertex.x,  legToPtY		= inLegToPt.y	- inVertex.y;
				var otherPtX	= inOtherPt.x	- inVertex.x,  otherPtY		= inOtherPt.y	- inVertex.y;

				// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.
				var from2toAngle	= legFromPtX * legToPtY - legFromPtY * legToPtX;
				var from2otherAngle	= legFromPtX * otherPtY - legFromPtY * otherPtX;

				if ( Math.abs( from2toAngle ) > Number.EPSILON ) {

					// angle != 180 deg.

					var other2toAngle		= otherPtX * legToPtY - otherPtY * legToPtX;
					// console.log( "from2to: " + from2toAngle + ", from2other: " + from2otherAngle + ", other2to: " + other2toAngle );

					if ( from2toAngle > 0 ) {

						// main angle < 180 deg.
						return	( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );

					} else {

						// main angle > 180 deg.
						return	( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );

					}

				} else {

					// angle == 180 deg.
					// console.log( "from2to: 180 deg., from2other: " + from2otherAngle  );
					return	( from2otherAngle > 0 );

				}

			}


			function removeHoles( contour, holes ) {

				var shape = contour.concat(); // work on this shape
				var hole;

				function isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {

					// Check if hole point lies within angle around shape point
					var lastShapeIdx = shape.length - 1;

					var prevShapeIdx = inShapeIdx - 1;
					if ( prevShapeIdx < 0 )			prevShapeIdx = lastShapeIdx;

					var nextShapeIdx = inShapeIdx + 1;
					if ( nextShapeIdx > lastShapeIdx )	nextShapeIdx = 0;

					var insideAngle = isPointInsideAngle( shape[ inShapeIdx ], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[ inHoleIdx ] );
					if ( ! insideAngle ) {

						// console.log( "Vertex (Shape): " + inShapeIdx + ", Point: " + hole[inHoleIdx].x + "/" + hole[inHoleIdx].y );
						return	false;

					}

					// Check if shape point lies within angle around hole point
					var lastHoleIdx = hole.length - 1;

					var prevHoleIdx = inHoleIdx - 1;
					if ( prevHoleIdx < 0 )			prevHoleIdx = lastHoleIdx;

					var nextHoleIdx = inHoleIdx + 1;
					if ( nextHoleIdx > lastHoleIdx )	nextHoleIdx = 0;

					insideAngle = isPointInsideAngle( hole[ inHoleIdx ], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[ inShapeIdx ] );
					if ( ! insideAngle ) {

						// console.log( "Vertex (Hole): " + inHoleIdx + ", Point: " + shape[inShapeIdx].x + "/" + shape[inShapeIdx].y );
						return	false;

					}

					return	true;

				}

				function intersectsShapeEdge( inShapePt, inHolePt ) {

					// checks for intersections with shape edges
					var sIdx, nextIdx, intersection;
					for ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {

						nextIdx = sIdx + 1; nextIdx %= shape.length;
						intersection = intersect_segments_2D( inShapePt, inHolePt, shape[ sIdx ], shape[ nextIdx ], true );
						if ( intersection.length > 0 )		return	true;

					}

					return	false;

				}

				var indepHoles = [];

				function intersectsHoleEdge( inShapePt, inHolePt ) {

					// checks for intersections with hole edges
					var ihIdx, chkHole,
						hIdx, nextIdx, intersection;
					for ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {

						chkHole = holes[ indepHoles[ ihIdx ]];
						for ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {

							nextIdx = hIdx + 1; nextIdx %= chkHole.length;
							intersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[ hIdx ], chkHole[ nextIdx ], true );
							if ( intersection.length > 0 )		return	true;

						}

					}
					return	false;

				}

				var holeIndex, shapeIndex,
					shapePt, holePt,
					holeIdx, cutKey, failedCuts = [],
					tmpShape1, tmpShape2,
					tmpHole1, tmpHole2;

				for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

					indepHoles.push( h );

				}

				var minShapeIndex = 0;
				var counter = indepHoles.length * 2;
				while ( indepHoles.length > 0 ) {

					counter --;
					if ( counter < 0 ) {

						console.log( "Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!" );
						break;

					}

					// search for shape-vertex and hole-vertex,
					// which can be connected without intersections
					for ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {

						shapePt = shape[ shapeIndex ];
						holeIndex	= - 1;

						// search for hole which can be reached without intersections
						for ( var h = 0; h < indepHoles.length; h ++ ) {

							holeIdx = indepHoles[ h ];

							// prevent multiple checks
							cutKey = shapePt.x + ":" + shapePt.y + ":" + holeIdx;
							if ( failedCuts[ cutKey ] !== undefined )			continue;

							hole = holes[ holeIdx ];
							for ( var h2 = 0; h2 < hole.length; h2 ++ ) {

								holePt = hole[ h2 ];
								if ( ! isCutLineInsideAngles( shapeIndex, h2 ) )		continue;
								if ( intersectsShapeEdge( shapePt, holePt ) )		continue;
								if ( intersectsHoleEdge( shapePt, holePt ) )		continue;

								holeIndex = h2;
								indepHoles.splice( h, 1 );

								tmpShape1 = shape.slice( 0, shapeIndex + 1 );
								tmpShape2 = shape.slice( shapeIndex );
								tmpHole1 = hole.slice( holeIndex );
								tmpHole2 = hole.slice( 0, holeIndex + 1 );

								shape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );

								minShapeIndex = shapeIndex;

								// Debug only, to show the selected cuts
								// glob_CutLines.push( [ shapePt, holePt ] );

								break;

							}
							if ( holeIndex >= 0 )	break;		// hole-vertex found

							failedCuts[ cutKey ] = true;			// remember failure

						}
						if ( holeIndex >= 0 )	break;		// hole-vertex found

					}

				}

				return shape; 			/* shape with no holes */

			}


			var i, il, f, face,
				key, index,
				allPointsMap = {};

			// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.

			var allpoints = contour.concat();

			for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

				Array.prototype.push.apply( allpoints, holes[ h ] );

			}

			//console.log( "allpoints",allpoints, allpoints.length );

			// prepare all points map

			for ( i = 0, il = allpoints.length; i < il; i ++ ) {

				key = allpoints[ i ].x + ":" + allpoints[ i ].y;

				if ( allPointsMap[ key ] !== undefined ) {

					console.warn( "THREE.Shape: Duplicate point", key );

				}

				allPointsMap[ key ] = i;

			}

			// remove holes by cutting paths to holes and adding them to the shape
			var shapeWithoutHoles = removeHoles( contour, holes );

			var triangles = THREE.ShapeUtils.triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape
			//console.log( "triangles",triangles, triangles.length );

			// check all face vertices against all points map

			for ( i = 0, il = triangles.length; i < il; i ++ ) {

				face = triangles[ i ];

				for ( f = 0; f < 3; f ++ ) {

					key = face[ f ].x + ":" + face[ f ].y;

					index = allPointsMap[ key ];

					if ( index !== undefined ) {

						face[ f ] = index;

					}

				}

			}

			return triangles.concat();

		},

		isClockWise: function ( pts ) {

			return THREE.ShapeUtils.area( pts ) < 0;

		},

		// Bezier Curves formulas obtained from
		// http://en.wikipedia.org/wiki/B%C3%A9zier_curve

		// Quad Bezier Functions

		b2: ( function () {

			function b2p0( t, p ) {

				var k = 1 - t;
				return k * k * p;

			}

			function b2p1( t, p ) {

				return 2 * ( 1 - t ) * t * p;

			}

			function b2p2( t, p ) {

				return t * t * p;

			}

			return function ( t, p0, p1, p2 ) {

				return b2p0( t, p0 ) + b2p1( t, p1 ) + b2p2( t, p2 );

			};

		} )(),

		// Cubic Bezier Functions

		b3: ( function () {

			function b3p0( t, p ) {

				var k = 1 - t;
				return k * k * k * p;

			}

			function b3p1( t, p ) {

				var k = 1 - t;
				return 3 * k * k * t * p;

			}

			function b3p2( t, p ) {

				var k = 1 - t;
				return 3 * k * t * t * p;

			}

			function b3p3( t, p ) {

				return t * t * t * p;

			}

			return function ( t, p0, p1, p2, p3 ) {

				return b3p0( t, p0 ) + b3p1( t, p1 ) + b3p2( t, p2 ) + b3p3( t, p3 );

			};

		} )()

	};

	// File:src/extras/audio/Audio.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.Audio = function ( listener ) {

		THREE.Object3D.call( this );

		this.type = 'Audio';

		this.context = listener.context;
		this.source = this.context.createBufferSource();
		this.source.onended = this.onEnded.bind( this );

		this.gain = this.context.createGain();
		this.gain.connect( this.context.destination );

		this.panner = this.context.createPanner();
		this.panner.connect( this.gain );

		this.autoplay = false;

		this.startTime = 0;
		this.playbackRate = 1;
		this.isPlaying = false;

	};

	THREE.Audio.prototype = Object.create( THREE.Object3D.prototype );
	THREE.Audio.prototype.constructor = THREE.Audio;

	THREE.Audio.prototype.load = function ( file ) {

		var scope = this;

		var request = new XMLHttpRequest();
		request.open( 'GET', file, true );
		request.responseType = 'arraybuffer';
		request.onload = function ( e ) {

			scope.context.decodeAudioData( this.response, function ( buffer ) {

				scope.source.buffer = buffer;

				if ( scope.autoplay ) scope.play();

			} );

		};
		request.send();

		return this;

	};

	THREE.Audio.prototype.play = function () {

		if ( this.isPlaying === true ) {

			console.warn( 'THREE.Audio: Audio is already playing.' );
			return;

		}

		var source = this.context.createBufferSource();

		source.buffer = this.source.buffer;
		source.loop = this.source.loop;
		source.onended = this.source.onended;
		source.start( 0, this.startTime );
		source.playbackRate.value = this.playbackRate;

		this.isPlaying = true;

		this.source = source;

		this.connect();

	};

	THREE.Audio.prototype.pause = function () {

		this.source.stop();
		this.startTime = this.context.currentTime;

	};

	THREE.Audio.prototype.stop = function () {

		this.source.stop();
		this.startTime = 0;

	};

	THREE.Audio.prototype.connect = function () {

		if ( this.filter !== undefined ) {

			this.source.connect( this.filter );
			this.filter.connect( this.panner );

		} else {

			this.source.connect( this.panner );

		}

	};

	THREE.Audio.prototype.disconnect = function () {

		if ( this.filter !== undefined ) {

			this.source.disconnect( this.filter );
			this.filter.disconnect( this.panner );

		} else {

			this.source.disconnect( this.panner );

		}

	};

	THREE.Audio.prototype.setFilter = function ( value ) {

		if ( this.isPlaying === true ) {

			this.disconnect();
			this.filter = value;
			this.connect();

		} else {

			this.filter = value;

		}

	};

	THREE.Audio.prototype.getFilter = function () {

		return this.filter;

	};

	THREE.Audio.prototype.setPlaybackRate = function ( value ) {

		this.playbackRate = value;

		if ( this.isPlaying === true ) {

			this.source.playbackRate.value = this.playbackRate;

		}

	};

	THREE.Audio.prototype.getPlaybackRate = function () {

		return this.playbackRate;

	};

	THREE.Audio.prototype.onEnded = function() {

		this.isPlaying = false;

	};

	THREE.Audio.prototype.setLoop = function ( value ) {

		this.source.loop = value;

	};

	THREE.Audio.prototype.getLoop = function () {

		return this.source.loop;

	};

	THREE.Audio.prototype.setRefDistance = function ( value ) {

		this.panner.refDistance = value;

	};

	THREE.Audio.prototype.getRefDistance = function () {

		return this.panner.refDistance;

	};

	THREE.Audio.prototype.setRolloffFactor = function ( value ) {

		this.panner.rolloffFactor = value;

	};

	THREE.Audio.prototype.getRolloffFactor = function () {

		return this.panner.rolloffFactor;

	};

	THREE.Audio.prototype.setVolume = function ( value ) {

		this.gain.gain.value = value;

	};

	THREE.Audio.prototype.getVolume = function () {

		return this.gain.gain.value;

	};

	THREE.Audio.prototype.updateMatrixWorld = ( function () {

		var position = new THREE.Vector3();

		return function updateMatrixWorld( force ) {

			THREE.Object3D.prototype.updateMatrixWorld.call( this, force );

			position.setFromMatrixPosition( this.matrixWorld );

			this.panner.setPosition( position.x, position.y, position.z );

		};

	} )();

	// File:src/extras/audio/AudioListener.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.AudioListener = function () {

		THREE.Object3D.call( this );

		this.type = 'AudioListener';

		this.context = new ( window.AudioContext || window.webkitAudioContext )();

	};

	THREE.AudioListener.prototype = Object.create( THREE.Object3D.prototype );
	THREE.AudioListener.prototype.constructor = THREE.AudioListener;

	THREE.AudioListener.prototype.updateMatrixWorld = ( function () {

		var position = new THREE.Vector3();
		var quaternion = new THREE.Quaternion();
		var scale = new THREE.Vector3();

		var orientation = new THREE.Vector3();

		return function updateMatrixWorld( force ) {

			THREE.Object3D.prototype.updateMatrixWorld.call( this, force );

			var listener = this.context.listener;
			var up = this.up;

			this.matrixWorld.decompose( position, quaternion, scale );

			orientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );

			listener.setPosition( position.x, position.y, position.z );
			listener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );

		};

	} )();

	// File:src/extras/core/Curve.js

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Extensible curve object
	 *
	 * Some common of Curve methods
	 * .getPoint(t), getTangent(t)
	 * .getPointAt(u), getTagentAt(u)
	 * .getPoints(), .getSpacedPoints()
	 * .getLength()
	 * .updateArcLengths()
	 *
	 * This following classes subclasses THREE.Curve:
	 *
	 * -- 2d classes --
	 * THREE.LineCurve
	 * THREE.QuadraticBezierCurve
	 * THREE.CubicBezierCurve
	 * THREE.SplineCurve
	 * THREE.ArcCurve
	 * THREE.EllipseCurve
	 *
	 * -- 3d classes --
	 * THREE.LineCurve3
	 * THREE.QuadraticBezierCurve3
	 * THREE.CubicBezierCurve3
	 * THREE.SplineCurve3
	 * THREE.ClosedSplineCurve3
	 *
	 * A series of curves can be represented as a THREE.CurvePath
	 *
	 **/

	/**************************************************************
	 *	Abstract Curve base class
	 **************************************************************/

	THREE.Curve = function () {

	};

	THREE.Curve.prototype = {

		constructor: THREE.Curve,

		// Virtual base class method to overwrite and implement in subclasses
		//	- t [0 .. 1]

		getPoint: function ( t ) {

			console.warn( "THREE.Curve: Warning, getPoint() not implemented!" );
			return null;

		},

		// Get point at relative position in curve according to arc length
		// - u [0 .. 1]

		getPointAt: function ( u ) {

			var t = this.getUtoTmapping( u );
			return this.getPoint( t );

		},

		// Get sequence of points using getPoint( t )

		getPoints: function ( divisions ) {

			if ( ! divisions ) divisions = 5;

			var d, pts = [];

			for ( d = 0; d <= divisions; d ++ ) {

				pts.push( this.getPoint( d / divisions ) );

			}

			return pts;

		},

		// Get sequence of points using getPointAt( u )

		getSpacedPoints: function ( divisions ) {

			if ( ! divisions ) divisions = 5;

			var d, pts = [];

			for ( d = 0; d <= divisions; d ++ ) {

				pts.push( this.getPointAt( d / divisions ) );

			}

			return pts;

		},

		// Get total curve arc length

		getLength: function () {

			var lengths = this.getLengths();
			return lengths[ lengths.length - 1 ];

		},

		// Get list of cumulative segment lengths

		getLengths: function ( divisions ) {

			if ( ! divisions ) divisions = ( this.__arcLengthDivisions ) ? ( this.__arcLengthDivisions ) : 200;

			if ( this.cacheArcLengths
				&& ( this.cacheArcLengths.length === divisions + 1 )
				&& ! this.needsUpdate ) {

				//console.log( "cached", this.cacheArcLengths );
				return this.cacheArcLengths;

			}

			this.needsUpdate = false;

			var cache = [];
			var current, last = this.getPoint( 0 );
			var p, sum = 0;

			cache.push( 0 );

			for ( p = 1; p <= divisions; p ++ ) {

				current = this.getPoint ( p / divisions );
				sum += current.distanceTo( last );
				cache.push( sum );
				last = current;

			}

			this.cacheArcLengths = cache;

			return cache; // { sums: cache, sum:sum }; Sum is in the last element.

		},

		updateArcLengths: function() {

			this.needsUpdate = true;
			this.getLengths();

		},

		// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

		getUtoTmapping: function ( u, distance ) {

			var arcLengths = this.getLengths();

			var i = 0, il = arcLengths.length;

			var targetArcLength; // The targeted u distance value to get

			if ( distance ) {

				targetArcLength = distance;

			} else {

				targetArcLength = u * arcLengths[ il - 1 ];

			}

			//var time = Date.now();

			// binary search for the index with largest value smaller than target u distance

			var low = 0, high = il - 1, comparison;

			while ( low <= high ) {

				i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

				comparison = arcLengths[ i ] - targetArcLength;

				if ( comparison < 0 ) {

					low = i + 1;

				} else if ( comparison > 0 ) {

					high = i - 1;

				} else {

					high = i;
					break;

					// DONE

				}

			}

			i = high;

			//console.log('b' , i, low, high, Date.now()- time);

			if ( arcLengths[ i ] === targetArcLength ) {

				var t = i / ( il - 1 );
				return t;

			}

			// we could get finer grain at lengths, or use simple interpolation between two points

			var lengthBefore = arcLengths[ i ];
			var lengthAfter = arcLengths[ i + 1 ];

			var segmentLength = lengthAfter - lengthBefore;

			// determine where we are between the 'before' and 'after' points

			var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

			// add that fractional amount to t

			var t = ( i + segmentFraction ) / ( il - 1 );

			return t;

		},

		// Returns a unit vector tangent at t
		// In case any sub curve does not implement its tangent derivation,
		// 2 points a small delta apart will be used to find its gradient
		// which seems to give a reasonable approximation

		getTangent: function( t ) {

			var delta = 0.0001;
			var t1 = t - delta;
			var t2 = t + delta;

			// Capping in case of danger

			if ( t1 < 0 ) t1 = 0;
			if ( t2 > 1 ) t2 = 1;

			var pt1 = this.getPoint( t1 );
			var pt2 = this.getPoint( t2 );

			var vec = pt2.clone().sub( pt1 );
			return vec.normalize();

		},

		getTangentAt: function ( u ) {

			var t = this.getUtoTmapping( u );
			return this.getTangent( t );

		}

	}

	THREE.Curve.Utils = THREE.CurveUtils; // backwards compatibility

	// TODO: Transformation for Curves?

	/**************************************************************
	 *	3D Curves
	 **************************************************************/

	// A Factory method for creating new curve subclasses

	THREE.Curve.create = function ( constructor, getPointFunc ) {

		constructor.prototype = Object.create( THREE.Curve.prototype );
		constructor.prototype.constructor = constructor;
		constructor.prototype.getPoint = getPointFunc;

		return constructor;

	};

	// File:src/extras/core/CurvePath.js

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 *
	 **/

	/**************************************************************
	 *	Curved Path - a curve path is simply a array of connected
	 *  curves, but retains the api of a curve
	 **************************************************************/

	THREE.CurvePath = function () {

		this.curves = [];

		this.autoClose = false; // Automatically closes the path

	};

	THREE.CurvePath.prototype = Object.create( THREE.Curve.prototype );
	THREE.CurvePath.prototype.constructor = THREE.CurvePath;

	THREE.CurvePath.prototype.add = function ( curve ) {

		this.curves.push( curve );

	};

	/*
	THREE.CurvePath.prototype.checkConnection = function() {
		// TODO
		// If the ending of curve is not connected to the starting
		// or the next curve, then, this is not a real path
	};
	*/

	THREE.CurvePath.prototype.closePath = function() {

		// TODO Test
		// and verify for vector3 (needs to implement equals)
		// Add a line curve if start and end of lines are not connected
		var startPoint = this.curves[ 0 ].getPoint( 0 );
		var endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );

		if ( ! startPoint.equals( endPoint ) ) {

			this.curves.push( new THREE.LineCurve( endPoint, startPoint ) );

		}

	};

	// To get accurate point with reference to
	// entire path distance at time t,
	// following has to be done:

	// 1. Length of each sub path have to be known
	// 2. Locate and identify type of curve
	// 3. Get t for the curve
	// 4. Return curve.getPointAt(t')

	THREE.CurvePath.prototype.getPoint = function( t ) {

		var d = t * this.getLength();
		var curveLengths = this.getCurveLengths();
		var i = 0;

		// To think about boundaries points.

		while ( i < curveLengths.length ) {

			if ( curveLengths[ i ] >= d ) {

				var diff = curveLengths[ i ] - d;
				var curve = this.curves[ i ];

				var u = 1 - diff / curve.getLength();

				return curve.getPointAt( u );

			}

			i ++;

		}

		return null;

		// loop where sum != 0, sum > d , sum+1 <d

	};

	/*
	THREE.CurvePath.prototype.getTangent = function( t ) {
	};
	*/

	// We cannot use the default THREE.Curve getPoint() with getLength() because in
	// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
	// getPoint() depends on getLength

	THREE.CurvePath.prototype.getLength = function() {

		var lens = this.getCurveLengths();
		return lens[ lens.length - 1 ];

	};

	// Compute lengths and cache them
	// We cannot overwrite getLengths() because UtoT mapping uses it.

	THREE.CurvePath.prototype.getCurveLengths = function() {

		// We use cache values if curves and cache array are same length

		if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {

			return this.cacheLengths;

		}

		// Get length of sub-curve
		// Push sums into cached array

		var lengths = [], sums = 0;

		for ( var i = 0, l = this.curves.length; i < l; i ++ ) {

			sums += this.curves[ i ].getLength();
			lengths.push( sums );

		}

		this.cacheLengths = lengths;

		return lengths;

	};



	/**************************************************************
	 *	Create Geometries Helpers
	 **************************************************************/

	/// Generate geometry from path points (for Line or Points objects)

	THREE.CurvePath.prototype.createPointsGeometry = function( divisions ) {

		var pts = this.getPoints( divisions, true );
		return this.createGeometry( pts );

	};

	// Generate geometry from equidistant sampling along the path

	THREE.CurvePath.prototype.createSpacedPointsGeometry = function( divisions ) {

		var pts = this.getSpacedPoints( divisions, true );
		return this.createGeometry( pts );

	};

	THREE.CurvePath.prototype.createGeometry = function( points ) {

		var geometry = new THREE.Geometry();

		for ( var i = 0, l = points.length; i < l; i ++ ) {

			var point = points[ i ];
			geometry.vertices.push( new THREE.Vector3( point.x, point.y, point.z || 0 ) );

		}

		return geometry;

	};

	// File:src/extras/core/Path.js

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Creates free form 2d path using series of points, lines or curves.
	 *
	 **/

	THREE.Path = function ( points ) {

		THREE.CurvePath.call( this );

		this.actions = [];

		if ( points ) {

			this.fromPoints( points );

		}

	};

	THREE.Path.prototype = Object.create( THREE.CurvePath.prototype );
	THREE.Path.prototype.constructor = THREE.Path;

	// TODO Clean up PATH API

	// Create path using straight lines to connect all points
	// - vectors: array of Vector2

	THREE.Path.prototype.fromPoints = function ( vectors ) {

		this.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );

		for ( var i = 1, l = vectors.length; i < l; i ++ ) {

			this.lineTo( vectors[ i ].x, vectors[ i ].y );

		}

	};

	// startPath() endPath()?

	THREE.Path.prototype.moveTo = function ( x, y ) {

		this.actions.push( { action: 'moveTo', args: [ x, y ] } );

	};

	THREE.Path.prototype.lineTo = function ( x, y ) {

		var lastargs = this.actions[ this.actions.length - 1 ].args;

		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];

		var curve = new THREE.LineCurve( new THREE.Vector2( x0, y0 ), new THREE.Vector2( x, y ) );
		this.curves.push( curve );

		this.actions.push( { action: 'lineTo', args: [ x, y ] } );

	};

	THREE.Path.prototype.quadraticCurveTo = function( aCPx, aCPy, aX, aY ) {

		var lastargs = this.actions[ this.actions.length - 1 ].args;

		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];

		var curve = new THREE.QuadraticBezierCurve(
			new THREE.Vector2( x0, y0 ),
			new THREE.Vector2( aCPx, aCPy ),
			new THREE.Vector2( aX, aY )
		);

		this.curves.push( curve );

		this.actions.push( { action: 'quadraticCurveTo', args: [ aCPx, aCPy, aX, aY ] } );

	};

	THREE.Path.prototype.bezierCurveTo = function( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

		var lastargs = this.actions[ this.actions.length - 1 ].args;

		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];

		var curve = new THREE.CubicBezierCurve(
			new THREE.Vector2( x0, y0 ),
			new THREE.Vector2( aCP1x, aCP1y ),
			new THREE.Vector2( aCP2x, aCP2y ),
			new THREE.Vector2( aX, aY )
		);

		this.curves.push( curve );

		this.actions.push( { action: 'bezierCurveTo', args: [ aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ] } );

	};

	THREE.Path.prototype.splineThru = function( pts /*Array of Vector*/ ) {

		var args = Array.prototype.slice.call( arguments );

		var lastargs = this.actions[ this.actions.length - 1 ].args;

		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];

		var npts = [ new THREE.Vector2( x0, y0 ) ];
		Array.prototype.push.apply( npts, pts );

		var curve = new THREE.SplineCurve( npts );
		this.curves.push( curve );

		this.actions.push( { action: 'splineThru', args: args } );

	};

	// FUTURE: Change the API or follow canvas API?

	THREE.Path.prototype.arc = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

		var lastargs = this.actions[ this.actions.length - 1 ].args;
		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];

		this.absarc( aX + x0, aY + y0, aRadius,
			aStartAngle, aEndAngle, aClockwise );

	 };

	 THREE.Path.prototype.absarc = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

		this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

	 };

	THREE.Path.prototype.ellipse = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

		var lastargs = this.actions[ this.actions.length - 1 ].args;
		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];

		this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

	 };


	THREE.Path.prototype.absellipse = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

		var args = [
			aX, aY,
			xRadius, yRadius,
			aStartAngle, aEndAngle,
			aClockwise,
			aRotation || 0 // aRotation is optional.
		];

		var curve = new THREE.EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );
		this.curves.push( curve );

		var lastPoint = curve.getPoint( 1 );
		args.push( lastPoint.x );
		args.push( lastPoint.y );

		this.actions.push( { action: 'ellipse', args: args } );

	 };

	THREE.Path.prototype.getSpacedPoints = function ( divisions, closedPath ) {

		if ( ! divisions ) divisions = 40;

		var points = [];

		for ( var i = 0; i < divisions; i ++ ) {

			points.push( this.getPoint( i / divisions ) );

			//if ( !this.getPoint( i / divisions ) ) throw "DIE";

		}

		// if ( closedPath ) {
		//
		// 	points.push( points[ 0 ] );
		//
		// }

		return points;

	};

	/* Return an array of vectors based on contour of the path */

	THREE.Path.prototype.getPoints = function( divisions, closedPath ) {

		divisions = divisions || 12;

		var b2 = THREE.ShapeUtils.b2;
		var b3 = THREE.ShapeUtils.b3;

		var points = [];

		var cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0,
			laste, tx, ty;

		for ( var i = 0, l = this.actions.length; i < l; i ++ ) {

			var item = this.actions[ i ];

			var action = item.action;
			var args = item.args;

			switch ( action ) {

			case 'moveTo':

				points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );

				break;

			case 'lineTo':

				points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );

				break;

			case 'quadraticCurveTo':

				cpx  = args[ 2 ];
				cpy  = args[ 3 ];

				cpx1 = args[ 0 ];
				cpy1 = args[ 1 ];

				if ( points.length > 0 ) {

					laste = points[ points.length - 1 ];

					cpx0 = laste.x;
					cpy0 = laste.y;

				} else {

					laste = this.actions[ i - 1 ].args;

					cpx0 = laste[ laste.length - 2 ];
					cpy0 = laste[ laste.length - 1 ];

				}

				for ( var j = 1; j <= divisions; j ++ ) {

					var t = j / divisions;

					tx = b2( t, cpx0, cpx1, cpx );
					ty = b2( t, cpy0, cpy1, cpy );

					points.push( new THREE.Vector2( tx, ty ) );

				}

				break;

			case 'bezierCurveTo':

				cpx  = args[ 4 ];
				cpy  = args[ 5 ];

				cpx1 = args[ 0 ];
				cpy1 = args[ 1 ];

				cpx2 = args[ 2 ];
				cpy2 = args[ 3 ];

				if ( points.length > 0 ) {

					laste = points[ points.length - 1 ];

					cpx0 = laste.x;
					cpy0 = laste.y;

				} else {

					laste = this.actions[ i - 1 ].args;

					cpx0 = laste[ laste.length - 2 ];
					cpy0 = laste[ laste.length - 1 ];

				}


				for ( var j = 1; j <= divisions; j ++ ) {

					var t = j / divisions;

					tx = b3( t, cpx0, cpx1, cpx2, cpx );
					ty = b3( t, cpy0, cpy1, cpy2, cpy );

					points.push( new THREE.Vector2( tx, ty ) );

				}

				break;

			case 'splineThru':

				laste = this.actions[ i - 1 ].args;

				var last = new THREE.Vector2( laste[ laste.length - 2 ], laste[ laste.length - 1 ] );
				var spts = [ last ];

				var n = divisions * args[ 0 ].length;

				spts = spts.concat( args[ 0 ] );

				var spline = new THREE.SplineCurve( spts );

				for ( var j = 1; j <= n; j ++ ) {

					points.push( spline.getPointAt( j / n ) );

				}

				break;

			case 'arc':

				var aX = args[ 0 ], aY = args[ 1 ],
					aRadius = args[ 2 ],
					aStartAngle = args[ 3 ], aEndAngle = args[ 4 ],
					aClockwise = !! args[ 5 ];

				var deltaAngle = aEndAngle - aStartAngle;
				var angle;
				var tdivisions = divisions * 2;

				for ( var j = 1; j <= tdivisions; j ++ ) {

					var t = j / tdivisions;

					if ( ! aClockwise ) {

						t = 1 - t;

					}

					angle = aStartAngle + t * deltaAngle;

					tx = aX + aRadius * Math.cos( angle );
					ty = aY + aRadius * Math.sin( angle );

					//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);

					points.push( new THREE.Vector2( tx, ty ) );

				}

				//console.log(points);

				break;

			case 'ellipse':

				var aX = args[ 0 ], aY = args[ 1 ],
					xRadius = args[ 2 ],
					yRadius = args[ 3 ],
					aStartAngle = args[ 4 ], aEndAngle = args[ 5 ],
					aClockwise = !! args[ 6 ],
					aRotation = args[ 7 ];


				var deltaAngle = aEndAngle - aStartAngle;
				var angle;
				var tdivisions = divisions * 2;

				var cos, sin;
				if ( aRotation !== 0 ) {

					cos = Math.cos( aRotation );
					sin = Math.sin( aRotation );

				}

				for ( var j = 1; j <= tdivisions; j ++ ) {

					var t = j / tdivisions;

					if ( ! aClockwise ) {

						t = 1 - t;

					}

					angle = aStartAngle + t * deltaAngle;

					tx = aX + xRadius * Math.cos( angle );
					ty = aY + yRadius * Math.sin( angle );

					if ( aRotation !== 0 ) {

						var x = tx, y = ty;

						// Rotate the point about the center of the ellipse.
						tx = ( x - aX ) * cos - ( y - aY ) * sin + aX;
						ty = ( x - aX ) * sin + ( y - aY ) * cos + aY;

					}

					//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);

					points.push( new THREE.Vector2( tx, ty ) );

				}

				//console.log(points);

				break;

			} // end switch

		}



		// Normalize to remove the closing point by default.
		var lastPoint = points[ points.length - 1 ];
		if ( Math.abs( lastPoint.x - points[ 0 ].x ) < Number.EPSILON &&
				 Math.abs( lastPoint.y - points[ 0 ].y ) < Number.EPSILON )
			points.splice( points.length - 1, 1 );
		if ( closedPath ) {

			points.push( points[ 0 ] );

		}

		return points;

	};

	//
	// Breaks path into shapes
	//
	//	Assumptions (if parameter isCCW==true the opposite holds):
	//	- solid shapes are defined clockwise (CW)
	//	- holes are defined counterclockwise (CCW)
	//
	//	If parameter noHoles==true:
	//  - all subPaths are regarded as solid shapes
	//  - definition order CW/CCW has no relevance
	//

	THREE.Path.prototype.toShapes = function( isCCW, noHoles ) {

		function extractSubpaths( inActions ) {

			var subPaths = [], lastPath = new THREE.Path();

			for ( var i = 0, l = inActions.length; i < l; i ++ ) {

				var item = inActions[ i ];

				var args = item.args;
				var action = item.action;

				if ( action === 'moveTo' ) {

					if ( lastPath.actions.length !== 0 ) {

						subPaths.push( lastPath );
						lastPath = new THREE.Path();

					}

				}

				lastPath[ action ].apply( lastPath, args );

			}

			if ( lastPath.actions.length !== 0 ) {

				subPaths.push( lastPath );

			}

			// console.log(subPaths);

			return	subPaths;

		}

		function toShapesNoHoles( inSubpaths ) {

			var shapes = [];

			for ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {

				var tmpPath = inSubpaths[ i ];

				var tmpShape = new THREE.Shape();
				tmpShape.actions = tmpPath.actions;
				tmpShape.curves = tmpPath.curves;

				shapes.push( tmpShape );

			}

			//console.log("shape", shapes);

			return shapes;

		}

		function isPointInsidePolygon( inPt, inPolygon ) {

			var polyLen = inPolygon.length;

			// inPt on polygon contour => immediate success    or
			// toggling of inside/outside at every single! intersection point of an edge
			//  with the horizontal line through inPt, left of inPt
			//  not counting lowerY endpoints of edges and whole edges on that line
			var inside = false;
			for ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {

				var edgeLowPt  = inPolygon[ p ];
				var edgeHighPt = inPolygon[ q ];

				var edgeDx = edgeHighPt.x - edgeLowPt.x;
				var edgeDy = edgeHighPt.y - edgeLowPt.y;

				if ( Math.abs( edgeDy ) > Number.EPSILON ) {

					// not parallel
					if ( edgeDy < 0 ) {

						edgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;
						edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;

					}
					if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;

					if ( inPt.y === edgeLowPt.y ) {

						if ( inPt.x === edgeLowPt.x )		return	true;		// inPt is on contour ?
						// continue;				// no intersection or edgeLowPt => doesn't count !!!

					} else {

						var perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );
						if ( perpEdge === 0 )				return	true;		// inPt is on contour ?
						if ( perpEdge < 0 ) 				continue;
						inside = ! inside;		// true intersection left of inPt

					}

				} else {

					// parallel or collinear
					if ( inPt.y !== edgeLowPt.y ) 		continue;			// parallel
					// edge lies on the same horizontal line as inPt
					if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
						 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !
					// continue;

				}

			}

			return	inside;

		}

		var isClockWise = THREE.ShapeUtils.isClockWise;

		var subPaths = extractSubpaths( this.actions );
		if ( subPaths.length === 0 ) return [];

		if ( noHoles === true )	return	toShapesNoHoles( subPaths );


		var solid, tmpPath, tmpShape, shapes = [];

		if ( subPaths.length === 1 ) {

			tmpPath = subPaths[ 0 ];
			tmpShape = new THREE.Shape();
			tmpShape.actions = tmpPath.actions;
			tmpShape.curves = tmpPath.curves;
			shapes.push( tmpShape );
			return shapes;

		}

		var holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );
		holesFirst = isCCW ? ! holesFirst : holesFirst;

		// console.log("Holes first", holesFirst);

		var betterShapeHoles = [];
		var newShapes = [];
		var newShapeHoles = [];
		var mainIdx = 0;
		var tmpPoints;

		newShapes[ mainIdx ] = undefined;
		newShapeHoles[ mainIdx ] = [];

		for ( var i = 0, l = subPaths.length; i < l; i ++ ) {

			tmpPath = subPaths[ i ];
			tmpPoints = tmpPath.getPoints();
			solid = isClockWise( tmpPoints );
			solid = isCCW ? ! solid : solid;

			if ( solid ) {

				if ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )	mainIdx ++;

				newShapes[ mainIdx ] = { s: new THREE.Shape(), p: tmpPoints };
				newShapes[ mainIdx ].s.actions = tmpPath.actions;
				newShapes[ mainIdx ].s.curves = tmpPath.curves;

				if ( holesFirst )	mainIdx ++;
				newShapeHoles[ mainIdx ] = [];

				//console.log('cw', i);

			} else {

				newShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );

				//console.log('ccw', i);

			}

		}

		// only Holes? -> probably all Shapes with wrong orientation
		if ( ! newShapes[ 0 ] )	return	toShapesNoHoles( subPaths );


		if ( newShapes.length > 1 ) {

			var ambiguous = false;
			var toChange = [];

			for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

				betterShapeHoles[ sIdx ] = [];

			}

			for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

				var sho = newShapeHoles[ sIdx ];

				for ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {

					var ho = sho[ hIdx ];
					var hole_unassigned = true;

					for ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {

						if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {

							if ( sIdx !== s2Idx )	toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );
							if ( hole_unassigned ) {

								hole_unassigned = false;
								betterShapeHoles[ s2Idx ].push( ho );

							} else {

								ambiguous = true;

							}

						}

					}
					if ( hole_unassigned ) {

						betterShapeHoles[ sIdx ].push( ho );

					}

				}

			}
			// console.log("ambiguous: ", ambiguous);
			if ( toChange.length > 0 ) {

				// console.log("to change: ", toChange);
				if ( ! ambiguous )	newShapeHoles = betterShapeHoles;

			}

		}

		var tmpHoles;

		for ( var i = 0, il = newShapes.length; i < il; i ++ ) {

			tmpShape = newShapes[ i ].s;
			shapes.push( tmpShape );
			tmpHoles = newShapeHoles[ i ];

			for ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {

				tmpShape.holes.push( tmpHoles[ j ].h );

			}

		}

		//console.log("shape", shapes);

		return shapes;

	};

	// File:src/extras/core/Shape.js

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Defines a 2d shape plane using paths.
	 **/

	// STEP 1 Create a path.
	// STEP 2 Turn path into shape.
	// STEP 3 ExtrudeGeometry takes in Shape/Shapes
	// STEP 3a - Extract points from each shape, turn to vertices
	// STEP 3b - Triangulate each shape, add faces.

	THREE.Shape = function () {

		THREE.Path.apply( this, arguments );

		this.holes = [];

	};

	THREE.Shape.prototype = Object.create( THREE.Path.prototype );
	THREE.Shape.prototype.constructor = THREE.Shape;

	// Convenience method to return ExtrudeGeometry

	THREE.Shape.prototype.extrude = function ( options ) {

		return new THREE.ExtrudeGeometry( this, options );

	};

	// Convenience method to return ShapeGeometry

	THREE.Shape.prototype.makeGeometry = function ( options ) {

		return new THREE.ShapeGeometry( this, options );

	};

	// Get points of holes

	THREE.Shape.prototype.getPointsHoles = function ( divisions ) {

		var holesPts = [];

		for ( var i = 0, l = this.holes.length; i < l; i ++ ) {

			holesPts[ i ] = this.holes[ i ].getPoints( divisions );

		}

		return holesPts;

	};


	// Get points of shape and holes (keypoints based on segments parameter)

	THREE.Shape.prototype.extractAllPoints = function ( divisions ) {

		return {

			shape: this.getPoints( divisions ),
			holes: this.getPointsHoles( divisions )

		};

	};

	THREE.Shape.prototype.extractPoints = function ( divisions ) {

		return this.extractAllPoints( divisions );

	};

	THREE.Shape.Utils = THREE.ShapeUtils; // backwards compatibility

	// File:src/extras/curves/LineCurve.js

	/**************************************************************
	 *	Line
	 **************************************************************/

	THREE.LineCurve = function ( v1, v2 ) {

		this.v1 = v1;
		this.v2 = v2;

	};

	THREE.LineCurve.prototype = Object.create( THREE.Curve.prototype );
	THREE.LineCurve.prototype.constructor = THREE.LineCurve;

	THREE.LineCurve.prototype.getPoint = function ( t ) {

		var point = this.v2.clone().sub( this.v1 );
		point.multiplyScalar( t ).add( this.v1 );

		return point;

	};

	// Line curve is linear, so we can overwrite default getPointAt

	THREE.LineCurve.prototype.getPointAt = function ( u ) {

		return this.getPoint( u );

	};

	THREE.LineCurve.prototype.getTangent = function( t ) {

		var tangent = this.v2.clone().sub( this.v1 );

		return tangent.normalize();

	};

	// File:src/extras/curves/QuadraticBezierCurve.js

	/**************************************************************
	 *	Quadratic Bezier curve
	 **************************************************************/


	THREE.QuadraticBezierCurve = function ( v0, v1, v2 ) {

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;

	};

	THREE.QuadraticBezierCurve.prototype = Object.create( THREE.Curve.prototype );
	THREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve;


	THREE.QuadraticBezierCurve.prototype.getPoint = function ( t ) {

		var b2 = THREE.ShapeUtils.b2;

		return new THREE.Vector2(
			b2( t, this.v0.x, this.v1.x, this.v2.x ),
			b2( t, this.v0.y, this.v1.y, this.v2.y )
		);

	};


	THREE.QuadraticBezierCurve.prototype.getTangent = function( t ) {

		var tangentQuadraticBezier = THREE.CurveUtils.tangentQuadraticBezier;

		return new THREE.Vector2(
			tangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x ),
			tangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y )
		).normalize();

	};

	// File:src/extras/curves/CubicBezierCurve.js

	/**************************************************************
	 *	Cubic Bezier curve
	 **************************************************************/

	THREE.CubicBezierCurve = function ( v0, v1, v2, v3 ) {

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
		this.v3 = v3;

	};

	THREE.CubicBezierCurve.prototype = Object.create( THREE.Curve.prototype );
	THREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve;

	THREE.CubicBezierCurve.prototype.getPoint = function ( t ) {

		var b3 = THREE.ShapeUtils.b3;

		return new THREE.Vector2( 
			b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),
			b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )
		);

	};

	THREE.CubicBezierCurve.prototype.getTangent = function( t ) {

		var tangentCubicBezier = THREE.CurveUtils.tangentCubicBezier;

		return new THREE.Vector2( 
			tangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),
			tangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )
		).normalize();

	};

	// File:src/extras/curves/SplineCurve.js

	/**************************************************************
	 *	Spline curve
	 **************************************************************/

	THREE.SplineCurve = function ( points /* array of Vector2 */ ) {

		this.points = ( points == undefined ) ? [] : points;

	};

	THREE.SplineCurve.prototype = Object.create( THREE.Curve.prototype );
	THREE.SplineCurve.prototype.constructor = THREE.SplineCurve;

	THREE.SplineCurve.prototype.getPoint = function ( t ) {

		var points = this.points;
		var point = ( points.length - 1 ) * t;

		var intPoint = Math.floor( point );
		var weight = point - intPoint;

		var point0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
		var point1 = points[ intPoint ];
		var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
		var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

		var interpolate = THREE.CurveUtils.interpolate;

		return new THREE.Vector2(
			interpolate( point0.x, point1.x, point2.x, point3.x, weight ),
			interpolate( point0.y, point1.y, point2.y, point3.y, weight )
		);

	};

	// File:src/extras/curves/EllipseCurve.js

	/**************************************************************
	 *	Ellipse curve
	 **************************************************************/

	THREE.EllipseCurve = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

		this.aX = aX;
		this.aY = aY;

		this.xRadius = xRadius;
		this.yRadius = yRadius;

		this.aStartAngle = aStartAngle;
		this.aEndAngle = aEndAngle;

		this.aClockwise = aClockwise;
		
		this.aRotation = aRotation || 0;

	};

	THREE.EllipseCurve.prototype = Object.create( THREE.Curve.prototype );
	THREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve;

	THREE.EllipseCurve.prototype.getPoint = function ( t ) {

		var deltaAngle = this.aEndAngle - this.aStartAngle;

		if ( deltaAngle < 0 ) deltaAngle += Math.PI * 2;
		if ( deltaAngle > Math.PI * 2 ) deltaAngle -= Math.PI * 2;

		var angle;

		if ( this.aClockwise === true ) {

			angle = this.aEndAngle + ( 1 - t ) * ( Math.PI * 2 - deltaAngle );

		} else {

			angle = this.aStartAngle + t * deltaAngle;

		}
		
		var x = this.aX + this.xRadius * Math.cos( angle );
		var y = this.aY + this.yRadius * Math.sin( angle );

		if ( this.aRotation !== 0 ) {

			var cos = Math.cos( this.aRotation );
			var sin = Math.sin( this.aRotation );

			var tx = x, ty = y;

			// Rotate the point about the center of the ellipse.
			x = ( tx - this.aX ) * cos - ( ty - this.aY ) * sin + this.aX;
			y = ( tx - this.aX ) * sin + ( ty - this.aY ) * cos + this.aY;

		}

		return new THREE.Vector2( x, y );

	};

	// File:src/extras/curves/ArcCurve.js

	/**************************************************************
	 *	Arc curve
	 **************************************************************/

	THREE.ArcCurve = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

		THREE.EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

	};

	THREE.ArcCurve.prototype = Object.create( THREE.EllipseCurve.prototype );
	THREE.ArcCurve.prototype.constructor = THREE.ArcCurve;

	// File:src/extras/curves/LineCurve3.js

	/**************************************************************
	 *	Line3D
	 **************************************************************/

	THREE.LineCurve3 = THREE.Curve.create(

		function ( v1, v2 ) {

			this.v1 = v1;
			this.v2 = v2;

		},

		function ( t ) {

			var vector = new THREE.Vector3();

			vector.subVectors( this.v2, this.v1 ); // diff
			vector.multiplyScalar( t );
			vector.add( this.v1 );

			return vector;

		}

	);

	// File:src/extras/curves/QuadraticBezierCurve3.js

	/**************************************************************
	 *	Quadratic Bezier 3D curve
	 **************************************************************/

	THREE.QuadraticBezierCurve3 = THREE.Curve.create(

		function ( v0, v1, v2 ) {

			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;

		},

		function ( t ) {

			var b2 = THREE.ShapeUtils.b2;		

			return new THREE.Vector3(
				b2( t, this.v0.x, this.v1.x, this.v2.x ),
				b2( t, this.v0.y, this.v1.y, this.v2.y ),
				b2( t, this.v0.z, this.v1.z, this.v2.z )
			);

		}

	);

	// File:src/extras/curves/CubicBezierCurve3.js

	/**************************************************************
	 *	Cubic Bezier 3D curve
	 **************************************************************/

	THREE.CubicBezierCurve3 = THREE.Curve.create(

		function ( v0, v1, v2, v3 ) {

			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
			this.v3 = v3;

		},

		function ( t ) {

			var b3 = THREE.ShapeUtils.b3;

			return new THREE.Vector3(
				b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),
				b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y ),
				b3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z )
			);

		}

	);

	// File:src/extras/curves/SplineCurve3.js

	/**************************************************************
	 *	Spline 3D curve
	 **************************************************************/


	THREE.SplineCurve3 = THREE.Curve.create(

		function ( points /* array of Vector3 */ ) {

			console.warn( 'THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3' );
			this.points = ( points == undefined ) ? [] : points;

		},

		function ( t ) {

			var points = this.points;
			var point = ( points.length - 1 ) * t;

			var intPoint = Math.floor( point );
			var weight = point - intPoint;

			var point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];
			var point1 = points[ intPoint ];
			var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
			var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

			var interpolate = THREE.CurveUtils.interpolate;

			return new THREE.Vector3(
				interpolate( point0.x, point1.x, point2.x, point3.x, weight ),
				interpolate( point0.y, point1.y, point2.y, point3.y, weight ),
				interpolate( point0.z, point1.z, point2.z, point3.z, weight )
			);

		}

	);

	// File:src/extras/curves/CatmullRomCurve3.js

	/**
	 * @author zz85 https://github.com/zz85
	 *
	 * Centripetal CatmullRom Curve - which is useful for avoiding
	 * cusps and self-intersections in non-uniform catmull rom curves.
	 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
	 *
	 * curve.type accepts centripetal(default), chordal and catmullrom
	 * curve.tension is used for catmullrom which defaults to 0.5
	 */

	THREE.CatmullRomCurve3 = ( function() {

		var
			tmp = new THREE.Vector3(),
			px = new CubicPoly(),
			py = new CubicPoly(),
			pz = new CubicPoly();

		/*
		Based on an optimized c++ solution in
		 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
		 - http://ideone.com/NoEbVM

		This CubicPoly class could be used for reusing some variables and calculations,
		but for three.js curve use, it could be possible inlined and flatten into a single function call
		which can be placed in CurveUtils.
		*/

		function CubicPoly() {

		}

		/*
		 * Compute coefficients for a cubic polynomial
		 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
		 * such that
		 *   p(0) = x0, p(1) = x1
		 *  and
		 *   p'(0) = t0, p'(1) = t1.
		 */
		CubicPoly.prototype.init = function( x0, x1, t0, t1 ) {

			this.c0 = x0;
			this.c1 = t0;
			this.c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
			this.c3 = 2 * x0 - 2 * x1 + t0 + t1;

		};

		CubicPoly.prototype.initNonuniformCatmullRom = function( x0, x1, x2, x3, dt0, dt1, dt2 ) {

			// compute tangents when parameterized in [t1,t2]
			var t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
			var t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;

			// rescale tangents for parametrization in [0,1]
			t1 *= dt1;
			t2 *= dt1;

			// initCubicPoly
			this.init( x1, x2, t1, t2 );

		};

		// standard Catmull-Rom spline: interpolate between x1 and x2 with previous/following points x1/x4
		CubicPoly.prototype.initCatmullRom = function( x0, x1, x2, x3, tension ) {

			this.init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );

		};

		CubicPoly.prototype.calc = function( t ) {

			var t2 = t * t;
			var t3 = t2 * t;
			return this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;

		};

		// Subclass Three.js curve
		return THREE.Curve.create(

			function ( p /* array of Vector3 */ ) {

				this.points = p || [];

			},

			function ( t ) {

				var points = this.points,
					point, intPoint, weight, l;

				l = points.length;

				if ( l < 2 ) console.log( 'duh, you need at least 2 points' );

				point = ( l - 1 ) * t;
				intPoint = Math.floor( point );
				weight = point - intPoint;

				if ( weight === 0 && intPoint === l - 1 ) {

					intPoint = l - 2;
					weight = 1;

				}

				var p0, p1, p2, p3;

				if ( intPoint === 0 ) {

					// extrapolate first point
					tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
					p0 = tmp;

				} else {

					p0 = points[ intPoint - 1 ];

				}

				p1 = points[ intPoint ];
				p2 = points[ intPoint + 1 ];

				if ( intPoint + 2 < l ) {

					p3 = points[ intPoint + 2 ]

				} else {

					// extrapolate last point
					tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 2 ] );
					p3 = tmp;

				}

				if ( this.type === undefined || this.type === 'centripetal' || this.type === 'chordal' ) {

					// init Centripetal / Chordal Catmull-Rom
					var pow = this.type === 'chordal' ? 0.5 : 0.25;
					var dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
					var dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
					var dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );

					// safety check for repeated points
					if ( dt1 < 1e-4 ) dt1 = 1.0;
					if ( dt0 < 1e-4 ) dt0 = dt1;
					if ( dt2 < 1e-4 ) dt2 = dt1;

					px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
					py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
					pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );

				} else if ( this.type === 'catmullrom' ) {

					var tension = this.tension !== undefined ? this.tension : 0.5;
					px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, tension );
					py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, tension );
					pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, tension );

				}

				var v = new THREE.Vector3(
					px.calc( weight ),
					py.calc( weight ),
					pz.calc( weight )
				);

				return v;

			}

		);

	} )();

	// File:src/extras/curves/ClosedSplineCurve3.js

	/**************************************************************
	 *	Closed Spline 3D curve
	 **************************************************************/


	THREE.ClosedSplineCurve3 = THREE.Curve.create(

		function ( points /* array of Vector3 */ ) {

			this.points = ( points == undefined ) ? [] : points;

		},

		function ( t ) {

			var points = this.points;
			var point = ( points.length - 0 ) * t; // This needs to be from 0-length +1

			var intPoint = Math.floor( point );
			var weight = point - intPoint;

			intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;

			var point0 = points[ ( intPoint - 1 ) % points.length ];
			var point1 = points[ ( intPoint     ) % points.length ];
			var point2 = points[ ( intPoint + 1 ) % points.length ];
			var point3 = points[ ( intPoint + 2 ) % points.length ];

			var interpolate = THREE.CurveUtils.interpolate;

			return new THREE.Vector3(
				interpolate( point0.x, point1.x, point2.x, point3.x, weight ),
				interpolate( point0.y, point1.y, point2.y, point3.y, weight ),
				interpolate( point0.z, point1.z, point2.z, point3.z, weight )
			);

		}

	);

	// File:src/extras/geometries/BoxGeometry.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as
	 */

	THREE.BoxGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {

		THREE.Geometry.call( this );

		this.type = 'BoxGeometry';

		this.parameters = {
			width: width,
			height: height,
			depth: depth,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			depthSegments: depthSegments
		};

		this.widthSegments = widthSegments || 1;
		this.heightSegments = heightSegments || 1;
		this.depthSegments = depthSegments || 1;

		var scope = this;

		var width_half = width / 2;
		var height_half = height / 2;
		var depth_half = depth / 2;

		buildPlane( 'z', 'y', - 1, - 1, depth, height, width_half, 0 ); // px
		buildPlane( 'z', 'y',   1, - 1, depth, height, - width_half, 1 ); // nx
		buildPlane( 'x', 'z',   1,   1, width, depth, height_half, 2 ); // py
		buildPlane( 'x', 'z',   1, - 1, width, depth, - height_half, 3 ); // ny
		buildPlane( 'x', 'y',   1, - 1, width, height, depth_half, 4 ); // pz
		buildPlane( 'x', 'y', - 1, - 1, width, height, - depth_half, 5 ); // nz

		function buildPlane( u, v, udir, vdir, width, height, depth, materialIndex ) {

			var w, ix, iy,
			gridX = scope.widthSegments,
			gridY = scope.heightSegments,
			width_half = width / 2,
			height_half = height / 2,
			offset = scope.vertices.length;

			if ( ( u === 'x' && v === 'y' ) || ( u === 'y' && v === 'x' ) ) {

				w = 'z';

			} else if ( ( u === 'x' && v === 'z' ) || ( u === 'z' && v === 'x' ) ) {

				w = 'y';
				gridY = scope.depthSegments;

			} else if ( ( u === 'z' && v === 'y' ) || ( u === 'y' && v === 'z' ) ) {

				w = 'x';
				gridX = scope.depthSegments;

			}

			var gridX1 = gridX + 1,
			gridY1 = gridY + 1,
			segment_width = width / gridX,
			segment_height = height / gridY,
			normal = new THREE.Vector3();

			normal[ w ] = depth > 0 ? 1 : - 1;

			for ( iy = 0; iy < gridY1; iy ++ ) {

				for ( ix = 0; ix < gridX1; ix ++ ) {

					var vector = new THREE.Vector3();
					vector[ u ] = ( ix * segment_width - width_half ) * udir;
					vector[ v ] = ( iy * segment_height - height_half ) * vdir;
					vector[ w ] = depth;

					scope.vertices.push( vector );

				}

			}

			for ( iy = 0; iy < gridY; iy ++ ) {

				for ( ix = 0; ix < gridX; ix ++ ) {

					var a = ix + gridX1 * iy;
					var b = ix + gridX1 * ( iy + 1 );
					var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
					var d = ( ix + 1 ) + gridX1 * iy;

					var uva = new THREE.Vector2( ix / gridX, 1 - iy / gridY );
					var uvb = new THREE.Vector2( ix / gridX, 1 - ( iy + 1 ) / gridY );
					var uvc = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - ( iy + 1 ) / gridY );
					var uvd = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - iy / gridY );

					var face = new THREE.Face3( a + offset, b + offset, d + offset );
					face.normal.copy( normal );
					face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );
					face.materialIndex = materialIndex;

					scope.faces.push( face );
					scope.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

					face = new THREE.Face3( b + offset, c + offset, d + offset );
					face.normal.copy( normal );
					face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );
					face.materialIndex = materialIndex;

					scope.faces.push( face );
					scope.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

				}

			}

		}

		this.mergeVertices();

	};

	THREE.BoxGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry;

	THREE.BoxGeometry.prototype.clone = function () {

		var parameters = this.parameters;

		return new THREE.BoxGeometry(
			parameters.width,
			parameters.height,
			parameters.depth,
			parameters.widthSegments,
			parameters.heightSegments,
			parameters.depthSegments
		);

	};

	THREE.CubeGeometry = THREE.BoxGeometry; // backwards compatibility

	// File:src/extras/geometries/CircleGeometry.js

	/**
	 * @author hughes
	 */

	THREE.CircleGeometry = function ( radius, segments, thetaStart, thetaLength ) {

		THREE.Geometry.call( this );

		this.type = 'CircleGeometry';

		this.parameters = {
			radius: radius,
			segments: segments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		this.fromBufferGeometry( new THREE.CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );

	};

	THREE.CircleGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry;

	THREE.CircleGeometry.prototype.clone = function () {

		var parameters = this.parameters;

		return new THREE.CircleGeometry(
			parameters.radius,
			parameters.segments,
			parameters.thetaStart,
			parameters.thetaLength
		);

	};

	// File:src/extras/geometries/CircleBufferGeometry.js

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */

	THREE.CircleBufferGeometry = function ( radius, segments, thetaStart, thetaLength ) {

		THREE.BufferGeometry.call( this );

		this.type = 'CircleBufferGeometry';

		this.parameters = {
			radius: radius,
			segments: segments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		radius = radius || 50;
		segments = segments !== undefined ? Math.max( 3, segments ) : 8;

		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

		var vertices = segments + 2;

		var positions = new Float32Array( vertices * 3 );
		var normals = new Float32Array( vertices * 3 );
		var uvs = new Float32Array( vertices * 2 );

		// center data is already zero, but need to set a few extras
		normals[ 2 ] = 1.0;
		uvs[ 0 ] = 0.5;
		uvs[ 1 ] = 0.5;

		for ( var s = 0, i = 3, ii = 2 ; s <= segments; s ++, i += 3, ii += 2 ) {

			var segment = thetaStart + s / segments * thetaLength;

			positions[ i ] = radius * Math.cos( segment );
			positions[ i + 1 ] = radius * Math.sin( segment );

			normals[ i + 2 ] = 1; // normal z

			uvs[ ii ] = ( positions[ i ] / radius + 1 ) / 2;
			uvs[ ii + 1 ] = ( positions[ i + 1 ] / radius + 1 ) / 2;

		}

		var indices = [];

		for ( var i = 1; i <= segments; i ++ ) {

			indices.push( i, i + 1, 0 );

		}

		this.setIndex( new THREE.BufferAttribute( new Uint16Array( indices ), 1 ) );
		this.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
		this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

		this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

	};

	THREE.CircleBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
	THREE.CircleBufferGeometry.prototype.constructor = THREE.CircleBufferGeometry;

	THREE.CircleBufferGeometry.prototype.clone = function () {

		var parameters = this.parameters;

		return new THREE.CircleBufferGeometry(
			parameters.radius,
			parameters.segments,
			parameters.thetaStart,
			parameters.thetaLength
		);

	};

	// File:src/extras/geometries/CylinderGeometry.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.CylinderGeometry = function ( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

		THREE.Geometry.call( this );

		this.type = 'CylinderGeometry';

		this.parameters = {
			radiusTop: radiusTop,
			radiusBottom: radiusBottom,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		radiusTop = radiusTop !== undefined ? radiusTop : 20;
		radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
		height = height !== undefined ? height : 100;

		radialSegments = radialSegments || 8;
		heightSegments = heightSegments || 1;

		openEnded = openEnded !== undefined ? openEnded : false;
		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : 2 * Math.PI;

		var heightHalf = height / 2;

		var x, y, vertices = [], uvs = [];

		for ( y = 0; y <= heightSegments; y ++ ) {

			var verticesRow = [];
			var uvsRow = [];

			var v = y / heightSegments;
			var radius = v * ( radiusBottom - radiusTop ) + radiusTop;

			for ( x = 0; x <= radialSegments; x ++ ) {

				var u = x / radialSegments;

				var vertex = new THREE.Vector3();
				vertex.x = radius * Math.sin( u * thetaLength + thetaStart );
				vertex.y = - v * height + heightHalf;
				vertex.z = radius * Math.cos( u * thetaLength + thetaStart );

				this.vertices.push( vertex );

				verticesRow.push( this.vertices.length - 1 );
				uvsRow.push( new THREE.Vector2( u, 1 - v ) );

			}

			vertices.push( verticesRow );
			uvs.push( uvsRow );

		}

		var tanTheta = ( radiusBottom - radiusTop ) / height;
		var na, nb;

		for ( x = 0; x < radialSegments; x ++ ) {

			if ( radiusTop !== 0 ) {

				na = this.vertices[ vertices[ 0 ][ x ] ].clone();
				nb = this.vertices[ vertices[ 0 ][ x + 1 ] ].clone();

			} else {

				na = this.vertices[ vertices[ 1 ][ x ] ].clone();
				nb = this.vertices[ vertices[ 1 ][ x + 1 ] ].clone();

			}

			na.setY( Math.sqrt( na.x * na.x + na.z * na.z ) * tanTheta ).normalize();
			nb.setY( Math.sqrt( nb.x * nb.x + nb.z * nb.z ) * tanTheta ).normalize();

			for ( y = 0; y < heightSegments; y ++ ) {

				var v1 = vertices[ y ][ x ];
				var v2 = vertices[ y + 1 ][ x ];
				var v3 = vertices[ y + 1 ][ x + 1 ];
				var v4 = vertices[ y ][ x + 1 ];

				var n1 = na.clone();
				var n2 = na.clone();
				var n3 = nb.clone();
				var n4 = nb.clone();

				var uv1 = uvs[ y ][ x ].clone();
				var uv2 = uvs[ y + 1 ][ x ].clone();
				var uv3 = uvs[ y + 1 ][ x + 1 ].clone();
				var uv4 = uvs[ y ][ x + 1 ].clone();

				this.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );

				this.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );

			}

		}

		// top cap

		if ( openEnded === false && radiusTop > 0 ) {

			this.vertices.push( new THREE.Vector3( 0, heightHalf, 0 ) );

			for ( x = 0; x < radialSegments; x ++ ) {

				var v1 = vertices[ 0 ][ x ];
				var v2 = vertices[ 0 ][ x + 1 ];
				var v3 = this.vertices.length - 1;

				var n1 = new THREE.Vector3( 0, 1, 0 );
				var n2 = new THREE.Vector3( 0, 1, 0 );
				var n3 = new THREE.Vector3( 0, 1, 0 );

				var uv1 = uvs[ 0 ][ x ].clone();
				var uv2 = uvs[ 0 ][ x + 1 ].clone();
				var uv3 = new THREE.Vector2( uv2.x, 0 );

				this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ], undefined, 1 ) );
				this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

			}

		}

		// bottom cap

		if ( openEnded === false && radiusBottom > 0 ) {

			this.vertices.push( new THREE.Vector3( 0, - heightHalf, 0 ) );

			for ( x = 0; x < radialSegments; x ++ ) {

				var v1 = vertices[ heightSegments ][ x + 1 ];
				var v2 = vertices[ heightSegments ][ x ];
				var v3 = this.vertices.length - 1;

				var n1 = new THREE.Vector3( 0, - 1, 0 );
				var n2 = new THREE.Vector3( 0, - 1, 0 );
				var n3 = new THREE.Vector3( 0, - 1, 0 );

				var uv1 = uvs[ heightSegments ][ x + 1 ].clone();
				var uv2 = uvs[ heightSegments ][ x ].clone();
				var uv3 = new THREE.Vector2( uv2.x, 1 );

				this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ], undefined, 2 ) );
				this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

			}

		}

		this.computeFaceNormals();

	};

	THREE.CylinderGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry;

	THREE.CylinderGeometry.prototype.clone = function () {

		var parameters = this.parameters;

		return new THREE.CylinderGeometry(
			parameters.radiusTop,
			parameters.radiusBottom,
			parameters.height,
			parameters.radialSegments,
			parameters.heightSegments,
			parameters.openEnded,
			parameters.thetaStart,
			parameters.thetaLength
		);

	};

	// File:src/extras/geometries/EdgesGeometry.js

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 */

	THREE.EdgesGeometry = function ( geometry, thresholdAngle ) {

		THREE.BufferGeometry.call( this );

		thresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;

		var thresholdDot = Math.cos( THREE.Math.degToRad( thresholdAngle ) );

		var edge = [ 0, 0 ], hash = {};

		function sortFunction( a, b ) {

			return a - b;

		}

		var keys = [ 'a', 'b', 'c' ];

		var geometry2;

		if ( geometry instanceof THREE.BufferGeometry ) {

			geometry2 = new THREE.Geometry();
			geometry2.fromBufferGeometry( geometry );

		} else {

			geometry2 = geometry.clone();

		}

		geometry2.mergeVertices();
		geometry2.computeFaceNormals();

		var vertices = geometry2.vertices;
		var faces = geometry2.faces;

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			for ( var j = 0; j < 3; j ++ ) {

				edge[ 0 ] = face[ keys[ j ] ];
				edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
				edge.sort( sortFunction );

				var key = edge.toString();

				if ( hash[ key ] === undefined ) {

					hash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };

				} else {

					hash[ key ].face2 = i;

				}

			}

		}

		var coords = [];

		for ( var key in hash ) {

			var h = hash[ key ];

			if ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) <= thresholdDot ) {

				var vertex = vertices[ h.vert1 ];
				coords.push( vertex.x );
				coords.push( vertex.y );
				coords.push( vertex.z );

				vertex = vertices[ h.vert2 ];
				coords.push( vertex.x );
				coords.push( vertex.y );
				coords.push( vertex.z );

			}

		}

		this.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( coords ), 3 ) );

	};

	THREE.EdgesGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
	THREE.EdgesGeometry.prototype.constructor = THREE.EdgesGeometry;

	// File:src/extras/geometries/ExtrudeGeometry.js

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 *
	 * Creates extruded geometry from a path shape.
	 *
	 * parameters = {
	 *
	 *  curveSegments: <int>, // number of points on the curves
	 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
	 *  amount: <int>, // Depth to extrude the shape
	 *
	 *  bevelEnabled: <bool>, // turn on bevel
	 *  bevelThickness: <float>, // how deep into the original shape bevel goes
	 *  bevelSize: <float>, // how far from shape outline is bevel
	 *  bevelSegments: <int>, // number of bevel layers
	 *
	 *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)
	 *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals
	 *
	 *  uvGenerator: <Object> // object that provides UV generator functions
	 *
	 * }
	 **/

	THREE.ExtrudeGeometry = function ( shapes, options ) {

		if ( typeof( shapes ) === "undefined" ) {

			shapes = [];
			return;

		}

		THREE.Geometry.call( this );

		this.type = 'ExtrudeGeometry';

		shapes = Array.isArray( shapes ) ? shapes : [ shapes ];

		this.addShapeList( shapes, options );

		this.computeFaceNormals();

		// can't really use automatic vertex normals
		// as then front and back sides get smoothed too
		// should do separate smoothing just for sides

		//this.computeVertexNormals();

		//console.log( "took", ( Date.now() - startTime ) );

	};

	THREE.ExtrudeGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry;

	THREE.ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {

		var sl = shapes.length;

		for ( var s = 0; s < sl; s ++ ) {

			var shape = shapes[ s ];
			this.addShape( shape, options );

		}

	};

	THREE.ExtrudeGeometry.prototype.addShape = function ( shape, options ) {

		var amount = options.amount !== undefined ? options.amount : 100;

		var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10
		var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8
		var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

		var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false

		var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

		var steps = options.steps !== undefined ? options.steps : 1;

		var extrudePath = options.extrudePath;
		var extrudePts, extrudeByPath = false;

		// Use default WorldUVGenerator if no UV generators are specified.
		var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;

		var splineTube, binormal, normal, position2;
		if ( extrudePath ) {

			extrudePts = extrudePath.getSpacedPoints( steps );

			extrudeByPath = true;
			bevelEnabled = false; // bevels not supported for path extrusion

			// SETUP TNB variables

			// Reuse TNB from TubeGeomtry for now.
			// TODO1 - have a .isClosed in spline?

			splineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames( extrudePath, steps, false );

			// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

			binormal = new THREE.Vector3();
			normal = new THREE.Vector3();
			position2 = new THREE.Vector3();

		}

		// Safeguards if bevels are not enabled

		if ( ! bevelEnabled ) {

			bevelSegments = 0;
			bevelThickness = 0;
			bevelSize = 0;

		}

		// Variables initialization

		var ahole, h, hl; // looping of holes
		var scope = this;

		var shapesOffset = this.vertices.length;

		var shapePoints = shape.extractPoints( curveSegments );

		var vertices = shapePoints.shape;
		var holes = shapePoints.holes;

		var reverse = ! THREE.ShapeUtils.isClockWise( vertices );

		if ( reverse ) {

			vertices = vertices.reverse();

			// Maybe we should also check if holes are in the opposite direction, just to be safe ...

			for ( h = 0, hl = holes.length; h < hl; h ++ ) {

				ahole = holes[ h ];

				if ( THREE.ShapeUtils.isClockWise( ahole ) ) {

					holes[ h ] = ahole.reverse();

				}

			}

			reverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!

		}


		var faces = THREE.ShapeUtils.triangulateShape( vertices, holes );

		/* Vertices */

		var contour = vertices; // vertices has all points but contour has only points of circumference

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];

			vertices = vertices.concat( ahole );

		}


		function scalePt2 ( pt, vec, size ) {

			if ( ! vec ) console.error( "THREE.ExtrudeGeometry: vec does not exist" );

			return vec.clone().multiplyScalar( size ).add( pt );

		}

		var b, bs, t, z,
			vert, vlen = vertices.length,
			face, flen = faces.length;


		// Find directions for point movement


		function getBevelVec( inPt, inPrev, inNext ) {

			// computes for inPt the corresponding point inPt' on a new contour
			//   shifted by 1 unit (length of normalized vector) to the left
			// if we walk along contour clockwise, this new contour is outside the old one
			//
			// inPt' is the intersection of the two lines parallel to the two
			//  adjacent edges of inPt at a distance of 1 unit on the left side.

			var v_trans_x, v_trans_y, shrink_by = 1;		// resulting translation vector for inPt

			// good reading for geometry algorithms (here: line-line intersection)
			// http://geomalgorithms.com/a05-_intersect-1.html

			var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
			var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;

			var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );

			// check for collinear edges
			var collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );

			if ( Math.abs( collinear0 ) > Number.EPSILON ) {

				// not collinear

				// length of vectors for normalizing

				var v_prev_len = Math.sqrt( v_prev_lensq );
				var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );

				// shift adjacent points by unit vectors to the left

				var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
				var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );

				var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
				var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );

				// scaling factor for v_prev to intersection point

				var sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
							( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /
						  ( v_prev_x * v_next_y - v_prev_y * v_next_x );

				// vector from inPt to intersection point

				v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
				v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );

				// Don't normalize!, otherwise sharp corners become ugly
				//  but prevent crazy spikes
				var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
				if ( v_trans_lensq <= 2 ) {

					return	new THREE.Vector2( v_trans_x, v_trans_y );

				} else {

					shrink_by = Math.sqrt( v_trans_lensq / 2 );

				}

			} else {

				// handle special case of collinear edges

				var direction_eq = false;		// assumes: opposite
				if ( v_prev_x > Number.EPSILON ) {

					if ( v_next_x > Number.EPSILON ) {

						direction_eq = true;

					}

				} else {

					if ( v_prev_x < - Number.EPSILON ) {

						if ( v_next_x < - Number.EPSILON ) {

							direction_eq = true;

						}

					} else {

						if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {

							direction_eq = true;

						}

					}

				}

				if ( direction_eq ) {

					// console.log("Warning: lines are a straight sequence");
					v_trans_x = - v_prev_y;
					v_trans_y =  v_prev_x;
					shrink_by = Math.sqrt( v_prev_lensq );

				} else {

					// console.log("Warning: lines are a straight spike");
					v_trans_x = v_prev_x;
					v_trans_y = v_prev_y;
					shrink_by = Math.sqrt( v_prev_lensq / 2 );

				}

			}

			return	new THREE.Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

		}


		var contourMovements = [];

		for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

			if ( j === il ) j = 0;
			if ( k === il ) k = 0;

			//  (j)---(i)---(k)
			// console.log('i,j,k', i, j , k)

			contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

		}

		var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];

			oneHoleMovements = [];

			for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

				if ( j === il ) j = 0;
				if ( k === il ) k = 0;

				//  (j)---(i)---(k)
				oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

			}

			holesMovements.push( oneHoleMovements );
			verticesMovements = verticesMovements.concat( oneHoleMovements );

		}


		// Loop bevelSegments, 1 for the front, 1 for the back

		for ( b = 0; b < bevelSegments; b ++ ) {

			//for ( b = bevelSegments; b > 0; b -- ) {

			t = b / bevelSegments;
			z = bevelThickness * ( 1 - t );

			//z = bevelThickness * t;
			bs = bevelSize * ( Math.sin ( t * Math.PI / 2 ) ); // curved
			//bs = bevelSize * t; // linear

			// contract shape

			for ( i = 0, il = contour.length; i < il; i ++ ) {

				vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

				v( vert.x, vert.y,  - z );

			}

			// expand holes

			for ( h = 0, hl = holes.length; h < hl; h ++ ) {

				ahole = holes[ h ];
				oneHoleMovements = holesMovements[ h ];

				for ( i = 0, il = ahole.length; i < il; i ++ ) {

					vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

					v( vert.x, vert.y,  - z );

				}

			}

		}

		bs = bevelSize;

		// Back facing vertices

		for ( i = 0; i < vlen; i ++ ) {

			vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

			if ( ! extrudeByPath ) {

				v( vert.x, vert.y, 0 );

			} else {

				// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

				normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
				binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );

				position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );

				v( position2.x, position2.y, position2.z );

			}

		}

		// Add stepped vertices...
		// Including front facing vertices

		var s;

		for ( s = 1; s <= steps; s ++ ) {

			for ( i = 0; i < vlen; i ++ ) {

				vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

				if ( ! extrudeByPath ) {

					v( vert.x, vert.y, amount / steps * s );

				} else {

					// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

					normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
					binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );

					position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );

					v( position2.x, position2.y, position2.z );

				}

			}

		}


		// Add bevel segments planes

		//for ( b = 1; b <= bevelSegments; b ++ ) {
		for ( b = bevelSegments - 1; b >= 0; b -- ) {

			t = b / bevelSegments;
			z = bevelThickness * ( 1 - t );
			//bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );
			bs = bevelSize * Math.sin ( t * Math.PI / 2 );

			// contract shape

			for ( i = 0, il = contour.length; i < il; i ++ ) {

				vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
				v( vert.x, vert.y,  amount + z );

			}

			// expand holes

			for ( h = 0, hl = holes.length; h < hl; h ++ ) {

				ahole = holes[ h ];
				oneHoleMovements = holesMovements[ h ];

				for ( i = 0, il = ahole.length; i < il; i ++ ) {

					vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

					if ( ! extrudeByPath ) {

						v( vert.x, vert.y,  amount + z );

					} else {

						v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

					}

				}

			}

		}

		/* Faces */

		// Top and bottom faces

		buildLidFaces();

		// Sides faces

		buildSideFaces();


		/////  Internal functions

		function buildLidFaces() {

			if ( bevelEnabled ) {

				var layer = 0; // steps + 1
				var offset = vlen * layer;

				// Bottom faces

				for ( i = 0; i < flen; i ++ ) {

					face = faces[ i ];
					f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );

				}

				layer = steps + bevelSegments * 2;
				offset = vlen * layer;

				// Top faces

				for ( i = 0; i < flen; i ++ ) {

					face = faces[ i ];
					f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

				}

			} else {

				// Bottom faces

				for ( i = 0; i < flen; i ++ ) {

					face = faces[ i ];
					f3( face[ 2 ], face[ 1 ], face[ 0 ] );

				}

				// Top faces

				for ( i = 0; i < flen; i ++ ) {

					face = faces[ i ];
					f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

				}

			}

		}

		// Create faces for the z-sides of the shape

		function buildSideFaces() {

			var layeroffset = 0;
			sidewalls( contour, layeroffset );
			layeroffset += contour.length;

			for ( h = 0, hl = holes.length; h < hl; h ++ ) {

				ahole = holes[ h ];
				sidewalls( ahole, layeroffset );

				//, true
				layeroffset += ahole.length;

			}

		}

		function sidewalls( contour, layeroffset ) {

			var j, k;
			i = contour.length;

			while ( -- i >= 0 ) {

				j = i;
				k = i - 1;
				if ( k < 0 ) k = contour.length - 1;

				//console.log('b', i,j, i-1, k,vertices.length);

				var s = 0, sl = steps  + bevelSegments * 2;

				for ( s = 0; s < sl; s ++ ) {

					var slen1 = vlen * s;
					var slen2 = vlen * ( s + 1 );

					var a = layeroffset + j + slen1,
						b = layeroffset + k + slen1,
						c = layeroffset + k + slen2,
						d = layeroffset + j + slen2;

					f4( a, b, c, d, contour, s, sl, j, k );

				}

			}

		}


		function v( x, y, z ) {

			scope.vertices.push( new THREE.Vector3( x, y, z ) );

		}

		function f3( a, b, c ) {

			a += shapesOffset;
			b += shapesOffset;
			c += shapesOffset;

			scope.faces.push( new THREE.Face3( a, b, c, null, null, 0 ) );

			var uvs = uvgen.generateTopUV( scope, a, b, c );

			scope.faceVertexUvs[ 0 ].push( uvs );

		}

		function f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {

			a += shapesOffset;
			b += shapesOffset;
			c += shapesOffset;
			d += shapesOffset;

			scope.faces.push( new THREE.Face3( a, b, d, null, null, 1 ) );
			scope.faces.push( new THREE.Face3( b, c, d, null, null, 1 ) );

			var uvs = uvgen.generateSideWallUV( scope, a, b, c, d );

			scope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );
			scope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );

		}

	};

	THREE.ExtrudeGeometry.WorldUVGenerator = {

		generateTopUV: function ( geometry, indexA, indexB, indexC ) {

			var vertices = geometry.vertices;

			var a = vertices[ indexA ];
			var b = vertices[ indexB ];
			var c = vertices[ indexC ];

			return [
				new THREE.Vector2( a.x, a.y ),
				new THREE.Vector2( b.x, b.y ),
				new THREE.Vector2( c.x, c.y )
			];

		},

		generateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {

			var vertices = geometry.vertices;

			var a = vertices[ indexA ];
			var b = vertices[ indexB ];
			var c = vertices[ indexC ];
			var d = vertices[ indexD ];

			if ( Math.abs( a.y - b.y ) < 0.01 ) {

				return [
					new THREE.Vector2( a.x, 1 - a.z ),
					new THREE.Vector2( b.x, 1 - b.z ),
					new THREE.Vector2( c.x, 1 - c.z ),
					new THREE.Vector2( d.x, 1 - d.z )
				];

			} else {

				return [
					new THREE.Vector2( a.y, 1 - a.z ),
					new THREE.Vector2( b.y, 1 - b.z ),
					new THREE.Vector2( c.y, 1 - c.z ),
					new THREE.Vector2( d.y, 1 - d.z )
				];

			}

		}
	};

	// File:src/extras/geometries/ShapeGeometry.js

	/**
	 * @author jonobr1 / http://jonobr1.com
	 *
	 * Creates a one-sided polygonal geometry from a path shape. Similar to
	 * ExtrudeGeometry.
	 *
	 * parameters = {
	 *
	 *	curveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.
	 *
	 *	material: <int> // material index for front and back faces
	 *	uvGenerator: <Object> // object that provides UV generator functions
	 *
	 * }
	 **/

	THREE.ShapeGeometry = function ( shapes, options ) {

		THREE.Geometry.call( this );

		this.type = 'ShapeGeometry';

		if ( Array.isArray( shapes ) === false ) shapes = [ shapes ];

		this.addShapeList( shapes, options );

		this.computeFaceNormals();

	};

	THREE.ShapeGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry;

	/**
	 * Add an array of shapes to THREE.ShapeGeometry.
	 */
	THREE.ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {

		for ( var i = 0, l = shapes.length; i < l; i ++ ) {

			this.addShape( shapes[ i ], options );

		}

		return this;

	};

	/**
	 * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.
	 */
	THREE.ShapeGeometry.prototype.addShape = function ( shape, options ) {

		if ( options === undefined ) options = {};
		var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

		var material = options.material;
		var uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;

		//

		var i, l, hole;

		var shapesOffset = this.vertices.length;
		var shapePoints = shape.extractPoints( curveSegments );

		var vertices = shapePoints.shape;
		var holes = shapePoints.holes;

		var reverse = ! THREE.ShapeUtils.isClockWise( vertices );

		if ( reverse ) {

			vertices = vertices.reverse();

			// Maybe we should also check if holes are in the opposite direction, just to be safe...

			for ( i = 0, l = holes.length; i < l; i ++ ) {

				hole = holes[ i ];

				if ( THREE.ShapeUtils.isClockWise( hole ) ) {

					holes[ i ] = hole.reverse();

				}

			}

			reverse = false;

		}

		var faces = THREE.ShapeUtils.triangulateShape( vertices, holes );

		// Vertices

		for ( i = 0, l = holes.length; i < l; i ++ ) {

			hole = holes[ i ];
			vertices = vertices.concat( hole );

		}

		//

		var vert, vlen = vertices.length;
		var face, flen = faces.length;

		for ( i = 0; i < vlen; i ++ ) {

			vert = vertices[ i ];

			this.vertices.push( new THREE.Vector3( vert.x, vert.y, 0 ) );

		}

		for ( i = 0; i < flen; i ++ ) {

			face = faces[ i ];

			var a = face[ 0 ] + shapesOffset;
			var b = face[ 1 ] + shapesOffset;
			var c = face[ 2 ] + shapesOffset;

			this.faces.push( new THREE.Face3( a, b, c, null, null, material ) );
			this.faceVertexUvs[ 0 ].push( uvgen.generateTopUV( this, a, b, c ) );

		}

	};

	// File:src/extras/geometries/LatheGeometry.js

	/**
	 * @author astrodud / http://astrodud.isgreat.org/
	 * @author zz85 / https://github.com/zz85
	 * @author bhouston / http://clara.io
	 */

	// points - to create a closed torus, one must use a set of points 
	//    like so: [ a, b, c, d, a ], see first is the same as last.
	// segments - the number of circumference segments to create
	// phiStart - the starting radian
	// phiLength - the radian (0 to 2*PI) range of the lathed section
	//    2*pi is a closed lathe, less than 2PI is a portion.

	THREE.LatheGeometry = function ( points, segments, phiStart, phiLength ) {

		THREE.Geometry.call( this );

		this.type = 'LatheGeometry';

		this.parameters = {
			points: points,
			segments: segments,
			phiStart: phiStart,
			phiLength: phiLength
		};

		segments = segments || 12;
		phiStart = phiStart || 0;
		phiLength = phiLength || 2 * Math.PI;

		var inversePointLength = 1.0 / ( points.length - 1 );
		var inverseSegments = 1.0 / segments;

		for ( var i = 0, il = segments; i <= il; i ++ ) {

			var phi = phiStart + i * inverseSegments * phiLength;

			var c = Math.cos( phi ),
				s = Math.sin( phi );

			for ( var j = 0, jl = points.length; j < jl; j ++ ) {

				var pt = points[ j ];

				var vertex = new THREE.Vector3();

				vertex.x = c * pt.x - s * pt.y;
				vertex.y = s * pt.x + c * pt.y;
				vertex.z = pt.z;

				this.vertices.push( vertex );

			}

		}

		var np = points.length;

		for ( var i = 0, il = segments; i < il; i ++ ) {

			for ( var j = 0, jl = points.length - 1; j < jl; j ++ ) {

				var base = j + np * i;
				var a = base;
				var b = base + np;
				var c = base + 1 + np;
				var d = base + 1;

				var u0 = i * inverseSegments;
				var v0 = j * inversePointLength;
				var u1 = u0 + inverseSegments;
				var v1 = v0 + inversePointLength;

				this.faces.push( new THREE.Face3( a, b, d ) );

				this.faceVertexUvs[ 0 ].push( [

					new THREE.Vector2( u0, v0 ),
					new THREE.Vector2( u1, v0 ),
					new THREE.Vector2( u0, v1 )

				] );

				this.faces.push( new THREE.Face3( b, c, d ) );

				this.faceVertexUvs[ 0 ].push( [

					new THREE.Vector2( u1, v0 ),
					new THREE.Vector2( u1, v1 ),
					new THREE.Vector2( u0, v1 )

				] );


			}

		}

		this.mergeVertices();
		this.computeFaceNormals();
		this.computeVertexNormals();

	};

	THREE.LatheGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry;

	// File:src/extras/geometries/PlaneGeometry.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
	 */

	THREE.PlaneGeometry = function ( width, height, widthSegments, heightSegments ) {

		THREE.Geometry.call( this );

		this.type = 'PlaneGeometry';

		this.parameters = {
			width: width,
			height: height,
			widthSegments: widthSegments,
			heightSegments: heightSegments
		};

		this.fromBufferGeometry( new THREE.PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );

	};

	THREE.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry;

	THREE.PlaneGeometry.prototype.clone = function () {

		var parameters = this.parameters;

		return new THREE.PlaneGeometry(
			parameters.width,
			parameters.height,
			parameters.widthSegments,
			parameters.heightSegments
		);

	};

	// File:src/extras/geometries/PlaneBufferGeometry.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
	 */

	THREE.PlaneBufferGeometry = function ( width, height, widthSegments, heightSegments ) {

		THREE.BufferGeometry.call( this );

		this.type = 'PlaneBufferGeometry';

		this.parameters = {
			width: width,
			height: height,
			widthSegments: widthSegments,
			heightSegments: heightSegments
		};

		var width_half = width / 2;
		var height_half = height / 2;

		var gridX = Math.floor( widthSegments ) || 1;
		var gridY = Math.floor( heightSegments ) || 1;

		var gridX1 = gridX + 1;
		var gridY1 = gridY + 1;

		var segment_width = width / gridX;
		var segment_height = height / gridY;

		var vertices = new Float32Array( gridX1 * gridY1 * 3 );
		var normals = new Float32Array( gridX1 * gridY1 * 3 );
		var uvs = new Float32Array( gridX1 * gridY1 * 2 );

		var offset = 0;
		var offset2 = 0;

		for ( var iy = 0; iy < gridY1; iy ++ ) {

			var y = iy * segment_height - height_half;

			for ( var ix = 0; ix < gridX1; ix ++ ) {

				var x = ix * segment_width - width_half;

				vertices[ offset ] = x;
				vertices[ offset + 1 ] = - y;

				normals[ offset + 2 ] = 1;

				uvs[ offset2 ] = ix / gridX;
				uvs[ offset2 + 1 ] = 1 - ( iy / gridY );

				offset += 3;
				offset2 += 2;

			}

		}

		offset = 0;

		var indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );

		for ( var iy = 0; iy < gridY; iy ++ ) {

			for ( var ix = 0; ix < gridX; ix ++ ) {

				var a = ix + gridX1 * iy;
				var b = ix + gridX1 * ( iy + 1 );
				var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
				var d = ( ix + 1 ) + gridX1 * iy;

				indices[ offset ] = a;
				indices[ offset + 1 ] = b;
				indices[ offset + 2 ] = d;

				indices[ offset + 3 ] = b;
				indices[ offset + 4 ] = c;
				indices[ offset + 5 ] = d;

				offset += 6;

			}

		}

		this.setIndex( new THREE.BufferAttribute( indices, 1 ) );
		this.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

	};

	THREE.PlaneBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
	THREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry;

	THREE.PlaneBufferGeometry.prototype.clone = function () {

		var parameters = this.parameters;

		return new THREE.PlaneBufferGeometry(
			parameters.width,
			parameters.height,
			parameters.widthSegments,
			parameters.heightSegments
		);

	};

	// File:src/extras/geometries/RingGeometry.js

	/**
	 * @author Kaleb Murphy
	 */

	THREE.RingGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

		THREE.Geometry.call( this );

		this.type = 'RingGeometry';

		this.parameters = {
			innerRadius: innerRadius,
			outerRadius: outerRadius,
			thetaSegments: thetaSegments,
			phiSegments: phiSegments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		innerRadius = innerRadius || 0;
		outerRadius = outerRadius || 50;

		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

		thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
		phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 8;

		var i, o, uvs = [], radius = innerRadius, radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );

		for ( i = 0; i < phiSegments + 1; i ++ ) {

			// concentric circles inside ring

			for ( o = 0; o < thetaSegments + 1; o ++ ) {

				// number of segments per circle

				var vertex = new THREE.Vector3();
				var segment = thetaStart + o / thetaSegments * thetaLength;
				vertex.x = radius * Math.cos( segment );
				vertex.y = radius * Math.sin( segment );

				this.vertices.push( vertex );
				uvs.push( new THREE.Vector2( ( vertex.x / outerRadius + 1 ) / 2, ( vertex.y / outerRadius + 1 ) / 2 ) );

			}

			radius += radiusStep;

		}

		var n = new THREE.Vector3( 0, 0, 1 );

		for ( i = 0; i < phiSegments; i ++ ) {

			// concentric circles inside ring

			var thetaSegment = i * ( thetaSegments + 1 );

			for ( o = 0; o < thetaSegments ; o ++ ) {

				// number of segments per circle

				var segment = o + thetaSegment;

				var v1 = segment;
				var v2 = segment + thetaSegments + 1;
				var v3 = segment + thetaSegments + 2;

				this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
				this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ] );

				v1 = segment;
				v2 = segment + thetaSegments + 2;
				v3 = segment + 1;

				this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
				this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ] );

			}

		}

		this.computeFaceNormals();

		this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

	};

	THREE.RingGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.RingGeometry.prototype.constructor = THREE.RingGeometry;

	THREE.RingGeometry.prototype.clone = function () {

		var parameters = this.parameters;

		return new THREE.RingGeometry(
			parameters.innerRadius,
			parameters.outerRadius,
			parameters.thetaSegments,
			parameters.phiSegments,
			parameters.thetaStart,
			parameters.thetaLength
		);

	};

	// File:src/extras/geometries/SphereGeometry.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.SphereGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

		THREE.Geometry.call( this );

		this.type = 'SphereGeometry';

		this.parameters = {
			radius: radius,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			phiStart: phiStart,
			phiLength: phiLength,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		this.fromBufferGeometry( new THREE.SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );

	};

	THREE.SphereGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry;

	THREE.SphereGeometry.prototype.clone = function () {

		var parameters = this.parameters;

		return new THREE.SphereGeometry(
			parameters.radius,
			parameters.widthSegments,
			parameters.heightSegments,
			parameters.phiStart,
			parameters.phiLength,
			parameters.thetaStart,
			parameters.thetaLength
		);

	};

	// File:src/extras/geometries/SphereBufferGeometry.js

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 * based on THREE.SphereGeometry
	 */

	THREE.SphereBufferGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

		THREE.BufferGeometry.call( this );

		this.type = 'SphereBufferGeometry';

		this.parameters = {
			radius: radius,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			phiStart: phiStart,
			phiLength: phiLength,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		radius = radius || 50;

		widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
		heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );

		phiStart = phiStart !== undefined ? phiStart : 0;
		phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;

		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;

		var thetaEnd = thetaStart + thetaLength;

		var vertexCount = ( ( widthSegments + 1 ) * ( heightSegments + 1 ) );

		var positions = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
		var normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
		var uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );

		var index = 0, vertices = [], normal = new THREE.Vector3();

		for ( var y = 0; y <= heightSegments; y ++ ) {

			var verticesRow = [];

			var v = y / heightSegments;

			for ( var x = 0; x <= widthSegments; x ++ ) {

				var u = x / widthSegments;

				var px = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
				var py = radius * Math.cos( thetaStart + v * thetaLength );
				var pz = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

				normal.set( px, py, pz ).normalize();

				positions.setXYZ( index, px, py, pz );
				normals.setXYZ( index, normal.x, normal.y, normal.z );
				uvs.setXY( index, u, 1 - v );

				verticesRow.push( index );

				index ++;

			}

			vertices.push( verticesRow );

		}

		var indices = [];

		for ( var y = 0; y < heightSegments; y ++ ) {

			for ( var x = 0; x < widthSegments; x ++ ) {

				var v1 = vertices[ y ][ x + 1 ];
				var v2 = vertices[ y ][ x ];
				var v3 = vertices[ y + 1 ][ x ];
				var v4 = vertices[ y + 1 ][ x + 1 ];

				if ( y !== 0 || thetaStart > 0 ) indices.push( v1, v2, v4 );
				if ( y !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( v2, v3, v4 );

			}

		}

		this.setIndex( new ( positions.count > 65535 ? THREE.Uint32Attribute : THREE.Uint16Attribute )( indices, 1 ) );
		this.addAttribute( 'position', positions );
		this.addAttribute( 'normal', normals );
		this.addAttribute( 'uv', uvs );

		this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

	};

	THREE.SphereBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
	THREE.SphereBufferGeometry.prototype.constructor = THREE.SphereBufferGeometry;

	THREE.SphereBufferGeometry.prototype.clone = function () {

		var parameters = this.parameters;

		return new THREE.SphereBufferGeometry(
			parameters.radius,
			parameters.widthSegments,
			parameters.heightSegments,
			parameters.phiStart,
			parameters.phiLength,
			parameters.thetaStart,
			parameters.thetaLength
		);

	};

	// File:src/extras/geometries/TorusGeometry.js

	/**
	 * @author oosmoxiecode
	 * @author mrdoob / http://mrdoob.com/
	 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888
	 */

	THREE.TorusGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {

		THREE.Geometry.call( this );

		this.type = 'TorusGeometry';

		this.parameters = {
			radius: radius,
			tube: tube,
			radialSegments: radialSegments,
			tubularSegments: tubularSegments,
			arc: arc
		};

		radius = radius || 100;
		tube = tube || 40;
		radialSegments = radialSegments || 8;
		tubularSegments = tubularSegments || 6;
		arc = arc || Math.PI * 2;

		var center = new THREE.Vector3(), uvs = [], normals = [];

		for ( var j = 0; j <= radialSegments; j ++ ) {

			for ( var i = 0; i <= tubularSegments; i ++ ) {

				var u = i / tubularSegments * arc;
				var v = j / radialSegments * Math.PI * 2;

				center.x = radius * Math.cos( u );
				center.y = radius * Math.sin( u );

				var vertex = new THREE.Vector3();
				vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
				vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
				vertex.z = tube * Math.sin( v );

				this.vertices.push( vertex );

				uvs.push( new THREE.Vector2( i / tubularSegments, j / radialSegments ) );
				normals.push( vertex.clone().sub( center ).normalize() );

			}

		}

		for ( var j = 1; j <= radialSegments; j ++ ) {

			for ( var i = 1; i <= tubularSegments; i ++ ) {

				var a = ( tubularSegments + 1 ) * j + i - 1;
				var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
				var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
				var d = ( tubularSegments + 1 ) * j + i;

				var face = new THREE.Face3( a, b, d, [ normals[ a ].clone(), normals[ b ].clone(), normals[ d ].clone() ] );
				this.faces.push( face );
				this.faceVertexUvs[ 0 ].push( [ uvs[ a ].clone(), uvs[ b ].clone(), uvs[ d ].clone() ] );

				face = new THREE.Face3( b, c, d, [ normals[ b ].clone(), normals[ c ].clone(), normals[ d ].clone() ] );
				this.faces.push( face );
				this.faceVertexUvs[ 0 ].push( [ uvs[ b ].clone(), uvs[ c ].clone(), uvs[ d ].clone() ] );

			}

		}

		this.computeFaceNormals();

	};

	THREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry;

	THREE.TorusGeometry.prototype.clone = function () {

		var parameters = this.parameters;

		return new THREE.TorusGeometry(
			parameters.radius,
			parameters.tube,
			parameters.radialSegments,
			parameters.tubularSegments,
			parameters.arc
		);

	};

	// File:src/extras/geometries/TorusKnotGeometry.js

	/**
	 * @author oosmoxiecode
	 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473
	 */

	THREE.TorusKnotGeometry = function ( radius, tube, radialSegments, tubularSegments, p, q, heightScale ) {

		THREE.Geometry.call( this );

		this.type = 'TorusKnotGeometry';

		this.parameters = {
			radius: radius,
			tube: tube,
			radialSegments: radialSegments,
			tubularSegments: tubularSegments,
			p: p,
			q: q,
			heightScale: heightScale
		};

		radius = radius || 100;
		tube = tube || 40;
		radialSegments = radialSegments || 64;
		tubularSegments = tubularSegments || 8;
		p = p || 2;
		q = q || 3;
		heightScale = heightScale || 1;

		var grid = new Array( radialSegments );
		var tang = new THREE.Vector3();
		var n = new THREE.Vector3();
		var bitan = new THREE.Vector3();

		for ( var i = 0; i < radialSegments; ++ i ) {

			grid[ i ] = new Array( tubularSegments );
			var u = i / radialSegments * 2 * p * Math.PI;
			var p1 = getPos( u, q, p, radius, heightScale );
			var p2 = getPos( u + 0.01, q, p, radius, heightScale );
			tang.subVectors( p2, p1 );
			n.addVectors( p2, p1 );

			bitan.crossVectors( tang, n );
			n.crossVectors( bitan, tang );
			bitan.normalize();
			n.normalize();

			for ( var j = 0; j < tubularSegments; ++ j ) {

				var v = j / tubularSegments * 2 * Math.PI;
				var cx = - tube * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
				var cy = tube * Math.sin( v );

				var pos = new THREE.Vector3();
				pos.x = p1.x + cx * n.x + cy * bitan.x;
				pos.y = p1.y + cx * n.y + cy * bitan.y;
				pos.z = p1.z + cx * n.z + cy * bitan.z;

				grid[ i ][ j ] = this.vertices.push( pos ) - 1;

			}

		}

		for ( var i = 0; i < radialSegments; ++ i ) {

			for ( var j = 0; j < tubularSegments; ++ j ) {

				var ip = ( i + 1 ) % radialSegments;
				var jp = ( j + 1 ) % tubularSegments;

				var a = grid[ i ][ j ];
				var b = grid[ ip ][ j ];
				var c = grid[ ip ][ jp ];
				var d = grid[ i ][ jp ];

				var uva = new THREE.Vector2( i / radialSegments, j / tubularSegments );
				var uvb = new THREE.Vector2( ( i + 1 ) / radialSegments, j / tubularSegments );
				var uvc = new THREE.Vector2( ( i + 1 ) / radialSegments, ( j + 1 ) / tubularSegments );
				var uvd = new THREE.Vector2( i / radialSegments, ( j + 1 ) / tubularSegments );

				this.faces.push( new THREE.Face3( a, b, d ) );
				this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

				this.faces.push( new THREE.Face3( b, c, d ) );
				this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

			}

		}

		this.computeFaceNormals();
		this.computeVertexNormals();

		function getPos( u, in_q, in_p, radius, heightScale ) {

			var cu = Math.cos( u );
			var su = Math.sin( u );
			var quOverP = in_q / in_p * u;
			var cs = Math.cos( quOverP );

			var tx = radius * ( 2 + cs ) * 0.5 * cu;
			var ty = radius * ( 2 + cs ) * su * 0.5;
			var tz = heightScale * radius * Math.sin( quOverP ) * 0.5;

			return new THREE.Vector3( tx, ty, tz );

		}

	};

	THREE.TorusKnotGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry;

	THREE.TorusKnotGeometry.prototype.clone = function () {

		var parameters = this.parameters;

		return new THREE.TorusKnotGeometry(
			parameters.radius,
			parameters.tube,
			parameters.radialSegments,
			parameters.tubularSegments,
			parameters.p,
			parameters.q,
			parameters.heightScale
		);

	};

	// File:src/extras/geometries/TubeGeometry.js

	/**
	 * @author WestLangley / https://github.com/WestLangley
	 * @author zz85 / https://github.com/zz85
	 * @author miningold / https://github.com/miningold
	 * @author jonobr1 / https://github.com/jonobr1
	 *
	 * Modified from the TorusKnotGeometry by @oosmoxiecode
	 *
	 * Creates a tube which extrudes along a 3d spline
	 *
	 * Uses parallel transport frames as described in
	 * http://www.cs.indiana.edu/pub/techreports/TR425.pdf
	 */

	THREE.TubeGeometry = function ( path, segments, radius, radialSegments, closed, taper ) {

		THREE.Geometry.call( this );

		this.type = 'TubeGeometry';

		this.parameters = {
			path: path,
			segments: segments,
			radius: radius,
			radialSegments: radialSegments,
			closed: closed,
			taper: taper
		};

		segments = segments || 64;
		radius = radius || 1;
		radialSegments = radialSegments || 8;
		closed = closed || false;
		taper = taper || THREE.TubeGeometry.NoTaper;

		var grid = [];

		var scope = this,

			tangent,
			normal,
			binormal,

			numpoints = segments + 1,

			u, v, r,

			cx, cy,
			pos, pos2 = new THREE.Vector3(),
			i, j,
			ip, jp,
			a, b, c, d,
			uva, uvb, uvc, uvd;

		var frames = new THREE.TubeGeometry.FrenetFrames( path, segments, closed ),
			tangents = frames.tangents,
			normals = frames.normals,
			binormals = frames.binormals;

		// proxy internals
		this.tangents = tangents;
		this.normals = normals;
		this.binormals = binormals;

		function vert( x, y, z ) {

			return scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;

		}

		// construct the grid

		for ( i = 0; i < numpoints; i ++ ) {

			grid[ i ] = [];

			u = i / ( numpoints - 1 );

			pos = path.getPointAt( u );

			tangent = tangents[ i ];
			normal = normals[ i ];
			binormal = binormals[ i ];

			r = radius * taper( u );

			for ( j = 0; j < radialSegments; j ++ ) {

				v = j / radialSegments * 2 * Math.PI;

				cx = - r * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
				cy = r * Math.sin( v );

				pos2.copy( pos );
				pos2.x += cx * normal.x + cy * binormal.x;
				pos2.y += cx * normal.y + cy * binormal.y;
				pos2.z += cx * normal.z + cy * binormal.z;

				grid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );

			}

		}


		// construct the mesh

		for ( i = 0; i < segments; i ++ ) {

			for ( j = 0; j < radialSegments; j ++ ) {

				ip = ( closed ) ? ( i + 1 ) % segments : i + 1;
				jp = ( j + 1 ) % radialSegments;

				a = grid[ i ][ j ];		// *** NOT NECESSARILY PLANAR ! ***
				b = grid[ ip ][ j ];
				c = grid[ ip ][ jp ];
				d = grid[ i ][ jp ];

				uva = new THREE.Vector2( i / segments, j / radialSegments );
				uvb = new THREE.Vector2( ( i + 1 ) / segments, j / radialSegments );
				uvc = new THREE.Vector2( ( i + 1 ) / segments, ( j + 1 ) / radialSegments );
				uvd = new THREE.Vector2( i / segments, ( j + 1 ) / radialSegments );

				this.faces.push( new THREE.Face3( a, b, d ) );
				this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

				this.faces.push( new THREE.Face3( b, c, d ) );
				this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

			}

		}

		this.computeFaceNormals();
		this.computeVertexNormals();

	};

	THREE.TubeGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry;
	THREE.TubeGeometry.prototype.clone = function() {

		return new this.constructor( this.parameters.path,
			this.parameters.segments, this.parameters.radius, this.parameters.radialSegments,
			this.parameters.closed, this.parameters.taper
		);

	};

	THREE.TubeGeometry.NoTaper = function ( u ) {

		return 1;

	};

	THREE.TubeGeometry.SinusoidalTaper = function ( u ) {

		return Math.sin( Math.PI * u );

	};

	// For computing of Frenet frames, exposing the tangents, normals and binormals the spline
	THREE.TubeGeometry.FrenetFrames = function ( path, segments, closed ) {

		var	normal = new THREE.Vector3(),

			tangents = [],
			normals = [],
			binormals = [],

			vec = new THREE.Vector3(),
			mat = new THREE.Matrix4(),

			numpoints = segments + 1,
			theta,
			smallest,

			tx, ty, tz,
			i, u;


		// expose internals
		this.tangents = tangents;
		this.normals = normals;
		this.binormals = binormals;

		// compute the tangent vectors for each segment on the path

		for ( i = 0; i < numpoints; i ++ ) {

			u = i / ( numpoints - 1 );

			tangents[ i ] = path.getTangentAt( u );
			tangents[ i ].normalize();

		}

		initialNormal3();

		/*
		function initialNormal1(lastBinormal) {
			// fixed start binormal. Has dangers of 0 vectors
			normals[ 0 ] = new THREE.Vector3();
			binormals[ 0 ] = new THREE.Vector3();
			if (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );
			normals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();
			binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();
		}

		function initialNormal2() {

			// This uses the Frenet-Serret formula for deriving binormal
			var t2 = path.getTangentAt( epsilon );

			normals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();
			binormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );

			normals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent
			binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();

		}
		*/

		function initialNormal3() {

			// select an initial normal vector perpendicular to the first tangent vector,
			// and in the direction of the smallest tangent xyz component

			normals[ 0 ] = new THREE.Vector3();
			binormals[ 0 ] = new THREE.Vector3();
			smallest = Number.MAX_VALUE;
			tx = Math.abs( tangents[ 0 ].x );
			ty = Math.abs( tangents[ 0 ].y );
			tz = Math.abs( tangents[ 0 ].z );

			if ( tx <= smallest ) {

				smallest = tx;
				normal.set( 1, 0, 0 );

			}

			if ( ty <= smallest ) {

				smallest = ty;
				normal.set( 0, 1, 0 );

			}

			if ( tz <= smallest ) {

				normal.set( 0, 0, 1 );

			}

			vec.crossVectors( tangents[ 0 ], normal ).normalize();

			normals[ 0 ].crossVectors( tangents[ 0 ], vec );
			binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );

		}


		// compute the slowly-varying normal and binormal vectors for each segment on the path

		for ( i = 1; i < numpoints; i ++ ) {

			normals[ i ] = normals[ i - 1 ].clone();

			binormals[ i ] = binormals[ i - 1 ].clone();

			vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );

			if ( vec.length() > Number.EPSILON ) {

				vec.normalize();

				theta = Math.acos( THREE.Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

				normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

			}

			binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

		}


		// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

		if ( closed ) {

			theta = Math.acos( THREE.Math.clamp( normals[ 0 ].dot( normals[ numpoints - 1 ] ), - 1, 1 ) );
			theta /= ( numpoints - 1 );

			if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints - 1 ] ) ) > 0 ) {

				theta = - theta;

			}

			for ( i = 1; i < numpoints; i ++ ) {

				// twist a little...
				normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
				binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

			}

		}

	};

	// File:src/extras/geometries/PolyhedronGeometry.js

	/**
	 * @author clockworkgeek / https://github.com/clockworkgeek
	 * @author timothypratley / https://github.com/timothypratley
	 * @author WestLangley / http://github.com/WestLangley
	*/

	THREE.PolyhedronGeometry = function ( vertices, indices, radius, detail ) {

		THREE.Geometry.call( this );

		this.type = 'PolyhedronGeometry';

		this.parameters = {
			vertices: vertices,
			indices: indices,
			radius: radius,
			detail: detail
		};

		radius = radius || 1;
		detail = detail || 0;

		var that = this;

		for ( var i = 0, l = vertices.length; i < l; i += 3 ) {

			prepare( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );

		}

		var p = this.vertices;

		var faces = [];

		for ( var i = 0, j = 0, l = indices.length; i < l; i += 3, j ++ ) {

			var v1 = p[ indices[ i ] ];
			var v2 = p[ indices[ i + 1 ] ];
			var v3 = p[ indices[ i + 2 ] ];

			faces[ j ] = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ], undefined, j );

		}

		var centroid = new THREE.Vector3();

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			subdivide( faces[ i ], detail );

		}


		// Handle case when face straddles the seam

		for ( var i = 0, l = this.faceVertexUvs[ 0 ].length; i < l; i ++ ) {

			var uvs = this.faceVertexUvs[ 0 ][ i ];

			var x0 = uvs[ 0 ].x;
			var x1 = uvs[ 1 ].x;
			var x2 = uvs[ 2 ].x;

			var max = Math.max( x0, x1, x2 );
			var min = Math.min( x0, x1, x2 );

			if ( max > 0.9 && min < 0.1 ) {

				// 0.9 is somewhat arbitrary

				if ( x0 < 0.2 ) uvs[ 0 ].x += 1;
				if ( x1 < 0.2 ) uvs[ 1 ].x += 1;
				if ( x2 < 0.2 ) uvs[ 2 ].x += 1;

			}

		}


		// Apply radius

		for ( var i = 0, l = this.vertices.length; i < l; i ++ ) {

			this.vertices[ i ].multiplyScalar( radius );

		}


		// Merge vertices

		this.mergeVertices();

		this.computeFaceNormals();

		this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );


		// Project vector onto sphere's surface

		function prepare( vector ) {

			var vertex = vector.normalize().clone();
			vertex.index = that.vertices.push( vertex ) - 1;

			// Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.

			var u = azimuth( vector ) / 2 / Math.PI + 0.5;
			var v = inclination( vector ) / Math.PI + 0.5;
			vertex.uv = new THREE.Vector2( u, 1 - v );

			return vertex;

		}


		// Approximate a curved face with recursively sub-divided triangles.

		function make( v1, v2, v3, materialIndex ) {

			var face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ], undefined, materialIndex );
			that.faces.push( face );

			centroid.copy( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );

			var azi = azimuth( centroid );

			that.faceVertexUvs[ 0 ].push( [
				correctUV( v1.uv, v1, azi ),
				correctUV( v2.uv, v2, azi ),
				correctUV( v3.uv, v3, azi )
			] );

		}


		// Analytically subdivide a face to the required detail level.

		function subdivide( face, detail ) {

			var cols = Math.pow( 2, detail );
			var a = prepare( that.vertices[ face.a ] );
			var b = prepare( that.vertices[ face.b ] );
			var c = prepare( that.vertices[ face.c ] );
			var v = [];

			var materialIndex = face.materialIndex;

			// Construct all of the vertices for this subdivision.

			for ( var i = 0 ; i <= cols; i ++ ) {

				v[ i ] = [];

				var aj = prepare( a.clone().lerp( c, i / cols ) );
				var bj = prepare( b.clone().lerp( c, i / cols ) );
				var rows = cols - i;

				for ( var j = 0; j <= rows; j ++ ) {

					if ( j === 0 && i === cols ) {

						v[ i ][ j ] = aj;

					} else {

						v[ i ][ j ] = prepare( aj.clone().lerp( bj, j / rows ) );

					}

				}

			}

			// Construct all of the faces.

			for ( var i = 0; i < cols ; i ++ ) {

				for ( var j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {

					var k = Math.floor( j / 2 );

					if ( j % 2 === 0 ) {

						make(
							v[ i ][ k + 1 ],
							v[ i + 1 ][ k ],
							v[ i ][ k ],
							materialIndex
						);

					} else {

						make(
							v[ i ][ k + 1 ],
							v[ i + 1 ][ k + 1 ],
							v[ i + 1 ][ k ],
							materialIndex
						);

					}

				}

			}

		}


		// Angle around the Y axis, counter-clockwise when looking from above.

		function azimuth( vector ) {

			return Math.atan2( vector.z, - vector.x );

		}


		// Angle above the XZ plane.

		function inclination( vector ) {

			return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

		}


		// Texture fixing helper. Spheres have some odd behaviours.

		function correctUV( uv, vector, azimuth ) {

			if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new THREE.Vector2( uv.x - 1, uv.y );
			if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );
			return uv.clone();

		}


	};

	THREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry;

	THREE.PolyhedronGeometry.prototype.clone = function () {

		var parameters = this.parameters;

		return new THREE.PolyhedronGeometry(
			parameters.vertices,
			parameters.indices,
			parameters.radius,
			parameters.detail
		);

	};

	// File:src/extras/geometries/DodecahedronGeometry.js

	/**
	 * @author Abe Pazos / https://hamoid.com
	 */

	THREE.DodecahedronGeometry = function ( radius, detail ) {

		var t = ( 1 + Math.sqrt( 5 ) ) / 2;
		var r = 1 / t;

		var vertices = [

			// (Â±1, Â±1, Â±1)
			- 1, - 1, - 1,    - 1, - 1,  1,
			- 1,  1, - 1,    - 1,  1,  1,
			 1, - 1, - 1,     1, - 1,  1,
			 1,  1, - 1,     1,  1,  1,

			// (0, Â±1/Ï, Â±Ï)
			 0, - r, - t,     0, - r,  t,
			 0,  r, - t,     0,  r,  t,

			// (Â±1/Ï, Â±Ï, 0)
			- r, - t,  0,    - r,  t,  0,
			 r, - t,  0,     r,  t,  0,

			// (Â±Ï, 0, Â±1/Ï)
			- t,  0, - r,     t,  0, - r,
			- t,  0,  r,     t,  0,  r
		];

		var indices = [
			 3, 11,  7,      3,  7, 15,      3, 15, 13,
			 7, 19, 17,      7, 17,  6,      7,  6, 15,
			17,  4,  8,     17,  8, 10,     17, 10,  6,
			 8,  0, 16,      8, 16,  2,      8,  2, 10,
			 0, 12,  1,      0,  1, 18,      0, 18, 16,
			 6, 10,  2,      6,  2, 13,      6, 13, 15,
			 2, 16, 18,      2, 18,  3,      2,  3, 13,
			18,  1,  9,     18,  9, 11,     18, 11,  3,
			 4, 14, 12,      4, 12,  0,      4,  0,  8,
			11,  9,  5,     11,  5, 19,     11, 19,  7,
			19,  5, 14,     19, 14,  4,     19,  4, 17,
			 1, 12, 14,      1, 14,  5,      1,  5,  9
		];

		THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

		this.type = 'DodecahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	};

	THREE.DodecahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
	THREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry;

	THREE.DodecahedronGeometry.prototype.clone = function () {

		var parameters = this.parameters;

		return new THREE.DodecahedronGeometry(
			parameters.radius,
			parameters.detail
		);

	};

	// File:src/extras/geometries/IcosahedronGeometry.js

	/**
	 * @author timothypratley / https://github.com/timothypratley
	 */

	THREE.IcosahedronGeometry = function ( radius, detail ) {

		var t = ( 1 + Math.sqrt( 5 ) ) / 2;

		var vertices = [
			- 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,
			 0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,
			 t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1
		];

		var indices = [
			 0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,
			 1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,
			 3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,
			 4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1
		];

		THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

		this.type = 'IcosahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	};

	THREE.IcosahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
	THREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry;

	THREE.IcosahedronGeometry.prototype.clone = function () {

		var parameters = this.parameters;

		return new THREE.IcosahedronGeometry(
			parameters.radius,
			parameters.detail
		);

	};

	// File:src/extras/geometries/OctahedronGeometry.js

	/**
	 * @author timothypratley / https://github.com/timothypratley
	 */

	THREE.OctahedronGeometry = function ( radius, detail ) {

		var vertices = [
			1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0, - 1, 0,    0, 0, 1,    0, 0, - 1
		];

		var indices = [
			0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2
		];

		THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

		this.type = 'OctahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	};

	THREE.OctahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
	THREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry;

	THREE.OctahedronGeometry.prototype.clone = function () {

		var parameters = this.parameters;

		return new THREE.OctahedronGeometry(
			parameters.radius,
			parameters.detail
		);

	};

	// File:src/extras/geometries/TetrahedronGeometry.js

	/**
	 * @author timothypratley / https://github.com/timothypratley
	 */

	THREE.TetrahedronGeometry = function ( radius, detail ) {

		var vertices = [
			 1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1
		];

		var indices = [
			 2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1
		];

		THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

		this.type = 'TetrahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	};

	THREE.TetrahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
	THREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry;

	THREE.TetrahedronGeometry.prototype.clone = function () {

		var parameters = this.parameters;

		return new THREE.TetrahedronGeometry(
			parameters.radius,
			parameters.detail
		);

	};

	// File:src/extras/geometries/ParametricGeometry.js

	/**
	 * @author zz85 / https://github.com/zz85
	 * Parametric Surfaces Geometry
	 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
	 *
	 * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements );
	 *
	 */

	THREE.ParametricGeometry = function ( func, slices, stacks ) {

		THREE.Geometry.call( this );

		this.type = 'ParametricGeometry';

		this.parameters = {
			func: func,
			slices: slices,
			stacks: stacks
		};

		var verts = this.vertices;
		var faces = this.faces;
		var uvs = this.faceVertexUvs[ 0 ];

		var i, j, p;
		var u, v;

		var sliceCount = slices + 1;

		for ( i = 0; i <= stacks; i ++ ) {

			v = i / stacks;

			for ( j = 0; j <= slices; j ++ ) {

				u = j / slices;

				p = func( u, v );
				verts.push( p );

			}

		}

		var a, b, c, d;
		var uva, uvb, uvc, uvd;

		for ( i = 0; i < stacks; i ++ ) {

			for ( j = 0; j < slices; j ++ ) {

				a = i * sliceCount + j;
				b = i * sliceCount + j + 1;
				c = ( i + 1 ) * sliceCount + j + 1;
				d = ( i + 1 ) * sliceCount + j;

				uva = new THREE.Vector2( j / slices, i / stacks );
				uvb = new THREE.Vector2( ( j + 1 ) / slices, i / stacks );
				uvc = new THREE.Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );
				uvd = new THREE.Vector2( j / slices, ( i + 1 ) / stacks );

				faces.push( new THREE.Face3( a, b, d ) );
				uvs.push( [ uva, uvb, uvd ] );

				faces.push( new THREE.Face3( b, c, d ) );
				uvs.push( [ uvb.clone(), uvc, uvd.clone() ] );

			}

		}

		// console.log(this);

		// magic bullet
		// var diff = this.mergeVertices();
		// console.log('removed ', diff, ' vertices by merging');

		this.computeFaceNormals();
		this.computeVertexNormals();

	};

	THREE.ParametricGeometry.prototype = Object.create( THREE.Geometry.prototype );
	THREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry;

	// File:src/extras/geometries/WireframeGeometry.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.WireframeGeometry = function ( geometry ) {

		THREE.BufferGeometry.call( this );

		var edge = [ 0, 0 ], hash = {};

		function sortFunction( a, b ) {

			return a - b;

		}

		var keys = [ 'a', 'b', 'c' ];

		if ( geometry instanceof THREE.Geometry ) {

			var vertices = geometry.vertices;
			var faces = geometry.faces;
			var numEdges = 0;

			// allocate maximal size
			var edges = new Uint32Array( 6 * faces.length );

			for ( var i = 0, l = faces.length; i < l; i ++ ) {

				var face = faces[ i ];

				for ( var j = 0; j < 3; j ++ ) {

					edge[ 0 ] = face[ keys[ j ] ];
					edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
					edge.sort( sortFunction );

					var key = edge.toString();

					if ( hash[ key ] === undefined ) {

						edges[ 2 * numEdges ] = edge[ 0 ];
						edges[ 2 * numEdges + 1 ] = edge[ 1 ];
						hash[ key ] = true;
						numEdges ++;

					}

				}

			}

			var coords = new Float32Array( numEdges * 2 * 3 );

			for ( var i = 0, l = numEdges; i < l; i ++ ) {

				for ( var j = 0; j < 2; j ++ ) {

					var vertex = vertices[ edges [ 2 * i + j ] ];

					var index = 6 * i + 3 * j;
					coords[ index + 0 ] = vertex.x;
					coords[ index + 1 ] = vertex.y;
					coords[ index + 2 ] = vertex.z;

				}

			}

			this.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

		} else if ( geometry instanceof THREE.BufferGeometry ) {

			if ( geometry.index !== null ) {

				// Indexed BufferGeometry

				var indices = geometry.index.array;
				var vertices = geometry.attributes.position;
				var drawcalls = geometry.drawcalls;
				var numEdges = 0;

				if ( drawcalls.length === 0 ) {

					geometry.addGroup( 0, indices.length );

				}

				// allocate maximal size
				var edges = new Uint32Array( 2 * indices.length );

				for ( var o = 0, ol = drawcalls.length; o < ol; ++ o ) {

					var drawcall = drawcalls[ o ];

					var start = drawcall.start;
					var count = drawcall.count;

					for ( var i = start, il = start + count; i < il; i += 3 ) {

						for ( var j = 0; j < 3; j ++ ) {

							edge[ 0 ] = indices[ i + j ];
							edge[ 1 ] = indices[ i + ( j + 1 ) % 3 ];
							edge.sort( sortFunction );

							var key = edge.toString();

							if ( hash[ key ] === undefined ) {

								edges[ 2 * numEdges ] = edge[ 0 ];
								edges[ 2 * numEdges + 1 ] = edge[ 1 ];
								hash[ key ] = true;
								numEdges ++;

							}

						}

					}

				}

				var coords = new Float32Array( numEdges * 2 * 3 );

				for ( var i = 0, l = numEdges; i < l; i ++ ) {

					for ( var j = 0; j < 2; j ++ ) {

						var index = 6 * i + 3 * j;
						var index2 = edges[ 2 * i + j ];

						coords[ index + 0 ] = vertices.getX( index2 );
						coords[ index + 1 ] = vertices.getY( index2 );
						coords[ index + 2 ] = vertices.getZ( index2 );

					}

				}

				this.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

			} else {

				// non-indexed BufferGeometry

				var vertices = geometry.attributes.position.array;
				var numEdges = vertices.length / 3;
				var numTris = numEdges / 3;

				var coords = new Float32Array( numEdges * 2 * 3 );

				for ( var i = 0, l = numTris; i < l; i ++ ) {

					for ( var j = 0; j < 3; j ++ ) {

						var index = 18 * i + 6 * j;

						var index1 = 9 * i + 3 * j;
						coords[ index + 0 ] = vertices[ index1 ];
						coords[ index + 1 ] = vertices[ index1 + 1 ];
						coords[ index + 2 ] = vertices[ index1 + 2 ];

						var index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );
						coords[ index + 3 ] = vertices[ index2 ];
						coords[ index + 4 ] = vertices[ index2 + 1 ];
						coords[ index + 5 ] = vertices[ index2 + 2 ];

					}

				}

				this.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

			}

		}

	};

	THREE.WireframeGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
	THREE.WireframeGeometry.prototype.constructor = THREE.WireframeGeometry;

	// File:src/extras/helpers/AxisHelper.js

	/**
	 * @author sroucheray / http://sroucheray.org/
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.AxisHelper = function ( size ) {

		size = size || 1;

		var vertices = new Float32Array( [
			0, 0, 0,  size, 0, 0,
			0, 0, 0,  0, size, 0,
			0, 0, 0,  0, 0, size
		] );

		var colors = new Float32Array( [
			1, 0, 0,  1, 0.6, 0,
			0, 1, 0,  0.6, 1, 0,
			0, 0, 1,  0, 0.6, 1
		] );

		var geometry = new THREE.BufferGeometry();
		geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
		geometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );

		var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );

		THREE.LineSegments.call( this, geometry, material );

	};

	THREE.AxisHelper.prototype = Object.create( THREE.LineSegments.prototype );
	THREE.AxisHelper.prototype.constructor = THREE.AxisHelper;

	// File:src/extras/helpers/ArrowHelper.js

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 * @author zz85 / http://github.com/zz85
	 * @author bhouston / http://clara.io
	 *
	 * Creates an arrow for visualizing directions
	 *
	 * Parameters:
	 *  dir - Vector3
	 *  origin - Vector3
	 *  length - Number
	 *  color - color in hex value
	 *  headLength - Number
	 *  headWidth - Number
	 */

	THREE.ArrowHelper = ( function () {

		var lineGeometry = new THREE.Geometry();
		lineGeometry.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 1, 0 ) );

		var coneGeometry = new THREE.CylinderGeometry( 0, 0.5, 1, 5, 1 );
		coneGeometry.translate( 0, - 0.5, 0 );

		return function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {

			// dir is assumed to be normalized

			THREE.Object3D.call( this );

			if ( color === undefined ) color = 0xffff00;
			if ( length === undefined ) length = 1;
			if ( headLength === undefined ) headLength = 0.2 * length;
			if ( headWidth === undefined ) headWidth = 0.2 * headLength;

			this.position.copy( origin );
			
			if ( headLength < length ) {
				this.line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color: color } ) );
				this.line.matrixAutoUpdate = false;
				this.add( this.line );
			}

			this.cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( { color: color } ) );
			this.cone.matrixAutoUpdate = false;
			this.add( this.cone );

			this.setDirection( dir );
			this.setLength( length, headLength, headWidth );

		}

	}() );

	THREE.ArrowHelper.prototype = Object.create( THREE.Object3D.prototype );
	THREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper;

	THREE.ArrowHelper.prototype.setDirection = ( function () {

		var axis = new THREE.Vector3();
		var radians;

		return function setDirection( dir ) {

			// dir is assumed to be normalized

			if ( dir.y > 0.99999 ) {

				this.quaternion.set( 0, 0, 0, 1 );

			} else if ( dir.y < - 0.99999 ) {

				this.quaternion.set( 1, 0, 0, 0 );

			} else {

				axis.set( dir.z, 0, - dir.x ).normalize();

				radians = Math.acos( dir.y );

				this.quaternion.setFromAxisAngle( axis, radians );

			}

		};

	}() );

	THREE.ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {

		if ( headLength === undefined ) headLength = 0.2 * length;
		if ( headWidth === undefined ) headWidth = 0.2 * headLength;

		if ( headLength < length ){
			this.line.scale.set( 1, length - headLength, 1 );
			this.line.updateMatrix();
		}

		this.cone.scale.set( headWidth, headLength, headWidth );
		this.cone.position.y = length;
		this.cone.updateMatrix();

	};

	THREE.ArrowHelper.prototype.setColor = function ( color ) {

		if ( this.line !== undefined ) this.line.material.color.set( color );
		this.cone.material.color.set( color );

	};

	// File:src/extras/helpers/BoxHelper.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.BoxHelper = function ( object ) {

		var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
		var positions = new Float32Array( 8 * 3 );

		var geometry = new THREE.BufferGeometry();
		geometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );
		geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );

		THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: 0xffff00 } ) );

		if ( object !== undefined ) {

			this.update( object );

		}

	};

	THREE.BoxHelper.prototype = Object.create( THREE.LineSegments.prototype );
	THREE.BoxHelper.prototype.constructor = THREE.BoxHelper;

	THREE.BoxHelper.prototype.update = ( function () {

		var box = new THREE.Box3();

		return function ( object ) {

			box.setFromObject( object );

			if ( box.empty() ) return;

			var min = box.min;
			var max = box.max;

			/*
			  5____4
			1/___0/|
			| 6__|_7
			2/___3/

			0: max.x, max.y, max.z
			1: min.x, max.y, max.z
			2: min.x, min.y, max.z
			3: max.x, min.y, max.z
			4: max.x, max.y, min.z
			5: min.x, max.y, min.z
			6: min.x, min.y, min.z
			7: max.x, min.y, min.z
			*/

			var position = this.geometry.attributes.position;
			var array = position.array;

			array[  0 ] = max.x; array[  1 ] = max.y; array[  2 ] = max.z;
			array[  3 ] = min.x; array[  4 ] = max.y; array[  5 ] = max.z;
			array[  6 ] = min.x; array[  7 ] = min.y; array[  8 ] = max.z;
			array[  9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;
			array[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;
			array[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;
			array[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;
			array[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;

			position.needsUpdate = true;

			this.geometry.computeBoundingSphere();

		}

	} )();

	// File:src/extras/helpers/BoundingBoxHelper.js

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 */

	// a helper to show the world-axis-aligned bounding box for an object

	THREE.BoundingBoxHelper = function ( object, hex ) {

		var color = ( hex !== undefined ) ? hex : 0x888888;

		this.object = object;

		this.box = new THREE.Box3();

		THREE.Mesh.call( this, new THREE.BoxGeometry( 1, 1, 1 ), new THREE.MeshBasicMaterial( { color: color, wireframe: true } ) );

	};

	THREE.BoundingBoxHelper.prototype = Object.create( THREE.Mesh.prototype );
	THREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper;

	THREE.BoundingBoxHelper.prototype.update = function () {

		this.box.setFromObject( this.object );

		this.box.size( this.scale );

		this.box.center( this.position );

	};

	// File:src/extras/helpers/CameraHelper.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 *	- shows frustum, line of sight and up of the camera
	 *	- suitable for fast updates
	 * 	- based on frustum visualization in lightgl.js shadowmap example
	 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
	 */

	THREE.CameraHelper = function ( camera ) {

		var geometry = new THREE.Geometry();
		var material = new THREE.LineBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } );

		var pointMap = {};

		// colors

		var hexFrustum = 0xffaa00;
		var hexCone = 0xff0000;
		var hexUp = 0x00aaff;
		var hexTarget = 0xffffff;
		var hexCross = 0x333333;

		// near

		addLine( "n1", "n2", hexFrustum );
		addLine( "n2", "n4", hexFrustum );
		addLine( "n4", "n3", hexFrustum );
		addLine( "n3", "n1", hexFrustum );

		// far

		addLine( "f1", "f2", hexFrustum );
		addLine( "f2", "f4", hexFrustum );
		addLine( "f4", "f3", hexFrustum );
		addLine( "f3", "f1", hexFrustum );

		// sides

		addLine( "n1", "f1", hexFrustum );
		addLine( "n2", "f2", hexFrustum );
		addLine( "n3", "f3", hexFrustum );
		addLine( "n4", "f4", hexFrustum );

		// cone

		addLine( "p", "n1", hexCone );
		addLine( "p", "n2", hexCone );
		addLine( "p", "n3", hexCone );
		addLine( "p", "n4", hexCone );

		// up

		addLine( "u1", "u2", hexUp );
		addLine( "u2", "u3", hexUp );
		addLine( "u3", "u1", hexUp );

		// target

		addLine( "c", "t", hexTarget );
		addLine( "p", "c", hexCross );

		// cross

		addLine( "cn1", "cn2", hexCross );
		addLine( "cn3", "cn4", hexCross );

		addLine( "cf1", "cf2", hexCross );
		addLine( "cf3", "cf4", hexCross );

		function addLine( a, b, hex ) {

			addPoint( a, hex );
			addPoint( b, hex );

		}

		function addPoint( id, hex ) {

			geometry.vertices.push( new THREE.Vector3() );
			geometry.colors.push( new THREE.Color( hex ) );

			if ( pointMap[ id ] === undefined ) {

				pointMap[ id ] = [];

			}

			pointMap[ id ].push( geometry.vertices.length - 1 );

		}

		THREE.LineSegments.call( this, geometry, material );

		this.camera = camera;
		this.camera.updateProjectionMatrix();

		this.matrix = camera.matrixWorld;
		this.matrixAutoUpdate = false;

		this.pointMap = pointMap;

		this.update();

	};

	THREE.CameraHelper.prototype = Object.create( THREE.LineSegments.prototype );
	THREE.CameraHelper.prototype.constructor = THREE.CameraHelper;

	THREE.CameraHelper.prototype.update = function () {

		var geometry, pointMap;

		var vector = new THREE.Vector3();
		var camera = new THREE.Camera();

		function setPoint( point, x, y, z ) {

			vector.set( x, y, z ).unproject( camera );

			var points = pointMap[ point ];

			if ( points !== undefined ) {

				for ( var i = 0, il = points.length; i < il; i ++ ) {

					geometry.vertices[ points[ i ] ].copy( vector );

				}

			}

		}

		return function () {

			geometry = this.geometry;
			pointMap = this.pointMap;

			var w = 1, h = 1;

			// we need just camera projection matrix
			// world matrix must be identity

			camera.projectionMatrix.copy( this.camera.projectionMatrix );

			// center / target

			setPoint( "c", 0, 0, - 1 );
			setPoint( "t", 0, 0,  1 );

			// near

			setPoint( "n1", - w, - h, - 1 );
			setPoint( "n2",   w, - h, - 1 );
			setPoint( "n3", - w,   h, - 1 );
			setPoint( "n4",   w,   h, - 1 );

			// far

			setPoint( "f1", - w, - h, 1 );
			setPoint( "f2",   w, - h, 1 );
			setPoint( "f3", - w,   h, 1 );
			setPoint( "f4",   w,   h, 1 );

			// up

			setPoint( "u1",   w * 0.7, h * 1.1, - 1 );
			setPoint( "u2", - w * 0.7, h * 1.1, - 1 );
			setPoint( "u3",         0, h * 2,   - 1 );

			// cross

			setPoint( "cf1", - w,   0, 1 );
			setPoint( "cf2",   w,   0, 1 );
			setPoint( "cf3",   0, - h, 1 );
			setPoint( "cf4",   0,   h, 1 );

			setPoint( "cn1", - w,   0, - 1 );
			setPoint( "cn2",   w,   0, - 1 );
			setPoint( "cn3",   0, - h, - 1 );
			setPoint( "cn4",   0,   h, - 1 );

			geometry.verticesNeedUpdate = true;

		};

	}();

	// File:src/extras/helpers/DirectionalLightHelper.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	THREE.DirectionalLightHelper = function ( light, size ) {

		THREE.Object3D.call( this );

		this.light = light;
		this.light.updateMatrixWorld();

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		size = size || 1;

		var geometry = new THREE.Geometry();
		geometry.vertices.push(
			new THREE.Vector3( - size,   size, 0 ),
			new THREE.Vector3(   size,   size, 0 ),
			new THREE.Vector3(   size, - size, 0 ),
			new THREE.Vector3( - size, - size, 0 ),
			new THREE.Vector3( - size,   size, 0 )
		);

		var material = new THREE.LineBasicMaterial( { fog: false } );
		material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

		this.lightPlane = new THREE.Line( geometry, material );
		this.add( this.lightPlane );

		geometry = new THREE.Geometry();
		geometry.vertices.push(
			new THREE.Vector3(),
			new THREE.Vector3()
		);

		material = new THREE.LineBasicMaterial( { fog: false } );
		material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

		this.targetLine = new THREE.Line( geometry, material );
		this.add( this.targetLine );

		this.update();

	};

	THREE.DirectionalLightHelper.prototype = Object.create( THREE.Object3D.prototype );
	THREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper;

	THREE.DirectionalLightHelper.prototype.dispose = function () {

		this.lightPlane.geometry.dispose();
		this.lightPlane.material.dispose();
		this.targetLine.geometry.dispose();
		this.targetLine.material.dispose();

	};

	THREE.DirectionalLightHelper.prototype.update = function () {

		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();
		var v3 = new THREE.Vector3();

		return function () {

			v1.setFromMatrixPosition( this.light.matrixWorld );
			v2.setFromMatrixPosition( this.light.target.matrixWorld );
			v3.subVectors( v2, v1 );

			this.lightPlane.lookAt( v3 );
			this.lightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

			this.targetLine.geometry.vertices[ 1 ].copy( v3 );
			this.targetLine.geometry.verticesNeedUpdate = true;
			this.targetLine.material.color.copy( this.lightPlane.material.color );

		};

	}();

	// File:src/extras/helpers/EdgesHelper.js

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 * @param object THREE.Mesh whose geometry will be used
	 * @param hex line color
	 * @param thresholdAngle the minimum angle (in degrees),
	 * between the face normals of adjacent faces,
	 * that is required to render an edge. A value of 10 means
	 * an edge is only rendered if the angle is at least 10 degrees.
	 */

	THREE.EdgesHelper = function ( object, hex, thresholdAngle ) {

		var color = ( hex !== undefined ) ? hex : 0xffffff;

		THREE.LineSegments.call( this, new THREE.EdgesGeometry( object.geometry, thresholdAngle ), new THREE.LineBasicMaterial( { color: color } ) );

		this.matrix = object.matrixWorld;
		this.matrixAutoUpdate = false;

	};

	THREE.EdgesHelper.prototype = Object.create( THREE.LineSegments.prototype );
	THREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper;

	// File:src/extras/helpers/FaceNormalsHelper.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	*/

	THREE.FaceNormalsHelper = function ( object, size, hex, linewidth ) {

		// FaceNormalsHelper only supports THREE.Geometry

		this.object = object;

		this.size = ( size !== undefined ) ? size : 1;

		var color = ( hex !== undefined ) ? hex : 0xffff00;

		var width = ( linewidth !== undefined ) ? linewidth : 1;

		//

		var nNormals = 0;

		var objGeometry = this.object.geometry;

		if ( objGeometry instanceof THREE.Geometry ) {

			nNormals = objGeometry.faces.length;

		} else {

			console.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );

		}

		//

		var geometry = new THREE.BufferGeometry();

		var positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );

		geometry.addAttribute( 'position', positions );

		THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );

		//

		this.matrixAutoUpdate = false;
		this.update();

	};

	THREE.FaceNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );
	THREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper;

	THREE.FaceNormalsHelper.prototype.update = ( function () {

		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();
		var normalMatrix = new THREE.Matrix3();

		return function update() {

			this.object.updateMatrixWorld( true );

			normalMatrix.getNormalMatrix( this.object.matrixWorld );

			var matrixWorld = this.object.matrixWorld;

			var position = this.geometry.attributes.position;

			//

			var objGeometry = this.object.geometry;

			var vertices = objGeometry.vertices;

			var faces = objGeometry.faces;

			var idx = 0;

			for ( var i = 0, l = faces.length; i < l; i ++ ) {

				var face = faces[ i ];

				var normal = face.normal;

				v1.copy( vertices[ face.a ] )
					.add( vertices[ face.b ] )
					.add( vertices[ face.c ] )
					.divideScalar( 3 )
					.applyMatrix4( matrixWorld );

				v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

				position.setXYZ( idx, v1.x, v1.y, v1.z );

				idx = idx + 1;

				position.setXYZ( idx, v2.x, v2.y, v2.z );

				idx = idx + 1;

			}

			position.needsUpdate = true;

			return this;

		}

	}() );

	// File:src/extras/helpers/GridHelper.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.GridHelper = function ( size, step ) {

		var geometry = new THREE.Geometry();
		var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );

		this.color1 = new THREE.Color( 0x444444 );
		this.color2 = new THREE.Color( 0x888888 );

		for ( var i = - size; i <= size; i += step ) {

			geometry.vertices.push(
				new THREE.Vector3( - size, 0, i ), new THREE.Vector3( size, 0, i ),
				new THREE.Vector3( i, 0, - size ), new THREE.Vector3( i, 0, size )
			);

			var color = i === 0 ? this.color1 : this.color2;

			geometry.colors.push( color, color, color, color );

		}

		THREE.LineSegments.call( this, geometry, material );

	};

	THREE.GridHelper.prototype = Object.create( THREE.LineSegments.prototype );
	THREE.GridHelper.prototype.constructor = THREE.GridHelper;

	THREE.GridHelper.prototype.setColors = function( colorCenterLine, colorGrid ) {

		this.color1.set( colorCenterLine );
		this.color2.set( colorGrid );

		this.geometry.colorsNeedUpdate = true;

	};

	// File:src/extras/helpers/HemisphereLightHelper.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.HemisphereLightHelper = function ( light, sphereSize ) {

		THREE.Object3D.call( this );

		this.light = light;
		this.light.updateMatrixWorld();

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.colors = [ new THREE.Color(), new THREE.Color() ];

		var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );
		geometry.rotateX( - Math.PI / 2 );

		for ( var i = 0, il = 8; i < il; i ++ ) {

			geometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];

		}

		var material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, wireframe: true } );

		this.lightSphere = new THREE.Mesh( geometry, material );
		this.add( this.lightSphere );

		this.update();

	};

	THREE.HemisphereLightHelper.prototype = Object.create( THREE.Object3D.prototype );
	THREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper;

	THREE.HemisphereLightHelper.prototype.dispose = function () {

		this.lightSphere.geometry.dispose();
		this.lightSphere.material.dispose();

	};

	THREE.HemisphereLightHelper.prototype.update = function () {

		var vector = new THREE.Vector3();

		return function () {

			this.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );
			this.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );

			this.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );
			this.lightSphere.geometry.colorsNeedUpdate = true;

		}

	}();

	// File:src/extras/helpers/PointLightHelper.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.PointLightHelper = function ( light, sphereSize ) {

		this.light = light;
		this.light.updateMatrixWorld();

		var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );
		var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );
		material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

		THREE.Mesh.call( this, geometry, material );

		this.matrix = this.light.matrixWorld;
		this.matrixAutoUpdate = false;

		/*
		var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
		var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

		this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
		this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

		var d = light.distance;

		if ( d === 0.0 ) {

			this.lightDistance.visible = false;

		} else {

			this.lightDistance.scale.set( d, d, d );

		}

		this.add( this.lightDistance );
		*/

	};

	THREE.PointLightHelper.prototype = Object.create( THREE.Mesh.prototype );
	THREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper;

	THREE.PointLightHelper.prototype.dispose = function () {

		this.geometry.dispose();
		this.material.dispose();

	};

	THREE.PointLightHelper.prototype.update = function () {

		this.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

		/*
		var d = this.light.distance;

		if ( d === 0.0 ) {

			this.lightDistance.visible = false;

		} else {

			this.lightDistance.visible = true;
			this.lightDistance.scale.set( d, d, d );

		}
		*/

	};

	// File:src/extras/helpers/SkeletonHelper.js

	/**
	 * @author Sean Griffin / http://twitter.com/sgrif
	 * @author Michael Guerrero / http://realitymeltdown.com
	 * @author mrdoob / http://mrdoob.com/
	 * @author ikerr / http://verold.com
	 */

	THREE.SkeletonHelper = function ( object ) {

		this.bones = this.getBoneList( object );

		var geometry = new THREE.Geometry();

		for ( var i = 0; i < this.bones.length; i ++ ) {

			var bone = this.bones[ i ];

			if ( bone.parent instanceof THREE.Bone ) {

				geometry.vertices.push( new THREE.Vector3() );
				geometry.vertices.push( new THREE.Vector3() );
				geometry.colors.push( new THREE.Color( 0, 0, 1 ) );
				geometry.colors.push( new THREE.Color( 0, 1, 0 ) );

			}

		}

		geometry.dynamic = true;

		var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors, depthTest: false, depthWrite: false, transparent: true } );

		THREE.LineSegments.call( this, geometry, material );

		this.root = object;

		this.matrix = object.matrixWorld;
		this.matrixAutoUpdate = false;

		this.update();

	};


	THREE.SkeletonHelper.prototype = Object.create( THREE.LineSegments.prototype );
	THREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper;

	THREE.SkeletonHelper.prototype.getBoneList = function( object ) {

		var boneList = [];

		if ( object instanceof THREE.Bone ) {

			boneList.push( object );

		}

		for ( var i = 0; i < object.children.length; i ++ ) {

			boneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );

		}

		return boneList;

	};

	THREE.SkeletonHelper.prototype.update = function () {

		var geometry = this.geometry;

		var matrixWorldInv = new THREE.Matrix4().getInverse( this.root.matrixWorld );

		var boneMatrix = new THREE.Matrix4();

		var j = 0;

		for ( var i = 0; i < this.bones.length; i ++ ) {

			var bone = this.bones[ i ];

			if ( bone.parent instanceof THREE.Bone ) {

				boneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );
				geometry.vertices[ j ].setFromMatrixPosition( boneMatrix );

				boneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );
				geometry.vertices[ j + 1 ].setFromMatrixPosition( boneMatrix );

				j += 2;

			}

		}

		geometry.verticesNeedUpdate = true;

		geometry.computeBoundingSphere();

	};

	// File:src/extras/helpers/SpotLightHelper.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	*/

	THREE.SpotLightHelper = function ( light ) {

		THREE.Object3D.call( this );

		this.light = light;
		this.light.updateMatrixWorld();

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		var geometry = new THREE.CylinderGeometry( 0, 1, 1, 8, 1, true );

		geometry.translate( 0, - 0.5, 0 );
		geometry.rotateX( - Math.PI / 2 );

		var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );

		this.cone = new THREE.Mesh( geometry, material );
		this.add( this.cone );

		this.update();

	};

	THREE.SpotLightHelper.prototype = Object.create( THREE.Object3D.prototype );
	THREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper;

	THREE.SpotLightHelper.prototype.dispose = function () {

		this.cone.geometry.dispose();
		this.cone.material.dispose();

	};

	THREE.SpotLightHelper.prototype.update = function () {

		var vector = new THREE.Vector3();
		var vector2 = new THREE.Vector3();

		return function () {

			var coneLength = this.light.distance ? this.light.distance : 10000;
			var coneWidth = coneLength * Math.tan( this.light.angle );

			this.cone.scale.set( coneWidth, coneWidth, coneLength );

			vector.setFromMatrixPosition( this.light.matrixWorld );
			vector2.setFromMatrixPosition( this.light.target.matrixWorld );

			this.cone.lookAt( vector2.sub( vector ) );

			this.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

		};

	}();

	// File:src/extras/helpers/VertexNormalsHelper.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	*/

	THREE.VertexNormalsHelper = function ( object, size, hex, linewidth ) {

		this.object = object;

		this.size = ( size !== undefined ) ? size : 1;

		var color = ( hex !== undefined ) ? hex : 0xff0000;

		var width = ( linewidth !== undefined ) ? linewidth : 1;

		//

		var nNormals = 0;

		var objGeometry = this.object.geometry;

		if ( objGeometry instanceof THREE.Geometry ) {

			nNormals = objGeometry.faces.length * 3;

		} else if ( objGeometry instanceof THREE.BufferGeometry ) {

			nNormals = objGeometry.attributes.normal.count

		}

		//

		var geometry = new THREE.BufferGeometry();

		var positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );

		geometry.addAttribute( 'position', positions );

		THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );

		//

		this.matrixAutoUpdate = false;

		this.update();

	};

	THREE.VertexNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );
	THREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper;

	THREE.VertexNormalsHelper.prototype.update = ( function () {

		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();
		var normalMatrix = new THREE.Matrix3();

		return function update() {

			var keys = [ 'a', 'b', 'c' ];

			this.object.updateMatrixWorld( true );

			normalMatrix.getNormalMatrix( this.object.matrixWorld );

			var matrixWorld = this.object.matrixWorld;

			var position = this.geometry.attributes.position;

			//

			var objGeometry = this.object.geometry;

			if ( objGeometry instanceof THREE.Geometry ) {

				var vertices = objGeometry.vertices;

				var faces = objGeometry.faces;

				var idx = 0;

				for ( var i = 0, l = faces.length; i < l; i ++ ) {

					var face = faces[ i ];

					for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

						var vertex = vertices[ face[ keys[ j ] ] ];

						var normal = face.vertexNormals[ j ];

						v1.copy( vertex ).applyMatrix4( matrixWorld );

						v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

						position.setXYZ( idx, v1.x, v1.y, v1.z );

						idx = idx + 1;

						position.setXYZ( idx, v2.x, v2.y, v2.z );

						idx = idx + 1;

					}

				}

			} else if ( objGeometry instanceof THREE.BufferGeometry ) {

				var objPos = objGeometry.attributes.position;

				var objNorm = objGeometry.attributes.normal;

				var idx = 0;

				// for simplicity, ignore index and drawcalls, and render every normal

				for ( var j = 0, jl = objPos.count; j < jl; j ++ ) {

					v1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );

					v2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );

					v2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

					position.setXYZ( idx, v1.x, v1.y, v1.z );

					idx = idx + 1;

					position.setXYZ( idx, v2.x, v2.y, v2.z );

					idx = idx + 1;

				}

			}

			position.needsUpdate = true;

			return this;

		}

	}() );

	// File:src/extras/helpers/WireframeHelper.js

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	THREE.WireframeHelper = function ( object, hex ) {

		var color = ( hex !== undefined ) ? hex : 0xffffff;

		THREE.LineSegments.call( this, new THREE.WireframeGeometry( object.geometry ), new THREE.LineBasicMaterial( { color: color } ) );

		this.matrix = object.matrixWorld;
		this.matrixAutoUpdate = false;

	};

	THREE.WireframeHelper.prototype = Object.create( THREE.LineSegments.prototype );
	THREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper;

	// File:src/extras/objects/ImmediateRenderObject.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.ImmediateRenderObject = function ( material ) {

		THREE.Object3D.call( this );

		this.material = material;
		this.render = function ( renderCallback ) {};

	};

	THREE.ImmediateRenderObject.prototype = Object.create( THREE.Object3D.prototype );
	THREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject;

	// File:src/extras/objects/MorphBlendMesh.js

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.MorphBlendMesh = function( geometry, material ) {

		THREE.Mesh.call( this, geometry, material );

		this.animationsMap = {};
		this.animationsList = [];

		// prepare default animation
		// (all frames played together in 1 second)

		var numFrames = this.geometry.morphTargets.length;

		var name = "__default";

		var startFrame = 0;
		var endFrame = numFrames - 1;

		var fps = numFrames / 1;

		this.createAnimation( name, startFrame, endFrame, fps );
		this.setAnimationWeight( name, 1 );

	};

	THREE.MorphBlendMesh.prototype = Object.create( THREE.Mesh.prototype );
	THREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh;

	THREE.MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {

		var animation = {

			start: start,
			end: end,

			length: end - start + 1,

			fps: fps,
			duration: ( end - start ) / fps,

			lastFrame: 0,
			currentFrame: 0,

			active: false,

			time: 0,
			direction: 1,
			weight: 1,

			directionBackwards: false,
			mirroredLoop: false

		};

		this.animationsMap[ name ] = animation;
		this.animationsList.push( animation );

	};

	THREE.MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {

		var pattern = /([a-z]+)_?(\d+)/;

		var firstAnimation, frameRanges = {};

		var geometry = this.geometry;

		for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {

			var morph = geometry.morphTargets[ i ];
			var chunks = morph.name.match( pattern );

			if ( chunks && chunks.length > 1 ) {

				var name = chunks[ 1 ];

				if ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };

				var range = frameRanges[ name ];

				if ( i < range.start ) range.start = i;
				if ( i > range.end ) range.end = i;

				if ( ! firstAnimation ) firstAnimation = name;

			}

		}

		for ( var name in frameRanges ) {

			var range = frameRanges[ name ];
			this.createAnimation( name, range.start, range.end, fps );

		}

		this.firstAnimation = firstAnimation;

	};

	THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {

		var animation = this.animationsMap[ name ];

		if ( animation ) {

			animation.direction = 1;
			animation.directionBackwards = false;

		}

	};

	THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {

		var animation = this.animationsMap[ name ];

		if ( animation ) {

			animation.direction = - 1;
			animation.directionBackwards = true;

		}

	};

	THREE.MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {

		var animation = this.animationsMap[ name ];

		if ( animation ) {

			animation.fps = fps;
			animation.duration = ( animation.end - animation.start ) / animation.fps;

		}

	};

	THREE.MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {

		var animation = this.animationsMap[ name ];

		if ( animation ) {

			animation.duration = duration;
			animation.fps = ( animation.end - animation.start ) / animation.duration;

		}

	};

	THREE.MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {

		var animation = this.animationsMap[ name ];

		if ( animation ) {

			animation.weight = weight;

		}

	};

	THREE.MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {

		var animation = this.animationsMap[ name ];

		if ( animation ) {

			animation.time = time;

		}

	};

	THREE.MorphBlendMesh.prototype.getAnimationTime = function ( name ) {

		var time = 0;

		var animation = this.animationsMap[ name ];

		if ( animation ) {

			time = animation.time;

		}

		return time;

	};

	THREE.MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {

		var duration = - 1;

		var animation = this.animationsMap[ name ];

		if ( animation ) {

			duration = animation.duration;

		}

		return duration;

	};

	THREE.MorphBlendMesh.prototype.playAnimation = function ( name ) {

		var animation = this.animationsMap[ name ];

		if ( animation ) {

			animation.time = 0;
			animation.active = true;

		} else {

			console.warn( "THREE.MorphBlendMesh: animation[" + name + "] undefined in .playAnimation()" );

		}

	};

	THREE.MorphBlendMesh.prototype.stopAnimation = function ( name ) {

		var animation = this.animationsMap[ name ];

		if ( animation ) {

			animation.active = false;

		}

	};

	THREE.MorphBlendMesh.prototype.update = function ( delta ) {

		for ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {

			var animation = this.animationsList[ i ];

			if ( ! animation.active ) continue;

			var frameTime = animation.duration / animation.length;

			animation.time += animation.direction * delta;

			if ( animation.mirroredLoop ) {

				if ( animation.time > animation.duration || animation.time < 0 ) {

					animation.direction *= - 1;

					if ( animation.time > animation.duration ) {

						animation.time = animation.duration;
						animation.directionBackwards = true;

					}

					if ( animation.time < 0 ) {

						animation.time = 0;
						animation.directionBackwards = false;

					}

				}

			} else {

				animation.time = animation.time % animation.duration;

				if ( animation.time < 0 ) animation.time += animation.duration;

			}

			var keyframe = animation.start + THREE.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );
			var weight = animation.weight;

			if ( keyframe !== animation.currentFrame ) {

				this.morphTargetInfluences[ animation.lastFrame ] = 0;
				this.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;

				this.morphTargetInfluences[ keyframe ] = 0;

				animation.lastFrame = animation.currentFrame;
				animation.currentFrame = keyframe;

			}

			var mix = ( animation.time % frameTime ) / frameTime;

			if ( animation.directionBackwards ) mix = 1 - mix;

			if ( animation.currentFrame !== animation.lastFrame ) {

				this.morphTargetInfluences[ animation.currentFrame ] = mix * weight;
				this.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;

			} else {

				this.morphTargetInfluences[ animation.currentFrame ] = weight;

			}

		}

	};

	if( typeof define !== "undefined" && define instanceof Function && define.amd != undefined ){

		define(function(){

			return THREE;

		});

	}
	else if( typeof module !== "undefined" && module.exports ){

		module.exports = THREE;

	}
	else if( this != undefined ){

		this.THREE = THREE;

	};

})(this || {});
},{}],"/Users/tommy.cornilleau/Desktop/TEMP/sphere-particle/src/scripts/components/scene.js":[function(require,module,exports){
'use strict';

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _threeJs = require("three-js");

var _threeJs2 = _interopRequireDefault(_threeJs);

var _utilsConfig = require('../utils/config');

var _utilsConfig2 = _interopRequireDefault(_utilsConfig);

var _utilsRaf = require('../utils/raf');

var _utilsRaf2 = _interopRequireDefault(_utilsRaf);

var _utilsMapper = require('../utils/mapper');

var _utilsMapper2 = _interopRequireDefault(_utilsMapper);

var THREE = (0, _threeJs2['default'])();

module.exports = {

	init: function init() {

		this.render = this.render.bind(this);
		this.onClick = this.onClick.bind(this);
		this.onResize = this.onResize.bind(this);
		this.onMove = this.onMove.bind(this);
		this.clock = new THREE.Clock();
		this.cameraPos = new THREE.Vector3(_utilsConfig2['default'].camera.position.x, _utilsConfig2['default'].camera.position.y, _utilsConfig2['default'].camera.position.z);
		this.currentCameraPos = new THREE.Vector3(this.cameraPos.x, this.cameraPos.y, this.cameraPos.z);

		this.plane = null;
		this.explosionsPos = [];
		this.explosionsTime = [];

		// KEEP THIS SHIT
		// ADD VALUES IN A PREDEFINED LENGTH ARRAY
		// POP THE LASTS AND UNSHIFT THE NEW ONES
		for (var i = 0; i < _utilsConfig2['default'].particles.maxExplosions - 1; i++) {
			this.explosionsPos[i] = new THREE.Vector2(0, 0, 0);
			this.explosionsTime[i] = 100;
			this.explosionsIndex = 0;
		}

		//// INIT
		this.scene = new THREE.Scene();
		this.container = _utilsConfig2['default'].canvas.element;

		this.camera = new THREE.PerspectiveCamera(45, this.ratio, 15, 3000);
		this.camera.position.x = _utilsConfig2['default'].camera.position.x;
		this.camera.position.y = _utilsConfig2['default'].camera.position.y;
		this.camera.position.z = _utilsConfig2['default'].camera.position.z;
		this.camera.lookAt(_utilsConfig2['default'].camera.target);

		if (_utilsConfig2['default'].axisHelper) {
			this.axisHelper = new THREE.AxisHelper(5);
			this.scene.add(this.axisHelper);
		}

		//// RENDERER
		this.renderer = new THREE.WebGLRenderer();
		this.renderer.setClearColor(_utilsConfig2['default'].canvas.color, 1.0);
		this.renderer.setSize(window.innerWidth, window.innerHeight);

		//// AMBIANT LIGHT
		this.ambient = new THREE.AmbientLight(_utilsConfig2['default'].lights.ambient.color);

		//// ADD OBJECTS TO SCENE
		this.scene.add(this.ambient);

		//// ADD CANVAS TO DOM
		this.container.appendChild(this.renderer.domElement);

		this.createParticles();

		//// REGIST RENDERER
		_utilsRaf2['default'].register(this.render);
		_utilsRaf2['default'].start();
		this.onResize();

		window.addEventListener('click', this.onClick);
		window.addEventListener('resize', this.onResize);
		window.addEventListener('mousemove', this.onMove);
	},

	createParticles: function createParticles() {
		this.uniforms = {
			time: { type: 'f', value: 0.0 },
			map: { type: 't', value: THREE.ImageUtils.loadTexture(_utilsConfig2['default'].particles.texture) }

		};

		this.geometry = new THREE.BufferGeometry();
		this.vertices = new Float32Array(_utilsConfig2['default'].particles.count * 3);
		this.sizes = new Float32Array(_utilsConfig2['default'].particles.count);

		for (var i = 0; i < _utilsConfig2['default'].particles.count; i++) {

			// let angle1 = Math.random() * Math.PI * 2;
			// let angle2 = Math.acos( Math.random() * 2 - 1 );
			// let dist   = 400;

			// let pX = dist * Math.sin( angle1 ) * Math.cos( angle2 );
			// let pY = dist * Math.sin( angle1 ) * Math.sin( angle2 );
			// let pZ = dist * Math.cos( angle1 );

			// this.vertices[i * 3] = pX;
			// this.vertices[i * 3 + 1] = pY;
			// this.vertices[i * 3 + 2] = pZ;

			this.vertices[i * 3] = Math.random();
			this.vertices[i * 3 + 1] = Math.random();
			this.vertices[i * 3 + 2] = 0;

			this.sizes[i] = 1;
		}

		this.geometry.addAttribute('position', new THREE.BufferAttribute(this.vertices, 3));
		this.geometry.addAttribute('size', new THREE.BufferAttribute(this.sizes, 1));

		this.material = new THREE.ShaderMaterial({
			uniforms: this.uniforms,
			transparent: true,
			vertexShader: require('../shaders/noises/noise2D.glsl') + require('../shaders/particles.vertex.glsl'),
			fragmentShader: require('../shaders/particles.fragment.glsl')
		});

		this.particleSystem = new THREE.Points(this.geometry, this.material);

		this.scene.add(this.particleSystem);
	},

	onClick: function onClick(event) {},

	onMove: function onMove(event) {
		this.cameraPos.x = event.clientX - this.halfWidth;
		this.cameraPos.y = event.clientY - this.halfHeight;
	},

	onResize: function onResize() {
		this.renderer.setSize(window.innerWidth, window.innerHeight);
		this.ratio = window.innerWidth / window.innerHeight;

		this.camera.aspect = this.ratio;
		this.camera.updateProjectionMatrix();

		this.halfWidth = window.innerWidth * .5;
		this.halfHeight = window.innerHeight * .5;
	},

	render: function render() {
		var delta = this.clock.getDelta();

		this.currentCameraPos.x += (this.cameraPos.x * .7 - this.currentCameraPos.x) * 0.01;
		this.currentCameraPos.y += (this.cameraPos.y * .8 - this.currentCameraPos.y) * 0.01;

		this.camera.position.set(this.currentCameraPos.x, this.currentCameraPos.y, this.currentCameraPos.z);
		this.camera.lookAt(_utilsConfig2['default'].camera.target);

		this.uniforms.time.value += delta;

		this.renderer.render(this.scene, this.camera);
	}

};

},{"../shaders/noises/noise2D.glsl":"/Users/tommy.cornilleau/Desktop/TEMP/sphere-particle/src/scripts/shaders/noises/noise2D.glsl","../shaders/particles.fragment.glsl":"/Users/tommy.cornilleau/Desktop/TEMP/sphere-particle/src/scripts/shaders/particles.fragment.glsl","../shaders/particles.vertex.glsl":"/Users/tommy.cornilleau/Desktop/TEMP/sphere-particle/src/scripts/shaders/particles.vertex.glsl","../utils/config":"/Users/tommy.cornilleau/Desktop/TEMP/sphere-particle/src/scripts/utils/config.js","../utils/mapper":"/Users/tommy.cornilleau/Desktop/TEMP/sphere-particle/src/scripts/utils/mapper.js","../utils/raf":"/Users/tommy.cornilleau/Desktop/TEMP/sphere-particle/src/scripts/utils/raf.js","three-js":"/Users/tommy.cornilleau/Desktop/TEMP/sphere-particle/node_modules/three-js/index.js"}],"/Users/tommy.cornilleau/Desktop/TEMP/sphere-particle/src/scripts/initialize.js":[function(require,module,exports){
'use strict';

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _componentsScene = require('./components/scene');

var _componentsScene2 = _interopRequireDefault(_componentsScene);

window.onload = function () {

	_componentsScene2['default'].init();
};

},{"./components/scene":"/Users/tommy.cornilleau/Desktop/TEMP/sphere-particle/src/scripts/components/scene.js"}],"/Users/tommy.cornilleau/Desktop/TEMP/sphere-particle/src/scripts/shaders/noises/noise2D.glsl":[function(require,module,exports){
module.exports = "//\n// Description : Array and textureless GLSL 2D simplex noise function.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n// \n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat snoise(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n";

},{}],"/Users/tommy.cornilleau/Desktop/TEMP/sphere-particle/src/scripts/shaders/particles.fragment.glsl":[function(require,module,exports){
module.exports = "uniform sampler2D map;\n\nvoid main() {\n\n\tgl_FragColor = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) );\n\n\tgl_FragColor = gl_FragColor * vec4( 1., 1., 1., 1. );\n\n}\n";

},{}],"/Users/tommy.cornilleau/Desktop/TEMP/sphere-particle/src/scripts/shaders/particles.vertex.glsl":[function(require,module,exports){
module.exports = "\n\n#define M_PI 3.1415926535897932384626433832795\n#define DIST 300.0\n\nuniform float time;\n\nattribute float size;\n\nvoid main() {\n\tvec2 fakePosition   = vec2( position.x, position.y );\n\tvec3 newPosition\t= vec3( .0, .0, .0 );\n\n\tfakePosition.x = snoise( vec2( position.x, time * .001 ) );\n\tfakePosition.y = snoise( vec2( position.y, time * .001 ) );\n\n\tfloat angle1 = 2. * M_PI * fakePosition.x;\n\tfloat angle2 = acos( fakePosition.y * 2. - 1. );\n\n\tnewPosition.x = DIST * sin( angle1 ) * cos( angle2 );\n\tnewPosition.y = DIST * sin( angle1 ) * sin( angle2 );\n\tnewPosition.z = DIST * cos( angle1 );\n\n\tvec4 mvPosition = modelViewMatrix * vec4( newPosition, 1. );\n\n\tgl_PointSize = size * ( 500. / - mvPosition.z );\n\n    gl_Position = projectionMatrix * mvPosition;\n}";

},{}],"/Users/tommy.cornilleau/Desktop/TEMP/sphere-particle/src/scripts/utils/config.js":[function(require,module,exports){
"use strict";

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var _threeJs = require("three-js");

var _threeJs2 = _interopRequireDefault(_threeJs);

var THREE = (0, _threeJs2["default"])();

var config = {

	canvas: {
		element: document.getElementById('container'),
		color: 0x1a2033
	},

	camera: {
		position: new THREE.Vector3(0, 0, 800),
		target: new THREE.Vector3(0, 0, 0)
	},

	axisHelper: false,

	lights: {
		ambient: {
			color: 0xffffff
		}
	},

	particles: {
		count: 500000,
		maxExplosions: 100,
		texture: "./assets/medias/smoke_3.png"
	},

	drawField: {
		maxHeight: 600,
		maxWidth: 600,
		maxDepth: 150,
		mitigator: .3
	},

	plane: {
		width: 700,
		height: 700,
		wireframe: true,
		opacity: 0
	}

};

module.exports = config;

},{"three-js":"/Users/tommy.cornilleau/Desktop/TEMP/sphere-particle/node_modules/three-js/index.js"}],"/Users/tommy.cornilleau/Desktop/TEMP/sphere-particle/src/scripts/utils/mapper.js":[function(require,module,exports){
// https://github.com/tommycor/mapperJS/blob/master/mapper-min.js
"use strict";

function mapper(val, oMin, oMax, nMin, nMax) {
  return (val - oMin) * (nMax - nMin) / (oMax - oMin) + nMin;
}

module.exports = mapper;

},{}],"/Users/tommy.cornilleau/Desktop/TEMP/sphere-particle/src/scripts/utils/raf.js":[function(require,module,exports){
'use strict';

function Raf() {

	this.loop = this.loop.bind(this);
	this.start = this.start.bind(this);
	this.stop = this.stop.bind(this);
	this.control = this.control.bind(this);

	this.toRefresh = [];

	window.addEventListener('keydown', this.control);
}

Raf.prototype.register = function (callback) {

	this.toRefresh.push(callback);
};

Raf.prototype.start = function () {

	this.loop();
};

Raf.prototype.stop = function () {

	cancelAnimationFrame(this.request);
};

Raf.prototype.loop = function () {

	var i;
	for (i = 0; i < this.toRefresh.length; i++) {
		this.toRefresh[i]();
	}

	this.request = requestAnimationFrame(this.start);
};

Raf.prototype.control = function (event) {
	if (event.keyCode === 0 || event.keyCode === 32) {

		if (this.request != null) this.stop();else this.start();
	}
};

module.exports = new Raf();

},{}]},{},["/Users/tommy.cornilleau/Desktop/TEMP/sphere-particle/src/scripts/initialize.js"])

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvdGhyZWUtanMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdGhyZWUtanMvdGhyZWUuanMiLCIvVXNlcnMvdG9tbXkuY29ybmlsbGVhdS9EZXNrdG9wL1RFTVAvc3BoZXJlLXBhcnRpY2xlL3NyYy9zY3JpcHRzL2NvbXBvbmVudHMvc2NlbmUuanMiLCIvVXNlcnMvdG9tbXkuY29ybmlsbGVhdS9EZXNrdG9wL1RFTVAvc3BoZXJlLXBhcnRpY2xlL3NyYy9zY3JpcHRzL2luaXRpYWxpemUuanMiLCJzcmMvc2NyaXB0cy9zaGFkZXJzL25vaXNlcy9ub2lzZTJELmdsc2wiLCJzcmMvc2NyaXB0cy9zaGFkZXJzL3BhcnRpY2xlcy5mcmFnbWVudC5nbHNsIiwic3JjL3NjcmlwdHMvc2hhZGVycy9wYXJ0aWNsZXMudmVydGV4Lmdsc2wiLCIvVXNlcnMvdG9tbXkuY29ybmlsbGVhdS9EZXNrdG9wL1RFTVAvc3BoZXJlLXBhcnRpY2xlL3NyYy9zY3JpcHRzL3V0aWxzL2NvbmZpZy5qcyIsIi9Vc2Vycy90b21teS5jb3JuaWxsZWF1L0Rlc2t0b3AvVEVNUC9zcGhlcmUtcGFydGljbGUvc3JjL3NjcmlwdHMvdXRpbHMvbWFwcGVyLmpzIiwiL1VzZXJzL3RvbW15LmNvcm5pbGxlYXUvRGVza3RvcC9URU1QL3NwaGVyZS1wYXJ0aWNsZS9zcmMvc2NyaXB0cy91dGlscy9yYWYuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozt1QkNyMW1Dd0IsVUFBVTs7OzsyQkFHWCxpQkFBaUI7Ozs7d0JBQ25CLGNBQWM7Ozs7MkJBQ1osaUJBQWlCOzs7O0FBSnhDLElBQU0sS0FBSyxHQUFHLDJCQUFTLENBQUM7O0FBTXhCLE1BQU0sQ0FBQyxPQUFPLEdBQUc7O0FBRWhCLEtBQUksRUFBRSxnQkFBVzs7QUFFaEIsTUFBSSxDQUFDLE1BQU0sR0FBTSxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUN4QyxNQUFJLENBQUMsT0FBTyxHQUFLLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ3pDLE1BQUksQ0FBQyxRQUFRLEdBQU0sSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDNUMsTUFBSSxDQUFDLE1BQU0sR0FBSyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUN2QyxNQUFJLENBQUMsS0FBSyxHQUFPLElBQUksS0FBSyxDQUFDLEtBQUssRUFBRSxDQUFDO0FBQ25DLE1BQUksQ0FBQyxTQUFTLEdBQUksSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFFLHlCQUFPLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLHlCQUFPLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLHlCQUFPLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFFLENBQUM7QUFDcEgsTUFBSSxDQUFDLGdCQUFnQixHQUFHLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBRSxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBRSxDQUFDOztBQUVsRyxNQUFJLENBQUMsS0FBSyxHQUFPLElBQUksQ0FBQztBQUN0QixNQUFJLENBQUMsYUFBYSxHQUFJLEVBQUUsQ0FBQztBQUN6QixNQUFJLENBQUMsY0FBYyxHQUFHLEVBQUUsQ0FBQzs7Ozs7QUFLekIsT0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUcsQ0FBQyxHQUFHLHlCQUFPLFNBQVMsQ0FBQyxhQUFhLEdBQUcsQ0FBQyxFQUFHLENBQUMsRUFBRSxFQUFHO0FBQy9ELE9BQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLEdBQUksSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFFLENBQUM7QUFDdEQsT0FBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUM7QUFDN0IsT0FBSSxDQUFDLGVBQWUsR0FBSyxDQUFDLENBQUM7R0FDM0I7OztBQUdELE1BQUksQ0FBQyxLQUFLLEdBQU8sSUFBSSxLQUFLLENBQUMsS0FBSyxFQUFFLENBQUM7QUFDbkMsTUFBSSxDQUFDLFNBQVMsR0FBRyx5QkFBTyxNQUFNLENBQUMsT0FBTyxDQUFDOztBQUV2QyxNQUFJLENBQUMsTUFBTSxHQUFRLElBQUksS0FBSyxDQUFDLGlCQUFpQixDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsS0FBSyxFQUFFLEVBQUUsRUFBRSxJQUFJLENBQUMsQ0FBQztBQUN6RSxNQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEdBQUcseUJBQU8sTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7QUFDbEQsTUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLHlCQUFPLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO0FBQ2xELE1BQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyx5QkFBTyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztBQUNsRCxNQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyx5QkFBTyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7O0FBRXpDLE1BQUsseUJBQU8sVUFBVSxFQUFHO0FBQ3hCLE9BQUksQ0FBQyxVQUFVLEdBQUksSUFBSSxLQUFLLENBQUMsVUFBVSxDQUFFLENBQUMsQ0FBRSxDQUFDO0FBQzdDLE9BQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFFLElBQUksQ0FBQyxVQUFVLENBQUUsQ0FBQztHQUNsQzs7O0FBR0QsTUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLEtBQUssQ0FBQyxhQUFhLEVBQUUsQ0FBQztBQUMxQyxNQUFJLENBQUMsUUFBUSxDQUFDLGFBQWEsQ0FBQyx5QkFBTyxNQUFNLENBQUMsS0FBSyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0FBQ3RELE1BQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxVQUFVLEVBQUUsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDOzs7QUFHN0QsTUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLEtBQUssQ0FBQyxZQUFZLENBQUUseUJBQU8sTUFBTSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUUsQ0FBQzs7O0FBR3JFLE1BQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFFLElBQUksQ0FBQyxPQUFPLENBQUUsQ0FBQzs7O0FBRy9CLE1BQUksQ0FBQyxTQUFTLENBQUMsV0FBVyxDQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFFLENBQUM7O0FBRXZELE1BQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQzs7O0FBR3ZCLHdCQUFJLFFBQVEsQ0FBRSxJQUFJLENBQUMsTUFBTSxDQUFFLENBQUM7QUFDNUIsd0JBQUksS0FBSyxFQUFFLENBQUM7QUFDWixNQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7O0FBRWhCLFFBQU0sQ0FBQyxnQkFBZ0IsQ0FBRSxPQUFPLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBRSxDQUFDO0FBQ2pELFFBQU0sQ0FBQyxnQkFBZ0IsQ0FBRSxRQUFRLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBRSxDQUFDO0FBQ25ELFFBQU0sQ0FBQyxnQkFBZ0IsQ0FBRSxXQUFXLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBRSxDQUFDO0VBQ3BEOztBQUVELGdCQUFlLEVBQUUsMkJBQVc7QUFDM0IsTUFBSSxDQUFDLFFBQVEsR0FBRztBQUNmLE9BQUksRUFBRSxFQUFFLElBQUksRUFBRSxHQUFHLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRTtBQUMvQixNQUFHLEVBQUUsRUFBRSxJQUFJLEVBQUUsR0FBRyxFQUFFLEtBQUssRUFBRSxLQUFLLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyx5QkFBTyxTQUFTLENBQUMsT0FBTyxDQUFDLEVBQUU7O0dBRWpGLENBQUE7O0FBRUQsTUFBSSxDQUFDLFFBQVEsR0FBSSxJQUFJLEtBQUssQ0FBQyxjQUFjLEVBQUUsQ0FBQztBQUM1QyxNQUFJLENBQUMsUUFBUSxHQUFJLElBQUksWUFBWSxDQUFFLHlCQUFPLFNBQVMsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFFLENBQUM7QUFDaEUsTUFBSSxDQUFDLEtBQUssR0FBSyxJQUFJLFlBQVksQ0FBRSx5QkFBTyxTQUFTLENBQUMsS0FBSyxDQUFFLENBQUM7O0FBRTFELE9BQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFHLENBQUMsR0FBRyx5QkFBTyxTQUFTLENBQUMsS0FBSyxFQUFHLENBQUMsRUFBRSxFQUFHOzs7Ozs7Ozs7Ozs7OztBQWNuRCxPQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7QUFDckMsT0FBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztBQUN6QyxPQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDOztBQUU3QixPQUFJLENBQUMsS0FBSyxDQUFFLENBQUMsQ0FBRSxHQUFHLENBQUMsQ0FBQztHQUNwQjs7QUFFRCxNQUFJLENBQUMsUUFBUSxDQUFDLFlBQVksQ0FBRSxVQUFVLEVBQUUsSUFBSSxLQUFLLENBQUMsZUFBZSxDQUFFLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFFLENBQUUsQ0FBQztBQUN4RixNQUFJLENBQUMsUUFBUSxDQUFDLFlBQVksQ0FBRSxNQUFNLEVBQUUsSUFBSSxLQUFLLENBQUMsZUFBZSxDQUFFLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFFLENBQUUsQ0FBQzs7QUFFakYsTUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLEtBQUssQ0FBQyxjQUFjLENBQUU7QUFDekMsV0FBUSxFQUFFLElBQUksQ0FBQyxRQUFRO0FBQ3ZCLGNBQVcsRUFBRSxJQUFJO0FBQ2pCLGVBQVksRUFBRSxPQUFPLENBQUMsZ0NBQWdDLENBQUMsR0FBRyxPQUFPLENBQUMsa0NBQWtDLENBQUM7QUFDckcsaUJBQWMsRUFBRSxPQUFPLENBQUMsb0NBQW9DLENBQUM7R0FDN0QsQ0FBQyxDQUFDOztBQUVILE1BQUksQ0FBQyxjQUFjLEdBQUcsSUFBSSxLQUFLLENBQUMsTUFBTSxDQUFFLElBQUksQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBRSxDQUFDOztBQUV2RSxNQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7RUFDcEM7O0FBRUQsUUFBTyxFQUFFLGlCQUFVLEtBQUssRUFBRyxFQUMxQjs7QUFFRCxPQUFNLEVBQUUsZ0JBQVUsS0FBSyxFQUFHO0FBQ3pCLE1BQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQztBQUNsRCxNQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUM7RUFDbkQ7O0FBRUQsU0FBUSxFQUFFLG9CQUFXO0FBQ3BCLE1BQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxVQUFVLEVBQUUsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDO0FBQzdELE1BQUksQ0FBQyxLQUFLLEdBQUcsTUFBTSxDQUFDLFVBQVUsR0FBRyxNQUFNLENBQUMsV0FBVyxDQUFDOztBQUVwRCxNQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDO0FBQ2hDLE1BQUksQ0FBQyxNQUFNLENBQUMsc0JBQXNCLEVBQUUsQ0FBQzs7QUFFckMsTUFBSSxDQUFDLFNBQVMsR0FBRyxNQUFNLENBQUMsVUFBVSxHQUFHLEVBQUUsQ0FBQztBQUN4QyxNQUFJLENBQUMsVUFBVSxHQUFHLE1BQU0sQ0FBQyxXQUFXLEdBQUcsRUFBRSxDQUFDO0VBQzFDOztBQUVELE9BQU0sRUFBRSxrQkFBVztBQUNsQixNQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFDOztBQUVsQyxNQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxJQUFJLENBQUUsQUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUksSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQSxHQUFLLElBQUksQ0FBQztBQUN6RixNQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxJQUFJLENBQUUsQUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUksSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQSxHQUFLLElBQUksQ0FBQzs7QUFFekYsTUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFFLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFFLENBQUM7QUFDdEcsTUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMseUJBQU8sTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDOztBQUV6QyxNQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxLQUFLLElBQUksS0FBSyxDQUFDOztBQUVsQyxNQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztFQUM5Qzs7Q0FFRCxDQUFDOzs7Ozs7OytCQ3pKZ0Isb0JBQW9COzs7O0FBRXRDLE1BQU0sQ0FBQyxNQUFNLEdBQUcsWUFBVzs7QUFFMUIsOEJBQU0sSUFBSSxFQUFFLENBQUM7Q0FFYixDQUFBOzs7QUNORDtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTs7Ozs7O3VCQ0RvQixVQUFVOzs7O0FBQzlCLElBQU0sS0FBSyxHQUFHLDJCQUFTLENBQUM7O0FBR3hCLElBQUksTUFBTSxHQUFHOztBQUVaLE9BQU0sRUFBRTtBQUNQLFNBQU8sRUFBRyxRQUFRLENBQUMsY0FBYyxDQUFDLFdBQVcsQ0FBQztBQUM5QyxPQUFLLEVBQUcsUUFBUTtFQUNoQjs7QUFFRCxPQUFNLEVBQUU7QUFDUCxVQUFRLEVBQUcsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDO0FBQ3ZDLFFBQU0sRUFBRyxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7RUFDbkM7O0FBRUQsV0FBVSxFQUFFLEtBQUs7O0FBRWpCLE9BQU0sRUFBRTtBQUNQLFNBQU8sRUFBRTtBQUNSLFFBQUssRUFBRyxRQUFRO0dBQ2hCO0VBQ0Q7O0FBRUQsVUFBUyxFQUFFO0FBQ1YsT0FBSyxFQUFFLE1BQU07QUFDYixlQUFhLEVBQUUsR0FBRztBQUNsQixTQUFPLEVBQUcsNkJBQTZCO0VBQ3ZDOztBQUVELFVBQVMsRUFBRTtBQUNWLFdBQVMsRUFBRSxHQUFHO0FBQ2QsVUFBUSxFQUFFLEdBQUc7QUFDYixVQUFRLEVBQUUsR0FBRztBQUNiLFdBQVMsRUFBRSxFQUFFO0VBQ2I7O0FBRUQsTUFBSyxFQUFFO0FBQ04sT0FBSyxFQUFFLEdBQUc7QUFDVixRQUFNLEVBQUUsR0FBRztBQUNYLFdBQVMsRUFBRSxJQUFJO0FBQ2YsU0FBTyxFQUFFLENBQUM7RUFDVjs7Q0FFRCxDQUFBOztBQUdELE1BQU0sQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDOzs7Ozs7QUM5Q3hCLFNBQVMsTUFBTSxDQUFDLEdBQUcsRUFBQyxJQUFJLEVBQUMsSUFBSSxFQUFDLElBQUksRUFBQyxJQUFJLEVBQUM7QUFBQyxTQUFNLEFBQUMsQUFBQyxDQUFDLEdBQUcsR0FBQyxJQUFJLENBQUEsSUFBRyxJQUFJLEdBQUMsSUFBSSxDQUFBLEFBQUMsSUFBRyxJQUFJLEdBQUMsSUFBSSxDQUFBLEFBQUMsR0FBRyxJQUFJLEFBQUMsQ0FBQztDQUFDOztBQUU5RixNQUFNLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQzs7Ozs7QUNIeEIsU0FBUyxHQUFHLEdBQUc7O0FBRWQsS0FBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUNqQyxLQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ25DLEtBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDakMsS0FBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQzs7QUFFdkMsS0FBSSxDQUFDLFNBQVMsR0FBRyxFQUFFLENBQUM7O0FBRXBCLE9BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0NBRWpEOztBQUVELEdBQUcsQ0FBQyxTQUFTLENBQUMsUUFBUSxHQUFHLFVBQVUsUUFBUSxFQUFHOztBQUU3QyxLQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztDQUU5QixDQUFBOztBQUVELEdBQUcsQ0FBQyxTQUFTLENBQUMsS0FBSyxHQUFHLFlBQVc7O0FBRWhDLEtBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQztDQUVaLENBQUE7O0FBRUQsR0FBRyxDQUFDLFNBQVMsQ0FBQyxJQUFJLEdBQUcsWUFBVzs7QUFFL0IscUJBQW9CLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0NBRW5DLENBQUE7O0FBRUQsR0FBRyxDQUFDLFNBQVMsQ0FBQyxJQUFJLEdBQUcsWUFBVzs7QUFFL0IsS0FBSSxDQUFDLENBQUM7QUFDTixNQUFLLENBQUMsR0FBRyxDQUFDLEVBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxFQUFHLENBQUMsRUFBRSxFQUFHO0FBQzlDLE1BQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztFQUNwQjs7QUFFRCxLQUFJLENBQUMsT0FBTyxHQUFHLHFCQUFxQixDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztDQUVqRCxDQUFBOztBQUVELEdBQUcsQ0FBQyxTQUFTLENBQUMsT0FBTyxHQUFHLFVBQVMsS0FBSyxFQUFFO0FBQ3ZDLEtBQUksS0FBSyxDQUFDLE9BQU8sS0FBSyxDQUFDLElBQUksS0FBSyxDQUFDLE9BQU8sS0FBSyxFQUFFLEVBQUU7O0FBRWhELE1BQUksSUFBSSxDQUFDLE9BQU8sSUFBSSxJQUFJLEVBQ3ZCLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQyxLQUVaLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQztFQUVkO0NBQ0QsQ0FBQzs7QUFFRixNQUFNLENBQUMsT0FBTyxHQUFHLElBQUksR0FBRyxFQUFFLENBQUMiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiKGZ1bmN0aW9uKCBzZWxmICl7XG5cblx0dmFyIFRIUkVFID0gcmVxdWlyZShcIi4vdGhyZWUuanNcIik7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiggYWRkb25zICl7XG5cblx0XHRpZiggYWRkb25zIGluc3RhbmNlb2YgQXJyYXkgKXtcblxuXHRcdFx0Zm9yKCB2YXIgYWRkb24gPSAwLCBsZW5ndGggPSBhZGRvbnMubGVuZ3RoOyBhZGRvbiA8IGxlbmd0aDsgYWRkb24rKyApe1xuXG5cdFx0XHRcdHJlcXVpcmUoXCIuL2FkZG9ucy9cIiArIGFkZG9uc1thZGRvbl0gKyBcIi5qc1wiKShUSFJFRSk7XG5cblx0XHRcdH07XG5cblx0XHR9O1xuXG5cdFx0cmV0dXJuIFRIUkVFO1xuXG5cdH07XG5cbn0pKHRoaXMgfHzCoHt9KTsiLCIvKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuKGZ1bmN0aW9uKCBzZWxmICl7XG5cblx0dmFyIFRIUkVFID0geyBSRVZJU0lPTjogJzczJyB9O1xuXG5cdC8vIHBvbHlmaWxsc1xuXG5cdGlmICggc2VsZi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09IHVuZGVmaW5lZCB8fCBzZWxmLmNhbmNlbEFuaW1hdGlvbkZyYW1lID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHQvLyBNaXNzaW5nIGluIEFuZHJvaWQgc3RvY2sgYnJvd3Nlci5cblxuXHRcdCggZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgbGFzdFRpbWUgPSAwO1xuXHRcdFx0dmFyIHZlbmRvcnMgPSBbICdtcycsICdtb3onLCAnd2Via2l0JywgJ28nIF07XG5cblx0XHRcdGZvciAoIHZhciB4ID0gMDsgeCA8IHZlbmRvcnMubGVuZ3RoICYmICEgc2VsZi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7ICsrIHggKSB7XG5cblx0XHRcdFx0c2VsZi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBzZWxmWyB2ZW5kb3JzWyB4IF0gKyAnUmVxdWVzdEFuaW1hdGlvbkZyYW1lJyBdO1xuXHRcdFx0XHRzZWxmLmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gc2VsZlsgdmVuZG9yc1sgeCBdICsgJ0NhbmNlbEFuaW1hdGlvbkZyYW1lJyBdIHx8IHNlbGZbIHZlbmRvcnNbIHggXSArICdDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnIF07XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBzZWxmLnJlcXVlc3RBbmltYXRpb25GcmFtZSA9PT0gdW5kZWZpbmVkICYmIHNlbGYuc2V0VGltZW91dCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHNlbGYucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcblxuXHRcdFx0XHRcdHZhciBjdXJyVGltZSA9IERhdGUubm93KCksIHRpbWVUb0NhbGwgPSBNYXRoLm1heCggMCwgMTYgLSAoIGN1cnJUaW1lIC0gbGFzdFRpbWUgKSApO1xuXHRcdFx0XHRcdHZhciBpZCA9IHNlbGYuc2V0VGltZW91dCggZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdFx0XHRjYWxsYmFjayggY3VyclRpbWUgKyB0aW1lVG9DYWxsICk7XG5cblx0XHRcdFx0XHR9LCB0aW1lVG9DYWxsICk7XG5cdFx0XHRcdFx0bGFzdFRpbWUgPSBjdXJyVGltZSArIHRpbWVUb0NhbGw7XG5cdFx0XHRcdFx0cmV0dXJuIGlkO1xuXG5cdFx0XHRcdH07XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBzZWxmLmNhbmNlbEFuaW1hdGlvbkZyYW1lID09PSB1bmRlZmluZWQgJiYgc2VsZi5jbGVhclRpbWVvdXQgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRzZWxmLmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gKCBpZCApIHtcblxuXHRcdFx0XHRcdHNlbGYuY2xlYXJUaW1lb3V0KCBpZCApO1xuXG5cdFx0XHRcdH07XG5cblx0XHRcdH1cblxuXHRcdH0gKSgpO1xuXG5cdH1cblxuXHQvL1xuXG5cdGlmICggc2VsZi5wZXJmb3JtYW5jZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0c2VsZi5wZXJmb3JtYW5jZSA9IHt9O1xuXG5cdH1cblxuXHRpZiAoIHNlbGYucGVyZm9ybWFuY2Uubm93ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHQoIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIHN0YXJ0ID0gRGF0ZS5ub3coKTtcblxuXHRcdFx0c2VsZi5wZXJmb3JtYW5jZS5ub3cgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0cmV0dXJuIERhdGUubm93KCkgLSBzdGFydDtcblxuXHRcdFx0fVxuXG5cdFx0fSApKCk7XG5cblx0fVxuXG5cdC8vXG5cblx0aWYgKCBOdW1iZXIuRVBTSUxPTiA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0TnVtYmVyLkVQU0lMT04gPSBNYXRoLnBvdyggMiwgLTUyICk7XG5cblx0fVxuXG5cdC8vXG5cblx0aWYgKCBNYXRoLnNpZ24gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvc2lnblxuXG5cdFx0TWF0aC5zaWduID0gZnVuY3Rpb24gKCB4ICkge1xuXG5cdFx0XHRyZXR1cm4gKCB4IDwgMCApID8gLSAxIDogKCB4ID4gMCApID8gMSA6ICsgeDtcblxuXHRcdH07XG5cblx0fVxuXG5cdGlmICggRnVuY3Rpb24ucHJvdG90eXBlLm5hbWUgPT09IHVuZGVmaW5lZCAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdC8vIE1pc3NpbmcgaW4gSUU5LTExLlxuXHRcdC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Z1bmN0aW9uL25hbWVcblxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggRnVuY3Rpb24ucHJvdG90eXBlLCAnbmFtZScsIHtcblxuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXMudG9TdHJpbmcoKS5tYXRjaCggL15cXHMqZnVuY3Rpb25cXHMqKFxcUyopXFxzKlxcKC8gKVsgMSBdO1xuXG5cdFx0XHR9XG5cblx0XHR9ICk7XG5cblx0fVxuXG5cdC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Nb3VzZUV2ZW50LmJ1dHRvblxuXG5cdFRIUkVFLk1PVVNFID0geyBMRUZUOiAwLCBNSURETEU6IDEsIFJJR0hUOiAyIH07XG5cblx0Ly8gR0wgU1RBVEUgQ09OU1RBTlRTXG5cblx0VEhSRUUuQ3VsbEZhY2VOb25lID0gMDtcblx0VEhSRUUuQ3VsbEZhY2VCYWNrID0gMTtcblx0VEhSRUUuQ3VsbEZhY2VGcm9udCA9IDI7XG5cdFRIUkVFLkN1bGxGYWNlRnJvbnRCYWNrID0gMztcblxuXHRUSFJFRS5Gcm9udEZhY2VEaXJlY3Rpb25DVyA9IDA7XG5cdFRIUkVFLkZyb250RmFjZURpcmVjdGlvbkNDVyA9IDE7XG5cblx0Ly8gU0hBRE9XSU5HIFRZUEVTXG5cblx0VEhSRUUuQmFzaWNTaGFkb3dNYXAgPSAwO1xuXHRUSFJFRS5QQ0ZTaGFkb3dNYXAgPSAxO1xuXHRUSFJFRS5QQ0ZTb2Z0U2hhZG93TWFwID0gMjtcblxuXHQvLyBNQVRFUklBTCBDT05TVEFOVFNcblxuXHQvLyBzaWRlXG5cblx0VEhSRUUuRnJvbnRTaWRlID0gMDtcblx0VEhSRUUuQmFja1NpZGUgPSAxO1xuXHRUSFJFRS5Eb3VibGVTaWRlID0gMjtcblxuXHQvLyBzaGFkaW5nXG5cblx0VEhSRUUuRmxhdFNoYWRpbmcgPSAxO1xuXHRUSFJFRS5TbW9vdGhTaGFkaW5nID0gMjtcblxuXHQvLyBjb2xvcnNcblxuXHRUSFJFRS5Ob0NvbG9ycyA9IDA7XG5cdFRIUkVFLkZhY2VDb2xvcnMgPSAxO1xuXHRUSFJFRS5WZXJ0ZXhDb2xvcnMgPSAyO1xuXG5cdC8vIGJsZW5kaW5nIG1vZGVzXG5cblx0VEhSRUUuTm9CbGVuZGluZyA9IDA7XG5cdFRIUkVFLk5vcm1hbEJsZW5kaW5nID0gMTtcblx0VEhSRUUuQWRkaXRpdmVCbGVuZGluZyA9IDI7XG5cdFRIUkVFLlN1YnRyYWN0aXZlQmxlbmRpbmcgPSAzO1xuXHRUSFJFRS5NdWx0aXBseUJsZW5kaW5nID0gNDtcblx0VEhSRUUuQ3VzdG9tQmxlbmRpbmcgPSA1O1xuXG5cdC8vIGN1c3RvbSBibGVuZGluZyBlcXVhdGlvbnNcblx0Ly8gKG51bWJlcnMgc3RhcnQgZnJvbSAxMDAgbm90IHRvIGNsYXNoIHdpdGggb3RoZXJcblx0Ly8gbWFwcGluZ3MgdG8gT3BlbkdMIGNvbnN0YW50cyBkZWZpbmVkIGluIFRleHR1cmUuanMpXG5cblx0VEhSRUUuQWRkRXF1YXRpb24gPSAxMDA7XG5cdFRIUkVFLlN1YnRyYWN0RXF1YXRpb24gPSAxMDE7XG5cdFRIUkVFLlJldmVyc2VTdWJ0cmFjdEVxdWF0aW9uID0gMTAyO1xuXHRUSFJFRS5NaW5FcXVhdGlvbiA9IDEwMztcblx0VEhSRUUuTWF4RXF1YXRpb24gPSAxMDQ7XG5cblx0Ly8gY3VzdG9tIGJsZW5kaW5nIGRlc3RpbmF0aW9uIGZhY3RvcnNcblxuXHRUSFJFRS5aZXJvRmFjdG9yID0gMjAwO1xuXHRUSFJFRS5PbmVGYWN0b3IgPSAyMDE7XG5cdFRIUkVFLlNyY0NvbG9yRmFjdG9yID0gMjAyO1xuXHRUSFJFRS5PbmVNaW51c1NyY0NvbG9yRmFjdG9yID0gMjAzO1xuXHRUSFJFRS5TcmNBbHBoYUZhY3RvciA9IDIwNDtcblx0VEhSRUUuT25lTWludXNTcmNBbHBoYUZhY3RvciA9IDIwNTtcblx0VEhSRUUuRHN0QWxwaGFGYWN0b3IgPSAyMDY7XG5cdFRIUkVFLk9uZU1pbnVzRHN0QWxwaGFGYWN0b3IgPSAyMDc7XG5cblx0Ly8gY3VzdG9tIGJsZW5kaW5nIHNvdXJjZSBmYWN0b3JzXG5cblx0Ly9USFJFRS5aZXJvRmFjdG9yID0gMjAwO1xuXHQvL1RIUkVFLk9uZUZhY3RvciA9IDIwMTtcblx0Ly9USFJFRS5TcmNBbHBoYUZhY3RvciA9IDIwNDtcblx0Ly9USFJFRS5PbmVNaW51c1NyY0FscGhhRmFjdG9yID0gMjA1O1xuXHQvL1RIUkVFLkRzdEFscGhhRmFjdG9yID0gMjA2O1xuXHQvL1RIUkVFLk9uZU1pbnVzRHN0QWxwaGFGYWN0b3IgPSAyMDc7XG5cdFRIUkVFLkRzdENvbG9yRmFjdG9yID0gMjA4O1xuXHRUSFJFRS5PbmVNaW51c0RzdENvbG9yRmFjdG9yID0gMjA5O1xuXHRUSFJFRS5TcmNBbHBoYVNhdHVyYXRlRmFjdG9yID0gMjEwO1xuXG5cdC8vIGRlcHRoIG1vZGVzXG5cblx0VEhSRUUuTmV2ZXJEZXB0aCA9IDA7XG5cdFRIUkVFLkFsd2F5c0RlcHRoID0gMTtcblx0VEhSRUUuTGVzc0RlcHRoID0gMjtcblx0VEhSRUUuTGVzc0VxdWFsRGVwdGggPSAzO1xuXHRUSFJFRS5FcXVhbERlcHRoID0gNDtcblx0VEhSRUUuR3JlYXRlckVxdWFsRGVwdGggPSA1O1xuXHRUSFJFRS5HcmVhdGVyRGVwdGggPSA2O1xuXHRUSFJFRS5Ob3RFcXVhbERlcHRoID0gNztcblxuXG5cdC8vIFRFWFRVUkUgQ09OU1RBTlRTXG5cblx0VEhSRUUuTXVsdGlwbHlPcGVyYXRpb24gPSAwO1xuXHRUSFJFRS5NaXhPcGVyYXRpb24gPSAxO1xuXHRUSFJFRS5BZGRPcGVyYXRpb24gPSAyO1xuXG5cdC8vIE1hcHBpbmcgbW9kZXNcblxuXHRUSFJFRS5VVk1hcHBpbmcgPSAzMDA7XG5cblx0VEhSRUUuQ3ViZVJlZmxlY3Rpb25NYXBwaW5nID0gMzAxO1xuXHRUSFJFRS5DdWJlUmVmcmFjdGlvbk1hcHBpbmcgPSAzMDI7XG5cblx0VEhSRUUuRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmcgPSAzMDM7XG5cdFRIUkVFLkVxdWlyZWN0YW5ndWxhclJlZnJhY3Rpb25NYXBwaW5nID0gMzA0O1xuXG5cdFRIUkVFLlNwaGVyaWNhbFJlZmxlY3Rpb25NYXBwaW5nID0gMzA1O1xuXG5cdC8vIFdyYXBwaW5nIG1vZGVzXG5cblx0VEhSRUUuUmVwZWF0V3JhcHBpbmcgPSAxMDAwO1xuXHRUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nID0gMTAwMTtcblx0VEhSRUUuTWlycm9yZWRSZXBlYXRXcmFwcGluZyA9IDEwMDI7XG5cblx0Ly8gRmlsdGVyc1xuXG5cdFRIUkVFLk5lYXJlc3RGaWx0ZXIgPSAxMDAzO1xuXHRUSFJFRS5OZWFyZXN0TWlwTWFwTmVhcmVzdEZpbHRlciA9IDEwMDQ7XG5cdFRIUkVFLk5lYXJlc3RNaXBNYXBMaW5lYXJGaWx0ZXIgPSAxMDA1O1xuXHRUSFJFRS5MaW5lYXJGaWx0ZXIgPSAxMDA2O1xuXHRUSFJFRS5MaW5lYXJNaXBNYXBOZWFyZXN0RmlsdGVyID0gMTAwNztcblx0VEhSRUUuTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyID0gMTAwODtcblxuXHQvLyBEYXRhIHR5cGVzXG5cblx0VEhSRUUuVW5zaWduZWRCeXRlVHlwZSA9IDEwMDk7XG5cdFRIUkVFLkJ5dGVUeXBlID0gMTAxMDtcblx0VEhSRUUuU2hvcnRUeXBlID0gMTAxMTtcblx0VEhSRUUuVW5zaWduZWRTaG9ydFR5cGUgPSAxMDEyO1xuXHRUSFJFRS5JbnRUeXBlID0gMTAxMztcblx0VEhSRUUuVW5zaWduZWRJbnRUeXBlID0gMTAxNDtcblx0VEhSRUUuRmxvYXRUeXBlID0gMTAxNTtcblx0VEhSRUUuSGFsZkZsb2F0VHlwZSA9IDEwMjU7XG5cblx0Ly8gUGl4ZWwgdHlwZXNcblxuXHQvL1RIUkVFLlVuc2lnbmVkQnl0ZVR5cGUgPSAxMDA5O1xuXHRUSFJFRS5VbnNpZ25lZFNob3J0NDQ0NFR5cGUgPSAxMDE2O1xuXHRUSFJFRS5VbnNpZ25lZFNob3J0NTU1MVR5cGUgPSAxMDE3O1xuXHRUSFJFRS5VbnNpZ25lZFNob3J0NTY1VHlwZSA9IDEwMTg7XG5cblx0Ly8gUGl4ZWwgZm9ybWF0c1xuXG5cdFRIUkVFLkFscGhhRm9ybWF0ID0gMTAxOTtcblx0VEhSRUUuUkdCRm9ybWF0ID0gMTAyMDtcblx0VEhSRUUuUkdCQUZvcm1hdCA9IDEwMjE7XG5cdFRIUkVFLkx1bWluYW5jZUZvcm1hdCA9IDEwMjI7XG5cdFRIUkVFLkx1bWluYW5jZUFscGhhRm9ybWF0ID0gMTAyMztcblx0Ly8gVEhSRUUuUkdCRUZvcm1hdCBoYW5kbGVkIGFzIFRIUkVFLlJHQkFGb3JtYXQgaW4gc2hhZGVyc1xuXHRUSFJFRS5SR0JFRm9ybWF0ID0gVEhSRUUuUkdCQUZvcm1hdDsgLy8xMDI0O1xuXG5cdC8vIEREUyAvIFNUM0MgQ29tcHJlc3NlZCB0ZXh0dXJlIGZvcm1hdHNcblxuXHRUSFJFRS5SR0JfUzNUQ19EWFQxX0Zvcm1hdCA9IDIwMDE7XG5cdFRIUkVFLlJHQkFfUzNUQ19EWFQxX0Zvcm1hdCA9IDIwMDI7XG5cdFRIUkVFLlJHQkFfUzNUQ19EWFQzX0Zvcm1hdCA9IDIwMDM7XG5cdFRIUkVFLlJHQkFfUzNUQ19EWFQ1X0Zvcm1hdCA9IDIwMDQ7XG5cblxuXHQvLyBQVlJUQyBjb21wcmVzc2VkIHRleHR1cmUgZm9ybWF0c1xuXG5cdFRIUkVFLlJHQl9QVlJUQ180QlBQVjFfRm9ybWF0ID0gMjEwMDtcblx0VEhSRUUuUkdCX1BWUlRDXzJCUFBWMV9Gb3JtYXQgPSAyMTAxO1xuXHRUSFJFRS5SR0JBX1BWUlRDXzRCUFBWMV9Gb3JtYXQgPSAyMTAyO1xuXHRUSFJFRS5SR0JBX1BWUlRDXzJCUFBWMV9Gb3JtYXQgPSAyMTAzO1xuXG5cdC8vIExvb3Agc3R5bGVzIGZvciBBbmltYXRpb25BY3Rpb25cblxuXHRUSFJFRS5Mb29wT25jZSA9IDIyMDA7XG5cdFRIUkVFLkxvb3BSZXBlYXQgPSAyMjAxO1xuXHRUSFJFRS5Mb29wUGluZ1BvbmcgPSAyMjAyO1xuXG5cdC8vIERFUFJFQ0FURURcblxuXHRUSFJFRS5Qcm9qZWN0b3IgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuUHJvamVjdG9yIGhhcyBiZWVuIG1vdmVkIHRvIC9leGFtcGxlcy9qcy9yZW5kZXJlcnMvUHJvamVjdG9yLmpzLicgKTtcblxuXHRcdHRoaXMucHJvamVjdFZlY3RvciA9IGZ1bmN0aW9uICggdmVjdG9yLCBjYW1lcmEgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlByb2plY3RvcjogLnByb2plY3RWZWN0b3IoKSBpcyBub3cgdmVjdG9yLnByb2plY3QoKS4nICk7XG5cdFx0XHR2ZWN0b3IucHJvamVjdCggY2FtZXJhICk7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy51bnByb2plY3RWZWN0b3IgPSBmdW5jdGlvbiAoIHZlY3RvciwgY2FtZXJhICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Qcm9qZWN0b3I6IC51bnByb2plY3RWZWN0b3IoKSBpcyBub3cgdmVjdG9yLnVucHJvamVjdCgpLicgKTtcblx0XHRcdHZlY3Rvci51bnByb2plY3QoIGNhbWVyYSApO1xuXG5cdFx0fTtcblxuXHRcdHRoaXMucGlja2luZ1JheSA9IGZ1bmN0aW9uICggdmVjdG9yLCBjYW1lcmEgKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5Qcm9qZWN0b3I6IC5waWNraW5nUmF5KCkgaXMgbm93IHJheWNhc3Rlci5zZXRGcm9tQ2FtZXJhKCkuJyApO1xuXG5cdFx0fTtcblxuXHR9O1xuXG5cdFRIUkVFLkNhbnZhc1JlbmRlcmVyID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkNhbnZhc1JlbmRlcmVyIGhhcyBiZWVuIG1vdmVkIHRvIC9leGFtcGxlcy9qcy9yZW5kZXJlcnMvQ2FudmFzUmVuZGVyZXIuanMnICk7XG5cblx0XHR0aGlzLmRvbUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnY2FudmFzJyApO1xuXHRcdHRoaXMuY2xlYXIgPSBmdW5jdGlvbiAoKSB7fTtcblx0XHR0aGlzLnJlbmRlciA9IGZ1bmN0aW9uICgpIHt9O1xuXHRcdHRoaXMuc2V0Q2xlYXJDb2xvciA9IGZ1bmN0aW9uICgpIHt9O1xuXHRcdHRoaXMuc2V0U2l6ZSA9IGZ1bmN0aW9uICgpIHt9O1xuXG5cdH07XG5cblx0Ly8gRmlsZTpzcmMvbWF0aC9Db2xvci5qc1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuXHQgKi9cblxuXHRUSFJFRS5Db2xvciA9IGZ1bmN0aW9uICggY29sb3IgKSB7XG5cblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPT09IDMgKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLmZyb21BcnJheSggYXJndW1lbnRzICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5zZXQoIGNvbG9yICk7XG5cblx0fTtcblxuXHRUSFJFRS5Db2xvci5wcm90b3R5cGUgPSB7XG5cblx0XHRjb25zdHJ1Y3RvcjogVEhSRUUuQ29sb3IsXG5cblx0XHRyOiAxLCBnOiAxLCBiOiAxLFxuXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHRpZiAoIHZhbHVlIGluc3RhbmNlb2YgVEhSRUUuQ29sb3IgKSB7XG5cblx0XHRcdFx0dGhpcy5jb3B5KCB2YWx1ZSApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICkge1xuXG5cdFx0XHRcdHRoaXMuc2V0SGV4KCB2YWx1ZSApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICkge1xuXG5cdFx0XHRcdHRoaXMuc2V0U3R5bGUoIHZhbHVlICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0c2V0SGV4OiBmdW5jdGlvbiAoIGhleCApIHtcblxuXHRcdFx0aGV4ID0gTWF0aC5mbG9vciggaGV4ICk7XG5cblx0XHRcdHRoaXMuciA9ICggaGV4ID4+IDE2ICYgMjU1ICkgLyAyNTU7XG5cdFx0XHR0aGlzLmcgPSAoIGhleCA+PiA4ICYgMjU1ICkgLyAyNTU7XG5cdFx0XHR0aGlzLmIgPSAoIGhleCAmIDI1NSApIC8gMjU1O1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRzZXRSR0I6IGZ1bmN0aW9uICggciwgZywgYiApIHtcblxuXHRcdFx0dGhpcy5yID0gcjtcblx0XHRcdHRoaXMuZyA9IGc7XG5cdFx0XHR0aGlzLmIgPSBiO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRzZXRIU0w6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0ZnVuY3Rpb24gaHVlMnJnYiggcCwgcSwgdCApIHtcblxuXHRcdFx0XHRpZiAoIHQgPCAwICkgdCArPSAxO1xuXHRcdFx0XHRpZiAoIHQgPiAxICkgdCAtPSAxO1xuXHRcdFx0XHRpZiAoIHQgPCAxIC8gNiApIHJldHVybiBwICsgKCBxIC0gcCApICogNiAqIHQ7XG5cdFx0XHRcdGlmICggdCA8IDEgLyAyICkgcmV0dXJuIHE7XG5cdFx0XHRcdGlmICggdCA8IDIgLyAzICkgcmV0dXJuIHAgKyAoIHEgLSBwICkgKiA2ICogKCAyIC8gMyAtIHQgKTtcblx0XHRcdFx0cmV0dXJuIHA7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uICggaCwgcywgbCApIHtcblxuXHRcdFx0XHQvLyBoLHMsbCByYW5nZXMgYXJlIGluIDAuMCAtIDEuMFxuXHRcdFx0XHRoID0gVEhSRUUuTWF0aC5ldWNsaWRlYW5Nb2R1bG8oIGgsIDEgKTtcblx0XHRcdFx0cyA9IFRIUkVFLk1hdGguY2xhbXAoIHMsIDAsIDEgKTtcblx0XHRcdFx0bCA9IFRIUkVFLk1hdGguY2xhbXAoIGwsIDAsIDEgKTtcblxuXHRcdFx0XHRpZiAoIHMgPT09IDAgKSB7XG5cblx0XHRcdFx0XHR0aGlzLnIgPSB0aGlzLmcgPSB0aGlzLmIgPSBsO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR2YXIgcCA9IGwgPD0gMC41ID8gbCAqICggMSArIHMgKSA6IGwgKyBzIC0gKCBsICogcyApO1xuXHRcdFx0XHRcdHZhciBxID0gKCAyICogbCApIC0gcDtcblxuXHRcdFx0XHRcdHRoaXMuciA9IGh1ZTJyZ2IoIHEsIHAsIGggKyAxIC8gMyApO1xuXHRcdFx0XHRcdHRoaXMuZyA9IGh1ZTJyZ2IoIHEsIHAsIGggKTtcblx0XHRcdFx0XHR0aGlzLmIgPSBodWUycmdiKCBxLCBwLCBoIC0gMSAvIDMgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdH07XG5cblx0XHR9KCksXG5cblx0XHRzZXRTdHlsZTogZnVuY3Rpb24gKCBzdHlsZSApIHtcblxuXHRcdFx0ZnVuY3Rpb24gaGFuZGxlQWxwaGEoIHN0cmluZyApIHtcblxuXHRcdFx0XHRpZiAoIHN0cmluZyA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuXG5cdFx0XHRcdGlmICggcGFyc2VGbG9hdCggc3RyaW5nICkgPCAxICkge1xuXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ29sb3I6IEFscGhhIGNvbXBvbmVudCBvZiAnICsgc3R5bGUgKyAnIHdpbGwgYmUgaWdub3JlZC4nICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblxuXHRcdFx0dmFyIG07XG5cblx0XHRcdGlmICggbSA9IC9eKCg/OnJnYnxoc2wpYT8pXFwoXFxzKihbXlxcKV0qKVxcKS8uZXhlYyggc3R5bGUgKSApIHtcblxuXHRcdFx0XHQvLyByZ2IgLyBoc2xcblxuXHRcdFx0XHR2YXIgY29sb3I7XG5cdFx0XHRcdHZhciBuYW1lID0gbVsgMSBdO1xuXHRcdFx0XHR2YXIgY29tcG9uZW50cyA9IG1bIDIgXTtcblxuXHRcdFx0XHRzd2l0Y2ggKCBuYW1lICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAncmdiJzpcblx0XHRcdFx0XHRjYXNlICdyZ2JhJzpcblxuXHRcdFx0XHRcdFx0aWYgKCBjb2xvciA9IC9eKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKigsXFxzKihbMC05XSpcXC4/WzAtOV0rKVxccyopPyQvLmV4ZWMoIGNvbXBvbmVudHMgKSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyByZ2IoMjU1LDAsMCkgcmdiYSgyNTUsMCwwLDAuNSlcblx0XHRcdFx0XHRcdFx0dGhpcy5yID0gTWF0aC5taW4oIDI1NSwgcGFyc2VJbnQoIGNvbG9yWyAxIF0sIDEwICkgKSAvIDI1NTtcblx0XHRcdFx0XHRcdFx0dGhpcy5nID0gTWF0aC5taW4oIDI1NSwgcGFyc2VJbnQoIGNvbG9yWyAyIF0sIDEwICkgKSAvIDI1NTtcblx0XHRcdFx0XHRcdFx0dGhpcy5iID0gTWF0aC5taW4oIDI1NSwgcGFyc2VJbnQoIGNvbG9yWyAzIF0sIDEwICkgKSAvIDI1NTtcblxuXHRcdFx0XHRcdFx0XHRoYW5kbGVBbHBoYSggY29sb3JbIDUgXSApO1xuXG5cdFx0XHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmICggY29sb3IgPSAvXihcXGQrKVxcJVxccyosXFxzKihcXGQrKVxcJVxccyosXFxzKihcXGQrKVxcJVxccyooLFxccyooWzAtOV0qXFwuP1swLTldKylcXHMqKT8kLy5leGVjKCBjb21wb25lbnRzICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gcmdiKDEwMCUsMCUsMCUpIHJnYmEoMTAwJSwwJSwwJSwwLjUpXG5cdFx0XHRcdFx0XHRcdHRoaXMuciA9IE1hdGgubWluKCAxMDAsIHBhcnNlSW50KCBjb2xvclsgMSBdLCAxMCApICkgLyAxMDA7XG5cdFx0XHRcdFx0XHRcdHRoaXMuZyA9IE1hdGgubWluKCAxMDAsIHBhcnNlSW50KCBjb2xvclsgMiBdLCAxMCApICkgLyAxMDA7XG5cdFx0XHRcdFx0XHRcdHRoaXMuYiA9IE1hdGgubWluKCAxMDAsIHBhcnNlSW50KCBjb2xvclsgMyBdLCAxMCApICkgLyAxMDA7XG5cblx0XHRcdFx0XHRcdFx0aGFuZGxlQWxwaGEoIGNvbG9yWyA1IF0gKTtcblxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ2hzbCc6XG5cdFx0XHRcdFx0Y2FzZSAnaHNsYSc6XG5cblx0XHRcdFx0XHRcdGlmICggY29sb3IgPSAvXihbMC05XSpcXC4/WzAtOV0rKVxccyosXFxzKihcXGQrKVxcJVxccyosXFxzKihcXGQrKVxcJVxccyooLFxccyooWzAtOV0qXFwuP1swLTldKylcXHMqKT8kLy5leGVjKCBjb21wb25lbnRzICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gaHNsKDEyMCw1MCUsNTAlKSBoc2xhKDEyMCw1MCUsNTAlLDAuNSlcblx0XHRcdFx0XHRcdFx0dmFyIGggPSBwYXJzZUZsb2F0KCBjb2xvclsgMSBdICkgLyAzNjA7XG5cdFx0XHRcdFx0XHRcdHZhciBzID0gcGFyc2VJbnQoIGNvbG9yWyAyIF0sIDEwICkgLyAxMDA7XG5cdFx0XHRcdFx0XHRcdHZhciBsID0gcGFyc2VJbnQoIGNvbG9yWyAzIF0sIDEwICkgLyAxMDA7XG5cblx0XHRcdFx0XHRcdFx0aGFuZGxlQWxwaGEoIGNvbG9yWyA1IF0gKTtcblxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5zZXRIU0woIGgsIHMsIGwgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAoIG0gPSAvXlxcIyhbQS1GYS1mMC05XSspJC8uZXhlYyggc3R5bGUgKSApIHtcblxuXHRcdFx0XHQvLyBoZXggY29sb3JcblxuXHRcdFx0XHR2YXIgaGV4ID0gbVsgMSBdO1xuXHRcdFx0XHR2YXIgc2l6ZSA9IGhleC5sZW5ndGg7XG5cblx0XHRcdFx0aWYgKCBzaXplID09PSAzICkge1xuXG5cdFx0XHRcdFx0Ly8gI2ZmMFxuXHRcdFx0XHRcdHRoaXMuciA9IHBhcnNlSW50KCBoZXguY2hhckF0KCAwICkgKyBoZXguY2hhckF0KCAwICksIDE2ICkgLyAyNTU7XG5cdFx0XHRcdFx0dGhpcy5nID0gcGFyc2VJbnQoIGhleC5jaGFyQXQoIDEgKSArIGhleC5jaGFyQXQoIDEgKSwgMTYgKSAvIDI1NTtcblx0XHRcdFx0XHR0aGlzLmIgPSBwYXJzZUludCggaGV4LmNoYXJBdCggMiApICsgaGV4LmNoYXJBdCggMiApLCAxNiApIC8gMjU1O1xuXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggc2l6ZSA9PT0gNiApIHtcblxuXHRcdFx0XHRcdC8vICNmZjAwMDBcblx0XHRcdFx0XHR0aGlzLnIgPSBwYXJzZUludCggaGV4LmNoYXJBdCggMCApICsgaGV4LmNoYXJBdCggMSApLCAxNiApIC8gMjU1O1xuXHRcdFx0XHRcdHRoaXMuZyA9IHBhcnNlSW50KCBoZXguY2hhckF0KCAyICkgKyBoZXguY2hhckF0KCAzICksIDE2ICkgLyAyNTU7XG5cdFx0XHRcdFx0dGhpcy5iID0gcGFyc2VJbnQoIGhleC5jaGFyQXQoIDQgKSArIGhleC5jaGFyQXQoIDUgKSwgMTYgKSAvIDI1NTtcblxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHN0eWxlICYmIHN0eWxlLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0Ly8gY29sb3Iga2V5d29yZHNcblx0XHRcdFx0dmFyIGhleCA9IFRIUkVFLkNvbG9yS2V5d29yZHNbIHN0eWxlIF07XG5cblx0XHRcdFx0aWYgKCBoZXggIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdC8vIHJlZFxuXHRcdFx0XHRcdHRoaXMuc2V0SGV4KCBoZXggKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ly8gdW5rbm93biBjb2xvclxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkNvbG9yOiBVbmtub3duIGNvbG9yICcgKyBzdHlsZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMuciwgdGhpcy5nLCB0aGlzLmIgKTtcblxuXHRcdH0sXG5cblx0XHRjb3B5OiBmdW5jdGlvbiAoIGNvbG9yICkge1xuXG5cdFx0XHR0aGlzLnIgPSBjb2xvci5yO1xuXHRcdFx0dGhpcy5nID0gY29sb3IuZztcblx0XHRcdHRoaXMuYiA9IGNvbG9yLmI7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGNvcHlHYW1tYVRvTGluZWFyOiBmdW5jdGlvbiAoIGNvbG9yLCBnYW1tYUZhY3RvciApIHtcblxuXHRcdFx0aWYgKCBnYW1tYUZhY3RvciA9PT0gdW5kZWZpbmVkICkgZ2FtbWFGYWN0b3IgPSAyLjA7XG5cblx0XHRcdHRoaXMuciA9IE1hdGgucG93KCBjb2xvci5yLCBnYW1tYUZhY3RvciApO1xuXHRcdFx0dGhpcy5nID0gTWF0aC5wb3coIGNvbG9yLmcsIGdhbW1hRmFjdG9yICk7XG5cdFx0XHR0aGlzLmIgPSBNYXRoLnBvdyggY29sb3IuYiwgZ2FtbWFGYWN0b3IgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0Y29weUxpbmVhclRvR2FtbWE6IGZ1bmN0aW9uICggY29sb3IsIGdhbW1hRmFjdG9yICkge1xuXG5cdFx0XHRpZiAoIGdhbW1hRmFjdG9yID09PSB1bmRlZmluZWQgKSBnYW1tYUZhY3RvciA9IDIuMDtcblxuXHRcdFx0dmFyIHNhZmVJbnZlcnNlID0gKCBnYW1tYUZhY3RvciA+IDAgKSA/ICggMS4wIC8gZ2FtbWFGYWN0b3IgKSA6IDEuMDtcblxuXHRcdFx0dGhpcy5yID0gTWF0aC5wb3coIGNvbG9yLnIsIHNhZmVJbnZlcnNlICk7XG5cdFx0XHR0aGlzLmcgPSBNYXRoLnBvdyggY29sb3IuZywgc2FmZUludmVyc2UgKTtcblx0XHRcdHRoaXMuYiA9IE1hdGgucG93KCBjb2xvci5iLCBzYWZlSW52ZXJzZSApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRjb252ZXJ0R2FtbWFUb0xpbmVhcjogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgciA9IHRoaXMuciwgZyA9IHRoaXMuZywgYiA9IHRoaXMuYjtcblxuXHRcdFx0dGhpcy5yID0gciAqIHI7XG5cdFx0XHR0aGlzLmcgPSBnICogZztcblx0XHRcdHRoaXMuYiA9IGIgKiBiO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRjb252ZXJ0TGluZWFyVG9HYW1tYTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR0aGlzLnIgPSBNYXRoLnNxcnQoIHRoaXMuciApO1xuXHRcdFx0dGhpcy5nID0gTWF0aC5zcXJ0KCB0aGlzLmcgKTtcblx0XHRcdHRoaXMuYiA9IE1hdGguc3FydCggdGhpcy5iICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGdldEhleDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gKCB0aGlzLnIgKiAyNTUgKSA8PCAxNiBeICggdGhpcy5nICogMjU1ICkgPDwgOCBeICggdGhpcy5iICogMjU1ICkgPDwgMDtcblxuXHRcdH0sXG5cblx0XHRnZXRIZXhTdHJpbmc6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuICggJzAwMDAwMCcgKyB0aGlzLmdldEhleCgpLnRvU3RyaW5nKCAxNiApICkuc2xpY2UoIC0gNiApO1xuXG5cdFx0fSxcblxuXHRcdGdldEhTTDogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdFx0Ly8gaCxzLGwgcmFuZ2VzIGFyZSBpbiAwLjAgLSAxLjBcblxuXHRcdFx0dmFyIGhzbCA9IG9wdGlvbmFsVGFyZ2V0IHx8IHsgaDogMCwgczogMCwgbDogMCB9O1xuXG5cdFx0XHR2YXIgciA9IHRoaXMuciwgZyA9IHRoaXMuZywgYiA9IHRoaXMuYjtcblxuXHRcdFx0dmFyIG1heCA9IE1hdGgubWF4KCByLCBnLCBiICk7XG5cdFx0XHR2YXIgbWluID0gTWF0aC5taW4oIHIsIGcsIGIgKTtcblxuXHRcdFx0dmFyIGh1ZSwgc2F0dXJhdGlvbjtcblx0XHRcdHZhciBsaWdodG5lc3MgPSAoIG1pbiArIG1heCApIC8gMi4wO1xuXG5cdFx0XHRpZiAoIG1pbiA9PT0gbWF4ICkge1xuXG5cdFx0XHRcdGh1ZSA9IDA7XG5cdFx0XHRcdHNhdHVyYXRpb24gPSAwO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHZhciBkZWx0YSA9IG1heCAtIG1pbjtcblxuXHRcdFx0XHRzYXR1cmF0aW9uID0gbGlnaHRuZXNzIDw9IDAuNSA/IGRlbHRhIC8gKCBtYXggKyBtaW4gKSA6IGRlbHRhIC8gKCAyIC0gbWF4IC0gbWluICk7XG5cblx0XHRcdFx0c3dpdGNoICggbWF4ICkge1xuXG5cdFx0XHRcdFx0Y2FzZSByOiBodWUgPSAoIGcgLSBiICkgLyBkZWx0YSArICggZyA8IGIgPyA2IDogMCApOyBicmVhaztcblx0XHRcdFx0XHRjYXNlIGc6IGh1ZSA9ICggYiAtIHIgKSAvIGRlbHRhICsgMjsgYnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBiOiBodWUgPSAoIHIgLSBnICkgLyBkZWx0YSArIDQ7IGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRodWUgLz0gNjtcblxuXHRcdFx0fVxuXG5cdFx0XHRoc2wuaCA9IGh1ZTtcblx0XHRcdGhzbC5zID0gc2F0dXJhdGlvbjtcblx0XHRcdGhzbC5sID0gbGlnaHRuZXNzO1xuXG5cdFx0XHRyZXR1cm4gaHNsO1xuXG5cdFx0fSxcblxuXHRcdGdldFN0eWxlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiAncmdiKCcgKyAoICggdGhpcy5yICogMjU1ICkgfCAwICkgKyAnLCcgKyAoICggdGhpcy5nICogMjU1ICkgfCAwICkgKyAnLCcgKyAoICggdGhpcy5iICogMjU1ICkgfCAwICkgKyAnKSc7XG5cblx0XHR9LFxuXG5cdFx0b2Zmc2V0SFNMOiBmdW5jdGlvbiAoIGgsIHMsIGwgKSB7XG5cblx0XHRcdHZhciBoc2wgPSB0aGlzLmdldEhTTCgpO1xuXG5cdFx0XHRoc2wuaCArPSBoOyBoc2wucyArPSBzOyBoc2wubCArPSBsO1xuXG5cdFx0XHR0aGlzLnNldEhTTCggaHNsLmgsIGhzbC5zLCBoc2wubCApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRhZGQ6IGZ1bmN0aW9uICggY29sb3IgKSB7XG5cblx0XHRcdHRoaXMuciArPSBjb2xvci5yO1xuXHRcdFx0dGhpcy5nICs9IGNvbG9yLmc7XG5cdFx0XHR0aGlzLmIgKz0gY29sb3IuYjtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0YWRkQ29sb3JzOiBmdW5jdGlvbiAoIGNvbG9yMSwgY29sb3IyICkge1xuXG5cdFx0XHR0aGlzLnIgPSBjb2xvcjEuciArIGNvbG9yMi5yO1xuXHRcdFx0dGhpcy5nID0gY29sb3IxLmcgKyBjb2xvcjIuZztcblx0XHRcdHRoaXMuYiA9IGNvbG9yMS5iICsgY29sb3IyLmI7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGFkZFNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xuXG5cdFx0XHR0aGlzLnIgKz0gcztcblx0XHRcdHRoaXMuZyArPSBzO1xuXHRcdFx0dGhpcy5iICs9IHM7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdG11bHRpcGx5OiBmdW5jdGlvbiAoIGNvbG9yICkge1xuXG5cdFx0XHR0aGlzLnIgKj0gY29sb3Iucjtcblx0XHRcdHRoaXMuZyAqPSBjb2xvci5nO1xuXHRcdFx0dGhpcy5iICo9IGNvbG9yLmI7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XG5cblx0XHRcdHRoaXMuciAqPSBzO1xuXHRcdFx0dGhpcy5nICo9IHM7XG5cdFx0XHR0aGlzLmIgKj0gcztcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0bGVycDogZnVuY3Rpb24gKCBjb2xvciwgYWxwaGEgKSB7XG5cblx0XHRcdHRoaXMuciArPSAoIGNvbG9yLnIgLSB0aGlzLnIgKSAqIGFscGhhO1xuXHRcdFx0dGhpcy5nICs9ICggY29sb3IuZyAtIHRoaXMuZyApICogYWxwaGE7XG5cdFx0XHR0aGlzLmIgKz0gKCBjb2xvci5iIC0gdGhpcy5iICkgKiBhbHBoYTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0ZXF1YWxzOiBmdW5jdGlvbiAoIGMgKSB7XG5cblx0XHRcdHJldHVybiAoIGMuciA9PT0gdGhpcy5yICkgJiYgKCBjLmcgPT09IHRoaXMuZyApICYmICggYy5iID09PSB0aGlzLmIgKTtcblxuXHRcdH0sXG5cblx0XHRmcm9tQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcblxuXHRcdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cblx0XHRcdHRoaXMuciA9IGFycmF5WyBvZmZzZXQgXTtcblx0XHRcdHRoaXMuZyA9IGFycmF5WyBvZmZzZXQgKyAxIF07XG5cdFx0XHR0aGlzLmIgPSBhcnJheVsgb2Zmc2V0ICsgMiBdO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHR0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XG5cblx0XHRcdGlmICggYXJyYXkgPT09IHVuZGVmaW5lZCApIGFycmF5ID0gW107XG5cdFx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuXHRcdFx0YXJyYXlbIG9mZnNldCBdID0gdGhpcy5yO1xuXHRcdFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMuZztcblx0XHRcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0aGlzLmI7XG5cblx0XHRcdHJldHVybiBhcnJheTtcblxuXHRcdH1cblxuXHR9O1xuXG5cdFRIUkVFLkNvbG9yS2V5d29yZHMgPSB7ICdhbGljZWJsdWUnOiAweEYwRjhGRiwgJ2FudGlxdWV3aGl0ZSc6IDB4RkFFQkQ3LCAnYXF1YSc6IDB4MDBGRkZGLCAnYXF1YW1hcmluZSc6IDB4N0ZGRkQ0LCAnYXp1cmUnOiAweEYwRkZGRixcblx0J2JlaWdlJzogMHhGNUY1REMsICdiaXNxdWUnOiAweEZGRTRDNCwgJ2JsYWNrJzogMHgwMDAwMDAsICdibGFuY2hlZGFsbW9uZCc6IDB4RkZFQkNELCAnYmx1ZSc6IDB4MDAwMEZGLCAnYmx1ZXZpb2xldCc6IDB4OEEyQkUyLFxuXHQnYnJvd24nOiAweEE1MkEyQSwgJ2J1cmx5d29vZCc6IDB4REVCODg3LCAnY2FkZXRibHVlJzogMHg1RjlFQTAsICdjaGFydHJldXNlJzogMHg3RkZGMDAsICdjaG9jb2xhdGUnOiAweEQyNjkxRSwgJ2NvcmFsJzogMHhGRjdGNTAsXG5cdCdjb3JuZmxvd2VyYmx1ZSc6IDB4NjQ5NUVELCAnY29ybnNpbGsnOiAweEZGRjhEQywgJ2NyaW1zb24nOiAweERDMTQzQywgJ2N5YW4nOiAweDAwRkZGRiwgJ2RhcmtibHVlJzogMHgwMDAwOEIsICdkYXJrY3lhbic6IDB4MDA4QjhCLFxuXHQnZGFya2dvbGRlbnJvZCc6IDB4Qjg4NjBCLCAnZGFya2dyYXknOiAweEE5QTlBOSwgJ2RhcmtncmVlbic6IDB4MDA2NDAwLCAnZGFya2dyZXknOiAweEE5QTlBOSwgJ2RhcmtraGFraSc6IDB4QkRCNzZCLCAnZGFya21hZ2VudGEnOiAweDhCMDA4Qixcblx0J2RhcmtvbGl2ZWdyZWVuJzogMHg1NTZCMkYsICdkYXJrb3JhbmdlJzogMHhGRjhDMDAsICdkYXJrb3JjaGlkJzogMHg5OTMyQ0MsICdkYXJrcmVkJzogMHg4QjAwMDAsICdkYXJrc2FsbW9uJzogMHhFOTk2N0EsICdkYXJrc2VhZ3JlZW4nOiAweDhGQkM4Rixcblx0J2RhcmtzbGF0ZWJsdWUnOiAweDQ4M0Q4QiwgJ2RhcmtzbGF0ZWdyYXknOiAweDJGNEY0RiwgJ2RhcmtzbGF0ZWdyZXknOiAweDJGNEY0RiwgJ2Rhcmt0dXJxdW9pc2UnOiAweDAwQ0VEMSwgJ2Rhcmt2aW9sZXQnOiAweDk0MDBEMyxcblx0J2RlZXBwaW5rJzogMHhGRjE0OTMsICdkZWVwc2t5Ymx1ZSc6IDB4MDBCRkZGLCAnZGltZ3JheSc6IDB4Njk2OTY5LCAnZGltZ3JleSc6IDB4Njk2OTY5LCAnZG9kZ2VyYmx1ZSc6IDB4MUU5MEZGLCAnZmlyZWJyaWNrJzogMHhCMjIyMjIsXG5cdCdmbG9yYWx3aGl0ZSc6IDB4RkZGQUYwLCAnZm9yZXN0Z3JlZW4nOiAweDIyOEIyMiwgJ2Z1Y2hzaWEnOiAweEZGMDBGRiwgJ2dhaW5zYm9ybyc6IDB4RENEQ0RDLCAnZ2hvc3R3aGl0ZSc6IDB4RjhGOEZGLCAnZ29sZCc6IDB4RkZENzAwLFxuXHQnZ29sZGVucm9kJzogMHhEQUE1MjAsICdncmF5JzogMHg4MDgwODAsICdncmVlbic6IDB4MDA4MDAwLCAnZ3JlZW55ZWxsb3cnOiAweEFERkYyRiwgJ2dyZXknOiAweDgwODA4MCwgJ2hvbmV5ZGV3JzogMHhGMEZGRjAsICdob3RwaW5rJzogMHhGRjY5QjQsXG5cdCdpbmRpYW5yZWQnOiAweENENUM1QywgJ2luZGlnbyc6IDB4NEIwMDgyLCAnaXZvcnknOiAweEZGRkZGMCwgJ2toYWtpJzogMHhGMEU2OEMsICdsYXZlbmRlcic6IDB4RTZFNkZBLCAnbGF2ZW5kZXJibHVzaCc6IDB4RkZGMEY1LCAnbGF3bmdyZWVuJzogMHg3Q0ZDMDAsXG5cdCdsZW1vbmNoaWZmb24nOiAweEZGRkFDRCwgJ2xpZ2h0Ymx1ZSc6IDB4QUREOEU2LCAnbGlnaHRjb3JhbCc6IDB4RjA4MDgwLCAnbGlnaHRjeWFuJzogMHhFMEZGRkYsICdsaWdodGdvbGRlbnJvZHllbGxvdyc6IDB4RkFGQUQyLCAnbGlnaHRncmF5JzogMHhEM0QzRDMsXG5cdCdsaWdodGdyZWVuJzogMHg5MEVFOTAsICdsaWdodGdyZXknOiAweEQzRDNEMywgJ2xpZ2h0cGluayc6IDB4RkZCNkMxLCAnbGlnaHRzYWxtb24nOiAweEZGQTA3QSwgJ2xpZ2h0c2VhZ3JlZW4nOiAweDIwQjJBQSwgJ2xpZ2h0c2t5Ymx1ZSc6IDB4ODdDRUZBLFxuXHQnbGlnaHRzbGF0ZWdyYXknOiAweDc3ODg5OSwgJ2xpZ2h0c2xhdGVncmV5JzogMHg3Nzg4OTksICdsaWdodHN0ZWVsYmx1ZSc6IDB4QjBDNERFLCAnbGlnaHR5ZWxsb3cnOiAweEZGRkZFMCwgJ2xpbWUnOiAweDAwRkYwMCwgJ2xpbWVncmVlbic6IDB4MzJDRDMyLFxuXHQnbGluZW4nOiAweEZBRjBFNiwgJ21hZ2VudGEnOiAweEZGMDBGRiwgJ21hcm9vbic6IDB4ODAwMDAwLCAnbWVkaXVtYXF1YW1hcmluZSc6IDB4NjZDREFBLCAnbWVkaXVtYmx1ZSc6IDB4MDAwMENELCAnbWVkaXVtb3JjaGlkJzogMHhCQTU1RDMsXG5cdCdtZWRpdW1wdXJwbGUnOiAweDkzNzBEQiwgJ21lZGl1bXNlYWdyZWVuJzogMHgzQ0IzNzEsICdtZWRpdW1zbGF0ZWJsdWUnOiAweDdCNjhFRSwgJ21lZGl1bXNwcmluZ2dyZWVuJzogMHgwMEZBOUEsICdtZWRpdW10dXJxdW9pc2UnOiAweDQ4RDFDQyxcblx0J21lZGl1bXZpb2xldHJlZCc6IDB4QzcxNTg1LCAnbWlkbmlnaHRibHVlJzogMHgxOTE5NzAsICdtaW50Y3JlYW0nOiAweEY1RkZGQSwgJ21pc3R5cm9zZSc6IDB4RkZFNEUxLCAnbW9jY2FzaW4nOiAweEZGRTRCNSwgJ25hdmFqb3doaXRlJzogMHhGRkRFQUQsXG5cdCduYXZ5JzogMHgwMDAwODAsICdvbGRsYWNlJzogMHhGREY1RTYsICdvbGl2ZSc6IDB4ODA4MDAwLCAnb2xpdmVkcmFiJzogMHg2QjhFMjMsICdvcmFuZ2UnOiAweEZGQTUwMCwgJ29yYW5nZXJlZCc6IDB4RkY0NTAwLCAnb3JjaGlkJzogMHhEQTcwRDYsXG5cdCdwYWxlZ29sZGVucm9kJzogMHhFRUU4QUEsICdwYWxlZ3JlZW4nOiAweDk4RkI5OCwgJ3BhbGV0dXJxdW9pc2UnOiAweEFGRUVFRSwgJ3BhbGV2aW9sZXRyZWQnOiAweERCNzA5MywgJ3BhcGF5YXdoaXAnOiAweEZGRUZENSwgJ3BlYWNocHVmZic6IDB4RkZEQUI5LFxuXHQncGVydSc6IDB4Q0Q4NTNGLCAncGluayc6IDB4RkZDMENCLCAncGx1bSc6IDB4RERBMERELCAncG93ZGVyYmx1ZSc6IDB4QjBFMEU2LCAncHVycGxlJzogMHg4MDAwODAsICdyZWQnOiAweEZGMDAwMCwgJ3Jvc3licm93bic6IDB4QkM4RjhGLFxuXHQncm95YWxibHVlJzogMHg0MTY5RTEsICdzYWRkbGVicm93bic6IDB4OEI0NTEzLCAnc2FsbW9uJzogMHhGQTgwNzIsICdzYW5keWJyb3duJzogMHhGNEE0NjAsICdzZWFncmVlbic6IDB4MkU4QjU3LCAnc2Vhc2hlbGwnOiAweEZGRjVFRSxcblx0J3NpZW5uYSc6IDB4QTA1MjJELCAnc2lsdmVyJzogMHhDMEMwQzAsICdza3libHVlJzogMHg4N0NFRUIsICdzbGF0ZWJsdWUnOiAweDZBNUFDRCwgJ3NsYXRlZ3JheSc6IDB4NzA4MDkwLCAnc2xhdGVncmV5JzogMHg3MDgwOTAsICdzbm93JzogMHhGRkZBRkEsXG5cdCdzcHJpbmdncmVlbic6IDB4MDBGRjdGLCAnc3RlZWxibHVlJzogMHg0NjgyQjQsICd0YW4nOiAweEQyQjQ4QywgJ3RlYWwnOiAweDAwODA4MCwgJ3RoaXN0bGUnOiAweEQ4QkZEOCwgJ3RvbWF0byc6IDB4RkY2MzQ3LCAndHVycXVvaXNlJzogMHg0MEUwRDAsXG5cdCd2aW9sZXQnOiAweEVFODJFRSwgJ3doZWF0JzogMHhGNURFQjMsICd3aGl0ZSc6IDB4RkZGRkZGLCAnd2hpdGVzbW9rZSc6IDB4RjVGNUY1LCAneWVsbG93JzogMHhGRkZGMDAsICd5ZWxsb3dncmVlbic6IDB4OUFDRDMyIH07XG5cblx0Ly8gRmlsZTpzcmMvbWF0aC9RdWF0ZXJuaW9uLmpzXG5cblx0LyoqXG5cdCAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG5cdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG5cdCAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuXHQgKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXG5cdCAqL1xuXG5cdFRIUkVFLlF1YXRlcm5pb24gPSBmdW5jdGlvbiAoIHgsIHksIHosIHcgKSB7XG5cblx0XHR0aGlzLl94ID0geCB8fCAwO1xuXHRcdHRoaXMuX3kgPSB5IHx8IDA7XG5cdFx0dGhpcy5feiA9IHogfHwgMDtcblx0XHR0aGlzLl93ID0gKCB3ICE9PSB1bmRlZmluZWQgKSA/IHcgOiAxO1xuXG5cdH07XG5cblx0VEhSRUUuUXVhdGVybmlvbi5wcm90b3R5cGUgPSB7XG5cblx0XHRjb25zdHJ1Y3RvcjogVEhSRUUuUXVhdGVybmlvbixcblxuXHRcdGdldCB4ICgpIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuX3g7XG5cblx0XHR9LFxuXG5cdFx0c2V0IHggKCB2YWx1ZSApIHtcblxuXHRcdFx0dGhpcy5feCA9IHZhbHVlO1xuXHRcdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHR9LFxuXG5cdFx0Z2V0IHkgKCkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5feTtcblxuXHRcdH0sXG5cblx0XHRzZXQgeSAoIHZhbHVlICkge1xuXG5cdFx0XHR0aGlzLl95ID0gdmFsdWU7XG5cdFx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdH0sXG5cblx0XHRnZXQgeiAoKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLl96O1xuXG5cdFx0fSxcblxuXHRcdHNldCB6ICggdmFsdWUgKSB7XG5cblx0XHRcdHRoaXMuX3ogPSB2YWx1ZTtcblx0XHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0fSxcblxuXHRcdGdldCB3ICgpIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuX3c7XG5cblx0XHR9LFxuXG5cdFx0c2V0IHcgKCB2YWx1ZSApIHtcblxuXHRcdFx0dGhpcy5fdyA9IHZhbHVlO1xuXHRcdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHR9LFxuXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHgsIHksIHosIHcgKSB7XG5cblx0XHRcdHRoaXMuX3ggPSB4O1xuXHRcdFx0dGhpcy5feSA9IHk7XG5cdFx0XHR0aGlzLl96ID0gejtcblx0XHRcdHRoaXMuX3cgPSB3O1xuXG5cdFx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLl94LCB0aGlzLl95LCB0aGlzLl96LCB0aGlzLl93ICk7XG5cblx0XHR9LFxuXG5cdFx0Y29weTogZnVuY3Rpb24gKCBxdWF0ZXJuaW9uICkge1xuXG5cdFx0XHR0aGlzLl94ID0gcXVhdGVybmlvbi54O1xuXHRcdFx0dGhpcy5feSA9IHF1YXRlcm5pb24ueTtcblx0XHRcdHRoaXMuX3ogPSBxdWF0ZXJuaW9uLno7XG5cdFx0XHR0aGlzLl93ID0gcXVhdGVybmlvbi53O1xuXG5cdFx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0c2V0RnJvbUV1bGVyOiBmdW5jdGlvbiAoIGV1bGVyLCB1cGRhdGUgKSB7XG5cblx0XHRcdGlmICggZXVsZXIgaW5zdGFuY2VvZiBUSFJFRS5FdWxlciA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuUXVhdGVybmlvbjogLnNldEZyb21FdWxlcigpIG5vdyBleHBlY3RzIGEgRXVsZXIgcm90YXRpb24gcmF0aGVyIHRoYW4gYSBWZWN0b3IzIGFuZCBvcmRlci4nICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gaHR0cDovL3d3dy5tYXRod29ya3MuY29tL21hdGxhYmNlbnRyYWwvZmlsZWV4Y2hhbmdlL1xuXHRcdFx0Ly8gXHQyMDY5Ni1mdW5jdGlvbi10by1jb252ZXJ0LWJldHdlZW4tZGNtLWV1bGVyLWFuZ2xlcy1xdWF0ZXJuaW9ucy1hbmQtZXVsZXItdmVjdG9ycy9cblx0XHRcdC8vXHRjb250ZW50L1NwaW5DYWxjLm1cblxuXHRcdFx0dmFyIGMxID0gTWF0aC5jb3MoIGV1bGVyLl94IC8gMiApO1xuXHRcdFx0dmFyIGMyID0gTWF0aC5jb3MoIGV1bGVyLl95IC8gMiApO1xuXHRcdFx0dmFyIGMzID0gTWF0aC5jb3MoIGV1bGVyLl96IC8gMiApO1xuXHRcdFx0dmFyIHMxID0gTWF0aC5zaW4oIGV1bGVyLl94IC8gMiApO1xuXHRcdFx0dmFyIHMyID0gTWF0aC5zaW4oIGV1bGVyLl95IC8gMiApO1xuXHRcdFx0dmFyIHMzID0gTWF0aC5zaW4oIGV1bGVyLl96IC8gMiApO1xuXG5cdFx0XHR2YXIgb3JkZXIgPSBldWxlci5vcmRlcjtcblxuXHRcdFx0aWYgKCBvcmRlciA9PT0gJ1hZWicgKSB7XG5cblx0XHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcblx0XHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcblx0XHRcdFx0dGhpcy5feiA9IGMxICogYzIgKiBzMyArIHMxICogczIgKiBjMztcblx0XHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMztcblxuXHRcdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdZWFonICkge1xuXG5cdFx0XHRcdHRoaXMuX3ggPSBzMSAqIGMyICogYzMgKyBjMSAqIHMyICogczM7XG5cdFx0XHRcdHRoaXMuX3kgPSBjMSAqIHMyICogYzMgLSBzMSAqIGMyICogczM7XG5cdFx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XG5cdFx0XHRcdHRoaXMuX3cgPSBjMSAqIGMyICogYzMgKyBzMSAqIHMyICogczM7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWlhZJyApIHtcblxuXHRcdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzIC0gYzEgKiBzMiAqIHMzO1xuXHRcdFx0XHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzICsgczEgKiBjMiAqIHMzO1xuXHRcdFx0XHR0aGlzLl96ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xuXHRcdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1pZWCcgKSB7XG5cblx0XHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyAtIGMxICogczIgKiBzMztcblx0XHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMztcblx0XHRcdFx0dGhpcy5feiA9IGMxICogYzIgKiBzMyAtIHMxICogczIgKiBjMztcblx0XHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcblxuXHRcdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdZWlgnICkge1xuXG5cdFx0XHRcdHRoaXMuX3ggPSBzMSAqIGMyICogYzMgKyBjMSAqIHMyICogczM7XG5cdFx0XHRcdHRoaXMuX3kgPSBjMSAqIHMyICogYzMgKyBzMSAqIGMyICogczM7XG5cdFx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XG5cdFx0XHRcdHRoaXMuX3cgPSBjMSAqIGMyICogYzMgLSBzMSAqIHMyICogczM7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWFpZJyApIHtcblxuXHRcdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzIC0gYzEgKiBzMiAqIHMzO1xuXHRcdFx0XHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzIC0gczEgKiBjMiAqIHMzO1xuXHRcdFx0XHR0aGlzLl96ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xuXHRcdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggdXBkYXRlICE9PSBmYWxzZSApIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRzZXRGcm9tQXhpc0FuZ2xlOiBmdW5jdGlvbiAoIGF4aXMsIGFuZ2xlICkge1xuXG5cdFx0XHQvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvYW5nbGVUb1F1YXRlcm5pb24vaW5kZXguaHRtXG5cblx0XHRcdC8vIGFzc3VtZXMgYXhpcyBpcyBub3JtYWxpemVkXG5cblx0XHRcdHZhciBoYWxmQW5nbGUgPSBhbmdsZSAvIDIsIHMgPSBNYXRoLnNpbiggaGFsZkFuZ2xlICk7XG5cblx0XHRcdHRoaXMuX3ggPSBheGlzLnggKiBzO1xuXHRcdFx0dGhpcy5feSA9IGF4aXMueSAqIHM7XG5cdFx0XHR0aGlzLl96ID0gYXhpcy56ICogcztcblx0XHRcdHRoaXMuX3cgPSBNYXRoLmNvcyggaGFsZkFuZ2xlICk7XG5cblx0XHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRzZXRGcm9tUm90YXRpb25NYXRyaXg6IGZ1bmN0aW9uICggbSApIHtcblxuXHRcdFx0Ly8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvZ2VvbWV0cnkvcm90YXRpb25zL2NvbnZlcnNpb25zL21hdHJpeFRvUXVhdGVybmlvbi9pbmRleC5odG1cblxuXHRcdFx0Ly8gYXNzdW1lcyB0aGUgdXBwZXIgM3gzIG9mIG0gaXMgYSBwdXJlIHJvdGF0aW9uIG1hdHJpeCAoaS5lLCB1bnNjYWxlZClcblxuXHRcdFx0dmFyIHRlID0gbS5lbGVtZW50cyxcblxuXHRcdFx0XHRtMTEgPSB0ZVsgMCBdLCBtMTIgPSB0ZVsgNCBdLCBtMTMgPSB0ZVsgOCBdLFxuXHRcdFx0XHRtMjEgPSB0ZVsgMSBdLCBtMjIgPSB0ZVsgNSBdLCBtMjMgPSB0ZVsgOSBdLFxuXHRcdFx0XHRtMzEgPSB0ZVsgMiBdLCBtMzIgPSB0ZVsgNiBdLCBtMzMgPSB0ZVsgMTAgXSxcblxuXHRcdFx0XHR0cmFjZSA9IG0xMSArIG0yMiArIG0zMyxcblx0XHRcdFx0cztcblxuXHRcdFx0aWYgKCB0cmFjZSA+IDAgKSB7XG5cblx0XHRcdFx0cyA9IDAuNSAvIE1hdGguc3FydCggdHJhY2UgKyAxLjAgKTtcblxuXHRcdFx0XHR0aGlzLl93ID0gMC4yNSAvIHM7XG5cdFx0XHRcdHRoaXMuX3ggPSAoIG0zMiAtIG0yMyApICogcztcblx0XHRcdFx0dGhpcy5feSA9ICggbTEzIC0gbTMxICkgKiBzO1xuXHRcdFx0XHR0aGlzLl96ID0gKCBtMjEgLSBtMTIgKSAqIHM7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG0xMSA+IG0yMiAmJiBtMTEgPiBtMzMgKSB7XG5cblx0XHRcdFx0cyA9IDIuMCAqIE1hdGguc3FydCggMS4wICsgbTExIC0gbTIyIC0gbTMzICk7XG5cblx0XHRcdFx0dGhpcy5fdyA9ICggbTMyIC0gbTIzICkgLyBzO1xuXHRcdFx0XHR0aGlzLl94ID0gMC4yNSAqIHM7XG5cdFx0XHRcdHRoaXMuX3kgPSAoIG0xMiArIG0yMSApIC8gcztcblx0XHRcdFx0dGhpcy5feiA9ICggbTEzICsgbTMxICkgLyBzO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBtMjIgPiBtMzMgKSB7XG5cblx0XHRcdFx0cyA9IDIuMCAqIE1hdGguc3FydCggMS4wICsgbTIyIC0gbTExIC0gbTMzICk7XG5cblx0XHRcdFx0dGhpcy5fdyA9ICggbTEzIC0gbTMxICkgLyBzO1xuXHRcdFx0XHR0aGlzLl94ID0gKCBtMTIgKyBtMjEgKSAvIHM7XG5cdFx0XHRcdHRoaXMuX3kgPSAwLjI1ICogcztcblx0XHRcdFx0dGhpcy5feiA9ICggbTIzICsgbTMyICkgLyBzO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHMgPSAyLjAgKiBNYXRoLnNxcnQoIDEuMCArIG0zMyAtIG0xMSAtIG0yMiApO1xuXG5cdFx0XHRcdHRoaXMuX3cgPSAoIG0yMSAtIG0xMiApIC8gcztcblx0XHRcdFx0dGhpcy5feCA9ICggbTEzICsgbTMxICkgLyBzO1xuXHRcdFx0XHR0aGlzLl95ID0gKCBtMjMgKyBtMzIgKSAvIHM7XG5cdFx0XHRcdHRoaXMuX3ogPSAwLjI1ICogcztcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0c2V0RnJvbVVuaXRWZWN0b3JzOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdC8vIGh0dHA6Ly9sb2xlbmdpbmUubmV0L2Jsb2cvMjAxNC8wMi8yNC9xdWF0ZXJuaW9uLWZyb20tdHdvLXZlY3RvcnMtZmluYWxcblxuXHRcdFx0Ly8gYXNzdW1lcyBkaXJlY3Rpb24gdmVjdG9ycyB2RnJvbSBhbmQgdlRvIGFyZSBub3JtYWxpemVkXG5cblx0XHRcdHZhciB2MSwgcjtcblxuXHRcdFx0dmFyIEVQUyA9IDAuMDAwMDAxO1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKCB2RnJvbSwgdlRvICkge1xuXG5cdFx0XHRcdGlmICggdjEgPT09IHVuZGVmaW5lZCApIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdFx0XHRyID0gdkZyb20uZG90KCB2VG8gKSArIDE7XG5cblx0XHRcdFx0aWYgKCByIDwgRVBTICkge1xuXG5cdFx0XHRcdFx0ciA9IDA7XG5cblx0XHRcdFx0XHRpZiAoIE1hdGguYWJzKCB2RnJvbS54ICkgPiBNYXRoLmFicyggdkZyb20ueiApICkge1xuXG5cdFx0XHRcdFx0XHR2MS5zZXQoIC0gdkZyb20ueSwgdkZyb20ueCwgMCApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0djEuc2V0KCAwLCAtIHZGcm9tLnosIHZGcm9tLnkgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0djEuY3Jvc3NWZWN0b3JzKCB2RnJvbSwgdlRvICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuX3ggPSB2MS54O1xuXHRcdFx0XHR0aGlzLl95ID0gdjEueTtcblx0XHRcdFx0dGhpcy5feiA9IHYxLno7XG5cdFx0XHRcdHRoaXMuX3cgPSByO1xuXG5cdFx0XHRcdHRoaXMubm9ybWFsaXplKCk7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdH1cblxuXHRcdH0oKSxcblxuXHRcdGludmVyc2U6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dGhpcy5jb25qdWdhdGUoKS5ub3JtYWxpemUoKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0Y29uanVnYXRlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHRoaXMuX3ggKj0gLSAxO1xuXHRcdFx0dGhpcy5feSAqPSAtIDE7XG5cdFx0XHR0aGlzLl96ICo9IC0gMTtcblxuXHRcdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGRvdDogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5feCAqIHYuX3ggKyB0aGlzLl95ICogdi5feSArIHRoaXMuX3ogKiB2Ll96ICsgdGhpcy5fdyAqIHYuX3c7XG5cblx0XHR9LFxuXG5cdFx0bGVuZ3RoU3E6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuX3ggKiB0aGlzLl94ICsgdGhpcy5feSAqIHRoaXMuX3kgKyB0aGlzLl96ICogdGhpcy5feiArIHRoaXMuX3cgKiB0aGlzLl93O1xuXG5cdFx0fSxcblxuXHRcdGxlbmd0aDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLl94ICogdGhpcy5feCArIHRoaXMuX3kgKiB0aGlzLl95ICsgdGhpcy5feiAqIHRoaXMuX3ogKyB0aGlzLl93ICogdGhpcy5fdyApO1xuXG5cdFx0fSxcblxuXHRcdG5vcm1hbGl6ZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgbCA9IHRoaXMubGVuZ3RoKCk7XG5cblx0XHRcdGlmICggbCA9PT0gMCApIHtcblxuXHRcdFx0XHR0aGlzLl94ID0gMDtcblx0XHRcdFx0dGhpcy5feSA9IDA7XG5cdFx0XHRcdHRoaXMuX3ogPSAwO1xuXHRcdFx0XHR0aGlzLl93ID0gMTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRsID0gMSAvIGw7XG5cblx0XHRcdFx0dGhpcy5feCA9IHRoaXMuX3ggKiBsO1xuXHRcdFx0XHR0aGlzLl95ID0gdGhpcy5feSAqIGw7XG5cdFx0XHRcdHRoaXMuX3ogPSB0aGlzLl96ICogbDtcblx0XHRcdFx0dGhpcy5fdyA9IHRoaXMuX3cgKiBsO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRtdWx0aXBseTogZnVuY3Rpb24gKCBxLCBwICkge1xuXG5cdFx0XHRpZiAoIHAgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5RdWF0ZXJuaW9uOiAubXVsdGlwbHkoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5tdWx0aXBseVF1YXRlcm5pb25zKCBhLCBiICkgaW5zdGVhZC4nICk7XG5cdFx0XHRcdHJldHVybiB0aGlzLm11bHRpcGx5UXVhdGVybmlvbnMoIHEsIHAgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVF1YXRlcm5pb25zKCB0aGlzLCBxICk7XG5cblx0XHR9LFxuXG5cdFx0bXVsdGlwbHlRdWF0ZXJuaW9uczogZnVuY3Rpb24gKCBhLCBiICkge1xuXG5cdFx0XHQvLyBmcm9tIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvcmVhbE5vcm1lZEFsZ2VicmEvcXVhdGVybmlvbnMvY29kZS9pbmRleC5odG1cblxuXHRcdFx0dmFyIHFheCA9IGEuX3gsIHFheSA9IGEuX3ksIHFheiA9IGEuX3osIHFhdyA9IGEuX3c7XG5cdFx0XHR2YXIgcWJ4ID0gYi5feCwgcWJ5ID0gYi5feSwgcWJ6ID0gYi5feiwgcWJ3ID0gYi5fdztcblxuXHRcdFx0dGhpcy5feCA9IHFheCAqIHFidyArIHFhdyAqIHFieCArIHFheSAqIHFieiAtIHFheiAqIHFieTtcblx0XHRcdHRoaXMuX3kgPSBxYXkgKiBxYncgKyBxYXcgKiBxYnkgKyBxYXogKiBxYnggLSBxYXggKiBxYno7XG5cdFx0XHR0aGlzLl96ID0gcWF6ICogcWJ3ICsgcWF3ICogcWJ6ICsgcWF4ICogcWJ5IC0gcWF5ICogcWJ4O1xuXHRcdFx0dGhpcy5fdyA9IHFhdyAqIHFidyAtIHFheCAqIHFieCAtIHFheSAqIHFieSAtIHFheiAqIHFiejtcblxuXHRcdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdG11bHRpcGx5VmVjdG9yMzogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlF1YXRlcm5pb246IC5tdWx0aXBseVZlY3RvcjMoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgaXMgbm93IHZlY3Rvci5hcHBseVF1YXRlcm5pb24oIHF1YXRlcm5pb24gKSBpbnN0ZWFkLicgKTtcblx0XHRcdHJldHVybiB2ZWN0b3IuYXBwbHlRdWF0ZXJuaW9uKCB0aGlzICk7XG5cblx0XHR9LFxuXG5cdFx0c2xlcnA6IGZ1bmN0aW9uICggcWIsIHQgKSB7XG5cblx0XHRcdGlmICggdCA9PT0gMCApIHJldHVybiB0aGlzO1xuXHRcdFx0aWYgKCB0ID09PSAxICkgcmV0dXJuIHRoaXMuY29weSggcWIgKTtcblxuXHRcdFx0dmFyIHggPSB0aGlzLl94LCB5ID0gdGhpcy5feSwgeiA9IHRoaXMuX3osIHcgPSB0aGlzLl93O1xuXG5cdFx0XHQvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL3JlYWxOb3JtZWRBbGdlYnJhL3F1YXRlcm5pb25zL3NsZXJwL1xuXG5cdFx0XHR2YXIgY29zSGFsZlRoZXRhID0gdyAqIHFiLl93ICsgeCAqIHFiLl94ICsgeSAqIHFiLl95ICsgeiAqIHFiLl96O1xuXG5cdFx0XHRpZiAoIGNvc0hhbGZUaGV0YSA8IDAgKSB7XG5cblx0XHRcdFx0dGhpcy5fdyA9IC0gcWIuX3c7XG5cdFx0XHRcdHRoaXMuX3ggPSAtIHFiLl94O1xuXHRcdFx0XHR0aGlzLl95ID0gLSBxYi5feTtcblx0XHRcdFx0dGhpcy5feiA9IC0gcWIuX3o7XG5cblx0XHRcdFx0Y29zSGFsZlRoZXRhID0gLSBjb3NIYWxmVGhldGE7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dGhpcy5jb3B5KCBxYiApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggY29zSGFsZlRoZXRhID49IDEuMCApIHtcblxuXHRcdFx0XHR0aGlzLl93ID0gdztcblx0XHRcdFx0dGhpcy5feCA9IHg7XG5cdFx0XHRcdHRoaXMuX3kgPSB5O1xuXHRcdFx0XHR0aGlzLl96ID0gejtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgaGFsZlRoZXRhID0gTWF0aC5hY29zKCBjb3NIYWxmVGhldGEgKTtcblx0XHRcdHZhciBzaW5IYWxmVGhldGEgPSBNYXRoLnNxcnQoIDEuMCAtIGNvc0hhbGZUaGV0YSAqIGNvc0hhbGZUaGV0YSApO1xuXG5cdFx0XHRpZiAoIE1hdGguYWJzKCBzaW5IYWxmVGhldGEgKSA8IDAuMDAxICkge1xuXG5cdFx0XHRcdHRoaXMuX3cgPSAwLjUgKiAoIHcgKyB0aGlzLl93ICk7XG5cdFx0XHRcdHRoaXMuX3ggPSAwLjUgKiAoIHggKyB0aGlzLl94ICk7XG5cdFx0XHRcdHRoaXMuX3kgPSAwLjUgKiAoIHkgKyB0aGlzLl95ICk7XG5cdFx0XHRcdHRoaXMuX3ogPSAwLjUgKiAoIHogKyB0aGlzLl96ICk7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIHJhdGlvQSA9IE1hdGguc2luKCAoIDEgLSB0ICkgKiBoYWxmVGhldGEgKSAvIHNpbkhhbGZUaGV0YSxcblx0XHRcdHJhdGlvQiA9IE1hdGguc2luKCB0ICogaGFsZlRoZXRhICkgLyBzaW5IYWxmVGhldGE7XG5cblx0XHRcdHRoaXMuX3cgPSAoIHcgKiByYXRpb0EgKyB0aGlzLl93ICogcmF0aW9CICk7XG5cdFx0XHR0aGlzLl94ID0gKCB4ICogcmF0aW9BICsgdGhpcy5feCAqIHJhdGlvQiApO1xuXHRcdFx0dGhpcy5feSA9ICggeSAqIHJhdGlvQSArIHRoaXMuX3kgKiByYXRpb0IgKTtcblx0XHRcdHRoaXMuX3ogPSAoIHogKiByYXRpb0EgKyB0aGlzLl96ICogcmF0aW9CICk7XG5cblx0XHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRlcXVhbHM6IGZ1bmN0aW9uICggcXVhdGVybmlvbiApIHtcblxuXHRcdFx0cmV0dXJuICggcXVhdGVybmlvbi5feCA9PT0gdGhpcy5feCApICYmICggcXVhdGVybmlvbi5feSA9PT0gdGhpcy5feSApICYmICggcXVhdGVybmlvbi5feiA9PT0gdGhpcy5feiApICYmICggcXVhdGVybmlvbi5fdyA9PT0gdGhpcy5fdyApO1xuXG5cdFx0fSxcblxuXHRcdGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xuXG5cdFx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuXHRcdFx0dGhpcy5feCA9IGFycmF5WyBvZmZzZXQgXTtcblx0XHRcdHRoaXMuX3kgPSBhcnJheVsgb2Zmc2V0ICsgMSBdO1xuXHRcdFx0dGhpcy5feiA9IGFycmF5WyBvZmZzZXQgKyAyIF07XG5cdFx0XHR0aGlzLl93ID0gYXJyYXlbIG9mZnNldCArIDMgXTtcblxuXHRcdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHRvQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcblxuXHRcdFx0aWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcblx0XHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG5cdFx0XHRhcnJheVsgb2Zmc2V0IF0gPSB0aGlzLl94O1xuXHRcdFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMuX3k7XG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGhpcy5fejtcblx0XHRcdGFycmF5WyBvZmZzZXQgKyAzIF0gPSB0aGlzLl93O1xuXG5cdFx0XHRyZXR1cm4gYXJyYXk7XG5cblx0XHR9LFxuXG5cdFx0b25DaGFuZ2U6IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XG5cblx0XHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjayA9IGNhbGxiYWNrO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRvbkNoYW5nZUNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7fVxuXG5cdH07XG5cblx0VEhSRUUuUXVhdGVybmlvbi5zbGVycCA9IGZ1bmN0aW9uICggcWEsIHFiLCBxbSwgdCApIHtcblxuXHRcdHJldHVybiBxbS5jb3B5KCBxYSApLnNsZXJwKCBxYiwgdCApO1xuXG5cdH07XG5cblx0Ly8gRmlsZTpzcmMvbWF0aC9WZWN0b3IyLmpzXG5cblx0LyoqXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqIEBhdXRob3IgcGhpbG9nYiAvIGh0dHA6Ly9ibG9nLnRoZWppdC5vcmcvXG5cdCAqIEBhdXRob3IgZWdyYWV0aGVyIC8gaHR0cDovL2VncmFldGhlci5jb20vXG5cdCAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcblx0ICovXG5cblx0VEhSRUUuVmVjdG9yMiA9IGZ1bmN0aW9uICggeCwgeSApIHtcblxuXHRcdHRoaXMueCA9IHggfHwgMDtcblx0XHR0aGlzLnkgPSB5IHx8IDA7XG5cblx0fTtcblxuXHRUSFJFRS5WZWN0b3IyLnByb3RvdHlwZSA9IHtcblxuXHRcdGNvbnN0cnVjdG9yOiBUSFJFRS5WZWN0b3IyLFxuXG5cdFx0Z2V0IHdpZHRoKCkgeyByZXR1cm4gdGhpcy54IH0sXG5cdFx0c2V0IHdpZHRoKCB2YWx1ZSApIHsgdGhpcy54ID0gdmFsdWUgfSxcblxuXHRcdGdldCBoZWlnaHQoKSB7IHJldHVybiB0aGlzLnkgfSxcblx0XHRzZXQgaGVpZ2h0KCB2YWx1ZSApIHsgdGhpcy55ID0gdmFsdWUgfSxcblxuXHRcdC8vXG5cblx0XHRzZXQ6IGZ1bmN0aW9uICggeCwgeSApIHtcblxuXHRcdFx0dGhpcy54ID0geDtcblx0XHRcdHRoaXMueSA9IHk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHNldFg6IGZ1bmN0aW9uICggeCApIHtcblxuXHRcdFx0dGhpcy54ID0geDtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0c2V0WTogZnVuY3Rpb24gKCB5ICkge1xuXG5cdFx0XHR0aGlzLnkgPSB5O1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRzZXRDb21wb25lbnQ6IGZ1bmN0aW9uICggaW5kZXgsIHZhbHVlICkge1xuXG5cdFx0XHRzd2l0Y2ggKCBpbmRleCApIHtcblxuXHRcdFx0XHRjYXNlIDA6IHRoaXMueCA9IHZhbHVlOyBicmVhaztcblx0XHRcdFx0Y2FzZSAxOiB0aGlzLnkgPSB2YWx1ZTsgYnJlYWs7XG5cdFx0XHRcdGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XG5cblx0XHRcdH1cblxuXHRcdH0sXG5cblx0XHRnZXRDb21wb25lbnQ6IGZ1bmN0aW9uICggaW5kZXggKSB7XG5cblx0XHRcdHN3aXRjaCAoIGluZGV4ICkge1xuXG5cdFx0XHRcdGNhc2UgMDogcmV0dXJuIHRoaXMueDtcblx0XHRcdFx0Y2FzZSAxOiByZXR1cm4gdGhpcy55O1xuXHRcdFx0XHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xuXG5cdFx0XHR9XG5cblx0XHR9LFxuXG5cdFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLngsIHRoaXMueSApO1xuXG5cdFx0fSxcblxuXHRcdGNvcHk6IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdFx0dGhpcy54ID0gdi54O1xuXHRcdFx0dGhpcy55ID0gdi55O1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRhZGQ6IGZ1bmN0aW9uICggdiwgdyApIHtcblxuXHRcdFx0aWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMjogLmFkZCgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLmFkZFZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXMuYWRkVmVjdG9ycyggdiwgdyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMueCArPSB2Lng7XG5cdFx0XHR0aGlzLnkgKz0gdi55O1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRhZGRTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcblxuXHRcdFx0dGhpcy54ICs9IHM7XG5cdFx0XHR0aGlzLnkgKz0gcztcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0YWRkVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xuXG5cdFx0XHR0aGlzLnggPSBhLnggKyBiLng7XG5cdFx0XHR0aGlzLnkgPSBhLnkgKyBiLnk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGFkZFNjYWxlZFZlY3RvcjogZnVuY3Rpb24gKCB2LCBzICkge1xuXG5cdFx0XHR0aGlzLnggKz0gdi54ICogcztcblx0XHRcdHRoaXMueSArPSB2LnkgKiBzO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRzdWI6IGZ1bmN0aW9uICggdiwgdyApIHtcblxuXHRcdFx0aWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMjogLnN1YigpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLnN1YlZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXMuc3ViVmVjdG9ycyggdiwgdyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMueCAtPSB2Lng7XG5cdFx0XHR0aGlzLnkgLT0gdi55O1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRzdWJTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcblxuXHRcdFx0dGhpcy54IC09IHM7XG5cdFx0XHR0aGlzLnkgLT0gcztcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0c3ViVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xuXG5cdFx0XHR0aGlzLnggPSBhLnggLSBiLng7XG5cdFx0XHR0aGlzLnkgPSBhLnkgLSBiLnk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdG11bHRpcGx5OiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHRcdHRoaXMueCAqPSB2Lng7XG5cdFx0XHR0aGlzLnkgKj0gdi55O1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XG5cblx0XHRcdGlmICggaXNGaW5pdGUoIHNjYWxhciApICkge1xuXHRcdFx0XHR0aGlzLnggKj0gc2NhbGFyO1xuXHRcdFx0XHR0aGlzLnkgKj0gc2NhbGFyO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy54ID0gMDtcblx0XHRcdFx0dGhpcy55ID0gMDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0ZGl2aWRlOiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHRcdHRoaXMueCAvPSB2Lng7XG5cdFx0XHR0aGlzLnkgLz0gdi55O1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRkaXZpZGVTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVNjYWxhciggMSAvIHNjYWxhciApO1xuXG5cdFx0fSxcblxuXHRcdG1pbjogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0XHR0aGlzLnggPSBNYXRoLm1pbiggdGhpcy54LCB2LnggKTtcblx0XHRcdHRoaXMueSA9IE1hdGgubWluKCB0aGlzLnksIHYueSApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRtYXg6IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdFx0dGhpcy54ID0gTWF0aC5tYXgoIHRoaXMueCwgdi54ICk7XG5cdFx0XHR0aGlzLnkgPSBNYXRoLm1heCggdGhpcy55LCB2LnkgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0Y2xhbXA6IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XG5cblx0XHRcdC8vIFRoaXMgZnVuY3Rpb24gYXNzdW1lcyBtaW4gPCBtYXgsIGlmIHRoaXMgYXNzdW1wdGlvbiBpc24ndCB0cnVlIGl0IHdpbGwgbm90IG9wZXJhdGUgY29ycmVjdGx5XG5cblx0XHRcdHRoaXMueCA9IE1hdGgubWF4KCBtaW4ueCwgTWF0aC5taW4oIG1heC54LCB0aGlzLnggKSApO1xuXHRcdFx0dGhpcy55ID0gTWF0aC5tYXgoIG1pbi55LCBNYXRoLm1pbiggbWF4LnksIHRoaXMueSApICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGNsYW1wU2NhbGFyOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciBtaW4sIG1heDtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIGNsYW1wU2NhbGFyKCBtaW5WYWwsIG1heFZhbCApIHtcblxuXHRcdFx0XHRpZiAoIG1pbiA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0bWluID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblx0XHRcdFx0XHRtYXggPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRtaW4uc2V0KCBtaW5WYWwsIG1pblZhbCApO1xuXHRcdFx0XHRtYXguc2V0KCBtYXhWYWwsIG1heFZhbCApO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzLmNsYW1wKCBtaW4sIG1heCApO1xuXG5cdFx0XHR9O1xuXG5cdFx0fSgpLFxuXG5cdFx0Y2xhbXBMZW5ndGg6IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XG5cblx0XHRcdHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCgpO1xuXG5cdFx0XHR0aGlzLm11bHRpcGx5U2NhbGFyKCBNYXRoLm1heCggbWluLCBNYXRoLm1pbiggbWF4LCBsZW5ndGggKSApIC8gbGVuZ3RoICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGZsb29yOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHRoaXMueCA9IE1hdGguZmxvb3IoIHRoaXMueCApO1xuXHRcdFx0dGhpcy55ID0gTWF0aC5mbG9vciggdGhpcy55ICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGNlaWw6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dGhpcy54ID0gTWF0aC5jZWlsKCB0aGlzLnggKTtcblx0XHRcdHRoaXMueSA9IE1hdGguY2VpbCggdGhpcy55ICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHJvdW5kOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHRoaXMueCA9IE1hdGgucm91bmQoIHRoaXMueCApO1xuXHRcdFx0dGhpcy55ID0gTWF0aC5yb3VuZCggdGhpcy55ICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHJvdW5kVG9aZXJvOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHRoaXMueCA9ICggdGhpcy54IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnggKSA6IE1hdGguZmxvb3IoIHRoaXMueCApO1xuXHRcdFx0dGhpcy55ID0gKCB0aGlzLnkgPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueSApIDogTWF0aC5mbG9vciggdGhpcy55ICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdG5lZ2F0ZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR0aGlzLnggPSAtIHRoaXMueDtcblx0XHRcdHRoaXMueSA9IC0gdGhpcy55O1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRkb3Q6IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMueCAqIHYueCArIHRoaXMueSAqIHYueTtcblxuXHRcdH0sXG5cblx0XHRsZW5ndGhTcTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55O1xuXG5cdFx0fSxcblxuXHRcdGxlbmd0aDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKTtcblxuXHRcdH0sXG5cblx0XHRsZW5ndGhNYW5oYXR0YW46IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRyZXR1cm4gTWF0aC5hYnMoIHRoaXMueCApICsgTWF0aC5hYnMoIHRoaXMueSApO1xuXG5cdFx0fSxcblxuXHRcdG5vcm1hbGl6ZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIoIHRoaXMubGVuZ3RoKCkgKTtcblxuXHRcdH0sXG5cblx0XHRkaXN0YW5jZVRvOiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMuZGlzdGFuY2VUb1NxdWFyZWQoIHYgKSApO1xuXG5cdFx0fSxcblxuXHRcdGRpc3RhbmNlVG9TcXVhcmVkOiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHRcdHZhciBkeCA9IHRoaXMueCAtIHYueCwgZHkgPSB0aGlzLnkgLSB2Lnk7XG5cdFx0XHRyZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG5cblx0XHR9LFxuXG5cdFx0c2V0TGVuZ3RoOiBmdW5jdGlvbiAoIGxlbmd0aCApIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoIGxlbmd0aCAvIHRoaXMubGVuZ3RoKCkgKTtcblxuXHRcdH0sXG5cblx0XHRsZXJwOiBmdW5jdGlvbiAoIHYsIGFscGhhICkge1xuXG5cdFx0XHR0aGlzLnggKz0gKCB2LnggLSB0aGlzLnggKSAqIGFscGhhO1xuXHRcdFx0dGhpcy55ICs9ICggdi55IC0gdGhpcy55ICkgKiBhbHBoYTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0bGVycFZlY3RvcnM6IGZ1bmN0aW9uICggdjEsIHYyLCBhbHBoYSApIHtcblxuXHRcdFx0dGhpcy5zdWJWZWN0b3JzKCB2MiwgdjEgKS5tdWx0aXBseVNjYWxhciggYWxwaGEgKS5hZGQoIHYxICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGVxdWFsczogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0XHRyZXR1cm4gKCAoIHYueCA9PT0gdGhpcy54ICkgJiYgKCB2LnkgPT09IHRoaXMueSApICk7XG5cblx0XHR9LFxuXG5cdFx0ZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XG5cblx0XHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG5cdFx0XHR0aGlzLnggPSBhcnJheVsgb2Zmc2V0IF07XG5cdFx0XHR0aGlzLnkgPSBhcnJheVsgb2Zmc2V0ICsgMSBdO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHR0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XG5cblx0XHRcdGlmICggYXJyYXkgPT09IHVuZGVmaW5lZCApIGFycmF5ID0gW107XG5cdFx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuXHRcdFx0YXJyYXlbIG9mZnNldCBdID0gdGhpcy54O1xuXHRcdFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMueTtcblxuXHRcdFx0cmV0dXJuIGFycmF5O1xuXG5cdFx0fSxcblxuXHRcdGZyb21BdHRyaWJ1dGU6IGZ1bmN0aW9uICggYXR0cmlidXRlLCBpbmRleCwgb2Zmc2V0ICkge1xuXG5cdFx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuXHRcdFx0aW5kZXggPSBpbmRleCAqIGF0dHJpYnV0ZS5pdGVtU2l6ZSArIG9mZnNldDtcblxuXHRcdFx0dGhpcy54ID0gYXR0cmlidXRlLmFycmF5WyBpbmRleCBdO1xuXHRcdFx0dGhpcy55ID0gYXR0cmlidXRlLmFycmF5WyBpbmRleCArIDEgXTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0cm90YXRlQXJvdW5kOiBmdW5jdGlvbiAoIGNlbnRlciwgYW5nbGUgKSB7XG5cblx0XHRcdHZhciBjID0gTWF0aC5jb3MoIGFuZ2xlICksIHMgPSBNYXRoLnNpbiggYW5nbGUgKTtcblxuXHRcdFx0dmFyIHggPSB0aGlzLnggLSBjZW50ZXIueDtcblx0XHRcdHZhciB5ID0gdGhpcy55IC0gY2VudGVyLnk7XG5cblx0XHRcdHRoaXMueCA9IHggKiBjIC0geSAqIHMgKyBjZW50ZXIueDtcblx0XHRcdHRoaXMueSA9IHggKiBzICsgeSAqIGMgKyBjZW50ZXIueTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9XG5cblx0fTtcblxuXHQvLyBGaWxlOnNyYy9tYXRoL1ZlY3RvcjMuanNcblxuXHQvKipcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICogQGF1dGhvciAqa2lsZSAvIGh0dHA6Ly9raWxlLnN0cmF2YWdhbnphLm9yZy9cblx0ICogQGF1dGhvciBwaGlsb2diIC8gaHR0cDovL2Jsb2cudGhlaml0Lm9yZy9cblx0ICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cblx0ICogQGF1dGhvciBlZ3JhZXRoZXIgLyBodHRwOi8vZWdyYWV0aGVyLmNvbS9cblx0ICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG5cdCAqL1xuXG5cdFRIUkVFLlZlY3RvcjMgPSBmdW5jdGlvbiAoIHgsIHksIHogKSB7XG5cblx0XHR0aGlzLnggPSB4IHx8IDA7XG5cdFx0dGhpcy55ID0geSB8fCAwO1xuXHRcdHRoaXMueiA9IHogfHwgMDtcblxuXHR9O1xuXG5cdFRIUkVFLlZlY3RvcjMucHJvdG90eXBlID0ge1xuXG5cdFx0Y29uc3RydWN0b3I6IFRIUkVFLlZlY3RvcjMsXG5cblx0XHRzZXQ6IGZ1bmN0aW9uICggeCwgeSwgeiApIHtcblxuXHRcdFx0dGhpcy54ID0geDtcblx0XHRcdHRoaXMueSA9IHk7XG5cdFx0XHR0aGlzLnogPSB6O1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRzZXRYOiBmdW5jdGlvbiAoIHggKSB7XG5cblx0XHRcdHRoaXMueCA9IHg7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHNldFk6IGZ1bmN0aW9uICggeSApIHtcblxuXHRcdFx0dGhpcy55ID0geTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0c2V0WjogZnVuY3Rpb24gKCB6ICkge1xuXG5cdFx0XHR0aGlzLnogPSB6O1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRzZXRDb21wb25lbnQ6IGZ1bmN0aW9uICggaW5kZXgsIHZhbHVlICkge1xuXG5cdFx0XHRzd2l0Y2ggKCBpbmRleCApIHtcblxuXHRcdFx0XHRjYXNlIDA6IHRoaXMueCA9IHZhbHVlOyBicmVhaztcblx0XHRcdFx0Y2FzZSAxOiB0aGlzLnkgPSB2YWx1ZTsgYnJlYWs7XG5cdFx0XHRcdGNhc2UgMjogdGhpcy56ID0gdmFsdWU7IGJyZWFrO1xuXHRcdFx0XHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xuXG5cdFx0XHR9XG5cblx0XHR9LFxuXG5cdFx0Z2V0Q29tcG9uZW50OiBmdW5jdGlvbiAoIGluZGV4ICkge1xuXG5cdFx0XHRzd2l0Y2ggKCBpbmRleCApIHtcblxuXHRcdFx0XHRjYXNlIDA6IHJldHVybiB0aGlzLng7XG5cdFx0XHRcdGNhc2UgMTogcmV0dXJuIHRoaXMueTtcblx0XHRcdFx0Y2FzZSAyOiByZXR1cm4gdGhpcy56O1xuXHRcdFx0XHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xuXG5cdFx0XHR9XG5cblx0XHR9LFxuXG5cdFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLngsIHRoaXMueSwgdGhpcy56ICk7XG5cblx0XHR9LFxuXG5cdFx0Y29weTogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0XHR0aGlzLnggPSB2Lng7XG5cdFx0XHR0aGlzLnkgPSB2Lnk7XG5cdFx0XHR0aGlzLnogPSB2Lno7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGFkZDogZnVuY3Rpb24gKCB2LCB3ICkge1xuXG5cdFx0XHRpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAuYWRkKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuYWRkVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5hZGRWZWN0b3JzKCB2LCB3ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy54ICs9IHYueDtcblx0XHRcdHRoaXMueSArPSB2Lnk7XG5cdFx0XHR0aGlzLnogKz0gdi56O1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRhZGRTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcblxuXHRcdFx0dGhpcy54ICs9IHM7XG5cdFx0XHR0aGlzLnkgKz0gcztcblx0XHRcdHRoaXMueiArPSBzO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRhZGRWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XG5cblx0XHRcdHRoaXMueCA9IGEueCArIGIueDtcblx0XHRcdHRoaXMueSA9IGEueSArIGIueTtcblx0XHRcdHRoaXMueiA9IGEueiArIGIuejtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0YWRkU2NhbGVkVmVjdG9yOiBmdW5jdGlvbiAoIHYsIHMgKSB7XG5cblx0XHRcdHRoaXMueCArPSB2LnggKiBzO1xuXHRcdFx0dGhpcy55ICs9IHYueSAqIHM7XG5cdFx0XHR0aGlzLnogKz0gdi56ICogcztcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0c3ViOiBmdW5jdGlvbiAoIHYsIHcgKSB7XG5cblx0XHRcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5zdWIoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5zdWJWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XG5cdFx0XHRcdHJldHVybiB0aGlzLnN1YlZlY3RvcnMoIHYsIHcgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnggLT0gdi54O1xuXHRcdFx0dGhpcy55IC09IHYueTtcblx0XHRcdHRoaXMueiAtPSB2Lno7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHN1YlNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xuXG5cdFx0XHR0aGlzLnggLT0gcztcblx0XHRcdHRoaXMueSAtPSBzO1xuXHRcdFx0dGhpcy56IC09IHM7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHN1YlZlY3RvcnM6IGZ1bmN0aW9uICggYSwgYiApIHtcblxuXHRcdFx0dGhpcy54ID0gYS54IC0gYi54O1xuXHRcdFx0dGhpcy55ID0gYS55IC0gYi55O1xuXHRcdFx0dGhpcy56ID0gYS56IC0gYi56O1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRtdWx0aXBseTogZnVuY3Rpb24gKCB2LCB3ICkge1xuXG5cdFx0XHRpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAubXVsdGlwbHkoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5tdWx0aXBseVZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlWZWN0b3JzKCB2LCB3ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy54ICo9IHYueDtcblx0XHRcdHRoaXMueSAqPSB2Lnk7XG5cdFx0XHR0aGlzLnogKj0gdi56O1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XG5cblx0XHRcdGlmICggaXNGaW5pdGUoIHNjYWxhciApICkge1xuXHRcdFx0XHR0aGlzLnggKj0gc2NhbGFyO1xuXHRcdFx0XHR0aGlzLnkgKj0gc2NhbGFyO1xuXHRcdFx0XHR0aGlzLnogKj0gc2NhbGFyO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy54ID0gMDtcblx0XHRcdFx0dGhpcy55ID0gMDtcblx0XHRcdFx0dGhpcy56ID0gMDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0bXVsdGlwbHlWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XG5cblx0XHRcdHRoaXMueCA9IGEueCAqIGIueDtcblx0XHRcdHRoaXMueSA9IGEueSAqIGIueTtcblx0XHRcdHRoaXMueiA9IGEueiAqIGIuejtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0YXBwbHlFdWxlcjogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgcXVhdGVybmlvbjtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIGFwcGx5RXVsZXIoIGV1bGVyICkge1xuXG5cdFx0XHRcdGlmICggZXVsZXIgaW5zdGFuY2VvZiBUSFJFRS5FdWxlciA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuVmVjdG9yMzogLmFwcGx5RXVsZXIoKSBub3cgZXhwZWN0cyBhIEV1bGVyIHJvdGF0aW9uIHJhdGhlciB0aGFuIGEgVmVjdG9yMyBhbmQgb3JkZXIuJyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHF1YXRlcm5pb24gPT09IHVuZGVmaW5lZCApIHF1YXRlcm5pb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuXG5cdFx0XHRcdHRoaXMuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uLnNldEZyb21FdWxlciggZXVsZXIgKSApO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0XHR9O1xuXG5cdFx0fSgpLFxuXG5cdFx0YXBwbHlBeGlzQW5nbGU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIHF1YXRlcm5pb247XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiBhcHBseUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKSB7XG5cblx0XHRcdFx0aWYgKCBxdWF0ZXJuaW9uID09PSB1bmRlZmluZWQgKSBxdWF0ZXJuaW9uID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcblxuXHRcdFx0XHR0aGlzLmFwcGx5UXVhdGVybmlvbiggcXVhdGVybmlvbi5zZXRGcm9tQXhpc0FuZ2xlKCBheGlzLCBhbmdsZSApICk7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdH07XG5cblx0XHR9KCksXG5cblx0XHRhcHBseU1hdHJpeDM6IGZ1bmN0aW9uICggbSApIHtcblxuXHRcdFx0dmFyIHggPSB0aGlzLng7XG5cdFx0XHR2YXIgeSA9IHRoaXMueTtcblx0XHRcdHZhciB6ID0gdGhpcy56O1xuXG5cdFx0XHR2YXIgZSA9IG0uZWxlbWVudHM7XG5cblx0XHRcdHRoaXMueCA9IGVbIDAgXSAqIHggKyBlWyAzIF0gKiB5ICsgZVsgNiBdICogejtcblx0XHRcdHRoaXMueSA9IGVbIDEgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgNyBdICogejtcblx0XHRcdHRoaXMueiA9IGVbIDIgXSAqIHggKyBlWyA1IF0gKiB5ICsgZVsgOCBdICogejtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0YXBwbHlNYXRyaXg0OiBmdW5jdGlvbiAoIG0gKSB7XG5cblx0XHRcdC8vIGlucHV0OiBUSFJFRS5NYXRyaXg0IGFmZmluZSBtYXRyaXhcblxuXHRcdFx0dmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XG5cblx0XHRcdHZhciBlID0gbS5lbGVtZW50cztcblxuXHRcdFx0dGhpcy54ID0gZVsgMCBdICogeCArIGVbIDQgXSAqIHkgKyBlWyA4IF0gICogeiArIGVbIDEyIF07XG5cdFx0XHR0aGlzLnkgPSBlWyAxIF0gKiB4ICsgZVsgNSBdICogeSArIGVbIDkgXSAgKiB6ICsgZVsgMTMgXTtcblx0XHRcdHRoaXMueiA9IGVbIDIgXSAqIHggKyBlWyA2IF0gKiB5ICsgZVsgMTAgXSAqIHogKyBlWyAxNCBdO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRhcHBseVByb2plY3Rpb246IGZ1bmN0aW9uICggbSApIHtcblxuXHRcdFx0Ly8gaW5wdXQ6IFRIUkVFLk1hdHJpeDQgcHJvamVjdGlvbiBtYXRyaXhcblxuXHRcdFx0dmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XG5cblx0XHRcdHZhciBlID0gbS5lbGVtZW50cztcblx0XHRcdHZhciBkID0gMSAvICggZVsgMyBdICogeCArIGVbIDcgXSAqIHkgKyBlWyAxMSBdICogeiArIGVbIDE1IF0gKTsgLy8gcGVyc3BlY3RpdmUgZGl2aWRlXG5cblx0XHRcdHRoaXMueCA9ICggZVsgMCBdICogeCArIGVbIDQgXSAqIHkgKyBlWyA4IF0gICogeiArIGVbIDEyIF0gKSAqIGQ7XG5cdFx0XHR0aGlzLnkgPSAoIGVbIDEgXSAqIHggKyBlWyA1IF0gKiB5ICsgZVsgOSBdICAqIHogKyBlWyAxMyBdICkgKiBkO1xuXHRcdFx0dGhpcy56ID0gKCBlWyAyIF0gKiB4ICsgZVsgNiBdICogeSArIGVbIDEwIF0gKiB6ICsgZVsgMTQgXSApICogZDtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0YXBwbHlRdWF0ZXJuaW9uOiBmdW5jdGlvbiAoIHEgKSB7XG5cblx0XHRcdHZhciB4ID0gdGhpcy54O1xuXHRcdFx0dmFyIHkgPSB0aGlzLnk7XG5cdFx0XHR2YXIgeiA9IHRoaXMuejtcblxuXHRcdFx0dmFyIHF4ID0gcS54O1xuXHRcdFx0dmFyIHF5ID0gcS55O1xuXHRcdFx0dmFyIHF6ID0gcS56O1xuXHRcdFx0dmFyIHF3ID0gcS53O1xuXG5cdFx0XHQvLyBjYWxjdWxhdGUgcXVhdCAqIHZlY3RvclxuXG5cdFx0XHR2YXIgaXggPSAgcXcgKiB4ICsgcXkgKiB6IC0gcXogKiB5O1xuXHRcdFx0dmFyIGl5ID0gIHF3ICogeSArIHF6ICogeCAtIHF4ICogejtcblx0XHRcdHZhciBpeiA9ICBxdyAqIHogKyBxeCAqIHkgLSBxeSAqIHg7XG5cdFx0XHR2YXIgaXcgPSAtIHF4ICogeCAtIHF5ICogeSAtIHF6ICogejtcblxuXHRcdFx0Ly8gY2FsY3VsYXRlIHJlc3VsdCAqIGludmVyc2UgcXVhdFxuXG5cdFx0XHR0aGlzLnggPSBpeCAqIHF3ICsgaXcgKiAtIHF4ICsgaXkgKiAtIHF6IC0gaXogKiAtIHF5O1xuXHRcdFx0dGhpcy55ID0gaXkgKiBxdyArIGl3ICogLSBxeSArIGl6ICogLSBxeCAtIGl4ICogLSBxejtcblx0XHRcdHRoaXMueiA9IGl6ICogcXcgKyBpdyAqIC0gcXogKyBpeCAqIC0gcXkgLSBpeSAqIC0gcXg7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHByb2plY3Q6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIG1hdHJpeDtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIHByb2plY3QoIGNhbWVyYSApIHtcblxuXHRcdFx0XHRpZiAoIG1hdHJpeCA9PT0gdW5kZWZpbmVkICkgbWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuXHRcdFx0XHRtYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLnByb2plY3Rpb25NYXRyaXgsIG1hdHJpeC5nZXRJbnZlcnNlKCBjYW1lcmEubWF0cml4V29ybGQgKSApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5hcHBseVByb2plY3Rpb24oIG1hdHJpeCApO1xuXG5cdFx0XHR9O1xuXG5cdFx0fSgpLFxuXG5cdFx0dW5wcm9qZWN0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciBtYXRyaXg7XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiB1bnByb2plY3QoIGNhbWVyYSApIHtcblxuXHRcdFx0XHRpZiAoIG1hdHJpeCA9PT0gdW5kZWZpbmVkICkgbWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuXHRcdFx0XHRtYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLm1hdHJpeFdvcmxkLCBtYXRyaXguZ2V0SW52ZXJzZSggY2FtZXJhLnByb2plY3Rpb25NYXRyaXggKSApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5hcHBseVByb2plY3Rpb24oIG1hdHJpeCApO1xuXG5cdFx0XHR9O1xuXG5cdFx0fSgpLFxuXG5cdFx0dHJhbnNmb3JtRGlyZWN0aW9uOiBmdW5jdGlvbiAoIG0gKSB7XG5cblx0XHRcdC8vIGlucHV0OiBUSFJFRS5NYXRyaXg0IGFmZmluZSBtYXRyaXhcblx0XHRcdC8vIHZlY3RvciBpbnRlcnByZXRlZCBhcyBhIGRpcmVjdGlvblxuXG5cdFx0XHR2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgeiA9IHRoaXMuejtcblxuXHRcdFx0dmFyIGUgPSBtLmVsZW1lbnRzO1xuXG5cdFx0XHR0aGlzLnggPSBlWyAwIF0gKiB4ICsgZVsgNCBdICogeSArIGVbIDggXSAgKiB6O1xuXHRcdFx0dGhpcy55ID0gZVsgMSBdICogeCArIGVbIDUgXSAqIHkgKyBlWyA5IF0gICogejtcblx0XHRcdHRoaXMueiA9IGVbIDIgXSAqIHggKyBlWyA2IF0gKiB5ICsgZVsgMTAgXSAqIHo7XG5cblx0XHRcdHRoaXMubm9ybWFsaXplKCk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGRpdmlkZTogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0XHR0aGlzLnggLz0gdi54O1xuXHRcdFx0dGhpcy55IC89IHYueTtcblx0XHRcdHRoaXMueiAvPSB2Lno7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGRpdmlkZVNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKCAxIC8gc2NhbGFyICk7XG5cblx0XHR9LFxuXG5cdFx0bWluOiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHRcdHRoaXMueCA9IE1hdGgubWluKCB0aGlzLngsIHYueCApO1xuXHRcdFx0dGhpcy55ID0gTWF0aC5taW4oIHRoaXMueSwgdi55ICk7XG5cdFx0XHR0aGlzLnogPSBNYXRoLm1pbiggdGhpcy56LCB2LnogKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0bWF4OiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHRcdHRoaXMueCA9IE1hdGgubWF4KCB0aGlzLngsIHYueCApO1xuXHRcdFx0dGhpcy55ID0gTWF0aC5tYXgoIHRoaXMueSwgdi55ICk7XG5cdFx0XHR0aGlzLnogPSBNYXRoLm1heCggdGhpcy56LCB2LnogKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0Y2xhbXA6IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XG5cblx0XHRcdC8vIFRoaXMgZnVuY3Rpb24gYXNzdW1lcyBtaW4gPCBtYXgsIGlmIHRoaXMgYXNzdW1wdGlvbiBpc24ndCB0cnVlIGl0IHdpbGwgbm90IG9wZXJhdGUgY29ycmVjdGx5XG5cblx0XHRcdHRoaXMueCA9IE1hdGgubWF4KCBtaW4ueCwgTWF0aC5taW4oIG1heC54LCB0aGlzLnggKSApO1xuXHRcdFx0dGhpcy55ID0gTWF0aC5tYXgoIG1pbi55LCBNYXRoLm1pbiggbWF4LnksIHRoaXMueSApICk7XG5cdFx0XHR0aGlzLnogPSBNYXRoLm1heCggbWluLnosIE1hdGgubWluKCBtYXgueiwgdGhpcy56ICkgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0Y2xhbXBTY2FsYXI6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIG1pbiwgbWF4O1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gY2xhbXBTY2FsYXIoIG1pblZhbCwgbWF4VmFsICkge1xuXG5cdFx0XHRcdGlmICggbWluID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRtaW4gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdFx0XHRcdG1heCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdG1pbi5zZXQoIG1pblZhbCwgbWluVmFsLCBtaW5WYWwgKTtcblx0XHRcdFx0bWF4LnNldCggbWF4VmFsLCBtYXhWYWwsIG1heFZhbCApO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzLmNsYW1wKCBtaW4sIG1heCApO1xuXG5cdFx0XHR9O1xuXG5cdFx0fSgpLFxuXG5cdFx0Y2xhbXBMZW5ndGg6IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XG5cblx0XHRcdHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCgpO1xuXG5cdFx0XHR0aGlzLm11bHRpcGx5U2NhbGFyKCBNYXRoLm1heCggbWluLCBNYXRoLm1pbiggbWF4LCBsZW5ndGggKSApIC8gbGVuZ3RoICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGZsb29yOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHRoaXMueCA9IE1hdGguZmxvb3IoIHRoaXMueCApO1xuXHRcdFx0dGhpcy55ID0gTWF0aC5mbG9vciggdGhpcy55ICk7XG5cdFx0XHR0aGlzLnogPSBNYXRoLmZsb29yKCB0aGlzLnogKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0Y2VpbDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR0aGlzLnggPSBNYXRoLmNlaWwoIHRoaXMueCApO1xuXHRcdFx0dGhpcy55ID0gTWF0aC5jZWlsKCB0aGlzLnkgKTtcblx0XHRcdHRoaXMueiA9IE1hdGguY2VpbCggdGhpcy56ICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHJvdW5kOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHRoaXMueCA9IE1hdGgucm91bmQoIHRoaXMueCApO1xuXHRcdFx0dGhpcy55ID0gTWF0aC5yb3VuZCggdGhpcy55ICk7XG5cdFx0XHR0aGlzLnogPSBNYXRoLnJvdW5kKCB0aGlzLnogKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0cm91bmRUb1plcm86IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dGhpcy54ID0gKCB0aGlzLnggPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueCApIDogTWF0aC5mbG9vciggdGhpcy54ICk7XG5cdFx0XHR0aGlzLnkgPSAoIHRoaXMueSA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy55ICkgOiBNYXRoLmZsb29yKCB0aGlzLnkgKTtcblx0XHRcdHRoaXMueiA9ICggdGhpcy56IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnogKSA6IE1hdGguZmxvb3IoIHRoaXMueiApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRuZWdhdGU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dGhpcy54ID0gLSB0aGlzLng7XG5cdFx0XHR0aGlzLnkgPSAtIHRoaXMueTtcblx0XHRcdHRoaXMueiA9IC0gdGhpcy56O1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRkb3Q6IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMueCAqIHYueCArIHRoaXMueSAqIHYueSArIHRoaXMueiAqIHYuejtcblxuXHRcdH0sXG5cblx0XHRsZW5ndGhTcTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56O1xuXG5cdFx0fSxcblxuXHRcdGxlbmd0aDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLnogKTtcblxuXHRcdH0sXG5cblx0XHRsZW5ndGhNYW5oYXR0YW46IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIE1hdGguYWJzKCB0aGlzLnggKSArIE1hdGguYWJzKCB0aGlzLnkgKSArIE1hdGguYWJzKCB0aGlzLnogKTtcblxuXHRcdH0sXG5cblx0XHRub3JtYWxpemU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKCB0aGlzLmxlbmd0aCgpICk7XG5cblx0XHR9LFxuXG5cdFx0c2V0TGVuZ3RoOiBmdW5jdGlvbiAoIGxlbmd0aCApIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoIGxlbmd0aCAvIHRoaXMubGVuZ3RoKCkgKTtcblxuXHRcdH0sXG5cblx0XHRsZXJwOiBmdW5jdGlvbiAoIHYsIGFscGhhICkge1xuXG5cdFx0XHR0aGlzLnggKz0gKCB2LnggLSB0aGlzLnggKSAqIGFscGhhO1xuXHRcdFx0dGhpcy55ICs9ICggdi55IC0gdGhpcy55ICkgKiBhbHBoYTtcblx0XHRcdHRoaXMueiArPSAoIHYueiAtIHRoaXMueiApICogYWxwaGE7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGxlcnBWZWN0b3JzOiBmdW5jdGlvbiAoIHYxLCB2MiwgYWxwaGEgKSB7XG5cblx0XHRcdHRoaXMuc3ViVmVjdG9ycyggdjIsIHYxICkubXVsdGlwbHlTY2FsYXIoIGFscGhhICkuYWRkKCB2MSApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRjcm9zczogZnVuY3Rpb24gKCB2LCB3ICkge1xuXG5cdFx0XHRpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAuY3Jvc3MoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5jcm9zc1ZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXMuY3Jvc3NWZWN0b3JzKCB2LCB3ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XG5cblx0XHRcdHRoaXMueCA9IHkgKiB2LnogLSB6ICogdi55O1xuXHRcdFx0dGhpcy55ID0geiAqIHYueCAtIHggKiB2Lno7XG5cdFx0XHR0aGlzLnogPSB4ICogdi55IC0geSAqIHYueDtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0Y3Jvc3NWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XG5cblx0XHRcdHZhciBheCA9IGEueCwgYXkgPSBhLnksIGF6ID0gYS56O1xuXHRcdFx0dmFyIGJ4ID0gYi54LCBieSA9IGIueSwgYnogPSBiLno7XG5cblx0XHRcdHRoaXMueCA9IGF5ICogYnogLSBheiAqIGJ5O1xuXHRcdFx0dGhpcy55ID0gYXogKiBieCAtIGF4ICogYno7XG5cdFx0XHR0aGlzLnogPSBheCAqIGJ5IC0gYXkgKiBieDtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0cHJvamVjdE9uVmVjdG9yOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciB2MSwgZG90O1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gcHJvamVjdE9uVmVjdG9yKCB2ZWN0b3IgKSB7XG5cblx0XHRcdFx0aWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0XHRcdHYxLmNvcHkoIHZlY3RvciApLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHRcdGRvdCA9IHRoaXMuZG90KCB2MSApO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzLmNvcHkoIHYxICkubXVsdGlwbHlTY2FsYXIoIGRvdCApO1xuXG5cdFx0XHR9O1xuXG5cdFx0fSgpLFxuXG5cdFx0cHJvamVjdE9uUGxhbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIHYxO1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gcHJvamVjdE9uUGxhbmUoIHBsYW5lTm9ybWFsICkge1xuXG5cdFx0XHRcdGlmICggdjEgPT09IHVuZGVmaW5lZCApIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdFx0XHR2MS5jb3B5KCB0aGlzICkucHJvamVjdE9uVmVjdG9yKCBwbGFuZU5vcm1hbCApO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzLnN1YiggdjEgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSgpLFxuXG5cdFx0cmVmbGVjdDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHQvLyByZWZsZWN0IGluY2lkZW50IHZlY3RvciBvZmYgcGxhbmUgb3J0aG9nb25hbCB0byBub3JtYWxcblx0XHRcdC8vIG5vcm1hbCBpcyBhc3N1bWVkIHRvIGhhdmUgdW5pdCBsZW5ndGhcblxuXHRcdFx0dmFyIHYxO1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gcmVmbGVjdCggbm9ybWFsICkge1xuXG5cdFx0XHRcdGlmICggdjEgPT09IHVuZGVmaW5lZCApIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcy5zdWIoIHYxLmNvcHkoIG5vcm1hbCApLm11bHRpcGx5U2NhbGFyKCAyICogdGhpcy5kb3QoIG5vcm1hbCApICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSgpLFxuXG5cdFx0YW5nbGVUbzogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0XHR2YXIgdGhldGEgPSB0aGlzLmRvdCggdiApIC8gKCB0aGlzLmxlbmd0aCgpICogdi5sZW5ndGgoKSApO1xuXG5cdFx0XHQvLyBjbGFtcCwgdG8gaGFuZGxlIG51bWVyaWNhbCBwcm9ibGVtc1xuXG5cdFx0XHRyZXR1cm4gTWF0aC5hY29zKCBUSFJFRS5NYXRoLmNsYW1wKCB0aGV0YSwgLSAxLCAxICkgKTtcblxuXHRcdH0sXG5cblx0XHRkaXN0YW5jZVRvOiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMuZGlzdGFuY2VUb1NxdWFyZWQoIHYgKSApO1xuXG5cdFx0fSxcblxuXHRcdGRpc3RhbmNlVG9TcXVhcmVkOiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHRcdHZhciBkeCA9IHRoaXMueCAtIHYueDtcblx0XHRcdHZhciBkeSA9IHRoaXMueSAtIHYueTtcblx0XHRcdHZhciBkeiA9IHRoaXMueiAtIHYuejtcblxuXHRcdFx0cmV0dXJuIGR4ICogZHggKyBkeSAqIGR5ICsgZHogKiBkejtcblxuXHRcdH0sXG5cblx0XHRzZXRFdWxlckZyb21Sb3RhdGlvbk1hdHJpeDogZnVuY3Rpb24gKCBtLCBvcmRlciApIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlZlY3RvcjM6IC5zZXRFdWxlckZyb21Sb3RhdGlvbk1hdHJpeCgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBFdWxlci5zZXRGcm9tUm90YXRpb25NYXRyaXgoKSBpbnN0ZWFkLicgKTtcblxuXHRcdH0sXG5cblx0XHRzZXRFdWxlckZyb21RdWF0ZXJuaW9uOiBmdW5jdGlvbiAoIHEsIG9yZGVyICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuVmVjdG9yMzogLnNldEV1bGVyRnJvbVF1YXRlcm5pb24oKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgRXVsZXIuc2V0RnJvbVF1YXRlcm5pb24oKSBpbnN0ZWFkLicgKTtcblxuXHRcdH0sXG5cblx0XHRnZXRQb3NpdGlvbkZyb21NYXRyaXg6IGZ1bmN0aW9uICggbSApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLmdldFBvc2l0aW9uRnJvbU1hdHJpeCgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLnNldEZyb21NYXRyaXhQb3NpdGlvbigpLicgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBtICk7XG5cblx0XHR9LFxuXG5cdFx0Z2V0U2NhbGVGcm9tTWF0cml4OiBmdW5jdGlvbiAoIG0gKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5nZXRTY2FsZUZyb21NYXRyaXgoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5zZXRGcm9tTWF0cml4U2NhbGUoKS4nICk7XG5cblx0XHRcdHJldHVybiB0aGlzLnNldEZyb21NYXRyaXhTY2FsZSggbSApO1xuXG5cdFx0fSxcblxuXHRcdGdldENvbHVtbkZyb21NYXRyaXg6IGZ1bmN0aW9uICggaW5kZXgsIG1hdHJpeCApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLmdldENvbHVtbkZyb21NYXRyaXgoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5zZXRGcm9tTWF0cml4Q29sdW1uKCkuJyApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKCBpbmRleCwgbWF0cml4ICk7XG5cblx0XHR9LFxuXG5cdFx0c2V0RnJvbU1hdHJpeFBvc2l0aW9uOiBmdW5jdGlvbiAoIG0gKSB7XG5cblx0XHRcdHRoaXMueCA9IG0uZWxlbWVudHNbIDEyIF07XG5cdFx0XHR0aGlzLnkgPSBtLmVsZW1lbnRzWyAxMyBdO1xuXHRcdFx0dGhpcy56ID0gbS5lbGVtZW50c1sgMTQgXTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0c2V0RnJvbU1hdHJpeFNjYWxlOiBmdW5jdGlvbiAoIG0gKSB7XG5cblx0XHRcdHZhciBzeCA9IHRoaXMuc2V0KCBtLmVsZW1lbnRzWyAwIF0sIG0uZWxlbWVudHNbIDEgXSwgbS5lbGVtZW50c1sgMiBdICkubGVuZ3RoKCk7XG5cdFx0XHR2YXIgc3kgPSB0aGlzLnNldCggbS5lbGVtZW50c1sgNCBdLCBtLmVsZW1lbnRzWyA1IF0sIG0uZWxlbWVudHNbIDYgXSApLmxlbmd0aCgpO1xuXHRcdFx0dmFyIHN6ID0gdGhpcy5zZXQoIG0uZWxlbWVudHNbIDggXSwgbS5lbGVtZW50c1sgOSBdLCBtLmVsZW1lbnRzWyAxMCBdICkubGVuZ3RoKCk7XG5cblx0XHRcdHRoaXMueCA9IHN4O1xuXHRcdFx0dGhpcy55ID0gc3k7XG5cdFx0XHR0aGlzLnogPSBzejtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0c2V0RnJvbU1hdHJpeENvbHVtbjogZnVuY3Rpb24gKCBpbmRleCwgbWF0cml4ICkge1xuXG5cdFx0XHR2YXIgb2Zmc2V0ID0gaW5kZXggKiA0O1xuXG5cdFx0XHR2YXIgbWUgPSBtYXRyaXguZWxlbWVudHM7XG5cblx0XHRcdHRoaXMueCA9IG1lWyBvZmZzZXQgXTtcblx0XHRcdHRoaXMueSA9IG1lWyBvZmZzZXQgKyAxIF07XG5cdFx0XHR0aGlzLnogPSBtZVsgb2Zmc2V0ICsgMiBdO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRlcXVhbHM6IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdFx0cmV0dXJuICggKCB2LnggPT09IHRoaXMueCApICYmICggdi55ID09PSB0aGlzLnkgKSAmJiAoIHYueiA9PT0gdGhpcy56ICkgKTtcblxuXHRcdH0sXG5cblx0XHRmcm9tQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcblxuXHRcdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cblx0XHRcdHRoaXMueCA9IGFycmF5WyBvZmZzZXQgXTtcblx0XHRcdHRoaXMueSA9IGFycmF5WyBvZmZzZXQgKyAxIF07XG5cdFx0XHR0aGlzLnogPSBhcnJheVsgb2Zmc2V0ICsgMiBdO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHR0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XG5cblx0XHRcdGlmICggYXJyYXkgPT09IHVuZGVmaW5lZCApIGFycmF5ID0gW107XG5cdFx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuXHRcdFx0YXJyYXlbIG9mZnNldCBdID0gdGhpcy54O1xuXHRcdFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMueTtcblx0XHRcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0aGlzLno7XG5cblx0XHRcdHJldHVybiBhcnJheTtcblxuXHRcdH0sXG5cblx0XHRmcm9tQXR0cmlidXRlOiBmdW5jdGlvbiAoIGF0dHJpYnV0ZSwgaW5kZXgsIG9mZnNldCApIHtcblxuXHRcdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cblx0XHRcdGluZGV4ID0gaW5kZXggKiBhdHRyaWJ1dGUuaXRlbVNpemUgKyBvZmZzZXQ7XG5cblx0XHRcdHRoaXMueCA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXggXTtcblx0XHRcdHRoaXMueSA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXggKyAxIF07XG5cdFx0XHR0aGlzLnogPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4ICsgMiBdO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH1cblxuXHR9O1xuXG5cdC8vIEZpbGU6c3JjL21hdGgvVmVjdG9yNC5qc1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIHN1cGVyZWdnYmVydCAvIGh0dHA6Ly93d3cucGF1bGJydW50LmNvLnVrL1xuXHQgKiBAYXV0aG9yIHBoaWxvZ2IgLyBodHRwOi8vYmxvZy50aGVqaXQub3JnL1xuXHQgKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuXHQgKiBAYXV0aG9yIGVncmFldGhlciAvIGh0dHA6Ly9lZ3JhZXRoZXIuY29tL1xuXHQgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcblx0ICovXG5cblx0VEhSRUUuVmVjdG9yNCA9IGZ1bmN0aW9uICggeCwgeSwgeiwgdyApIHtcblxuXHRcdHRoaXMueCA9IHggfHwgMDtcblx0XHR0aGlzLnkgPSB5IHx8IDA7XG5cdFx0dGhpcy56ID0geiB8fCAwO1xuXHRcdHRoaXMudyA9ICggdyAhPT0gdW5kZWZpbmVkICkgPyB3IDogMTtcblxuXHR9O1xuXG5cdFRIUkVFLlZlY3RvcjQucHJvdG90eXBlID0ge1xuXG5cdFx0Y29uc3RydWN0b3I6IFRIUkVFLlZlY3RvcjQsXG5cblx0XHRzZXQ6IGZ1bmN0aW9uICggeCwgeSwgeiwgdyApIHtcblxuXHRcdFx0dGhpcy54ID0geDtcblx0XHRcdHRoaXMueSA9IHk7XG5cdFx0XHR0aGlzLnogPSB6O1xuXHRcdFx0dGhpcy53ID0gdztcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0c2V0WDogZnVuY3Rpb24gKCB4ICkge1xuXG5cdFx0XHR0aGlzLnggPSB4O1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRzZXRZOiBmdW5jdGlvbiAoIHkgKSB7XG5cblx0XHRcdHRoaXMueSA9IHk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHNldFo6IGZ1bmN0aW9uICggeiApIHtcblxuXHRcdFx0dGhpcy56ID0gejtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0c2V0VzogZnVuY3Rpb24gKCB3ICkge1xuXG5cdFx0XHR0aGlzLncgPSB3O1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRzZXRDb21wb25lbnQ6IGZ1bmN0aW9uICggaW5kZXgsIHZhbHVlICkge1xuXG5cdFx0XHRzd2l0Y2ggKCBpbmRleCApIHtcblxuXHRcdFx0XHRjYXNlIDA6IHRoaXMueCA9IHZhbHVlOyBicmVhaztcblx0XHRcdFx0Y2FzZSAxOiB0aGlzLnkgPSB2YWx1ZTsgYnJlYWs7XG5cdFx0XHRcdGNhc2UgMjogdGhpcy56ID0gdmFsdWU7IGJyZWFrO1xuXHRcdFx0XHRjYXNlIDM6IHRoaXMudyA9IHZhbHVlOyBicmVhaztcblx0XHRcdFx0ZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXggKTtcblxuXHRcdFx0fVxuXG5cdFx0fSxcblxuXHRcdGdldENvbXBvbmVudDogZnVuY3Rpb24gKCBpbmRleCApIHtcblxuXHRcdFx0c3dpdGNoICggaW5kZXggKSB7XG5cblx0XHRcdFx0Y2FzZSAwOiByZXR1cm4gdGhpcy54O1xuXHRcdFx0XHRjYXNlIDE6IHJldHVybiB0aGlzLnk7XG5cdFx0XHRcdGNhc2UgMjogcmV0dXJuIHRoaXMuejtcblx0XHRcdFx0Y2FzZSAzOiByZXR1cm4gdGhpcy53O1xuXHRcdFx0XHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xuXG5cdFx0XHR9XG5cblx0XHR9LFxuXG5cdFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLngsIHRoaXMueSwgdGhpcy56LCB0aGlzLncgKTtcblxuXHRcdH0sXG5cblx0XHRjb3B5OiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHRcdHRoaXMueCA9IHYueDtcblx0XHRcdHRoaXMueSA9IHYueTtcblx0XHRcdHRoaXMueiA9IHYuejtcblx0XHRcdHRoaXMudyA9ICggdi53ICE9PSB1bmRlZmluZWQgKSA/IHYudyA6IDE7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGFkZDogZnVuY3Rpb24gKCB2LCB3ICkge1xuXG5cdFx0XHRpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3I0OiAuYWRkKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuYWRkVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5hZGRWZWN0b3JzKCB2LCB3ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy54ICs9IHYueDtcblx0XHRcdHRoaXMueSArPSB2Lnk7XG5cdFx0XHR0aGlzLnogKz0gdi56O1xuXHRcdFx0dGhpcy53ICs9IHYudztcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0YWRkU2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XG5cblx0XHRcdHRoaXMueCArPSBzO1xuXHRcdFx0dGhpcy55ICs9IHM7XG5cdFx0XHR0aGlzLnogKz0gcztcblx0XHRcdHRoaXMudyArPSBzO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRhZGRWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XG5cblx0XHRcdHRoaXMueCA9IGEueCArIGIueDtcblx0XHRcdHRoaXMueSA9IGEueSArIGIueTtcblx0XHRcdHRoaXMueiA9IGEueiArIGIuejtcblx0XHRcdHRoaXMudyA9IGEudyArIGIudztcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0YWRkU2NhbGVkVmVjdG9yOiBmdW5jdGlvbiAoIHYsIHMgKSB7XG5cblx0XHRcdHRoaXMueCArPSB2LnggKiBzO1xuXHRcdFx0dGhpcy55ICs9IHYueSAqIHM7XG5cdFx0XHR0aGlzLnogKz0gdi56ICogcztcblx0XHRcdHRoaXMudyArPSB2LncgKiBzO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRzdWI6IGZ1bmN0aW9uICggdiwgdyApIHtcblxuXHRcdFx0aWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yNDogLnN1YigpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLnN1YlZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXMuc3ViVmVjdG9ycyggdiwgdyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMueCAtPSB2Lng7XG5cdFx0XHR0aGlzLnkgLT0gdi55O1xuXHRcdFx0dGhpcy56IC09IHYuejtcblx0XHRcdHRoaXMudyAtPSB2Lnc7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHN1YlNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xuXG5cdFx0XHR0aGlzLnggLT0gcztcblx0XHRcdHRoaXMueSAtPSBzO1xuXHRcdFx0dGhpcy56IC09IHM7XG5cdFx0XHR0aGlzLncgLT0gcztcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0c3ViVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xuXG5cdFx0XHR0aGlzLnggPSBhLnggLSBiLng7XG5cdFx0XHR0aGlzLnkgPSBhLnkgLSBiLnk7XG5cdFx0XHR0aGlzLnogPSBhLnogLSBiLno7XG5cdFx0XHR0aGlzLncgPSBhLncgLSBiLnc7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcblxuXHRcdFx0aWYgKCBpc0Zpbml0ZSggc2NhbGFyICkgKSB7XG5cdFx0XHRcdHRoaXMueCAqPSBzY2FsYXI7XG5cdFx0XHRcdHRoaXMueSAqPSBzY2FsYXI7XG5cdFx0XHRcdHRoaXMueiAqPSBzY2FsYXI7XG5cdFx0XHRcdHRoaXMudyAqPSBzY2FsYXI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnggPSAwO1xuXHRcdFx0XHR0aGlzLnkgPSAwO1xuXHRcdFx0XHR0aGlzLnogPSAwO1xuXHRcdFx0XHR0aGlzLncgPSAwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRhcHBseU1hdHJpeDQ6IGZ1bmN0aW9uICggbSApIHtcblxuXHRcdFx0dmFyIHggPSB0aGlzLng7XG5cdFx0XHR2YXIgeSA9IHRoaXMueTtcblx0XHRcdHZhciB6ID0gdGhpcy56O1xuXHRcdFx0dmFyIHcgPSB0aGlzLnc7XG5cblx0XHRcdHZhciBlID0gbS5lbGVtZW50cztcblxuXHRcdFx0dGhpcy54ID0gZVsgMCBdICogeCArIGVbIDQgXSAqIHkgKyBlWyA4IF0gKiB6ICsgZVsgMTIgXSAqIHc7XG5cdFx0XHR0aGlzLnkgPSBlWyAxIF0gKiB4ICsgZVsgNSBdICogeSArIGVbIDkgXSAqIHogKyBlWyAxMyBdICogdztcblx0XHRcdHRoaXMueiA9IGVbIDIgXSAqIHggKyBlWyA2IF0gKiB5ICsgZVsgMTAgXSAqIHogKyBlWyAxNCBdICogdztcblx0XHRcdHRoaXMudyA9IGVbIDMgXSAqIHggKyBlWyA3IF0gKiB5ICsgZVsgMTEgXSAqIHogKyBlWyAxNSBdICogdztcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0ZGl2aWRlU2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoIDEgLyBzY2FsYXIgKTtcblxuXHRcdH0sXG5cblx0XHRzZXRBeGlzQW5nbGVGcm9tUXVhdGVybmlvbjogZnVuY3Rpb24gKCBxICkge1xuXG5cdFx0XHQvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvcXVhdGVybmlvblRvQW5nbGUvaW5kZXguaHRtXG5cblx0XHRcdC8vIHEgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXG5cblx0XHRcdHRoaXMudyA9IDIgKiBNYXRoLmFjb3MoIHEudyApO1xuXG5cdFx0XHR2YXIgcyA9IE1hdGguc3FydCggMSAtIHEudyAqIHEudyApO1xuXG5cdFx0XHRpZiAoIHMgPCAwLjAwMDEgKSB7XG5cblx0XHRcdFx0IHRoaXMueCA9IDE7XG5cdFx0XHRcdCB0aGlzLnkgPSAwO1xuXHRcdFx0XHQgdGhpcy56ID0gMDtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQgdGhpcy54ID0gcS54IC8gcztcblx0XHRcdFx0IHRoaXMueSA9IHEueSAvIHM7XG5cdFx0XHRcdCB0aGlzLnogPSBxLnogLyBzO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHNldEF4aXNBbmdsZUZyb21Sb3RhdGlvbk1hdHJpeDogZnVuY3Rpb24gKCBtICkge1xuXG5cdFx0XHQvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvbWF0cml4VG9BbmdsZS9pbmRleC5odG1cblxuXHRcdFx0Ly8gYXNzdW1lcyB0aGUgdXBwZXIgM3gzIG9mIG0gaXMgYSBwdXJlIHJvdGF0aW9uIG1hdHJpeCAoaS5lLCB1bnNjYWxlZClcblxuXHRcdFx0dmFyIGFuZ2xlLCB4LCB5LCB6LFx0XHQvLyB2YXJpYWJsZXMgZm9yIHJlc3VsdFxuXHRcdFx0XHRlcHNpbG9uID0gMC4wMSxcdFx0Ly8gbWFyZ2luIHRvIGFsbG93IGZvciByb3VuZGluZyBlcnJvcnNcblx0XHRcdFx0ZXBzaWxvbjIgPSAwLjEsXHRcdC8vIG1hcmdpbiB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIDAgYW5kIDE4MCBkZWdyZWVzXG5cblx0XHRcdFx0dGUgPSBtLmVsZW1lbnRzLFxuXG5cdFx0XHRcdG0xMSA9IHRlWyAwIF0sIG0xMiA9IHRlWyA0IF0sIG0xMyA9IHRlWyA4IF0sXG5cdFx0XHRcdG0yMSA9IHRlWyAxIF0sIG0yMiA9IHRlWyA1IF0sIG0yMyA9IHRlWyA5IF0sXG5cdFx0XHRcdG0zMSA9IHRlWyAyIF0sIG0zMiA9IHRlWyA2IF0sIG0zMyA9IHRlWyAxMCBdO1xuXG5cdFx0XHRpZiAoICggTWF0aC5hYnMoIG0xMiAtIG0yMSApIDwgZXBzaWxvbiApXG5cdFx0XHQgICAmJiAoIE1hdGguYWJzKCBtMTMgLSBtMzEgKSA8IGVwc2lsb24gKVxuXHRcdFx0ICAgJiYgKCBNYXRoLmFicyggbTIzIC0gbTMyICkgPCBlcHNpbG9uICkgKSB7XG5cblx0XHRcdFx0Ly8gc2luZ3VsYXJpdHkgZm91bmRcblx0XHRcdFx0Ly8gZmlyc3QgY2hlY2sgZm9yIGlkZW50aXR5IG1hdHJpeCB3aGljaCBtdXN0IGhhdmUgKzEgZm9yIGFsbCB0ZXJtc1xuXHRcdFx0XHQvLyBpbiBsZWFkaW5nIGRpYWdvbmFsIGFuZCB6ZXJvIGluIG90aGVyIHRlcm1zXG5cblx0XHRcdFx0aWYgKCAoIE1hdGguYWJzKCBtMTIgKyBtMjEgKSA8IGVwc2lsb24yIClcblx0XHRcdFx0ICAgJiYgKCBNYXRoLmFicyggbTEzICsgbTMxICkgPCBlcHNpbG9uMiApXG5cdFx0XHRcdCAgICYmICggTWF0aC5hYnMoIG0yMyArIG0zMiApIDwgZXBzaWxvbjIgKVxuXHRcdFx0XHQgICAmJiAoIE1hdGguYWJzKCBtMTEgKyBtMjIgKyBtMzMgLSAzICkgPCBlcHNpbG9uMiApICkge1xuXG5cdFx0XHRcdFx0Ly8gdGhpcyBzaW5ndWxhcml0eSBpcyBpZGVudGl0eSBtYXRyaXggc28gYW5nbGUgPSAwXG5cblx0XHRcdFx0XHR0aGlzLnNldCggMSwgMCwgMCwgMCApO1xuXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7IC8vIHplcm8gYW5nbGUsIGFyYml0cmFyeSBheGlzXG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIG90aGVyd2lzZSB0aGlzIHNpbmd1bGFyaXR5IGlzIGFuZ2xlID0gMTgwXG5cblx0XHRcdFx0YW5nbGUgPSBNYXRoLlBJO1xuXG5cdFx0XHRcdHZhciB4eCA9ICggbTExICsgMSApIC8gMjtcblx0XHRcdFx0dmFyIHl5ID0gKCBtMjIgKyAxICkgLyAyO1xuXHRcdFx0XHR2YXIgenogPSAoIG0zMyArIDEgKSAvIDI7XG5cdFx0XHRcdHZhciB4eSA9ICggbTEyICsgbTIxICkgLyA0O1xuXHRcdFx0XHR2YXIgeHogPSAoIG0xMyArIG0zMSApIC8gNDtcblx0XHRcdFx0dmFyIHl6ID0gKCBtMjMgKyBtMzIgKSAvIDQ7XG5cblx0XHRcdFx0aWYgKCAoIHh4ID4geXkgKSAmJiAoIHh4ID4genogKSApIHtcblxuXHRcdFx0XHRcdC8vIG0xMSBpcyB0aGUgbGFyZ2VzdCBkaWFnb25hbCB0ZXJtXG5cblx0XHRcdFx0XHRpZiAoIHh4IDwgZXBzaWxvbiApIHtcblxuXHRcdFx0XHRcdFx0eCA9IDA7XG5cdFx0XHRcdFx0XHR5ID0gMC43MDcxMDY3ODE7XG5cdFx0XHRcdFx0XHR6ID0gMC43MDcxMDY3ODE7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHR4ID0gTWF0aC5zcXJ0KCB4eCApO1xuXHRcdFx0XHRcdFx0eSA9IHh5IC8geDtcblx0XHRcdFx0XHRcdHogPSB4eiAvIHg7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIGlmICggeXkgPiB6eiApIHtcblxuXHRcdFx0XHRcdC8vIG0yMiBpcyB0aGUgbGFyZ2VzdCBkaWFnb25hbCB0ZXJtXG5cblx0XHRcdFx0XHRpZiAoIHl5IDwgZXBzaWxvbiApIHtcblxuXHRcdFx0XHRcdFx0eCA9IDAuNzA3MTA2NzgxO1xuXHRcdFx0XHRcdFx0eSA9IDA7XG5cdFx0XHRcdFx0XHR6ID0gMC43MDcxMDY3ODE7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHR5ID0gTWF0aC5zcXJ0KCB5eSApO1xuXHRcdFx0XHRcdFx0eCA9IHh5IC8geTtcblx0XHRcdFx0XHRcdHogPSB5eiAvIHk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIG0zMyBpcyB0aGUgbGFyZ2VzdCBkaWFnb25hbCB0ZXJtIHNvIGJhc2UgcmVzdWx0IG9uIHRoaXNcblxuXHRcdFx0XHRcdGlmICggenogPCBlcHNpbG9uICkge1xuXG5cdFx0XHRcdFx0XHR4ID0gMC43MDcxMDY3ODE7XG5cdFx0XHRcdFx0XHR5ID0gMC43MDcxMDY3ODE7XG5cdFx0XHRcdFx0XHR6ID0gMDtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdHogPSBNYXRoLnNxcnQoIHp6ICk7XG5cdFx0XHRcdFx0XHR4ID0geHogLyB6O1xuXHRcdFx0XHRcdFx0eSA9IHl6IC8gejtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5zZXQoIHgsIHksIHosIGFuZ2xlICk7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXM7IC8vIHJldHVybiAxODAgZGVnIHJvdGF0aW9uXG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gYXMgd2UgaGF2ZSByZWFjaGVkIGhlcmUgdGhlcmUgYXJlIG5vIHNpbmd1bGFyaXRpZXMgc28gd2UgY2FuIGhhbmRsZSBub3JtYWxseVxuXG5cdFx0XHR2YXIgcyA9IE1hdGguc3FydCggKCBtMzIgLSBtMjMgKSAqICggbTMyIC0gbTIzIClcblx0XHRcdFx0XHRcdFx0ICArICggbTEzIC0gbTMxICkgKiAoIG0xMyAtIG0zMSApXG5cdFx0XHRcdFx0XHRcdCAgKyAoIG0yMSAtIG0xMiApICogKCBtMjEgLSBtMTIgKSApOyAvLyB1c2VkIHRvIG5vcm1hbGl6ZVxuXG5cdFx0XHRpZiAoIE1hdGguYWJzKCBzICkgPCAwLjAwMSApIHMgPSAxO1xuXG5cdFx0XHQvLyBwcmV2ZW50IGRpdmlkZSBieSB6ZXJvLCBzaG91bGQgbm90IGhhcHBlbiBpZiBtYXRyaXggaXMgb3J0aG9nb25hbCBhbmQgc2hvdWxkIGJlXG5cdFx0XHQvLyBjYXVnaHQgYnkgc2luZ3VsYXJpdHkgdGVzdCBhYm92ZSwgYnV0IEkndmUgbGVmdCBpdCBpbiBqdXN0IGluIGNhc2VcblxuXHRcdFx0dGhpcy54ID0gKCBtMzIgLSBtMjMgKSAvIHM7XG5cdFx0XHR0aGlzLnkgPSAoIG0xMyAtIG0zMSApIC8gcztcblx0XHRcdHRoaXMueiA9ICggbTIxIC0gbTEyICkgLyBzO1xuXHRcdFx0dGhpcy53ID0gTWF0aC5hY29zKCAoIG0xMSArIG0yMiArIG0zMyAtIDEgKSAvIDIgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0bWluOiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHRcdHRoaXMueCA9IE1hdGgubWluKCB0aGlzLngsIHYueCApO1xuXHRcdFx0dGhpcy55ID0gTWF0aC5taW4oIHRoaXMueSwgdi55ICk7XG5cdFx0XHR0aGlzLnogPSBNYXRoLm1pbiggdGhpcy56LCB2LnogKTtcblx0XHRcdHRoaXMudyA9IE1hdGgubWluKCB0aGlzLncsIHYudyApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRtYXg6IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdFx0dGhpcy54ID0gTWF0aC5tYXgoIHRoaXMueCwgdi54ICk7XG5cdFx0XHR0aGlzLnkgPSBNYXRoLm1heCggdGhpcy55LCB2LnkgKTtcblx0XHRcdHRoaXMueiA9IE1hdGgubWF4KCB0aGlzLnosIHYueiApO1xuXHRcdFx0dGhpcy53ID0gTWF0aC5tYXgoIHRoaXMudywgdi53ICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGNsYW1wOiBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xuXG5cdFx0XHQvLyBUaGlzIGZ1bmN0aW9uIGFzc3VtZXMgbWluIDwgbWF4LCBpZiB0aGlzIGFzc3VtcHRpb24gaXNuJ3QgdHJ1ZSBpdCB3aWxsIG5vdCBvcGVyYXRlIGNvcnJlY3RseVxuXG5cdFx0XHR0aGlzLnggPSBNYXRoLm1heCggbWluLngsIE1hdGgubWluKCBtYXgueCwgdGhpcy54ICkgKTtcblx0XHRcdHRoaXMueSA9IE1hdGgubWF4KCBtaW4ueSwgTWF0aC5taW4oIG1heC55LCB0aGlzLnkgKSApO1xuXHRcdFx0dGhpcy56ID0gTWF0aC5tYXgoIG1pbi56LCBNYXRoLm1pbiggbWF4LnosIHRoaXMueiApICk7XG5cdFx0XHR0aGlzLncgPSBNYXRoLm1heCggbWluLncsIE1hdGgubWluKCBtYXgudywgdGhpcy53ICkgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0Y2xhbXBTY2FsYXI6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIG1pbiwgbWF4O1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gY2xhbXBTY2FsYXIoIG1pblZhbCwgbWF4VmFsICkge1xuXG5cdFx0XHRcdGlmICggbWluID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRtaW4gPSBuZXcgVEhSRUUuVmVjdG9yNCgpO1xuXHRcdFx0XHRcdG1heCA9IG5ldyBUSFJFRS5WZWN0b3I0KCk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdG1pbi5zZXQoIG1pblZhbCwgbWluVmFsLCBtaW5WYWwsIG1pblZhbCApO1xuXHRcdFx0XHRtYXguc2V0KCBtYXhWYWwsIG1heFZhbCwgbWF4VmFsLCBtYXhWYWwgKTtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcy5jbGFtcCggbWluLCBtYXggKTtcblxuXHRcdFx0fTtcblxuXHRcdH0oKSxcblxuXHRcdGZsb29yOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHRoaXMueCA9IE1hdGguZmxvb3IoIHRoaXMueCApO1xuXHRcdFx0dGhpcy55ID0gTWF0aC5mbG9vciggdGhpcy55ICk7XG5cdFx0XHR0aGlzLnogPSBNYXRoLmZsb29yKCB0aGlzLnogKTtcblx0XHRcdHRoaXMudyA9IE1hdGguZmxvb3IoIHRoaXMudyApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRjZWlsOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHRoaXMueCA9IE1hdGguY2VpbCggdGhpcy54ICk7XG5cdFx0XHR0aGlzLnkgPSBNYXRoLmNlaWwoIHRoaXMueSApO1xuXHRcdFx0dGhpcy56ID0gTWF0aC5jZWlsKCB0aGlzLnogKTtcblx0XHRcdHRoaXMudyA9IE1hdGguY2VpbCggdGhpcy53ICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHJvdW5kOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHRoaXMueCA9IE1hdGgucm91bmQoIHRoaXMueCApO1xuXHRcdFx0dGhpcy55ID0gTWF0aC5yb3VuZCggdGhpcy55ICk7XG5cdFx0XHR0aGlzLnogPSBNYXRoLnJvdW5kKCB0aGlzLnogKTtcblx0XHRcdHRoaXMudyA9IE1hdGgucm91bmQoIHRoaXMudyApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRyb3VuZFRvWmVybzogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR0aGlzLnggPSAoIHRoaXMueCA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy54ICkgOiBNYXRoLmZsb29yKCB0aGlzLnggKTtcblx0XHRcdHRoaXMueSA9ICggdGhpcy55IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnkgKSA6IE1hdGguZmxvb3IoIHRoaXMueSApO1xuXHRcdFx0dGhpcy56ID0gKCB0aGlzLnogPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueiApIDogTWF0aC5mbG9vciggdGhpcy56ICk7XG5cdFx0XHR0aGlzLncgPSAoIHRoaXMudyA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy53ICkgOiBNYXRoLmZsb29yKCB0aGlzLncgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0bmVnYXRlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHRoaXMueCA9IC0gdGhpcy54O1xuXHRcdFx0dGhpcy55ID0gLSB0aGlzLnk7XG5cdFx0XHR0aGlzLnogPSAtIHRoaXMuejtcblx0XHRcdHRoaXMudyA9IC0gdGhpcy53O1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRkb3Q6IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMueCAqIHYueCArIHRoaXMueSAqIHYueSArIHRoaXMueiAqIHYueiArIHRoaXMudyAqIHYudztcblxuXHRcdH0sXG5cblx0XHRsZW5ndGhTcTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56ICsgdGhpcy53ICogdGhpcy53O1xuXG5cdFx0fSxcblxuXHRcdGxlbmd0aDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLnogKyB0aGlzLncgKiB0aGlzLncgKTtcblxuXHRcdH0sXG5cblx0XHRsZW5ndGhNYW5oYXR0YW46IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIE1hdGguYWJzKCB0aGlzLnggKSArIE1hdGguYWJzKCB0aGlzLnkgKSArIE1hdGguYWJzKCB0aGlzLnogKSArIE1hdGguYWJzKCB0aGlzLncgKTtcblxuXHRcdH0sXG5cblx0XHRub3JtYWxpemU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKCB0aGlzLmxlbmd0aCgpICk7XG5cblx0XHR9LFxuXG5cdFx0c2V0TGVuZ3RoOiBmdW5jdGlvbiAoIGxlbmd0aCApIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoIGxlbmd0aCAvIHRoaXMubGVuZ3RoKCkgKTtcblxuXHRcdH0sXG5cblx0XHRsZXJwOiBmdW5jdGlvbiAoIHYsIGFscGhhICkge1xuXG5cdFx0XHR0aGlzLnggKz0gKCB2LnggLSB0aGlzLnggKSAqIGFscGhhO1xuXHRcdFx0dGhpcy55ICs9ICggdi55IC0gdGhpcy55ICkgKiBhbHBoYTtcblx0XHRcdHRoaXMueiArPSAoIHYueiAtIHRoaXMueiApICogYWxwaGE7XG5cdFx0XHR0aGlzLncgKz0gKCB2LncgLSB0aGlzLncgKSAqIGFscGhhO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRsZXJwVmVjdG9yczogZnVuY3Rpb24gKCB2MSwgdjIsIGFscGhhICkge1xuXG5cdFx0XHR0aGlzLnN1YlZlY3RvcnMoIHYyLCB2MSApLm11bHRpcGx5U2NhbGFyKCBhbHBoYSApLmFkZCggdjEgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0ZXF1YWxzOiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHRcdHJldHVybiAoICggdi54ID09PSB0aGlzLnggKSAmJiAoIHYueSA9PT0gdGhpcy55ICkgJiYgKCB2LnogPT09IHRoaXMueiApICYmICggdi53ID09PSB0aGlzLncgKSApO1xuXG5cdFx0fSxcblxuXHRcdGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xuXG5cdFx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuXHRcdFx0dGhpcy54ID0gYXJyYXlbIG9mZnNldCBdO1xuXHRcdFx0dGhpcy55ID0gYXJyYXlbIG9mZnNldCArIDEgXTtcblx0XHRcdHRoaXMueiA9IGFycmF5WyBvZmZzZXQgKyAyIF07XG5cdFx0XHR0aGlzLncgPSBhcnJheVsgb2Zmc2V0ICsgMyBdO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHR0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XG5cblx0XHRcdGlmICggYXJyYXkgPT09IHVuZGVmaW5lZCApIGFycmF5ID0gW107XG5cdFx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuXHRcdFx0YXJyYXlbIG9mZnNldCBdID0gdGhpcy54O1xuXHRcdFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMueTtcblx0XHRcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0aGlzLno7XG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGhpcy53O1xuXG5cdFx0XHRyZXR1cm4gYXJyYXk7XG5cblx0XHR9LFxuXG5cdFx0ZnJvbUF0dHJpYnV0ZTogZnVuY3Rpb24gKCBhdHRyaWJ1dGUsIGluZGV4LCBvZmZzZXQgKSB7XG5cblx0XHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG5cdFx0XHRpbmRleCA9IGluZGV4ICogYXR0cmlidXRlLml0ZW1TaXplICsgb2Zmc2V0O1xuXG5cdFx0XHR0aGlzLnggPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4IF07XG5cdFx0XHR0aGlzLnkgPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4ICsgMSBdO1xuXHRcdFx0dGhpcy56ID0gYXR0cmlidXRlLmFycmF5WyBpbmRleCArIDIgXTtcblx0XHRcdHRoaXMudyA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXggKyAzIF07XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0Ly8gRmlsZTpzcmMvbWF0aC9FdWxlci5qc1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuXHQgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcblx0ICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xuXHQgKi9cblxuXHRUSFJFRS5FdWxlciA9IGZ1bmN0aW9uICggeCwgeSwgeiwgb3JkZXIgKSB7XG5cblx0XHR0aGlzLl94ID0geCB8fCAwO1xuXHRcdHRoaXMuX3kgPSB5IHx8IDA7XG5cdFx0dGhpcy5feiA9IHogfHwgMDtcblx0XHR0aGlzLl9vcmRlciA9IG9yZGVyIHx8IFRIUkVFLkV1bGVyLkRlZmF1bHRPcmRlcjtcblxuXHR9O1xuXG5cdFRIUkVFLkV1bGVyLlJvdGF0aW9uT3JkZXJzID0gWyAnWFlaJywgJ1laWCcsICdaWFknLCAnWFpZJywgJ1lYWicsICdaWVgnIF07XG5cblx0VEhSRUUuRXVsZXIuRGVmYXVsdE9yZGVyID0gJ1hZWic7XG5cblx0VEhSRUUuRXVsZXIucHJvdG90eXBlID0ge1xuXG5cdFx0Y29uc3RydWN0b3I6IFRIUkVFLkV1bGVyLFxuXG5cdFx0Z2V0IHggKCkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5feDtcblxuXHRcdH0sXG5cblx0XHRzZXQgeCAoIHZhbHVlICkge1xuXG5cdFx0XHR0aGlzLl94ID0gdmFsdWU7XG5cdFx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdH0sXG5cblx0XHRnZXQgeSAoKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLl95O1xuXG5cdFx0fSxcblxuXHRcdHNldCB5ICggdmFsdWUgKSB7XG5cblx0XHRcdHRoaXMuX3kgPSB2YWx1ZTtcblx0XHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0fSxcblxuXHRcdGdldCB6ICgpIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuX3o7XG5cblx0XHR9LFxuXG5cdFx0c2V0IHogKCB2YWx1ZSApIHtcblxuXHRcdFx0dGhpcy5feiA9IHZhbHVlO1xuXHRcdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHR9LFxuXG5cdFx0Z2V0IG9yZGVyICgpIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuX29yZGVyO1xuXG5cdFx0fSxcblxuXHRcdHNldCBvcmRlciAoIHZhbHVlICkge1xuXG5cdFx0XHR0aGlzLl9vcmRlciA9IHZhbHVlO1xuXHRcdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHR9LFxuXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHgsIHksIHosIG9yZGVyICkge1xuXG5cdFx0XHR0aGlzLl94ID0geDtcblx0XHRcdHRoaXMuX3kgPSB5O1xuXHRcdFx0dGhpcy5feiA9IHo7XG5cdFx0XHR0aGlzLl9vcmRlciA9IG9yZGVyIHx8IHRoaXMuX29yZGVyO1xuXG5cdFx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLl94LCB0aGlzLl95LCB0aGlzLl96LCB0aGlzLl9vcmRlcik7XG5cblx0XHR9LFxuXG5cdFx0Y29weTogZnVuY3Rpb24gKCBldWxlciApIHtcblxuXHRcdFx0dGhpcy5feCA9IGV1bGVyLl94O1xuXHRcdFx0dGhpcy5feSA9IGV1bGVyLl95O1xuXHRcdFx0dGhpcy5feiA9IGV1bGVyLl96O1xuXHRcdFx0dGhpcy5fb3JkZXIgPSBldWxlci5fb3JkZXI7XG5cblx0XHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRzZXRGcm9tUm90YXRpb25NYXRyaXg6IGZ1bmN0aW9uICggbSwgb3JkZXIsIHVwZGF0ZSApIHtcblxuXHRcdFx0dmFyIGNsYW1wID0gVEhSRUUuTWF0aC5jbGFtcDtcblxuXHRcdFx0Ly8gYXNzdW1lcyB0aGUgdXBwZXIgM3gzIG9mIG0gaXMgYSBwdXJlIHJvdGF0aW9uIG1hdHJpeCAoaS5lLCB1bnNjYWxlZClcblxuXHRcdFx0dmFyIHRlID0gbS5lbGVtZW50cztcblx0XHRcdHZhciBtMTEgPSB0ZVsgMCBdLCBtMTIgPSB0ZVsgNCBdLCBtMTMgPSB0ZVsgOCBdO1xuXHRcdFx0dmFyIG0yMSA9IHRlWyAxIF0sIG0yMiA9IHRlWyA1IF0sIG0yMyA9IHRlWyA5IF07XG5cdFx0XHR2YXIgbTMxID0gdGVbIDIgXSwgbTMyID0gdGVbIDYgXSwgbTMzID0gdGVbIDEwIF07XG5cblx0XHRcdG9yZGVyID0gb3JkZXIgfHwgdGhpcy5fb3JkZXI7XG5cblx0XHRcdGlmICggb3JkZXIgPT09ICdYWVonICkge1xuXG5cdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmFzaW4oIGNsYW1wKCBtMTMsIC0gMSwgMSApICk7XG5cblx0XHRcdFx0aWYgKCBNYXRoLmFicyggbTEzICkgPCAwLjk5OTk5ICkge1xuXG5cdFx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIC0gbTIzLCBtMzMgKTtcblx0XHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hdGFuMiggLSBtMTIsIG0xMSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMiggbTMyLCBtMjIgKTtcblx0XHRcdFx0XHR0aGlzLl96ID0gMDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWVhaJyApIHtcblxuXHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hc2luKCAtIGNsYW1wKCBtMjMsIC0gMSwgMSApICk7XG5cblx0XHRcdFx0aWYgKCBNYXRoLmFicyggbTIzICkgPCAwLjk5OTk5ICkge1xuXG5cdFx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIG0xMywgbTMzICk7XG5cdFx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIG0yMSwgbTIyICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmF0YW4yKCAtIG0zMSwgbTExICk7XG5cdFx0XHRcdFx0dGhpcy5feiA9IDA7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1pYWScgKSB7XG5cblx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXNpbiggY2xhbXAoIG0zMiwgLSAxLCAxICkgKTtcblxuXHRcdFx0XHRpZiAoIE1hdGguYWJzKCBtMzIgKSA8IDAuOTk5OTkgKSB7XG5cblx0XHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggLSBtMzEsIG0zMyApO1xuXHRcdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCAtIG0xMiwgbTIyICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHRoaXMuX3kgPSAwO1xuXHRcdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCBtMjEsIG0xMSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdaWVgnICkge1xuXG5cdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmFzaW4oIC0gY2xhbXAoIG0zMSwgLSAxLCAxICkgKTtcblxuXHRcdFx0XHRpZiAoIE1hdGguYWJzKCBtMzEgKSA8IDAuOTk5OTkgKSB7XG5cblx0XHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMiggbTMyLCBtMzMgKTtcblx0XHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hdGFuMiggbTIxLCBtMTEgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dGhpcy5feCA9IDA7XG5cdFx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIC0gbTEyLCBtMjIgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWVpYJyApIHtcblxuXHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hc2luKCBjbGFtcCggbTIxLCAtIDEsIDEgKSApO1xuXG5cdFx0XHRcdGlmICggTWF0aC5hYnMoIG0yMSApIDwgMC45OTk5OSApIHtcblxuXHRcdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKCAtIG0yMywgbTIyICk7XG5cdFx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIC0gbTMxLCBtMTEgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dGhpcy5feCA9IDA7XG5cdFx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIG0xMywgbTMzICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1haWScgKSB7XG5cblx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXNpbiggLSBjbGFtcCggbTEyLCAtIDEsIDEgKSApO1xuXG5cdFx0XHRcdGlmICggTWF0aC5hYnMoIG0xMiApIDwgMC45OTk5OSApIHtcblxuXHRcdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKCBtMzIsIG0yMiApO1xuXHRcdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmF0YW4yKCBtMTMsIG0xMSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMiggLSBtMjMsIG0zMyApO1xuXHRcdFx0XHRcdHRoaXMuX3kgPSAwO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5FdWxlcjogLnNldEZyb21Sb3RhdGlvbk1hdHJpeCgpIGdpdmVuIHVuc3VwcG9ydGVkIG9yZGVyOiAnICsgb3JkZXIgKVxuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX29yZGVyID0gb3JkZXI7XG5cblx0XHRcdGlmICggdXBkYXRlICE9PSBmYWxzZSApIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRzZXRGcm9tUXVhdGVybmlvbjogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgbWF0cml4O1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKCBxLCBvcmRlciwgdXBkYXRlICkge1xuXG5cdFx0XHRcdGlmICggbWF0cml4ID09PSB1bmRlZmluZWQgKSBtYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXHRcdFx0XHRtYXRyaXgubWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24oIHEgKTtcblx0XHRcdFx0dGhpcy5zZXRGcm9tUm90YXRpb25NYXRyaXgoIG1hdHJpeCwgb3JkZXIsIHVwZGF0ZSApO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0XHR9O1xuXG5cdFx0fSgpLFxuXG5cdFx0c2V0RnJvbVZlY3RvcjM6IGZ1bmN0aW9uICggdiwgb3JkZXIgKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLnNldCggdi54LCB2LnksIHYueiwgb3JkZXIgfHwgdGhpcy5fb3JkZXIgKTtcblxuXHRcdH0sXG5cblx0XHRyZW9yZGVyOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdC8vIFdBUk5JTkc6IHRoaXMgZGlzY2FyZHMgcmV2b2x1dGlvbiBpbmZvcm1hdGlvbiAtYmhvdXN0b25cblxuXHRcdFx0dmFyIHEgPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKCBuZXdPcmRlciApIHtcblxuXHRcdFx0XHRxLnNldEZyb21FdWxlciggdGhpcyApO1xuXHRcdFx0XHR0aGlzLnNldEZyb21RdWF0ZXJuaW9uKCBxLCBuZXdPcmRlciApO1xuXG5cdFx0XHR9O1xuXG5cdFx0fSgpLFxuXG5cdFx0ZXF1YWxzOiBmdW5jdGlvbiAoIGV1bGVyICkge1xuXG5cdFx0XHRyZXR1cm4gKCBldWxlci5feCA9PT0gdGhpcy5feCApICYmICggZXVsZXIuX3kgPT09IHRoaXMuX3kgKSAmJiAoIGV1bGVyLl96ID09PSB0aGlzLl96ICkgJiYgKCBldWxlci5fb3JkZXIgPT09IHRoaXMuX29yZGVyICk7XG5cblx0XHR9LFxuXG5cdFx0ZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5ICkge1xuXG5cdFx0XHR0aGlzLl94ID0gYXJyYXlbIDAgXTtcblx0XHRcdHRoaXMuX3kgPSBhcnJheVsgMSBdO1xuXHRcdFx0dGhpcy5feiA9IGFycmF5WyAyIF07XG5cdFx0XHRpZiAoIGFycmF5WyAzIF0gIT09IHVuZGVmaW5lZCApIHRoaXMuX29yZGVyID0gYXJyYXlbIDMgXTtcblxuXHRcdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHRvQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcblxuXHRcdFx0aWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcblx0XHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG5cdFx0XHRhcnJheVsgb2Zmc2V0IF0gPSB0aGlzLl94O1xuXHRcdFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMuX3k7XG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGhpcy5fejtcblx0XHRcdGFycmF5WyBvZmZzZXQgKyAzIF0gPSB0aGlzLl9vcmRlcjtcblxuXHRcdFx0cmV0dXJuIGFycmF5O1xuXG5cdFx0fSxcblxuXHRcdHRvVmVjdG9yMzogZnVuY3Rpb24gKCBvcHRpb25hbFJlc3VsdCApIHtcblxuXHRcdFx0aWYgKCBvcHRpb25hbFJlc3VsdCApIHtcblxuXHRcdFx0XHRyZXR1cm4gb3B0aW9uYWxSZXN1bHQuc2V0KCB0aGlzLl94LCB0aGlzLl95LCB0aGlzLl96ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0cmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IzKCB0aGlzLl94LCB0aGlzLl95LCB0aGlzLl96ICk7XG5cblx0XHRcdH1cblxuXHRcdH0sXG5cblx0XHRvbkNoYW5nZTogZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcblxuXHRcdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrID0gY2FsbGJhY2s7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdG9uQ2hhbmdlQ2FsbGJhY2s6IGZ1bmN0aW9uICgpIHt9XG5cblx0fTtcblxuXHQvLyBGaWxlOnNyYy9tYXRoL0xpbmUzLmpzXG5cblx0LyoqXG5cdCAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cblx0ICovXG5cblx0VEhSRUUuTGluZTMgPSBmdW5jdGlvbiAoIHN0YXJ0LCBlbmQgKSB7XG5cblx0XHR0aGlzLnN0YXJ0ID0gKCBzdGFydCAhPT0gdW5kZWZpbmVkICkgPyBzdGFydCA6IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0dGhpcy5lbmQgPSAoIGVuZCAhPT0gdW5kZWZpbmVkICkgPyBlbmQgOiBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdH07XG5cblx0VEhSRUUuTGluZTMucHJvdG90eXBlID0ge1xuXG5cdFx0Y29uc3RydWN0b3I6IFRIUkVFLkxpbmUzLFxuXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHN0YXJ0LCBlbmQgKSB7XG5cblx0XHRcdHRoaXMuc3RhcnQuY29weSggc3RhcnQgKTtcblx0XHRcdHRoaXMuZW5kLmNvcHkoIGVuZCApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cblx0XHR9LFxuXG5cdFx0Y29weTogZnVuY3Rpb24gKCBsaW5lICkge1xuXG5cdFx0XHR0aGlzLnN0YXJ0LmNvcHkoIGxpbmUuc3RhcnQgKTtcblx0XHRcdHRoaXMuZW5kLmNvcHkoIGxpbmUuZW5kICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGNlbnRlcjogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0XHRyZXR1cm4gcmVzdWx0LmFkZFZlY3RvcnMoIHRoaXMuc3RhcnQsIHRoaXMuZW5kICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xuXG5cdFx0fSxcblxuXHRcdGRlbHRhOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHRcdHJldHVybiByZXN1bHQuc3ViVmVjdG9ycyggdGhpcy5lbmQsIHRoaXMuc3RhcnQgKTtcblxuXHRcdH0sXG5cblx0XHRkaXN0YW5jZVNxOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLnN0YXJ0LmRpc3RhbmNlVG9TcXVhcmVkKCB0aGlzLmVuZCApO1xuXG5cdFx0fSxcblxuXHRcdGRpc3RhbmNlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLnN0YXJ0LmRpc3RhbmNlVG8oIHRoaXMuZW5kICk7XG5cblx0XHR9LFxuXG5cdFx0YXQ6IGZ1bmN0aW9uICggdCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5kZWx0YSggcmVzdWx0ICkubXVsdGlwbHlTY2FsYXIoIHQgKS5hZGQoIHRoaXMuc3RhcnQgKTtcblxuXHRcdH0sXG5cblx0XHRjbG9zZXN0UG9pbnRUb1BvaW50UGFyYW1ldGVyOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciBzdGFydFAgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdFx0dmFyIHN0YXJ0RW5kID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uICggcG9pbnQsIGNsYW1wVG9MaW5lICkge1xuXG5cdFx0XHRcdHN0YXJ0UC5zdWJWZWN0b3JzKCBwb2ludCwgdGhpcy5zdGFydCApO1xuXHRcdFx0XHRzdGFydEVuZC5zdWJWZWN0b3JzKCB0aGlzLmVuZCwgdGhpcy5zdGFydCApO1xuXG5cdFx0XHRcdHZhciBzdGFydEVuZDIgPSBzdGFydEVuZC5kb3QoIHN0YXJ0RW5kICk7XG5cdFx0XHRcdHZhciBzdGFydEVuZF9zdGFydFAgPSBzdGFydEVuZC5kb3QoIHN0YXJ0UCApO1xuXG5cdFx0XHRcdHZhciB0ID0gc3RhcnRFbmRfc3RhcnRQIC8gc3RhcnRFbmQyO1xuXG5cdFx0XHRcdGlmICggY2xhbXBUb0xpbmUgKSB7XG5cblx0XHRcdFx0XHR0ID0gVEhSRUUuTWF0aC5jbGFtcCggdCwgMCwgMSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdDtcblxuXHRcdFx0fTtcblxuXHRcdH0oKSxcblxuXHRcdGNsb3Nlc3RQb2ludFRvUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIGNsYW1wVG9MaW5lLCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdFx0dmFyIHQgPSB0aGlzLmNsb3Nlc3RQb2ludFRvUG9pbnRQYXJhbWV0ZXIoIHBvaW50LCBjbGFtcFRvTGluZSApO1xuXG5cdFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdFx0cmV0dXJuIHRoaXMuZGVsdGEoIHJlc3VsdCApLm11bHRpcGx5U2NhbGFyKCB0ICkuYWRkKCB0aGlzLnN0YXJ0ICk7XG5cblx0XHR9LFxuXG5cdFx0YXBwbHlNYXRyaXg0OiBmdW5jdGlvbiAoIG1hdHJpeCApIHtcblxuXHRcdFx0dGhpcy5zdGFydC5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xuXHRcdFx0dGhpcy5lbmQuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0ZXF1YWxzOiBmdW5jdGlvbiAoIGxpbmUgKSB7XG5cblx0XHRcdHJldHVybiBsaW5lLnN0YXJ0LmVxdWFscyggdGhpcy5zdGFydCApICYmIGxpbmUuZW5kLmVxdWFscyggdGhpcy5lbmQgKTtcblxuXHRcdH1cblxuXHR9O1xuXG5cdC8vIEZpbGU6c3JjL21hdGgvQm94Mi5qc1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXG5cdCAqL1xuXG5cdFRIUkVFLkJveDIgPSBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xuXG5cdFx0dGhpcy5taW4gPSAoIG1pbiAhPT0gdW5kZWZpbmVkICkgPyBtaW4gOiBuZXcgVEhSRUUuVmVjdG9yMiggSW5maW5pdHksIEluZmluaXR5ICk7XG5cdFx0dGhpcy5tYXggPSAoIG1heCAhPT0gdW5kZWZpbmVkICkgPyBtYXggOiBuZXcgVEhSRUUuVmVjdG9yMiggLSBJbmZpbml0eSwgLSBJbmZpbml0eSApO1xuXG5cdH07XG5cblx0VEhSRUUuQm94Mi5wcm90b3R5cGUgPSB7XG5cblx0XHRjb25zdHJ1Y3RvcjogVEhSRUUuQm94MixcblxuXHRcdHNldDogZnVuY3Rpb24gKCBtaW4sIG1heCApIHtcblxuXHRcdFx0dGhpcy5taW4uY29weSggbWluICk7XG5cdFx0XHR0aGlzLm1heC5jb3B5KCBtYXggKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0c2V0RnJvbVBvaW50czogZnVuY3Rpb24gKCBwb2ludHMgKSB7XG5cblx0XHRcdHRoaXMubWFrZUVtcHR5KCk7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0dGhpcy5leHBhbmRCeVBvaW50KCBwb2ludHNbIGkgXSApXG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0c2V0RnJvbUNlbnRlckFuZFNpemU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uICggY2VudGVyLCBzaXplICkge1xuXG5cdFx0XHRcdHZhciBoYWxmU2l6ZSA9IHYxLmNvcHkoIHNpemUgKS5tdWx0aXBseVNjYWxhciggMC41ICk7XG5cdFx0XHRcdHRoaXMubWluLmNvcHkoIGNlbnRlciApLnN1YiggaGFsZlNpemUgKTtcblx0XHRcdFx0dGhpcy5tYXguY29weSggY2VudGVyICkuYWRkKCBoYWxmU2l6ZSApO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0XHR9O1xuXG5cdFx0fSgpLFxuXHRcdFxuXHRcdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuXHRcdH0sXG5cblx0XHRjb3B5OiBmdW5jdGlvbiAoIGJveCApIHtcblxuXHRcdFx0dGhpcy5taW4uY29weSggYm94Lm1pbiApO1xuXHRcdFx0dGhpcy5tYXguY29weSggYm94Lm1heCApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRtYWtlRW1wdHk6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dGhpcy5taW4ueCA9IHRoaXMubWluLnkgPSBJbmZpbml0eTtcblx0XHRcdHRoaXMubWF4LnggPSB0aGlzLm1heC55ID0gLSBJbmZpbml0eTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0ZW1wdHk6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Ly8gdGhpcyBpcyBhIG1vcmUgcm9idXN0IGNoZWNrIGZvciBlbXB0eSB0aGFuICggdm9sdW1lIDw9IDAgKSBiZWNhdXNlIHZvbHVtZSBjYW4gZ2V0IHBvc2l0aXZlIHdpdGggdHdvIG5lZ2F0aXZlIGF4ZXNcblxuXHRcdFx0cmV0dXJuICggdGhpcy5tYXgueCA8IHRoaXMubWluLnggKSB8fCAoIHRoaXMubWF4LnkgPCB0aGlzLm1pbi55ICk7XG5cblx0XHR9LFxuXG5cdFx0Y2VudGVyOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjIoKTtcblx0XHRcdHJldHVybiByZXN1bHQuYWRkVmVjdG9ycyggdGhpcy5taW4sIHRoaXMubWF4ICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xuXG5cdFx0fSxcblxuXHRcdHNpemU6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXHRcdFx0cmV0dXJuIHJlc3VsdC5zdWJWZWN0b3JzKCB0aGlzLm1heCwgdGhpcy5taW4gKTtcblxuXHRcdH0sXG5cblx0XHRleHBhbmRCeVBvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xuXG5cdFx0XHR0aGlzLm1pbi5taW4oIHBvaW50ICk7XG5cdFx0XHR0aGlzLm1heC5tYXgoIHBvaW50ICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGV4cGFuZEJ5VmVjdG9yOiBmdW5jdGlvbiAoIHZlY3RvciApIHtcblxuXHRcdFx0dGhpcy5taW4uc3ViKCB2ZWN0b3IgKTtcblx0XHRcdHRoaXMubWF4LmFkZCggdmVjdG9yICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGV4cGFuZEJ5U2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcblxuXHRcdFx0dGhpcy5taW4uYWRkU2NhbGFyKCAtIHNjYWxhciApO1xuXHRcdFx0dGhpcy5tYXguYWRkU2NhbGFyKCBzY2FsYXIgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0Y29udGFpbnNQb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcblxuXHRcdFx0aWYgKCBwb2ludC54IDwgdGhpcy5taW4ueCB8fCBwb2ludC54ID4gdGhpcy5tYXgueCB8fFxuXHRcdFx0ICAgICBwb2ludC55IDwgdGhpcy5taW4ueSB8fCBwb2ludC55ID4gdGhpcy5tYXgueSApIHtcblxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHR9LFxuXG5cdFx0Y29udGFpbnNCb3g6IGZ1bmN0aW9uICggYm94ICkge1xuXG5cdFx0XHRpZiAoICggdGhpcy5taW4ueCA8PSBib3gubWluLnggKSAmJiAoIGJveC5tYXgueCA8PSB0aGlzLm1heC54ICkgJiZcblx0XHRcdCAgICAgKCB0aGlzLm1pbi55IDw9IGJveC5taW4ueSApICYmICggYm94Lm1heC55IDw9IHRoaXMubWF4LnkgKSApIHtcblxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHR9LFxuXG5cdFx0Z2V0UGFyYW1ldGVyOiBmdW5jdGlvbiAoIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdFx0Ly8gVGhpcyBjYW4gcG90ZW50aWFsbHkgaGF2ZSBhIGRpdmlkZSBieSB6ZXJvIGlmIHRoZSBib3hcblx0XHRcdC8vIGhhcyBhIHNpemUgZGltZW5zaW9uIG9mIDAuXG5cblx0XHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXG5cdFx0XHRyZXR1cm4gcmVzdWx0LnNldChcblx0XHRcdFx0KCBwb2ludC54IC0gdGhpcy5taW4ueCApIC8gKCB0aGlzLm1heC54IC0gdGhpcy5taW4ueCApLFxuXHRcdFx0XHQoIHBvaW50LnkgLSB0aGlzLm1pbi55ICkgLyAoIHRoaXMubWF4LnkgLSB0aGlzLm1pbi55IClcblx0XHRcdCk7XG5cblx0XHR9LFxuXG5cdFx0aXNJbnRlcnNlY3Rpb25Cb3g6IGZ1bmN0aW9uICggYm94ICkge1xuXG5cdFx0XHQvLyB1c2luZyA2IHNwbGl0dGluZyBwbGFuZXMgdG8gcnVsZSBvdXQgaW50ZXJzZWN0aW9ucy5cblxuXHRcdFx0aWYgKCBib3gubWF4LnggPCB0aGlzLm1pbi54IHx8IGJveC5taW4ueCA+IHRoaXMubWF4LnggfHxcblx0XHRcdCAgICAgYm94Lm1heC55IDwgdGhpcy5taW4ueSB8fCBib3gubWluLnkgPiB0aGlzLm1heC55ICkge1xuXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdH0sXG5cblx0XHRjbGFtcFBvaW50OiBmdW5jdGlvbiAoIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cdFx0XHRyZXR1cm4gcmVzdWx0LmNvcHkoIHBvaW50ICkuY2xhbXAoIHRoaXMubWluLCB0aGlzLm1heCApO1xuXG5cdFx0fSxcblxuXHRcdGRpc3RhbmNlVG9Qb2ludDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKCBwb2ludCApIHtcblxuXHRcdFx0XHR2YXIgY2xhbXBlZFBvaW50ID0gdjEuY29weSggcG9pbnQgKS5jbGFtcCggdGhpcy5taW4sIHRoaXMubWF4ICk7XG5cdFx0XHRcdHJldHVybiBjbGFtcGVkUG9pbnQuc3ViKCBwb2ludCApLmxlbmd0aCgpO1xuXG5cdFx0XHR9O1xuXG5cdFx0fSgpLFxuXG5cdFx0aW50ZXJzZWN0OiBmdW5jdGlvbiAoIGJveCApIHtcblxuXHRcdFx0dGhpcy5taW4ubWF4KCBib3gubWluICk7XG5cdFx0XHR0aGlzLm1heC5taW4oIGJveC5tYXggKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0dW5pb246IGZ1bmN0aW9uICggYm94ICkge1xuXG5cdFx0XHR0aGlzLm1pbi5taW4oIGJveC5taW4gKTtcblx0XHRcdHRoaXMubWF4Lm1heCggYm94Lm1heCApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHR0cmFuc2xhdGU6IGZ1bmN0aW9uICggb2Zmc2V0ICkge1xuXG5cdFx0XHR0aGlzLm1pbi5hZGQoIG9mZnNldCApO1xuXHRcdFx0dGhpcy5tYXguYWRkKCBvZmZzZXQgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0ZXF1YWxzOiBmdW5jdGlvbiAoIGJveCApIHtcblxuXHRcdFx0cmV0dXJuIGJveC5taW4uZXF1YWxzKCB0aGlzLm1pbiApICYmIGJveC5tYXguZXF1YWxzKCB0aGlzLm1heCApO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0Ly8gRmlsZTpzcmMvbWF0aC9Cb3gzLmpzXG5cblx0LyoqXG5cdCAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cblx0ICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG5cdCAqL1xuXG5cdFRIUkVFLkJveDMgPSBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xuXG5cdFx0dGhpcy5taW4gPSAoIG1pbiAhPT0gdW5kZWZpbmVkICkgPyBtaW4gOiBuZXcgVEhSRUUuVmVjdG9yMyggSW5maW5pdHksIEluZmluaXR5LCBJbmZpbml0eSApO1xuXHRcdHRoaXMubWF4ID0gKCBtYXggIT09IHVuZGVmaW5lZCApID8gbWF4IDogbmV3IFRIUkVFLlZlY3RvcjMoIC0gSW5maW5pdHksIC0gSW5maW5pdHksIC0gSW5maW5pdHkgKTtcblxuXHR9O1xuXG5cdFRIUkVFLkJveDMucHJvdG90eXBlID0ge1xuXG5cdFx0Y29uc3RydWN0b3I6IFRIUkVFLkJveDMsXG5cblx0XHRzZXQ6IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XG5cblx0XHRcdHRoaXMubWluLmNvcHkoIG1pbiApO1xuXHRcdFx0dGhpcy5tYXguY29weSggbWF4ICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHNldEZyb21Qb2ludHM6IGZ1bmN0aW9uICggcG9pbnRzICkge1xuXG5cdFx0XHR0aGlzLm1ha2VFbXB0eSgpO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdHRoaXMuZXhwYW5kQnlQb2ludCggcG9pbnRzWyBpIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRzZXRGcm9tQ2VudGVyQW5kU2l6ZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKCBjZW50ZXIsIHNpemUgKSB7XG5cblx0XHRcdFx0dmFyIGhhbGZTaXplID0gdjEuY29weSggc2l6ZSApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcblxuXHRcdFx0XHR0aGlzLm1pbi5jb3B5KCBjZW50ZXIgKS5zdWIoIGhhbGZTaXplICk7XG5cdFx0XHRcdHRoaXMubWF4LmNvcHkoIGNlbnRlciApLmFkZCggaGFsZlNpemUgKTtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdFx0fTtcblxuXHRcdH0oKSxcblxuXHRcdHNldEZyb21PYmplY3Q6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Ly8gQ29tcHV0ZXMgdGhlIHdvcmxkLWF4aXMtYWxpZ25lZCBib3VuZGluZyBib3ggb2YgYW4gb2JqZWN0IChpbmNsdWRpbmcgaXRzIGNoaWxkcmVuKSxcblx0XHRcdC8vIGFjY291bnRpbmcgZm9yIGJvdGggdGhlIG9iamVjdCdzLCBhbmQgY2hpbGRyZW4ncywgd29ybGQgdHJhbnNmb3Jtc1xuXG5cdFx0XHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cblx0XHRcdFx0dmFyIHNjb3BlID0gdGhpcztcblxuXHRcdFx0XHRvYmplY3QudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcblxuXHRcdFx0XHR0aGlzLm1ha2VFbXB0eSgpO1xuXG5cdFx0XHRcdG9iamVjdC50cmF2ZXJzZSggZnVuY3Rpb24gKCBub2RlICkge1xuXG5cdFx0XHRcdFx0dmFyIGdlb21ldHJ5ID0gbm9kZS5nZW9tZXRyeTtcblxuXHRcdFx0XHRcdGlmICggZ2VvbWV0cnkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5ICkge1xuXG5cdFx0XHRcdFx0XHRcdHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzO1xuXG5cdFx0XHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSB2ZXJ0aWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRcdHYxLmNvcHkoIHZlcnRpY2VzWyBpIF0gKTtcblxuXHRcdFx0XHRcdFx0XHRcdHYxLmFwcGx5TWF0cml4NCggbm9kZS5tYXRyaXhXb3JsZCApO1xuXG5cdFx0XHRcdFx0XHRcdFx0c2NvcGUuZXhwYW5kQnlQb2ludCggdjEgKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkgJiYgZ2VvbWV0cnkuYXR0cmlidXRlc1sgJ3Bvc2l0aW9uJyBdICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0dmFyIHBvc2l0aW9ucyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXNbICdwb3NpdGlvbicgXS5hcnJheTtcblxuXHRcdFx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGlsOyBpICs9IDMgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHR2MS5zZXQoIHBvc2l0aW9uc1sgaSBdLCBwb3NpdGlvbnNbIGkgKyAxIF0sIHBvc2l0aW9uc1sgaSArIDIgXSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0djEuYXBwbHlNYXRyaXg0KCBub2RlLm1hdHJpeFdvcmxkICk7XG5cblx0XHRcdFx0XHRcdFx0XHRzY29wZS5leHBhbmRCeVBvaW50KCB2MSApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gKTtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdFx0fTtcblxuXHRcdH0oKSxcblxuXHRcdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuXHRcdH0sXG5cblx0XHRjb3B5OiBmdW5jdGlvbiAoIGJveCApIHtcblxuXHRcdFx0dGhpcy5taW4uY29weSggYm94Lm1pbiApO1xuXHRcdFx0dGhpcy5tYXguY29weSggYm94Lm1heCApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRtYWtlRW1wdHk6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dGhpcy5taW4ueCA9IHRoaXMubWluLnkgPSB0aGlzLm1pbi56ID0gSW5maW5pdHk7XG5cdFx0XHR0aGlzLm1heC54ID0gdGhpcy5tYXgueSA9IHRoaXMubWF4LnogPSAtIEluZmluaXR5O1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRlbXB0eTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHQvLyB0aGlzIGlzIGEgbW9yZSByb2J1c3QgY2hlY2sgZm9yIGVtcHR5IHRoYW4gKCB2b2x1bWUgPD0gMCApIGJlY2F1c2Ugdm9sdW1lIGNhbiBnZXQgcG9zaXRpdmUgd2l0aCB0d28gbmVnYXRpdmUgYXhlc1xuXG5cdFx0XHRyZXR1cm4gKCB0aGlzLm1heC54IDwgdGhpcy5taW4ueCApIHx8ICggdGhpcy5tYXgueSA8IHRoaXMubWluLnkgKSB8fCAoIHRoaXMubWF4LnogPCB0aGlzLm1pbi56ICk7XG5cblx0XHR9LFxuXG5cdFx0Y2VudGVyOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHRcdHJldHVybiByZXN1bHQuYWRkVmVjdG9ycyggdGhpcy5taW4sIHRoaXMubWF4ICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xuXG5cdFx0fSxcblxuXHRcdHNpemU6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdFx0cmV0dXJuIHJlc3VsdC5zdWJWZWN0b3JzKCB0aGlzLm1heCwgdGhpcy5taW4gKTtcblxuXHRcdH0sXG5cblx0XHRleHBhbmRCeVBvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xuXG5cdFx0XHR0aGlzLm1pbi5taW4oIHBvaW50ICk7XG5cdFx0XHR0aGlzLm1heC5tYXgoIHBvaW50ICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGV4cGFuZEJ5VmVjdG9yOiBmdW5jdGlvbiAoIHZlY3RvciApIHtcblxuXHRcdFx0dGhpcy5taW4uc3ViKCB2ZWN0b3IgKTtcblx0XHRcdHRoaXMubWF4LmFkZCggdmVjdG9yICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGV4cGFuZEJ5U2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcblxuXHRcdFx0dGhpcy5taW4uYWRkU2NhbGFyKCAtIHNjYWxhciApO1xuXHRcdFx0dGhpcy5tYXguYWRkU2NhbGFyKCBzY2FsYXIgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0Y29udGFpbnNQb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcblxuXHRcdFx0aWYgKCBwb2ludC54IDwgdGhpcy5taW4ueCB8fCBwb2ludC54ID4gdGhpcy5tYXgueCB8fFxuXHRcdFx0ICAgICBwb2ludC55IDwgdGhpcy5taW4ueSB8fCBwb2ludC55ID4gdGhpcy5tYXgueSB8fFxuXHRcdFx0ICAgICBwb2ludC56IDwgdGhpcy5taW4ueiB8fCBwb2ludC56ID4gdGhpcy5tYXgueiApIHtcblxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHR9LFxuXG5cdFx0Y29udGFpbnNCb3g6IGZ1bmN0aW9uICggYm94ICkge1xuXG5cdFx0XHRpZiAoICggdGhpcy5taW4ueCA8PSBib3gubWluLnggKSAmJiAoIGJveC5tYXgueCA8PSB0aGlzLm1heC54ICkgJiZcblx0XHRcdFx0ICggdGhpcy5taW4ueSA8PSBib3gubWluLnkgKSAmJiAoIGJveC5tYXgueSA8PSB0aGlzLm1heC55ICkgJiZcblx0XHRcdFx0ICggdGhpcy5taW4ueiA8PSBib3gubWluLnogKSAmJiAoIGJveC5tYXgueiA8PSB0aGlzLm1heC56ICkgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0fSxcblxuXHRcdGdldFBhcmFtZXRlcjogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHRcdC8vIFRoaXMgY2FuIHBvdGVudGlhbGx5IGhhdmUgYSBkaXZpZGUgYnkgemVybyBpZiB0aGUgYm94XG5cdFx0XHQvLyBoYXMgYSBzaXplIGRpbWVuc2lvbiBvZiAwLlxuXG5cdFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdFx0cmV0dXJuIHJlc3VsdC5zZXQoXG5cdFx0XHRcdCggcG9pbnQueCAtIHRoaXMubWluLnggKSAvICggdGhpcy5tYXgueCAtIHRoaXMubWluLnggKSxcblx0XHRcdFx0KCBwb2ludC55IC0gdGhpcy5taW4ueSApIC8gKCB0aGlzLm1heC55IC0gdGhpcy5taW4ueSApLFxuXHRcdFx0XHQoIHBvaW50LnogLSB0aGlzLm1pbi56ICkgLyAoIHRoaXMubWF4LnogLSB0aGlzLm1pbi56IClcblx0XHRcdCk7XG5cblx0XHR9LFxuXG5cdFx0aXNJbnRlcnNlY3Rpb25Cb3g6IGZ1bmN0aW9uICggYm94ICkge1xuXG5cdFx0XHQvLyB1c2luZyA2IHNwbGl0dGluZyBwbGFuZXMgdG8gcnVsZSBvdXQgaW50ZXJzZWN0aW9ucy5cblxuXHRcdFx0aWYgKCBib3gubWF4LnggPCB0aGlzLm1pbi54IHx8IGJveC5taW4ueCA+IHRoaXMubWF4LnggfHxcblx0XHRcdCAgICAgYm94Lm1heC55IDwgdGhpcy5taW4ueSB8fCBib3gubWluLnkgPiB0aGlzLm1heC55IHx8XG5cdFx0XHQgICAgIGJveC5tYXgueiA8IHRoaXMubWluLnogfHwgYm94Lm1pbi56ID4gdGhpcy5tYXgueiApIHtcblxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHR9LFxuXG5cdFx0Y2xhbXBQb2ludDogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdFx0cmV0dXJuIHJlc3VsdC5jb3B5KCBwb2ludCApLmNsYW1wKCB0aGlzLm1pbiwgdGhpcy5tYXggKTtcblxuXHRcdH0sXG5cblx0XHRkaXN0YW5jZVRvUG9pbnQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uICggcG9pbnQgKSB7XG5cblx0XHRcdFx0dmFyIGNsYW1wZWRQb2ludCA9IHYxLmNvcHkoIHBvaW50ICkuY2xhbXAoIHRoaXMubWluLCB0aGlzLm1heCApO1xuXHRcdFx0XHRyZXR1cm4gY2xhbXBlZFBvaW50LnN1YiggcG9pbnQgKS5sZW5ndGgoKTtcblxuXHRcdFx0fTtcblxuXHRcdH0oKSxcblxuXHRcdGdldEJvdW5kaW5nU3BoZXJlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0XHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuU3BoZXJlKCk7XG5cblx0XHRcdFx0cmVzdWx0LmNlbnRlciA9IHRoaXMuY2VudGVyKCk7XG5cdFx0XHRcdHJlc3VsdC5yYWRpdXMgPSB0aGlzLnNpemUoIHYxICkubGVuZ3RoKCkgKiAwLjU7XG5cblx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblxuXHRcdFx0fTtcblxuXHRcdH0oKSxcblxuXHRcdGludGVyc2VjdDogZnVuY3Rpb24gKCBib3ggKSB7XG5cblx0XHRcdHRoaXMubWluLm1heCggYm94Lm1pbiApO1xuXHRcdFx0dGhpcy5tYXgubWluKCBib3gubWF4ICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHVuaW9uOiBmdW5jdGlvbiAoIGJveCApIHtcblxuXHRcdFx0dGhpcy5taW4ubWluKCBib3gubWluICk7XG5cdFx0XHR0aGlzLm1heC5tYXgoIGJveC5tYXggKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0YXBwbHlNYXRyaXg0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciBwb2ludHMgPSBbXG5cdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IzKCksXG5cdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IzKCksXG5cdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IzKCksXG5cdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IzKCksXG5cdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IzKCksXG5cdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IzKCksXG5cdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IzKCksXG5cdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IzKClcblx0XHRcdF07XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiAoIG1hdHJpeCApIHtcblxuXHRcdFx0XHQvLyBOT1RFOiBJIGFtIHVzaW5nIGEgYmluYXJ5IHBhdHRlcm4gdG8gc3BlY2lmeSBhbGwgMl4zIGNvbWJpbmF0aW9ucyBiZWxvd1xuXHRcdFx0XHRwb2ludHNbIDAgXS5zZXQoIHRoaXMubWluLngsIHRoaXMubWluLnksIHRoaXMubWluLnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAwMDBcblx0XHRcdFx0cG9pbnRzWyAxIF0uc2V0KCB0aGlzLm1pbi54LCB0aGlzLm1pbi55LCB0aGlzLm1heC56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMDAxXG5cdFx0XHRcdHBvaW50c1sgMiBdLnNldCggdGhpcy5taW4ueCwgdGhpcy5tYXgueSwgdGhpcy5taW4ueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDAxMFxuXHRcdFx0XHRwb2ludHNbIDMgXS5zZXQoIHRoaXMubWluLngsIHRoaXMubWF4LnksIHRoaXMubWF4LnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAwMTFcblx0XHRcdFx0cG9pbnRzWyA0IF0uc2V0KCB0aGlzLm1heC54LCB0aGlzLm1pbi55LCB0aGlzLm1pbi56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMTAwXG5cdFx0XHRcdHBvaW50c1sgNSBdLnNldCggdGhpcy5tYXgueCwgdGhpcy5taW4ueSwgdGhpcy5tYXgueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDEwMVxuXHRcdFx0XHRwb2ludHNbIDYgXS5zZXQoIHRoaXMubWF4LngsIHRoaXMubWF4LnksIHRoaXMubWluLnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAxMTBcblx0XHRcdFx0cG9pbnRzWyA3IF0uc2V0KCB0aGlzLm1heC54LCB0aGlzLm1heC55LCB0aGlzLm1heC56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgIC8vIDExMVxuXG5cdFx0XHRcdHRoaXMubWFrZUVtcHR5KCk7XG5cdFx0XHRcdHRoaXMuc2V0RnJvbVBvaW50cyggcG9pbnRzICk7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdH07XG5cblx0XHR9KCksXG5cblx0XHR0cmFuc2xhdGU6IGZ1bmN0aW9uICggb2Zmc2V0ICkge1xuXG5cdFx0XHR0aGlzLm1pbi5hZGQoIG9mZnNldCApO1xuXHRcdFx0dGhpcy5tYXguYWRkKCBvZmZzZXQgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0ZXF1YWxzOiBmdW5jdGlvbiAoIGJveCApIHtcblxuXHRcdFx0cmV0dXJuIGJveC5taW4uZXF1YWxzKCB0aGlzLm1pbiApICYmIGJveC5tYXguZXF1YWxzKCB0aGlzLm1heCApO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0Ly8gRmlsZTpzcmMvbWF0aC9NYXRyaXgzLmpzXG5cblx0LyoqXG5cdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG5cdCAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuXHQgKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXG5cdCAqL1xuXG5cdFRIUkVFLk1hdHJpeDMgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLmVsZW1lbnRzID0gbmV3IEZsb2F0MzJBcnJheSggW1xuXG5cdFx0XHQxLCAwLCAwLFxuXHRcdFx0MCwgMSwgMCxcblx0XHRcdDAsIDAsIDFcblxuXHRcdF0gKTtcblxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXgzOiB0aGUgY29uc3RydWN0b3Igbm8gbG9uZ2VyIHJlYWRzIGFyZ3VtZW50cy4gdXNlIC5zZXQoKSBpbnN0ZWFkLicgKTtcblxuXHRcdH1cblxuXHR9O1xuXG5cdFRIUkVFLk1hdHJpeDMucHJvdG90eXBlID0ge1xuXG5cdFx0Y29uc3RydWN0b3I6IFRIUkVFLk1hdHJpeDMsXG5cblx0XHRzZXQ6IGZ1bmN0aW9uICggbjExLCBuMTIsIG4xMywgbjIxLCBuMjIsIG4yMywgbjMxLCBuMzIsIG4zMyApIHtcblxuXHRcdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdFx0dGVbIDAgXSA9IG4xMTsgdGVbIDMgXSA9IG4xMjsgdGVbIDYgXSA9IG4xMztcblx0XHRcdHRlWyAxIF0gPSBuMjE7IHRlWyA0IF0gPSBuMjI7IHRlWyA3IF0gPSBuMjM7XG5cdFx0XHR0ZVsgMiBdID0gbjMxOyB0ZVsgNSBdID0gbjMyOyB0ZVsgOCBdID0gbjMzO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRpZGVudGl0eTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR0aGlzLnNldChcblxuXHRcdFx0XHQxLCAwLCAwLFxuXHRcdFx0XHQwLCAxLCAwLFxuXHRcdFx0XHQwLCAwLCAxXG5cblx0XHRcdCk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmZyb21BcnJheSggdGhpcy5lbGVtZW50cyApO1xuXG5cdFx0fSxcblxuXHRcdGNvcHk6IGZ1bmN0aW9uICggbSApIHtcblxuXHRcdFx0dmFyIG1lID0gbS5lbGVtZW50cztcblxuXHRcdFx0dGhpcy5zZXQoXG5cblx0XHRcdFx0bWVbIDAgXSwgbWVbIDMgXSwgbWVbIDYgXSxcblx0XHRcdFx0bWVbIDEgXSwgbWVbIDQgXSwgbWVbIDcgXSxcblx0XHRcdFx0bWVbIDIgXSwgbWVbIDUgXSwgbWVbIDggXVxuXG5cdFx0XHQpO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRtdWx0aXBseVZlY3RvcjM6IGZ1bmN0aW9uICggdmVjdG9yICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXgzOiAubXVsdGlwbHlWZWN0b3IzKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIHZlY3Rvci5hcHBseU1hdHJpeDMoIG1hdHJpeCApIGluc3RlYWQuJyApO1xuXHRcdFx0cmV0dXJuIHZlY3Rvci5hcHBseU1hdHJpeDMoIHRoaXMgKTtcblxuXHRcdH0sXG5cblx0XHRtdWx0aXBseVZlY3RvcjNBcnJheTogZnVuY3Rpb24gKCBhICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXgzOiAubXVsdGlwbHlWZWN0b3IzQXJyYXkoKSBoYXMgYmVlbiByZW5hbWVkLiBVc2UgbWF0cml4LmFwcGx5VG9WZWN0b3IzQXJyYXkoIGFycmF5ICkgaW5zdGVhZC4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5hcHBseVRvVmVjdG9yM0FycmF5KCBhICk7XG5cblx0XHR9LFxuXG5cdFx0YXBwbHlUb1ZlY3RvcjNBcnJheTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgdjE7XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQsIGxlbmd0aCApIHtcblxuXHRcdFx0XHRpZiAoIHYxID09PSB1bmRlZmluZWQgKSB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0XHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXHRcdFx0XHRpZiAoIGxlbmd0aCA9PT0gdW5kZWZpbmVkICkgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaiA9IG9mZnNldDsgaSA8IGxlbmd0aDsgaSArPSAzLCBqICs9IDMgKSB7XG5cblx0XHRcdFx0XHR2MS5mcm9tQXJyYXkoIGFycmF5LCBqICk7XG5cdFx0XHRcdFx0djEuYXBwbHlNYXRyaXgzKCB0aGlzICk7XG5cdFx0XHRcdFx0djEudG9BcnJheSggYXJyYXksIGogKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGFycmF5O1xuXG5cdFx0XHR9O1xuXG5cdFx0fSgpLFxuXG5cdFx0YXBwbHlUb0J1ZmZlcjogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgdjE7XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiBhcHBseVRvQnVmZmVyKCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoICkge1xuXG5cdFx0XHRcdGlmICggdjEgPT09IHVuZGVmaW5lZCApIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHRcdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cdFx0XHRcdGlmICggbGVuZ3RoID09PSB1bmRlZmluZWQgKSBsZW5ndGggPSBidWZmZXIubGVuZ3RoIC8gYnVmZmVyLml0ZW1TaXplO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaiA9IG9mZnNldDsgaSA8IGxlbmd0aDsgaSArKywgaiArKyApIHtcblxuXHRcdFx0XHRcdHYxLnggPSBidWZmZXIuZ2V0WCggaiApO1xuXHRcdFx0XHRcdHYxLnkgPSBidWZmZXIuZ2V0WSggaiApO1xuXHRcdFx0XHRcdHYxLnogPSBidWZmZXIuZ2V0WiggaiApO1xuXG5cdFx0XHRcdFx0djEuYXBwbHlNYXRyaXgzKCB0aGlzICk7XG5cblx0XHRcdFx0XHRidWZmZXIuc2V0WFlaKCB2MS54LCB2MS55LCB2MS56ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBidWZmZXI7XG5cblx0XHRcdH07XG5cblx0XHR9KCksXG5cblx0XHRtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xuXG5cdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0XHR0ZVsgMCBdICo9IHM7IHRlWyAzIF0gKj0gczsgdGVbIDYgXSAqPSBzO1xuXHRcdFx0dGVbIDEgXSAqPSBzOyB0ZVsgNCBdICo9IHM7IHRlWyA3IF0gKj0gcztcblx0XHRcdHRlWyAyIF0gKj0gczsgdGVbIDUgXSAqPSBzOyB0ZVsgOCBdICo9IHM7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGRldGVybWluYW50OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRcdHZhciBhID0gdGVbIDAgXSwgYiA9IHRlWyAxIF0sIGMgPSB0ZVsgMiBdLFxuXHRcdFx0XHRkID0gdGVbIDMgXSwgZSA9IHRlWyA0IF0sIGYgPSB0ZVsgNSBdLFxuXHRcdFx0XHRnID0gdGVbIDYgXSwgaCA9IHRlWyA3IF0sIGkgPSB0ZVsgOCBdO1xuXG5cdFx0XHRyZXR1cm4gYSAqIGUgKiBpIC0gYSAqIGYgKiBoIC0gYiAqIGQgKiBpICsgYiAqIGYgKiBnICsgYyAqIGQgKiBoIC0gYyAqIGUgKiBnO1xuXG5cdFx0fSxcblxuXHRcdGdldEludmVyc2U6IGZ1bmN0aW9uICggbWF0cml4LCB0aHJvd09uSW52ZXJ0aWJsZSApIHtcblxuXHRcdFx0Ly8gaW5wdXQ6IFRIUkVFLk1hdHJpeDRcblx0XHRcdC8vICggYmFzZWQgb24gaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3dlYmdsLW1qcy8gKVxuXG5cdFx0XHR2YXIgbWUgPSBtYXRyaXguZWxlbWVudHM7XG5cdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0XHR0ZVsgMCBdID0gICBtZVsgMTAgXSAqIG1lWyA1IF0gLSBtZVsgNiBdICogbWVbIDkgXTtcblx0XHRcdHRlWyAxIF0gPSAtIG1lWyAxMCBdICogbWVbIDEgXSArIG1lWyAyIF0gKiBtZVsgOSBdO1xuXHRcdFx0dGVbIDIgXSA9ICAgbWVbIDYgXSAqIG1lWyAxIF0gLSBtZVsgMiBdICogbWVbIDUgXTtcblx0XHRcdHRlWyAzIF0gPSAtIG1lWyAxMCBdICogbWVbIDQgXSArIG1lWyA2IF0gKiBtZVsgOCBdO1xuXHRcdFx0dGVbIDQgXSA9ICAgbWVbIDEwIF0gKiBtZVsgMCBdIC0gbWVbIDIgXSAqIG1lWyA4IF07XG5cdFx0XHR0ZVsgNSBdID0gLSBtZVsgNiBdICogbWVbIDAgXSArIG1lWyAyIF0gKiBtZVsgNCBdO1xuXHRcdFx0dGVbIDYgXSA9ICAgbWVbIDkgXSAqIG1lWyA0IF0gLSBtZVsgNSBdICogbWVbIDggXTtcblx0XHRcdHRlWyA3IF0gPSAtIG1lWyA5IF0gKiBtZVsgMCBdICsgbWVbIDEgXSAqIG1lWyA4IF07XG5cdFx0XHR0ZVsgOCBdID0gICBtZVsgNSBdICogbWVbIDAgXSAtIG1lWyAxIF0gKiBtZVsgNCBdO1xuXG5cdFx0XHR2YXIgZGV0ID0gbWVbIDAgXSAqIHRlWyAwIF0gKyBtZVsgMSBdICogdGVbIDMgXSArIG1lWyAyIF0gKiB0ZVsgNiBdO1xuXG5cdFx0XHQvLyBubyBpbnZlcnNlXG5cblx0XHRcdGlmICggZGV0ID09PSAwICkge1xuXG5cdFx0XHRcdHZhciBtc2cgPSBcIk1hdHJpeDMuZ2V0SW52ZXJzZSgpOiBjYW4ndCBpbnZlcnQgbWF0cml4LCBkZXRlcm1pbmFudCBpcyAwXCI7XG5cblx0XHRcdFx0aWYgKCB0aHJvd09uSW52ZXJ0aWJsZSB8fCBmYWxzZSApIHtcblxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggbXNnICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggbXNnICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuaWRlbnRpdHkoKTtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLm11bHRpcGx5U2NhbGFyKCAxLjAgLyBkZXQgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0dHJhbnNwb3NlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciB0bXAsIG0gPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0XHR0bXAgPSBtWyAxIF07IG1bIDEgXSA9IG1bIDMgXTsgbVsgMyBdID0gdG1wO1xuXHRcdFx0dG1wID0gbVsgMiBdOyBtWyAyIF0gPSBtWyA2IF07IG1bIDYgXSA9IHRtcDtcblx0XHRcdHRtcCA9IG1bIDUgXTsgbVsgNSBdID0gbVsgNyBdOyBtWyA3IF0gPSB0bXA7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGZsYXR0ZW5Ub0FycmF5T2Zmc2V0OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XG5cblx0XHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRcdGFycmF5WyBvZmZzZXQgXSA9IHRlWyAwIF07XG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGVbIDEgXTtcblx0XHRcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0ZVsgMiBdO1xuXG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGVbIDMgXTtcblx0XHRcdGFycmF5WyBvZmZzZXQgKyA0IF0gPSB0ZVsgNCBdO1xuXHRcdFx0YXJyYXlbIG9mZnNldCArIDUgXSA9IHRlWyA1IF07XG5cblx0XHRcdGFycmF5WyBvZmZzZXQgKyA2IF0gPSB0ZVsgNiBdO1xuXHRcdFx0YXJyYXlbIG9mZnNldCArIDcgXSA9IHRlWyA3IF07XG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsgOCBdICA9IHRlWyA4IF07XG5cblx0XHRcdHJldHVybiBhcnJheTtcblxuXHRcdH0sXG5cblx0XHRnZXROb3JtYWxNYXRyaXg6IGZ1bmN0aW9uICggbSApIHtcblxuXHRcdFx0Ly8gaW5wdXQ6IFRIUkVFLk1hdHJpeDRcblxuXHRcdFx0dGhpcy5nZXRJbnZlcnNlKCBtICkudHJhbnNwb3NlKCk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHRyYW5zcG9zZUludG9BcnJheTogZnVuY3Rpb24gKCByICkge1xuXG5cdFx0XHR2YXIgbSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRcdHJbIDAgXSA9IG1bIDAgXTtcblx0XHRcdHJbIDEgXSA9IG1bIDMgXTtcblx0XHRcdHJbIDIgXSA9IG1bIDYgXTtcblx0XHRcdHJbIDMgXSA9IG1bIDEgXTtcblx0XHRcdHJbIDQgXSA9IG1bIDQgXTtcblx0XHRcdHJbIDUgXSA9IG1bIDcgXTtcblx0XHRcdHJbIDYgXSA9IG1bIDIgXTtcblx0XHRcdHJbIDcgXSA9IG1bIDUgXTtcblx0XHRcdHJbIDggXSA9IG1bIDggXTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0ZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5ICkge1xuXG5cdFx0XHR0aGlzLmVsZW1lbnRzLnNldCggYXJyYXkgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0dG9BcnJheTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHR0ZVsgMCBdLCB0ZVsgMSBdLCB0ZVsgMiBdLFxuXHRcdFx0XHR0ZVsgMyBdLCB0ZVsgNCBdLCB0ZVsgNSBdLFxuXHRcdFx0XHR0ZVsgNiBdLCB0ZVsgNyBdLCB0ZVsgOCBdXG5cdFx0XHRdO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0Ly8gRmlsZTpzcmMvbWF0aC9NYXRyaXg0LmpzXG5cblx0LyoqXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqIEBhdXRob3Igc3VwZXJlZ2diZXJ0IC8gaHR0cDovL3d3dy5wYXVsYnJ1bnQuY28udWsvXG5cdCAqIEBhdXRob3IgcGhpbG9nYiAvIGh0dHA6Ly9ibG9nLnRoZWppdC5vcmcvXG5cdCAqIEBhdXRob3Igam9yZGlfcm9zIC8gaHR0cDovL3BsYXR0c29mdC5jb21cblx0ICogQGF1dGhvciBEMXBsbzFkIC8gaHR0cDovL2dpdGh1Yi5jb20vRDFwbG8xZFxuXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuXHQgKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuXHQgKiBAYXV0aG9yIHRpbWtuaXAgLyBodHRwOi8vd3d3LmZsb29ycGxhbm5lci5jb20vXG5cdCAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cblx0ICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG5cdCAqL1xuXG5cdFRIUkVFLk1hdHJpeDQgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLmVsZW1lbnRzID0gbmV3IEZsb2F0MzJBcnJheSggW1xuXG5cdFx0XHQxLCAwLCAwLCAwLFxuXHRcdFx0MCwgMSwgMCwgMCxcblx0XHRcdDAsIDAsIDEsIDAsXG5cdFx0XHQwLCAwLCAwLCAxXG5cblx0XHRdICk7XG5cblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4NDogdGhlIGNvbnN0cnVjdG9yIG5vIGxvbmdlciByZWFkcyBhcmd1bWVudHMuIHVzZSAuc2V0KCkgaW5zdGVhZC4nICk7XG5cblx0XHR9XG5cblx0fTtcblxuXHRUSFJFRS5NYXRyaXg0LnByb3RvdHlwZSA9IHtcblxuXHRcdGNvbnN0cnVjdG9yOiBUSFJFRS5NYXRyaXg0LFxuXG5cdFx0c2V0OiBmdW5jdGlvbiAoIG4xMSwgbjEyLCBuMTMsIG4xNCwgbjIxLCBuMjIsIG4yMywgbjI0LCBuMzEsIG4zMiwgbjMzLCBuMzQsIG40MSwgbjQyLCBuNDMsIG40NCApIHtcblxuXHRcdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdFx0dGVbIDAgXSA9IG4xMTsgdGVbIDQgXSA9IG4xMjsgdGVbIDggXSA9IG4xMzsgdGVbIDEyIF0gPSBuMTQ7XG5cdFx0XHR0ZVsgMSBdID0gbjIxOyB0ZVsgNSBdID0gbjIyOyB0ZVsgOSBdID0gbjIzOyB0ZVsgMTMgXSA9IG4yNDtcblx0XHRcdHRlWyAyIF0gPSBuMzE7IHRlWyA2IF0gPSBuMzI7IHRlWyAxMCBdID0gbjMzOyB0ZVsgMTQgXSA9IG4zNDtcblx0XHRcdHRlWyAzIF0gPSBuNDE7IHRlWyA3IF0gPSBuNDI7IHRlWyAxMSBdID0gbjQzOyB0ZVsgMTUgXSA9IG40NDtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0aWRlbnRpdHk6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dGhpcy5zZXQoXG5cblx0XHRcdFx0MSwgMCwgMCwgMCxcblx0XHRcdFx0MCwgMSwgMCwgMCxcblx0XHRcdFx0MCwgMCwgMSwgMCxcblx0XHRcdFx0MCwgMCwgMCwgMVxuXG5cdFx0XHQpO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gbmV3IFRIUkVFLk1hdHJpeDQoKS5mcm9tQXJyYXkoIHRoaXMuZWxlbWVudHMgKTtcblxuXHRcdH0sXG5cblx0XHRjb3B5OiBmdW5jdGlvbiAoIG0gKSB7XG5cblx0XHRcdHRoaXMuZWxlbWVudHMuc2V0KCBtLmVsZW1lbnRzICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGV4dHJhY3RQb3NpdGlvbjogZnVuY3Rpb24gKCBtICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAuZXh0cmFjdFBvc2l0aW9uKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuY29weVBvc2l0aW9uKCkuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXMuY29weVBvc2l0aW9uKCBtICk7XG5cblx0XHR9LFxuXG5cdFx0Y29weVBvc2l0aW9uOiBmdW5jdGlvbiAoIG0gKSB7XG5cblx0XHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0XHR2YXIgbWUgPSBtLmVsZW1lbnRzO1xuXG5cdFx0XHR0ZVsgMTIgXSA9IG1lWyAxMiBdO1xuXHRcdFx0dGVbIDEzIF0gPSBtZVsgMTMgXTtcblx0XHRcdHRlWyAxNCBdID0gbWVbIDE0IF07XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGV4dHJhY3RCYXNpczogZnVuY3Rpb24gKCB4QXhpcywgeUF4aXMsIHpBeGlzICkge1xuXG5cdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0XHR4QXhpcy5zZXQoIHRlWyAwIF0sIHRlWyAxIF0sIHRlWyAyIF0gKTtcblx0XHRcdHlBeGlzLnNldCggdGVbIDQgXSwgdGVbIDUgXSwgdGVbIDYgXSApO1xuXHRcdFx0ekF4aXMuc2V0KCB0ZVsgOCBdLCB0ZVsgOSBdLCB0ZVsgMTAgXSApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRtYWtlQmFzaXM6IGZ1bmN0aW9uICggeEF4aXMsIHlBeGlzLCB6QXhpcyApIHtcblxuXHRcdFx0dGhpcy5zZXQoXG5cdFx0XHRcdHhBeGlzLngsIHlBeGlzLngsIHpBeGlzLngsIDAsXG5cdFx0XHRcdHhBeGlzLnksIHlBeGlzLnksIHpBeGlzLnksIDAsXG5cdFx0XHRcdHhBeGlzLnosIHlBeGlzLnosIHpBeGlzLnosIDAsXG5cdFx0XHRcdDAsICAgICAgIDAsICAgICAgIDAsICAgICAgIDFcblx0XHRcdCk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGV4dHJhY3RSb3RhdGlvbjogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgdjE7XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiAoIG0gKSB7XG5cblx0XHRcdFx0aWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0XHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0XHRcdHZhciBtZSA9IG0uZWxlbWVudHM7XG5cblx0XHRcdFx0dmFyIHNjYWxlWCA9IDEgLyB2MS5zZXQoIG1lWyAwIF0sIG1lWyAxIF0sIG1lWyAyIF0gKS5sZW5ndGgoKTtcblx0XHRcdFx0dmFyIHNjYWxlWSA9IDEgLyB2MS5zZXQoIG1lWyA0IF0sIG1lWyA1IF0sIG1lWyA2IF0gKS5sZW5ndGgoKTtcblx0XHRcdFx0dmFyIHNjYWxlWiA9IDEgLyB2MS5zZXQoIG1lWyA4IF0sIG1lWyA5IF0sIG1lWyAxMCBdICkubGVuZ3RoKCk7XG5cblx0XHRcdFx0dGVbIDAgXSA9IG1lWyAwIF0gKiBzY2FsZVg7XG5cdFx0XHRcdHRlWyAxIF0gPSBtZVsgMSBdICogc2NhbGVYO1xuXHRcdFx0XHR0ZVsgMiBdID0gbWVbIDIgXSAqIHNjYWxlWDtcblxuXHRcdFx0XHR0ZVsgNCBdID0gbWVbIDQgXSAqIHNjYWxlWTtcblx0XHRcdFx0dGVbIDUgXSA9IG1lWyA1IF0gKiBzY2FsZVk7XG5cdFx0XHRcdHRlWyA2IF0gPSBtZVsgNiBdICogc2NhbGVZO1xuXG5cdFx0XHRcdHRlWyA4IF0gPSBtZVsgOCBdICogc2NhbGVaO1xuXHRcdFx0XHR0ZVsgOSBdID0gbWVbIDkgXSAqIHNjYWxlWjtcblx0XHRcdFx0dGVbIDEwIF0gPSBtZVsgMTAgXSAqIHNjYWxlWjtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdFx0fTtcblxuXHRcdH0oKSxcblxuXHRcdG1ha2VSb3RhdGlvbkZyb21FdWxlcjogZnVuY3Rpb24gKCBldWxlciApIHtcblxuXHRcdFx0aWYgKCBldWxlciBpbnN0YW5jZW9mIFRIUkVFLkV1bGVyID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4OiAubWFrZVJvdGF0aW9uRnJvbUV1bGVyKCkgbm93IGV4cGVjdHMgYSBFdWxlciByb3RhdGlvbiByYXRoZXIgdGhhbiBhIFZlY3RvcjMgYW5kIG9yZGVyLicgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0XHR2YXIgeCA9IGV1bGVyLngsIHkgPSBldWxlci55LCB6ID0gZXVsZXIuejtcblx0XHRcdHZhciBhID0gTWF0aC5jb3MoIHggKSwgYiA9IE1hdGguc2luKCB4ICk7XG5cdFx0XHR2YXIgYyA9IE1hdGguY29zKCB5ICksIGQgPSBNYXRoLnNpbiggeSApO1xuXHRcdFx0dmFyIGUgPSBNYXRoLmNvcyggeiApLCBmID0gTWF0aC5zaW4oIHogKTtcblxuXHRcdFx0aWYgKCBldWxlci5vcmRlciA9PT0gJ1hZWicgKSB7XG5cblx0XHRcdFx0dmFyIGFlID0gYSAqIGUsIGFmID0gYSAqIGYsIGJlID0gYiAqIGUsIGJmID0gYiAqIGY7XG5cblx0XHRcdFx0dGVbIDAgXSA9IGMgKiBlO1xuXHRcdFx0XHR0ZVsgNCBdID0gLSBjICogZjtcblx0XHRcdFx0dGVbIDggXSA9IGQ7XG5cblx0XHRcdFx0dGVbIDEgXSA9IGFmICsgYmUgKiBkO1xuXHRcdFx0XHR0ZVsgNSBdID0gYWUgLSBiZiAqIGQ7XG5cdFx0XHRcdHRlWyA5IF0gPSAtIGIgKiBjO1xuXG5cdFx0XHRcdHRlWyAyIF0gPSBiZiAtIGFlICogZDtcblx0XHRcdFx0dGVbIDYgXSA9IGJlICsgYWYgKiBkO1xuXHRcdFx0XHR0ZVsgMTAgXSA9IGEgKiBjO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1lYWicgKSB7XG5cblx0XHRcdFx0dmFyIGNlID0gYyAqIGUsIGNmID0gYyAqIGYsIGRlID0gZCAqIGUsIGRmID0gZCAqIGY7XG5cblx0XHRcdFx0dGVbIDAgXSA9IGNlICsgZGYgKiBiO1xuXHRcdFx0XHR0ZVsgNCBdID0gZGUgKiBiIC0gY2Y7XG5cdFx0XHRcdHRlWyA4IF0gPSBhICogZDtcblxuXHRcdFx0XHR0ZVsgMSBdID0gYSAqIGY7XG5cdFx0XHRcdHRlWyA1IF0gPSBhICogZTtcblx0XHRcdFx0dGVbIDkgXSA9IC0gYjtcblxuXHRcdFx0XHR0ZVsgMiBdID0gY2YgKiBiIC0gZGU7XG5cdFx0XHRcdHRlWyA2IF0gPSBkZiArIGNlICogYjtcblx0XHRcdFx0dGVbIDEwIF0gPSBhICogYztcblxuXHRcdFx0fSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdaWFknICkge1xuXG5cdFx0XHRcdHZhciBjZSA9IGMgKiBlLCBjZiA9IGMgKiBmLCBkZSA9IGQgKiBlLCBkZiA9IGQgKiBmO1xuXG5cdFx0XHRcdHRlWyAwIF0gPSBjZSAtIGRmICogYjtcblx0XHRcdFx0dGVbIDQgXSA9IC0gYSAqIGY7XG5cdFx0XHRcdHRlWyA4IF0gPSBkZSArIGNmICogYjtcblxuXHRcdFx0XHR0ZVsgMSBdID0gY2YgKyBkZSAqIGI7XG5cdFx0XHRcdHRlWyA1IF0gPSBhICogZTtcblx0XHRcdFx0dGVbIDkgXSA9IGRmIC0gY2UgKiBiO1xuXG5cdFx0XHRcdHRlWyAyIF0gPSAtIGEgKiBkO1xuXHRcdFx0XHR0ZVsgNiBdID0gYjtcblx0XHRcdFx0dGVbIDEwIF0gPSBhICogYztcblxuXHRcdFx0fSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdaWVgnICkge1xuXG5cdFx0XHRcdHZhciBhZSA9IGEgKiBlLCBhZiA9IGEgKiBmLCBiZSA9IGIgKiBlLCBiZiA9IGIgKiBmO1xuXG5cdFx0XHRcdHRlWyAwIF0gPSBjICogZTtcblx0XHRcdFx0dGVbIDQgXSA9IGJlICogZCAtIGFmO1xuXHRcdFx0XHR0ZVsgOCBdID0gYWUgKiBkICsgYmY7XG5cblx0XHRcdFx0dGVbIDEgXSA9IGMgKiBmO1xuXHRcdFx0XHR0ZVsgNSBdID0gYmYgKiBkICsgYWU7XG5cdFx0XHRcdHRlWyA5IF0gPSBhZiAqIGQgLSBiZTtcblxuXHRcdFx0XHR0ZVsgMiBdID0gLSBkO1xuXHRcdFx0XHR0ZVsgNiBdID0gYiAqIGM7XG5cdFx0XHRcdHRlWyAxMCBdID0gYSAqIGM7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWVpYJyApIHtcblxuXHRcdFx0XHR2YXIgYWMgPSBhICogYywgYWQgPSBhICogZCwgYmMgPSBiICogYywgYmQgPSBiICogZDtcblxuXHRcdFx0XHR0ZVsgMCBdID0gYyAqIGU7XG5cdFx0XHRcdHRlWyA0IF0gPSBiZCAtIGFjICogZjtcblx0XHRcdFx0dGVbIDggXSA9IGJjICogZiArIGFkO1xuXG5cdFx0XHRcdHRlWyAxIF0gPSBmO1xuXHRcdFx0XHR0ZVsgNSBdID0gYSAqIGU7XG5cdFx0XHRcdHRlWyA5IF0gPSAtIGIgKiBlO1xuXG5cdFx0XHRcdHRlWyAyIF0gPSAtIGQgKiBlO1xuXHRcdFx0XHR0ZVsgNiBdID0gYWQgKiBmICsgYmM7XG5cdFx0XHRcdHRlWyAxMCBdID0gYWMgLSBiZCAqIGY7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWFpZJyApIHtcblxuXHRcdFx0XHR2YXIgYWMgPSBhICogYywgYWQgPSBhICogZCwgYmMgPSBiICogYywgYmQgPSBiICogZDtcblxuXHRcdFx0XHR0ZVsgMCBdID0gYyAqIGU7XG5cdFx0XHRcdHRlWyA0IF0gPSAtIGY7XG5cdFx0XHRcdHRlWyA4IF0gPSBkICogZTtcblxuXHRcdFx0XHR0ZVsgMSBdID0gYWMgKiBmICsgYmQ7XG5cdFx0XHRcdHRlWyA1IF0gPSBhICogZTtcblx0XHRcdFx0dGVbIDkgXSA9IGFkICogZiAtIGJjO1xuXG5cdFx0XHRcdHRlWyAyIF0gPSBiYyAqIGYgLSBhZDtcblx0XHRcdFx0dGVbIDYgXSA9IGIgKiBlO1xuXHRcdFx0XHR0ZVsgMTAgXSA9IGJkICogZiArIGFjO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGxhc3QgY29sdW1uXG5cdFx0XHR0ZVsgMyBdID0gMDtcblx0XHRcdHRlWyA3IF0gPSAwO1xuXHRcdFx0dGVbIDExIF0gPSAwO1xuXG5cdFx0XHQvLyBib3R0b20gcm93XG5cdFx0XHR0ZVsgMTIgXSA9IDA7XG5cdFx0XHR0ZVsgMTMgXSA9IDA7XG5cdFx0XHR0ZVsgMTQgXSA9IDA7XG5cdFx0XHR0ZVsgMTUgXSA9IDE7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHNldFJvdGF0aW9uRnJvbVF1YXRlcm5pb246IGZ1bmN0aW9uICggcSApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLnNldFJvdGF0aW9uRnJvbVF1YXRlcm5pb24oKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5tYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbigpLicgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXMubWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24oIHEgKTtcblxuXHRcdH0sXG5cblx0XHRtYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbjogZnVuY3Rpb24gKCBxICkge1xuXG5cdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0XHR2YXIgeCA9IHEueCwgeSA9IHEueSwgeiA9IHEueiwgdyA9IHEudztcblx0XHRcdHZhciB4MiA9IHggKyB4LCB5MiA9IHkgKyB5LCB6MiA9IHogKyB6O1xuXHRcdFx0dmFyIHh4ID0geCAqIHgyLCB4eSA9IHggKiB5MiwgeHogPSB4ICogejI7XG5cdFx0XHR2YXIgeXkgPSB5ICogeTIsIHl6ID0geSAqIHoyLCB6eiA9IHogKiB6Mjtcblx0XHRcdHZhciB3eCA9IHcgKiB4Miwgd3kgPSB3ICogeTIsIHd6ID0gdyAqIHoyO1xuXG5cdFx0XHR0ZVsgMCBdID0gMSAtICggeXkgKyB6eiApO1xuXHRcdFx0dGVbIDQgXSA9IHh5IC0gd3o7XG5cdFx0XHR0ZVsgOCBdID0geHogKyB3eTtcblxuXHRcdFx0dGVbIDEgXSA9IHh5ICsgd3o7XG5cdFx0XHR0ZVsgNSBdID0gMSAtICggeHggKyB6eiApO1xuXHRcdFx0dGVbIDkgXSA9IHl6IC0gd3g7XG5cblx0XHRcdHRlWyAyIF0gPSB4eiAtIHd5O1xuXHRcdFx0dGVbIDYgXSA9IHl6ICsgd3g7XG5cdFx0XHR0ZVsgMTAgXSA9IDEgLSAoIHh4ICsgeXkgKTtcblxuXHRcdFx0Ly8gbGFzdCBjb2x1bW5cblx0XHRcdHRlWyAzIF0gPSAwO1xuXHRcdFx0dGVbIDcgXSA9IDA7XG5cdFx0XHR0ZVsgMTEgXSA9IDA7XG5cblx0XHRcdC8vIGJvdHRvbSByb3dcblx0XHRcdHRlWyAxMiBdID0gMDtcblx0XHRcdHRlWyAxMyBdID0gMDtcblx0XHRcdHRlWyAxNCBdID0gMDtcblx0XHRcdHRlWyAxNSBdID0gMTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0bG9va0F0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciB4LCB5LCB6O1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKCBleWUsIHRhcmdldCwgdXAgKSB7XG5cblx0XHRcdFx0aWYgKCB4ID09PSB1bmRlZmluZWQgKSB4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHRcdFx0aWYgKCB5ID09PSB1bmRlZmluZWQgKSB5ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHRcdFx0aWYgKCB6ID09PSB1bmRlZmluZWQgKSB6ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0XHRcdHouc3ViVmVjdG9ycyggZXllLCB0YXJnZXQgKS5ub3JtYWxpemUoKTtcblxuXHRcdFx0XHRpZiAoIHoubGVuZ3RoU3EoKSA9PT0gMCApIHtcblxuXHRcdFx0XHRcdHoueiA9IDE7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHguY3Jvc3NWZWN0b3JzKCB1cCwgeiApLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHRcdGlmICggeC5sZW5ndGhTcSgpID09PSAwICkge1xuXG5cdFx0XHRcdFx0ei54ICs9IDAuMDAwMTtcblx0XHRcdFx0XHR4LmNyb3NzVmVjdG9ycyggdXAsIHogKS5ub3JtYWxpemUoKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0eS5jcm9zc1ZlY3RvcnMoIHosIHggKTtcblxuXG5cdFx0XHRcdHRlWyAwIF0gPSB4Lng7IHRlWyA0IF0gPSB5Lng7IHRlWyA4IF0gPSB6Lng7XG5cdFx0XHRcdHRlWyAxIF0gPSB4Lnk7IHRlWyA1IF0gPSB5Lnk7IHRlWyA5IF0gPSB6Lnk7XG5cdFx0XHRcdHRlWyAyIF0gPSB4Lno7IHRlWyA2IF0gPSB5Lno7IHRlWyAxMCBdID0gei56O1xuXG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0XHR9O1xuXG5cdFx0fSgpLFxuXG5cdFx0bXVsdGlwbHk6IGZ1bmN0aW9uICggbSwgbiApIHtcblxuXHRcdFx0aWYgKCBuICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLm11bHRpcGx5KCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAubXVsdGlwbHlNYXRyaWNlcyggYSwgYiApIGluc3RlYWQuJyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseU1hdHJpY2VzKCBtLCBuICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlNYXRyaWNlcyggdGhpcywgbSApO1xuXG5cdFx0fSxcblxuXHRcdG11bHRpcGx5TWF0cmljZXM6IGZ1bmN0aW9uICggYSwgYiApIHtcblxuXHRcdFx0dmFyIGFlID0gYS5lbGVtZW50cztcblx0XHRcdHZhciBiZSA9IGIuZWxlbWVudHM7XG5cdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0XHR2YXIgYTExID0gYWVbIDAgXSwgYTEyID0gYWVbIDQgXSwgYTEzID0gYWVbIDggXSwgYTE0ID0gYWVbIDEyIF07XG5cdFx0XHR2YXIgYTIxID0gYWVbIDEgXSwgYTIyID0gYWVbIDUgXSwgYTIzID0gYWVbIDkgXSwgYTI0ID0gYWVbIDEzIF07XG5cdFx0XHR2YXIgYTMxID0gYWVbIDIgXSwgYTMyID0gYWVbIDYgXSwgYTMzID0gYWVbIDEwIF0sIGEzNCA9IGFlWyAxNCBdO1xuXHRcdFx0dmFyIGE0MSA9IGFlWyAzIF0sIGE0MiA9IGFlWyA3IF0sIGE0MyA9IGFlWyAxMSBdLCBhNDQgPSBhZVsgMTUgXTtcblxuXHRcdFx0dmFyIGIxMSA9IGJlWyAwIF0sIGIxMiA9IGJlWyA0IF0sIGIxMyA9IGJlWyA4IF0sIGIxNCA9IGJlWyAxMiBdO1xuXHRcdFx0dmFyIGIyMSA9IGJlWyAxIF0sIGIyMiA9IGJlWyA1IF0sIGIyMyA9IGJlWyA5IF0sIGIyNCA9IGJlWyAxMyBdO1xuXHRcdFx0dmFyIGIzMSA9IGJlWyAyIF0sIGIzMiA9IGJlWyA2IF0sIGIzMyA9IGJlWyAxMCBdLCBiMzQgPSBiZVsgMTQgXTtcblx0XHRcdHZhciBiNDEgPSBiZVsgMyBdLCBiNDIgPSBiZVsgNyBdLCBiNDMgPSBiZVsgMTEgXSwgYjQ0ID0gYmVbIDE1IF07XG5cblx0XHRcdHRlWyAwIF0gPSBhMTEgKiBiMTEgKyBhMTIgKiBiMjEgKyBhMTMgKiBiMzEgKyBhMTQgKiBiNDE7XG5cdFx0XHR0ZVsgNCBdID0gYTExICogYjEyICsgYTEyICogYjIyICsgYTEzICogYjMyICsgYTE0ICogYjQyO1xuXHRcdFx0dGVbIDggXSA9IGExMSAqIGIxMyArIGExMiAqIGIyMyArIGExMyAqIGIzMyArIGExNCAqIGI0Mztcblx0XHRcdHRlWyAxMiBdID0gYTExICogYjE0ICsgYTEyICogYjI0ICsgYTEzICogYjM0ICsgYTE0ICogYjQ0O1xuXG5cdFx0XHR0ZVsgMSBdID0gYTIxICogYjExICsgYTIyICogYjIxICsgYTIzICogYjMxICsgYTI0ICogYjQxO1xuXHRcdFx0dGVbIDUgXSA9IGEyMSAqIGIxMiArIGEyMiAqIGIyMiArIGEyMyAqIGIzMiArIGEyNCAqIGI0Mjtcblx0XHRcdHRlWyA5IF0gPSBhMjEgKiBiMTMgKyBhMjIgKiBiMjMgKyBhMjMgKiBiMzMgKyBhMjQgKiBiNDM7XG5cdFx0XHR0ZVsgMTMgXSA9IGEyMSAqIGIxNCArIGEyMiAqIGIyNCArIGEyMyAqIGIzNCArIGEyNCAqIGI0NDtcblxuXHRcdFx0dGVbIDIgXSA9IGEzMSAqIGIxMSArIGEzMiAqIGIyMSArIGEzMyAqIGIzMSArIGEzNCAqIGI0MTtcblx0XHRcdHRlWyA2IF0gPSBhMzEgKiBiMTIgKyBhMzIgKiBiMjIgKyBhMzMgKiBiMzIgKyBhMzQgKiBiNDI7XG5cdFx0XHR0ZVsgMTAgXSA9IGEzMSAqIGIxMyArIGEzMiAqIGIyMyArIGEzMyAqIGIzMyArIGEzNCAqIGI0Mztcblx0XHRcdHRlWyAxNCBdID0gYTMxICogYjE0ICsgYTMyICogYjI0ICsgYTMzICogYjM0ICsgYTM0ICogYjQ0O1xuXG5cdFx0XHR0ZVsgMyBdID0gYTQxICogYjExICsgYTQyICogYjIxICsgYTQzICogYjMxICsgYTQ0ICogYjQxO1xuXHRcdFx0dGVbIDcgXSA9IGE0MSAqIGIxMiArIGE0MiAqIGIyMiArIGE0MyAqIGIzMiArIGE0NCAqIGI0Mjtcblx0XHRcdHRlWyAxMSBdID0gYTQxICogYjEzICsgYTQyICogYjIzICsgYTQzICogYjMzICsgYTQ0ICogYjQzO1xuXHRcdFx0dGVbIDE1IF0gPSBhNDEgKiBiMTQgKyBhNDIgKiBiMjQgKyBhNDMgKiBiMzQgKyBhNDQgKiBiNDQ7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdG11bHRpcGx5VG9BcnJheTogZnVuY3Rpb24gKCBhLCBiLCByICkge1xuXG5cdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0XHR0aGlzLm11bHRpcGx5TWF0cmljZXMoIGEsIGIgKTtcblxuXHRcdFx0clsgMCBdID0gdGVbIDAgXTsgclsgMSBdID0gdGVbIDEgXTsgclsgMiBdID0gdGVbIDIgXTsgclsgMyBdID0gdGVbIDMgXTtcblx0XHRcdHJbIDQgXSA9IHRlWyA0IF07IHJbIDUgXSA9IHRlWyA1IF07IHJbIDYgXSA9IHRlWyA2IF07IHJbIDcgXSA9IHRlWyA3IF07XG5cdFx0XHRyWyA4IF0gID0gdGVbIDggXTsgclsgOSBdICA9IHRlWyA5IF07IHJbIDEwIF0gPSB0ZVsgMTAgXTsgclsgMTEgXSA9IHRlWyAxMSBdO1xuXHRcdFx0clsgMTIgXSA9IHRlWyAxMiBdOyByWyAxMyBdID0gdGVbIDEzIF07IHJbIDE0IF0gPSB0ZVsgMTQgXTsgclsgMTUgXSA9IHRlWyAxNSBdO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xuXG5cdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0XHR0ZVsgMCBdICo9IHM7IHRlWyA0IF0gKj0gczsgdGVbIDggXSAqPSBzOyB0ZVsgMTIgXSAqPSBzO1xuXHRcdFx0dGVbIDEgXSAqPSBzOyB0ZVsgNSBdICo9IHM7IHRlWyA5IF0gKj0gczsgdGVbIDEzIF0gKj0gcztcblx0XHRcdHRlWyAyIF0gKj0gczsgdGVbIDYgXSAqPSBzOyB0ZVsgMTAgXSAqPSBzOyB0ZVsgMTQgXSAqPSBzO1xuXHRcdFx0dGVbIDMgXSAqPSBzOyB0ZVsgNyBdICo9IHM7IHRlWyAxMSBdICo9IHM7IHRlWyAxNSBdICo9IHM7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdG11bHRpcGx5VmVjdG9yMzogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5tdWx0aXBseVZlY3RvcjMoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgdmVjdG9yLmFwcGx5TWF0cml4NCggbWF0cml4ICkgb3IgdmVjdG9yLmFwcGx5UHJvamVjdGlvbiggbWF0cml4ICkgaW5zdGVhZC4nICk7XG5cdFx0XHRyZXR1cm4gdmVjdG9yLmFwcGx5UHJvamVjdGlvbiggdGhpcyApO1xuXG5cdFx0fSxcblxuXHRcdG11bHRpcGx5VmVjdG9yNDogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5tdWx0aXBseVZlY3RvcjQoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgdmVjdG9yLmFwcGx5TWF0cml4NCggbWF0cml4ICkgaW5zdGVhZC4nICk7XG5cdFx0XHRyZXR1cm4gdmVjdG9yLmFwcGx5TWF0cml4NCggdGhpcyApO1xuXG5cdFx0fSxcblxuXHRcdG11bHRpcGx5VmVjdG9yM0FycmF5OiBmdW5jdGlvbiAoIGEgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5tdWx0aXBseVZlY3RvcjNBcnJheSgpIGhhcyBiZWVuIHJlbmFtZWQuIFVzZSBtYXRyaXguYXBwbHlUb1ZlY3RvcjNBcnJheSggYXJyYXkgKSBpbnN0ZWFkLicgKTtcblx0XHRcdHJldHVybiB0aGlzLmFwcGx5VG9WZWN0b3IzQXJyYXkoIGEgKTtcblxuXHRcdH0sXG5cblx0XHRhcHBseVRvVmVjdG9yM0FycmF5OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciB2MTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCwgbGVuZ3RoICkge1xuXG5cdFx0XHRcdGlmICggdjEgPT09IHVuZGVmaW5lZCApIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHRcdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cdFx0XHRcdGlmICggbGVuZ3RoID09PSB1bmRlZmluZWQgKSBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBqID0gb2Zmc2V0OyBpIDwgbGVuZ3RoOyBpICs9IDMsIGogKz0gMyApIHtcblxuXHRcdFx0XHRcdHYxLmZyb21BcnJheSggYXJyYXksIGogKTtcblx0XHRcdFx0XHR2MS5hcHBseU1hdHJpeDQoIHRoaXMgKTtcblx0XHRcdFx0XHR2MS50b0FycmF5KCBhcnJheSwgaiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gYXJyYXk7XG5cblx0XHRcdH07XG5cblx0XHR9KCksXG5cblx0XHRhcHBseVRvQnVmZmVyOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciB2MTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIGFwcGx5VG9CdWZmZXIoIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGggKSB7XG5cblx0XHRcdFx0aWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdFx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblx0XHRcdFx0aWYgKCBsZW5ndGggPT09IHVuZGVmaW5lZCApIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGggLyBidWZmZXIuaXRlbVNpemU7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBqID0gb2Zmc2V0OyBpIDwgbGVuZ3RoOyBpICsrLCBqICsrICkge1xuXG5cdFx0XHRcdFx0djEueCA9IGJ1ZmZlci5nZXRYKCBqICk7XG5cdFx0XHRcdFx0djEueSA9IGJ1ZmZlci5nZXRZKCBqICk7XG5cdFx0XHRcdFx0djEueiA9IGJ1ZmZlci5nZXRaKCBqICk7XG5cblx0XHRcdFx0XHR2MS5hcHBseU1hdHJpeDQoIHRoaXMgKTtcblxuXHRcdFx0XHRcdGJ1ZmZlci5zZXRYWVooIHYxLngsIHYxLnksIHYxLnogKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGJ1ZmZlcjtcblxuXHRcdFx0fTtcblxuXHRcdH0oKSxcblxuXHRcdHJvdGF0ZUF4aXM6IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLnJvdGF0ZUF4aXMoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVmVjdG9yMy50cmFuc2Zvcm1EaXJlY3Rpb24oIG1hdHJpeCApIGluc3RlYWQuJyApO1xuXG5cdFx0XHR2LnRyYW5zZm9ybURpcmVjdGlvbiggdGhpcyApO1xuXG5cdFx0fSxcblxuXHRcdGNyb3NzVmVjdG9yOiBmdW5jdGlvbiAoIHZlY3RvciApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLmNyb3NzVmVjdG9yKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIHZlY3Rvci5hcHBseU1hdHJpeDQoIG1hdHJpeCApIGluc3RlYWQuJyApO1xuXHRcdFx0cmV0dXJuIHZlY3Rvci5hcHBseU1hdHJpeDQoIHRoaXMgKTtcblxuXHRcdH0sXG5cblx0XHRkZXRlcm1pbmFudDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0XHR2YXIgbjExID0gdGVbIDAgXSwgbjEyID0gdGVbIDQgXSwgbjEzID0gdGVbIDggXSwgbjE0ID0gdGVbIDEyIF07XG5cdFx0XHR2YXIgbjIxID0gdGVbIDEgXSwgbjIyID0gdGVbIDUgXSwgbjIzID0gdGVbIDkgXSwgbjI0ID0gdGVbIDEzIF07XG5cdFx0XHR2YXIgbjMxID0gdGVbIDIgXSwgbjMyID0gdGVbIDYgXSwgbjMzID0gdGVbIDEwIF0sIG4zNCA9IHRlWyAxNCBdO1xuXHRcdFx0dmFyIG40MSA9IHRlWyAzIF0sIG40MiA9IHRlWyA3IF0sIG40MyA9IHRlWyAxMSBdLCBuNDQgPSB0ZVsgMTUgXTtcblxuXHRcdFx0Ly9UT0RPOiBtYWtlIHRoaXMgbW9yZSBlZmZpY2llbnRcblx0XHRcdC8vKCBiYXNlZCBvbiBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL21hdHJpeC9mdW5jdGlvbnMvaW52ZXJzZS9mb3VyRC9pbmRleC5odG0gKVxuXG5cdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHRuNDEgKiAoXG5cdFx0XHRcdFx0KyBuMTQgKiBuMjMgKiBuMzJcblx0XHRcdFx0XHQgLSBuMTMgKiBuMjQgKiBuMzJcblx0XHRcdFx0XHQgLSBuMTQgKiBuMjIgKiBuMzNcblx0XHRcdFx0XHQgKyBuMTIgKiBuMjQgKiBuMzNcblx0XHRcdFx0XHQgKyBuMTMgKiBuMjIgKiBuMzRcblx0XHRcdFx0XHQgLSBuMTIgKiBuMjMgKiBuMzRcblx0XHRcdFx0KSArXG5cdFx0XHRcdG40MiAqIChcblx0XHRcdFx0XHQrIG4xMSAqIG4yMyAqIG4zNFxuXHRcdFx0XHRcdCAtIG4xMSAqIG4yNCAqIG4zM1xuXHRcdFx0XHRcdCArIG4xNCAqIG4yMSAqIG4zM1xuXHRcdFx0XHRcdCAtIG4xMyAqIG4yMSAqIG4zNFxuXHRcdFx0XHRcdCArIG4xMyAqIG4yNCAqIG4zMVxuXHRcdFx0XHRcdCAtIG4xNCAqIG4yMyAqIG4zMVxuXHRcdFx0XHQpICtcblx0XHRcdFx0bjQzICogKFxuXHRcdFx0XHRcdCsgbjExICogbjI0ICogbjMyXG5cdFx0XHRcdFx0IC0gbjExICogbjIyICogbjM0XG5cdFx0XHRcdFx0IC0gbjE0ICogbjIxICogbjMyXG5cdFx0XHRcdFx0ICsgbjEyICogbjIxICogbjM0XG5cdFx0XHRcdFx0ICsgbjE0ICogbjIyICogbjMxXG5cdFx0XHRcdFx0IC0gbjEyICogbjI0ICogbjMxXG5cdFx0XHRcdCkgK1xuXHRcdFx0XHRuNDQgKiAoXG5cdFx0XHRcdFx0LSBuMTMgKiBuMjIgKiBuMzFcblx0XHRcdFx0XHQgLSBuMTEgKiBuMjMgKiBuMzJcblx0XHRcdFx0XHQgKyBuMTEgKiBuMjIgKiBuMzNcblx0XHRcdFx0XHQgKyBuMTMgKiBuMjEgKiBuMzJcblx0XHRcdFx0XHQgLSBuMTIgKiBuMjEgKiBuMzNcblx0XHRcdFx0XHQgKyBuMTIgKiBuMjMgKiBuMzFcblx0XHRcdFx0KVxuXG5cdFx0XHQpO1xuXG5cdFx0fSxcblxuXHRcdHRyYW5zcG9zZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdFx0dmFyIHRtcDtcblxuXHRcdFx0dG1wID0gdGVbIDEgXTsgdGVbIDEgXSA9IHRlWyA0IF07IHRlWyA0IF0gPSB0bXA7XG5cdFx0XHR0bXAgPSB0ZVsgMiBdOyB0ZVsgMiBdID0gdGVbIDggXTsgdGVbIDggXSA9IHRtcDtcblx0XHRcdHRtcCA9IHRlWyA2IF07IHRlWyA2IF0gPSB0ZVsgOSBdOyB0ZVsgOSBdID0gdG1wO1xuXG5cdFx0XHR0bXAgPSB0ZVsgMyBdOyB0ZVsgMyBdID0gdGVbIDEyIF07IHRlWyAxMiBdID0gdG1wO1xuXHRcdFx0dG1wID0gdGVbIDcgXTsgdGVbIDcgXSA9IHRlWyAxMyBdOyB0ZVsgMTMgXSA9IHRtcDtcblx0XHRcdHRtcCA9IHRlWyAxMSBdOyB0ZVsgMTEgXSA9IHRlWyAxNCBdOyB0ZVsgMTQgXSA9IHRtcDtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0ZmxhdHRlblRvQXJyYXlPZmZzZXQ6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcblxuXHRcdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdFx0YXJyYXlbIG9mZnNldCBdID0gdGVbIDAgXTtcblx0XHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0ZVsgMSBdO1xuXHRcdFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IHRlWyAyIF07XG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGVbIDMgXTtcblxuXHRcdFx0YXJyYXlbIG9mZnNldCArIDQgXSA9IHRlWyA0IF07XG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsgNSBdID0gdGVbIDUgXTtcblx0XHRcdGFycmF5WyBvZmZzZXQgKyA2IF0gPSB0ZVsgNiBdO1xuXHRcdFx0YXJyYXlbIG9mZnNldCArIDcgXSA9IHRlWyA3IF07XG5cblx0XHRcdGFycmF5WyBvZmZzZXQgKyA4IF0gID0gdGVbIDggXTtcblx0XHRcdGFycmF5WyBvZmZzZXQgKyA5IF0gID0gdGVbIDkgXTtcblx0XHRcdGFycmF5WyBvZmZzZXQgKyAxMCBdID0gdGVbIDEwIF07XG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsgMTEgXSA9IHRlWyAxMSBdO1xuXG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsgMTIgXSA9IHRlWyAxMiBdO1xuXHRcdFx0YXJyYXlbIG9mZnNldCArIDEzIF0gPSB0ZVsgMTMgXTtcblx0XHRcdGFycmF5WyBvZmZzZXQgKyAxNCBdID0gdGVbIDE0IF07XG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsgMTUgXSA9IHRlWyAxNSBdO1xuXG5cdFx0XHRyZXR1cm4gYXJyYXk7XG5cblx0XHR9LFxuXG5cdFx0Z2V0UG9zaXRpb246IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIHYxO1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdGlmICggdjEgPT09IHVuZGVmaW5lZCApIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLmdldFBvc2l0aW9uKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBtYXRyaXggKSBpbnN0ZWFkLicgKTtcblxuXHRcdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdFx0XHRyZXR1cm4gdjEuc2V0KCB0ZVsgMTIgXSwgdGVbIDEzIF0sIHRlWyAxNCBdICk7XG5cblx0XHRcdH07XG5cblx0XHR9KCksXG5cblx0XHRzZXRQb3NpdGlvbjogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0XHR0ZVsgMTIgXSA9IHYueDtcblx0XHRcdHRlWyAxMyBdID0gdi55O1xuXHRcdFx0dGVbIDE0IF0gPSB2Lno7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGdldEludmVyc2U6IGZ1bmN0aW9uICggbSwgdGhyb3dPbkludmVydGlibGUgKSB7XG5cblx0XHRcdC8vIGJhc2VkIG9uIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvbWF0cml4L2Z1bmN0aW9ucy9pbnZlcnNlL2ZvdXJEL2luZGV4Lmh0bVxuXHRcdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRcdHZhciBtZSA9IG0uZWxlbWVudHM7XG5cblx0XHRcdHZhciBuMTEgPSBtZVsgMCBdLCBuMTIgPSBtZVsgNCBdLCBuMTMgPSBtZVsgOCBdLCBuMTQgPSBtZVsgMTIgXTtcblx0XHRcdHZhciBuMjEgPSBtZVsgMSBdLCBuMjIgPSBtZVsgNSBdLCBuMjMgPSBtZVsgOSBdLCBuMjQgPSBtZVsgMTMgXTtcblx0XHRcdHZhciBuMzEgPSBtZVsgMiBdLCBuMzIgPSBtZVsgNiBdLCBuMzMgPSBtZVsgMTAgXSwgbjM0ID0gbWVbIDE0IF07XG5cdFx0XHR2YXIgbjQxID0gbWVbIDMgXSwgbjQyID0gbWVbIDcgXSwgbjQzID0gbWVbIDExIF0sIG40NCA9IG1lWyAxNSBdO1xuXG5cdFx0XHR0ZVsgMCBdID0gbjIzICogbjM0ICogbjQyIC0gbjI0ICogbjMzICogbjQyICsgbjI0ICogbjMyICogbjQzIC0gbjIyICogbjM0ICogbjQzIC0gbjIzICogbjMyICogbjQ0ICsgbjIyICogbjMzICogbjQ0O1xuXHRcdFx0dGVbIDQgXSA9IG4xNCAqIG4zMyAqIG40MiAtIG4xMyAqIG4zNCAqIG40MiAtIG4xNCAqIG4zMiAqIG40MyArIG4xMiAqIG4zNCAqIG40MyArIG4xMyAqIG4zMiAqIG40NCAtIG4xMiAqIG4zMyAqIG40NDtcblx0XHRcdHRlWyA4IF0gPSBuMTMgKiBuMjQgKiBuNDIgLSBuMTQgKiBuMjMgKiBuNDIgKyBuMTQgKiBuMjIgKiBuNDMgLSBuMTIgKiBuMjQgKiBuNDMgLSBuMTMgKiBuMjIgKiBuNDQgKyBuMTIgKiBuMjMgKiBuNDQ7XG5cdFx0XHR0ZVsgMTIgXSA9IG4xNCAqIG4yMyAqIG4zMiAtIG4xMyAqIG4yNCAqIG4zMiAtIG4xNCAqIG4yMiAqIG4zMyArIG4xMiAqIG4yNCAqIG4zMyArIG4xMyAqIG4yMiAqIG4zNCAtIG4xMiAqIG4yMyAqIG4zNDtcblx0XHRcdHRlWyAxIF0gPSBuMjQgKiBuMzMgKiBuNDEgLSBuMjMgKiBuMzQgKiBuNDEgLSBuMjQgKiBuMzEgKiBuNDMgKyBuMjEgKiBuMzQgKiBuNDMgKyBuMjMgKiBuMzEgKiBuNDQgLSBuMjEgKiBuMzMgKiBuNDQ7XG5cdFx0XHR0ZVsgNSBdID0gbjEzICogbjM0ICogbjQxIC0gbjE0ICogbjMzICogbjQxICsgbjE0ICogbjMxICogbjQzIC0gbjExICogbjM0ICogbjQzIC0gbjEzICogbjMxICogbjQ0ICsgbjExICogbjMzICogbjQ0O1xuXHRcdFx0dGVbIDkgXSA9IG4xNCAqIG4yMyAqIG40MSAtIG4xMyAqIG4yNCAqIG40MSAtIG4xNCAqIG4yMSAqIG40MyArIG4xMSAqIG4yNCAqIG40MyArIG4xMyAqIG4yMSAqIG40NCAtIG4xMSAqIG4yMyAqIG40NDtcblx0XHRcdHRlWyAxMyBdID0gbjEzICogbjI0ICogbjMxIC0gbjE0ICogbjIzICogbjMxICsgbjE0ICogbjIxICogbjMzIC0gbjExICogbjI0ICogbjMzIC0gbjEzICogbjIxICogbjM0ICsgbjExICogbjIzICogbjM0O1xuXHRcdFx0dGVbIDIgXSA9IG4yMiAqIG4zNCAqIG40MSAtIG4yNCAqIG4zMiAqIG40MSArIG4yNCAqIG4zMSAqIG40MiAtIG4yMSAqIG4zNCAqIG40MiAtIG4yMiAqIG4zMSAqIG40NCArIG4yMSAqIG4zMiAqIG40NDtcblx0XHRcdHRlWyA2IF0gPSBuMTQgKiBuMzIgKiBuNDEgLSBuMTIgKiBuMzQgKiBuNDEgLSBuMTQgKiBuMzEgKiBuNDIgKyBuMTEgKiBuMzQgKiBuNDIgKyBuMTIgKiBuMzEgKiBuNDQgLSBuMTEgKiBuMzIgKiBuNDQ7XG5cdFx0XHR0ZVsgMTAgXSA9IG4xMiAqIG4yNCAqIG40MSAtIG4xNCAqIG4yMiAqIG40MSArIG4xNCAqIG4yMSAqIG40MiAtIG4xMSAqIG4yNCAqIG40MiAtIG4xMiAqIG4yMSAqIG40NCArIG4xMSAqIG4yMiAqIG40NDtcblx0XHRcdHRlWyAxNCBdID0gbjE0ICogbjIyICogbjMxIC0gbjEyICogbjI0ICogbjMxIC0gbjE0ICogbjIxICogbjMyICsgbjExICogbjI0ICogbjMyICsgbjEyICogbjIxICogbjM0IC0gbjExICogbjIyICogbjM0O1xuXHRcdFx0dGVbIDMgXSA9IG4yMyAqIG4zMiAqIG40MSAtIG4yMiAqIG4zMyAqIG40MSAtIG4yMyAqIG4zMSAqIG40MiArIG4yMSAqIG4zMyAqIG40MiArIG4yMiAqIG4zMSAqIG40MyAtIG4yMSAqIG4zMiAqIG40Mztcblx0XHRcdHRlWyA3IF0gPSBuMTIgKiBuMzMgKiBuNDEgLSBuMTMgKiBuMzIgKiBuNDEgKyBuMTMgKiBuMzEgKiBuNDIgLSBuMTEgKiBuMzMgKiBuNDIgLSBuMTIgKiBuMzEgKiBuNDMgKyBuMTEgKiBuMzIgKiBuNDM7XG5cdFx0XHR0ZVsgMTEgXSA9IG4xMyAqIG4yMiAqIG40MSAtIG4xMiAqIG4yMyAqIG40MSAtIG4xMyAqIG4yMSAqIG40MiArIG4xMSAqIG4yMyAqIG40MiArIG4xMiAqIG4yMSAqIG40MyAtIG4xMSAqIG4yMiAqIG40Mztcblx0XHRcdHRlWyAxNSBdID0gbjEyICogbjIzICogbjMxIC0gbjEzICogbjIyICogbjMxICsgbjEzICogbjIxICogbjMyIC0gbjExICogbjIzICogbjMyIC0gbjEyICogbjIxICogbjMzICsgbjExICogbjIyICogbjMzO1xuXG5cdFx0XHR2YXIgZGV0ID0gbjExICogdGVbIDAgXSArIG4yMSAqIHRlWyA0IF0gKyBuMzEgKiB0ZVsgOCBdICsgbjQxICogdGVbIDEyIF07XG5cblx0XHRcdGlmICggZGV0ID09PSAwICkge1xuXG5cdFx0XHRcdHZhciBtc2cgPSBcIlRIUkVFLk1hdHJpeDQuZ2V0SW52ZXJzZSgpOiBjYW4ndCBpbnZlcnQgbWF0cml4LCBkZXRlcm1pbmFudCBpcyAwXCI7XG5cblx0XHRcdFx0aWYgKCB0aHJvd09uSW52ZXJ0aWJsZSB8fCBmYWxzZSApIHtcblxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggbXNnICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggbXNnICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuaWRlbnRpdHkoKTtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLm11bHRpcGx5U2NhbGFyKCAxIC8gZGV0ICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHRyYW5zbGF0ZTogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4NDogLnRyYW5zbGF0ZSgpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuXG5cdFx0fSxcblxuXHRcdHJvdGF0ZVg6IGZ1bmN0aW9uICggYW5nbGUgKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXg0OiAucm90YXRlWCgpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuXG5cdFx0fSxcblxuXHRcdHJvdGF0ZVk6IGZ1bmN0aW9uICggYW5nbGUgKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXg0OiAucm90YXRlWSgpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuXG5cdFx0fSxcblxuXHRcdHJvdGF0ZVo6IGZ1bmN0aW9uICggYW5nbGUgKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXg0OiAucm90YXRlWigpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuXG5cdFx0fSxcblxuXHRcdHJvdGF0ZUJ5QXhpczogZnVuY3Rpb24gKCBheGlzLCBhbmdsZSApIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLk1hdHJpeDQ6IC5yb3RhdGVCeUF4aXMoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcblxuXHRcdH0sXG5cblx0XHRzY2FsZTogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdFx0dmFyIHggPSB2LngsIHkgPSB2LnksIHogPSB2Lno7XG5cblx0XHRcdHRlWyAwIF0gKj0geDsgdGVbIDQgXSAqPSB5OyB0ZVsgOCBdICo9IHo7XG5cdFx0XHR0ZVsgMSBdICo9IHg7IHRlWyA1IF0gKj0geTsgdGVbIDkgXSAqPSB6O1xuXHRcdFx0dGVbIDIgXSAqPSB4OyB0ZVsgNiBdICo9IHk7IHRlWyAxMCBdICo9IHo7XG5cdFx0XHR0ZVsgMyBdICo9IHg7IHRlWyA3IF0gKj0geTsgdGVbIDExIF0gKj0gejtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0Z2V0TWF4U2NhbGVPbkF4aXM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdFx0dmFyIHNjYWxlWFNxID0gdGVbIDAgXSAqIHRlWyAwIF0gKyB0ZVsgMSBdICogdGVbIDEgXSArIHRlWyAyIF0gKiB0ZVsgMiBdO1xuXHRcdFx0dmFyIHNjYWxlWVNxID0gdGVbIDQgXSAqIHRlWyA0IF0gKyB0ZVsgNSBdICogdGVbIDUgXSArIHRlWyA2IF0gKiB0ZVsgNiBdO1xuXHRcdFx0dmFyIHNjYWxlWlNxID0gdGVbIDggXSAqIHRlWyA4IF0gKyB0ZVsgOSBdICogdGVbIDkgXSArIHRlWyAxMCBdICogdGVbIDEwIF07XG5cblx0XHRcdHJldHVybiBNYXRoLnNxcnQoIE1hdGgubWF4KCBzY2FsZVhTcSwgc2NhbGVZU3EsIHNjYWxlWlNxICkgKTtcblxuXHRcdH0sXG5cblx0XHRtYWtlVHJhbnNsYXRpb246IGZ1bmN0aW9uICggeCwgeSwgeiApIHtcblxuXHRcdFx0dGhpcy5zZXQoXG5cblx0XHRcdFx0MSwgMCwgMCwgeCxcblx0XHRcdFx0MCwgMSwgMCwgeSxcblx0XHRcdFx0MCwgMCwgMSwgeixcblx0XHRcdFx0MCwgMCwgMCwgMVxuXG5cdFx0XHQpO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRtYWtlUm90YXRpb25YOiBmdW5jdGlvbiAoIHRoZXRhICkge1xuXG5cdFx0XHR2YXIgYyA9IE1hdGguY29zKCB0aGV0YSApLCBzID0gTWF0aC5zaW4oIHRoZXRhICk7XG5cblx0XHRcdHRoaXMuc2V0KFxuXG5cdFx0XHRcdDEsIDAsICAwLCAwLFxuXHRcdFx0XHQwLCBjLCAtIHMsIDAsXG5cdFx0XHRcdDAsIHMsICBjLCAwLFxuXHRcdFx0XHQwLCAwLCAgMCwgMVxuXG5cdFx0XHQpO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRtYWtlUm90YXRpb25ZOiBmdW5jdGlvbiAoIHRoZXRhICkge1xuXG5cdFx0XHR2YXIgYyA9IE1hdGguY29zKCB0aGV0YSApLCBzID0gTWF0aC5zaW4oIHRoZXRhICk7XG5cblx0XHRcdHRoaXMuc2V0KFxuXG5cdFx0XHRcdCBjLCAwLCBzLCAwLFxuXHRcdFx0XHQgMCwgMSwgMCwgMCxcblx0XHRcdFx0LSBzLCAwLCBjLCAwLFxuXHRcdFx0XHQgMCwgMCwgMCwgMVxuXG5cdFx0XHQpO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRtYWtlUm90YXRpb25aOiBmdW5jdGlvbiAoIHRoZXRhICkge1xuXG5cdFx0XHR2YXIgYyA9IE1hdGguY29zKCB0aGV0YSApLCBzID0gTWF0aC5zaW4oIHRoZXRhICk7XG5cblx0XHRcdHRoaXMuc2V0KFxuXG5cdFx0XHRcdGMsIC0gcywgMCwgMCxcblx0XHRcdFx0cywgIGMsIDAsIDAsXG5cdFx0XHRcdDAsICAwLCAxLCAwLFxuXHRcdFx0XHQwLCAgMCwgMCwgMVxuXG5cdFx0XHQpO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRtYWtlUm90YXRpb25BeGlzOiBmdW5jdGlvbiAoIGF4aXMsIGFuZ2xlICkge1xuXG5cdFx0XHQvLyBCYXNlZCBvbiBodHRwOi8vd3d3LmdhbWVkZXYubmV0L3JlZmVyZW5jZS9hcnRpY2xlcy9hcnRpY2xlMTE5OS5hc3BcblxuXHRcdFx0dmFyIGMgPSBNYXRoLmNvcyggYW5nbGUgKTtcblx0XHRcdHZhciBzID0gTWF0aC5zaW4oIGFuZ2xlICk7XG5cdFx0XHR2YXIgdCA9IDEgLSBjO1xuXHRcdFx0dmFyIHggPSBheGlzLngsIHkgPSBheGlzLnksIHogPSBheGlzLno7XG5cdFx0XHR2YXIgdHggPSB0ICogeCwgdHkgPSB0ICogeTtcblxuXHRcdFx0dGhpcy5zZXQoXG5cblx0XHRcdFx0dHggKiB4ICsgYywgdHggKiB5IC0gcyAqIHosIHR4ICogeiArIHMgKiB5LCAwLFxuXHRcdFx0XHR0eCAqIHkgKyBzICogeiwgdHkgKiB5ICsgYywgdHkgKiB6IC0gcyAqIHgsIDAsXG5cdFx0XHRcdHR4ICogeiAtIHMgKiB5LCB0eSAqIHogKyBzICogeCwgdCAqIHogKiB6ICsgYywgMCxcblx0XHRcdFx0MCwgMCwgMCwgMVxuXG5cdFx0XHQpO1xuXG5cdFx0XHQgcmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0bWFrZVNjYWxlOiBmdW5jdGlvbiAoIHgsIHksIHogKSB7XG5cblx0XHRcdHRoaXMuc2V0KFxuXG5cdFx0XHRcdHgsIDAsIDAsIDAsXG5cdFx0XHRcdDAsIHksIDAsIDAsXG5cdFx0XHRcdDAsIDAsIHosIDAsXG5cdFx0XHRcdDAsIDAsIDAsIDFcblxuXHRcdFx0KTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0Y29tcG9zZTogZnVuY3Rpb24gKCBwb3NpdGlvbiwgcXVhdGVybmlvbiwgc2NhbGUgKSB7XG5cblx0XHRcdHRoaXMubWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24oIHF1YXRlcm5pb24gKTtcblx0XHRcdHRoaXMuc2NhbGUoIHNjYWxlICk7XG5cdFx0XHR0aGlzLnNldFBvc2l0aW9uKCBwb3NpdGlvbiApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRkZWNvbXBvc2U6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIHZlY3RvciwgbWF0cml4O1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKCBwb3NpdGlvbiwgcXVhdGVybmlvbiwgc2NhbGUgKSB7XG5cblx0XHRcdFx0aWYgKCB2ZWN0b3IgPT09IHVuZGVmaW5lZCApIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0XHRcdGlmICggbWF0cml4ID09PSB1bmRlZmluZWQgKSBtYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG5cdFx0XHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRcdFx0dmFyIHN4ID0gdmVjdG9yLnNldCggdGVbIDAgXSwgdGVbIDEgXSwgdGVbIDIgXSApLmxlbmd0aCgpO1xuXHRcdFx0XHR2YXIgc3kgPSB2ZWN0b3Iuc2V0KCB0ZVsgNCBdLCB0ZVsgNSBdLCB0ZVsgNiBdICkubGVuZ3RoKCk7XG5cdFx0XHRcdHZhciBzeiA9IHZlY3Rvci5zZXQoIHRlWyA4IF0sIHRlWyA5IF0sIHRlWyAxMCBdICkubGVuZ3RoKCk7XG5cblx0XHRcdFx0Ly8gaWYgZGV0ZXJtaW5lIGlzIG5lZ2F0aXZlLCB3ZSBuZWVkIHRvIGludmVydCBvbmUgc2NhbGVcblx0XHRcdFx0dmFyIGRldCA9IHRoaXMuZGV0ZXJtaW5hbnQoKTtcblx0XHRcdFx0aWYgKCBkZXQgPCAwICkge1xuXG5cdFx0XHRcdFx0c3ggPSAtIHN4O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRwb3NpdGlvbi54ID0gdGVbIDEyIF07XG5cdFx0XHRcdHBvc2l0aW9uLnkgPSB0ZVsgMTMgXTtcblx0XHRcdFx0cG9zaXRpb24ueiA9IHRlWyAxNCBdO1xuXG5cdFx0XHRcdC8vIHNjYWxlIHRoZSByb3RhdGlvbiBwYXJ0XG5cblx0XHRcdFx0bWF0cml4LmVsZW1lbnRzLnNldCggdGhpcy5lbGVtZW50cyApOyAvLyBhdCB0aGlzIHBvaW50IG1hdHJpeCBpcyBpbmNvbXBsZXRlIHNvIHdlIGNhbid0IHVzZSAuY29weSgpXG5cblx0XHRcdFx0dmFyIGludlNYID0gMSAvIHN4O1xuXHRcdFx0XHR2YXIgaW52U1kgPSAxIC8gc3k7XG5cdFx0XHRcdHZhciBpbnZTWiA9IDEgLyBzejtcblxuXHRcdFx0XHRtYXRyaXguZWxlbWVudHNbIDAgXSAqPSBpbnZTWDtcblx0XHRcdFx0bWF0cml4LmVsZW1lbnRzWyAxIF0gKj0gaW52U1g7XG5cdFx0XHRcdG1hdHJpeC5lbGVtZW50c1sgMiBdICo9IGludlNYO1xuXG5cdFx0XHRcdG1hdHJpeC5lbGVtZW50c1sgNCBdICo9IGludlNZO1xuXHRcdFx0XHRtYXRyaXguZWxlbWVudHNbIDUgXSAqPSBpbnZTWTtcblx0XHRcdFx0bWF0cml4LmVsZW1lbnRzWyA2IF0gKj0gaW52U1k7XG5cblx0XHRcdFx0bWF0cml4LmVsZW1lbnRzWyA4IF0gKj0gaW52U1o7XG5cdFx0XHRcdG1hdHJpeC5lbGVtZW50c1sgOSBdICo9IGludlNaO1xuXHRcdFx0XHRtYXRyaXguZWxlbWVudHNbIDEwIF0gKj0gaW52U1o7XG5cblx0XHRcdFx0cXVhdGVybmlvbi5zZXRGcm9tUm90YXRpb25NYXRyaXgoIG1hdHJpeCApO1xuXG5cdFx0XHRcdHNjYWxlLnggPSBzeDtcblx0XHRcdFx0c2NhbGUueSA9IHN5O1xuXHRcdFx0XHRzY2FsZS56ID0gc3o7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdH07XG5cblx0XHR9KCksXG5cblx0XHRtYWtlRnJ1c3R1bTogZnVuY3Rpb24gKCBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhciApIHtcblxuXHRcdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRcdHZhciB4ID0gMiAqIG5lYXIgLyAoIHJpZ2h0IC0gbGVmdCApO1xuXHRcdFx0dmFyIHkgPSAyICogbmVhciAvICggdG9wIC0gYm90dG9tICk7XG5cblx0XHRcdHZhciBhID0gKCByaWdodCArIGxlZnQgKSAvICggcmlnaHQgLSBsZWZ0ICk7XG5cdFx0XHR2YXIgYiA9ICggdG9wICsgYm90dG9tICkgLyAoIHRvcCAtIGJvdHRvbSApO1xuXHRcdFx0dmFyIGMgPSAtICggZmFyICsgbmVhciApIC8gKCBmYXIgLSBuZWFyICk7XG5cdFx0XHR2YXIgZCA9IC0gMiAqIGZhciAqIG5lYXIgLyAoIGZhciAtIG5lYXIgKTtcblxuXHRcdFx0dGVbIDAgXSA9IHg7XHR0ZVsgNCBdID0gMDtcdHRlWyA4IF0gPSBhO1x0dGVbIDEyIF0gPSAwO1xuXHRcdFx0dGVbIDEgXSA9IDA7XHR0ZVsgNSBdID0geTtcdHRlWyA5IF0gPSBiO1x0dGVbIDEzIF0gPSAwO1xuXHRcdFx0dGVbIDIgXSA9IDA7XHR0ZVsgNiBdID0gMDtcdHRlWyAxMCBdID0gYztcdHRlWyAxNCBdID0gZDtcblx0XHRcdHRlWyAzIF0gPSAwO1x0dGVbIDcgXSA9IDA7XHR0ZVsgMTEgXSA9IC0gMTtcdHRlWyAxNSBdID0gMDtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0bWFrZVBlcnNwZWN0aXZlOiBmdW5jdGlvbiAoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKSB7XG5cblx0XHRcdHZhciB5bWF4ID0gbmVhciAqIE1hdGgudGFuKCBUSFJFRS5NYXRoLmRlZ1RvUmFkKCBmb3YgKiAwLjUgKSApO1xuXHRcdFx0dmFyIHltaW4gPSAtIHltYXg7XG5cdFx0XHR2YXIgeG1pbiA9IHltaW4gKiBhc3BlY3Q7XG5cdFx0XHR2YXIgeG1heCA9IHltYXggKiBhc3BlY3Q7XG5cblx0XHRcdHJldHVybiB0aGlzLm1ha2VGcnVzdHVtKCB4bWluLCB4bWF4LCB5bWluLCB5bWF4LCBuZWFyLCBmYXIgKTtcblxuXHRcdH0sXG5cblx0XHRtYWtlT3J0aG9ncmFwaGljOiBmdW5jdGlvbiAoIGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgbmVhciwgZmFyICkge1xuXG5cdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdFx0dmFyIHcgPSByaWdodCAtIGxlZnQ7XG5cdFx0XHR2YXIgaCA9IHRvcCAtIGJvdHRvbTtcblx0XHRcdHZhciBwID0gZmFyIC0gbmVhcjtcblxuXHRcdFx0dmFyIHggPSAoIHJpZ2h0ICsgbGVmdCApIC8gdztcblx0XHRcdHZhciB5ID0gKCB0b3AgKyBib3R0b20gKSAvIGg7XG5cdFx0XHR2YXIgeiA9ICggZmFyICsgbmVhciApIC8gcDtcblxuXHRcdFx0dGVbIDAgXSA9IDIgLyB3O1x0dGVbIDQgXSA9IDA7XHR0ZVsgOCBdID0gMDtcdHRlWyAxMiBdID0gLSB4O1xuXHRcdFx0dGVbIDEgXSA9IDA7XHR0ZVsgNSBdID0gMiAvIGg7XHR0ZVsgOSBdID0gMDtcdHRlWyAxMyBdID0gLSB5O1xuXHRcdFx0dGVbIDIgXSA9IDA7XHR0ZVsgNiBdID0gMDtcdHRlWyAxMCBdID0gLSAyIC8gcDtcdHRlWyAxNCBdID0gLSB6O1xuXHRcdFx0dGVbIDMgXSA9IDA7XHR0ZVsgNyBdID0gMDtcdHRlWyAxMSBdID0gMDtcdHRlWyAxNSBdID0gMTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0ZXF1YWxzOiBmdW5jdGlvbiAoIG1hdHJpeCApIHtcblxuXHRcdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRcdHZhciBtZSA9IG1hdHJpeC5lbGVtZW50cztcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgMTY7IGkgKysgKSB7XG5cblx0XHRcdFx0aWYgKCB0ZVsgaSBdICE9PSBtZVsgaSBdICkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0fSxcblxuXHRcdGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSApIHtcblxuXHRcdFx0dGhpcy5lbGVtZW50cy5zZXQoIGFycmF5ICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHRvQXJyYXk6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0dGVbIDAgXSwgdGVbIDEgXSwgdGVbIDIgXSwgdGVbIDMgXSxcblx0XHRcdFx0dGVbIDQgXSwgdGVbIDUgXSwgdGVbIDYgXSwgdGVbIDcgXSxcblx0XHRcdFx0dGVbIDggXSwgdGVbIDkgXSwgdGVbIDEwIF0sIHRlWyAxMSBdLFxuXHRcdFx0XHR0ZVsgMTIgXSwgdGVbIDEzIF0sIHRlWyAxNCBdLCB0ZVsgMTUgXVxuXHRcdFx0XTtcblxuXHRcdH1cblxuXHR9O1xuXG5cdC8vIEZpbGU6c3JjL21hdGgvUmF5LmpzXG5cblx0LyoqXG5cdCAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cblx0ICovXG5cblx0VEhSRUUuUmF5ID0gZnVuY3Rpb24gKCBvcmlnaW4sIGRpcmVjdGlvbiApIHtcblxuXHRcdHRoaXMub3JpZ2luID0gKCBvcmlnaW4gIT09IHVuZGVmaW5lZCApID8gb3JpZ2luIDogbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHR0aGlzLmRpcmVjdGlvbiA9ICggZGlyZWN0aW9uICE9PSB1bmRlZmluZWQgKSA/IGRpcmVjdGlvbiA6IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0fTtcblxuXHRUSFJFRS5SYXkucHJvdG90eXBlID0ge1xuXG5cdFx0Y29uc3RydWN0b3I6IFRIUkVFLlJheSxcblxuXHRcdHNldDogZnVuY3Rpb24gKCBvcmlnaW4sIGRpcmVjdGlvbiApIHtcblxuXHRcdFx0dGhpcy5vcmlnaW4uY29weSggb3JpZ2luICk7XG5cdFx0XHR0aGlzLmRpcmVjdGlvbi5jb3B5KCBkaXJlY3Rpb24gKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG5cdFx0fSxcblxuXHRcdGNvcHk6IGZ1bmN0aW9uICggcmF5ICkge1xuXG5cdFx0XHR0aGlzLm9yaWdpbi5jb3B5KCByYXkub3JpZ2luICk7XG5cdFx0XHR0aGlzLmRpcmVjdGlvbi5jb3B5KCByYXkuZGlyZWN0aW9uICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGF0OiBmdW5jdGlvbiAoIHQsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdFx0cmV0dXJuIHJlc3VsdC5jb3B5KCB0aGlzLmRpcmVjdGlvbiApLm11bHRpcGx5U2NhbGFyKCB0ICkuYWRkKCB0aGlzLm9yaWdpbiApO1xuXG5cdFx0fSxcblxuXHRcdHJlY2FzdDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKCB0ICkge1xuXG5cdFx0XHRcdHRoaXMub3JpZ2luLmNvcHkoIHRoaXMuYXQoIHQsIHYxICkgKTtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdFx0fTtcblxuXHRcdH0oKSxcblxuXHRcdGNsb3Nlc3RQb2ludFRvUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHRcdHJlc3VsdC5zdWJWZWN0b3JzKCBwb2ludCwgdGhpcy5vcmlnaW4gKTtcblx0XHRcdHZhciBkaXJlY3Rpb25EaXN0YW5jZSA9IHJlc3VsdC5kb3QoIHRoaXMuZGlyZWN0aW9uICk7XG5cblx0XHRcdGlmICggZGlyZWN0aW9uRGlzdGFuY2UgPCAwICkge1xuXG5cdFx0XHRcdHJldHVybiByZXN1bHQuY29weSggdGhpcy5vcmlnaW4gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcmVzdWx0LmNvcHkoIHRoaXMuZGlyZWN0aW9uICkubXVsdGlwbHlTY2FsYXIoIGRpcmVjdGlvbkRpc3RhbmNlICkuYWRkKCB0aGlzLm9yaWdpbiApO1xuXG5cdFx0fSxcblxuXHRcdGRpc3RhbmNlVG9Qb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcblxuXHRcdFx0cmV0dXJuIE1hdGguc3FydCggdGhpcy5kaXN0YW5jZVNxVG9Qb2ludCggcG9pbnQgKSApO1xuXG5cdFx0fSxcblxuXHRcdGRpc3RhbmNlU3FUb1BvaW50OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiAoIHBvaW50ICkge1xuXG5cdFx0XHRcdHZhciBkaXJlY3Rpb25EaXN0YW5jZSA9IHYxLnN1YlZlY3RvcnMoIHBvaW50LCB0aGlzLm9yaWdpbiApLmRvdCggdGhpcy5kaXJlY3Rpb24gKTtcblxuXHRcdFx0XHQvLyBwb2ludCBiZWhpbmQgdGhlIHJheVxuXG5cdFx0XHRcdGlmICggZGlyZWN0aW9uRGlzdGFuY2UgPCAwICkge1xuXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMub3JpZ2luLmRpc3RhbmNlVG9TcXVhcmVkKCBwb2ludCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2MS5jb3B5KCB0aGlzLmRpcmVjdGlvbiApLm11bHRpcGx5U2NhbGFyKCBkaXJlY3Rpb25EaXN0YW5jZSApLmFkZCggdGhpcy5vcmlnaW4gKTtcblxuXHRcdFx0XHRyZXR1cm4gdjEuZGlzdGFuY2VUb1NxdWFyZWQoIHBvaW50ICk7XG5cblx0XHRcdH07XG5cblx0XHR9KCksXG5cblx0XHRkaXN0YW5jZVNxVG9TZWdtZW50OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciBzZWdDZW50ZXIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdFx0dmFyIHNlZ0RpciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0XHR2YXIgZGlmZiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiAoIHYwLCB2MSwgb3B0aW9uYWxQb2ludE9uUmF5LCBvcHRpb25hbFBvaW50T25TZWdtZW50ICkge1xuXG5cdFx0XHRcdC8vIGZyb20gaHR0cDovL3d3dy5nZW9tZXRyaWN0b29scy5jb20vTGliTWF0aGVtYXRpY3MvRGlzdGFuY2UvV201RGlzdFJheTNTZWdtZW50My5jcHBcblx0XHRcdFx0Ly8gSXQgcmV0dXJucyB0aGUgbWluIGRpc3RhbmNlIGJldHdlZW4gdGhlIHJheSBhbmQgdGhlIHNlZ21lbnRcblx0XHRcdFx0Ly8gZGVmaW5lZCBieSB2MCBhbmQgdjFcblx0XHRcdFx0Ly8gSXQgY2FuIGFsc28gc2V0IHR3byBvcHRpb25hbCB0YXJnZXRzIDpcblx0XHRcdFx0Ly8gLSBUaGUgY2xvc2VzdCBwb2ludCBvbiB0aGUgcmF5XG5cdFx0XHRcdC8vIC0gVGhlIGNsb3Nlc3QgcG9pbnQgb24gdGhlIHNlZ21lbnRcblxuXHRcdFx0XHRzZWdDZW50ZXIuY29weSggdjAgKS5hZGQoIHYxICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xuXHRcdFx0XHRzZWdEaXIuY29weSggdjEgKS5zdWIoIHYwICkubm9ybWFsaXplKCk7XG5cdFx0XHRcdGRpZmYuY29weSggdGhpcy5vcmlnaW4gKS5zdWIoIHNlZ0NlbnRlciApO1xuXG5cdFx0XHRcdHZhciBzZWdFeHRlbnQgPSB2MC5kaXN0YW5jZVRvKCB2MSApICogMC41O1xuXHRcdFx0XHR2YXIgYTAxID0gLSB0aGlzLmRpcmVjdGlvbi5kb3QoIHNlZ0RpciApO1xuXHRcdFx0XHR2YXIgYjAgPSBkaWZmLmRvdCggdGhpcy5kaXJlY3Rpb24gKTtcblx0XHRcdFx0dmFyIGIxID0gLSBkaWZmLmRvdCggc2VnRGlyICk7XG5cdFx0XHRcdHZhciBjID0gZGlmZi5sZW5ndGhTcSgpO1xuXHRcdFx0XHR2YXIgZGV0ID0gTWF0aC5hYnMoIDEgLSBhMDEgKiBhMDEgKTtcblx0XHRcdFx0dmFyIHMwLCBzMSwgc3FyRGlzdCwgZXh0RGV0O1xuXG5cdFx0XHRcdGlmICggZGV0ID4gMCApIHtcblxuXHRcdFx0XHRcdC8vIFRoZSByYXkgYW5kIHNlZ21lbnQgYXJlIG5vdCBwYXJhbGxlbC5cblxuXHRcdFx0XHRcdHMwID0gYTAxICogYjEgLSBiMDtcblx0XHRcdFx0XHRzMSA9IGEwMSAqIGIwIC0gYjE7XG5cdFx0XHRcdFx0ZXh0RGV0ID0gc2VnRXh0ZW50ICogZGV0O1xuXG5cdFx0XHRcdFx0aWYgKCBzMCA+PSAwICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIHMxID49IC0gZXh0RGV0ICkge1xuXG5cdFx0XHRcdFx0XHRcdGlmICggczEgPD0gZXh0RGV0ICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gcmVnaW9uIDBcblx0XHRcdFx0XHRcdFx0XHQvLyBNaW5pbXVtIGF0IGludGVyaW9yIHBvaW50cyBvZiByYXkgYW5kIHNlZ21lbnQuXG5cblx0XHRcdFx0XHRcdFx0XHR2YXIgaW52RGV0ID0gMSAvIGRldDtcblx0XHRcdFx0XHRcdFx0XHRzMCAqPSBpbnZEZXQ7XG5cdFx0XHRcdFx0XHRcdFx0czEgKj0gaW52RGV0O1xuXHRcdFx0XHRcdFx0XHRcdHNxckRpc3QgPSBzMCAqICggczAgKyBhMDEgKiBzMSArIDIgKiBiMCApICsgczEgKiAoIGEwMSAqIHMwICsgczEgKyAyICogYjEgKSArIGM7XG5cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIHJlZ2lvbiAxXG5cblx0XHRcdFx0XHRcdFx0XHRzMSA9IHNlZ0V4dGVudDtcblx0XHRcdFx0XHRcdFx0XHRzMCA9IE1hdGgubWF4KCAwLCAtICggYTAxICogczEgKyBiMCApICk7XG5cdFx0XHRcdFx0XHRcdFx0c3FyRGlzdCA9IC0gczAgKiBzMCArIHMxICogKCBzMSArIDIgKiBiMSApICsgYztcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gcmVnaW9uIDVcblxuXHRcdFx0XHRcdFx0XHRzMSA9IC0gc2VnRXh0ZW50O1xuXHRcdFx0XHRcdFx0XHRzMCA9IE1hdGgubWF4KCAwLCAtICggYTAxICogczEgKyBiMCApICk7XG5cdFx0XHRcdFx0XHRcdHNxckRpc3QgPSAtIHMwICogczAgKyBzMSAqICggczEgKyAyICogYjEgKSArIGM7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdGlmICggczEgPD0gLSBleHREZXQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gcmVnaW9uIDRcblxuXHRcdFx0XHRcdFx0XHRzMCA9IE1hdGgubWF4KCAwLCAtICggLSBhMDEgKiBzZWdFeHRlbnQgKyBiMCApICk7XG5cdFx0XHRcdFx0XHRcdHMxID0gKCBzMCA+IDAgKSA/IC0gc2VnRXh0ZW50IDogTWF0aC5taW4oIE1hdGgubWF4KCAtIHNlZ0V4dGVudCwgLSBiMSApLCBzZWdFeHRlbnQgKTtcblx0XHRcdFx0XHRcdFx0c3FyRGlzdCA9IC0gczAgKiBzMCArIHMxICogKCBzMSArIDIgKiBiMSApICsgYztcblxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggczEgPD0gZXh0RGV0ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIHJlZ2lvbiAzXG5cblx0XHRcdFx0XHRcdFx0czAgPSAwO1xuXHRcdFx0XHRcdFx0XHRzMSA9IE1hdGgubWluKCBNYXRoLm1heCggLSBzZWdFeHRlbnQsIC0gYjEgKSwgc2VnRXh0ZW50ICk7XG5cdFx0XHRcdFx0XHRcdHNxckRpc3QgPSBzMSAqICggczEgKyAyICogYjEgKSArIGM7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gcmVnaW9uIDJcblxuXHRcdFx0XHRcdFx0XHRzMCA9IE1hdGgubWF4KCAwLCAtICggYTAxICogc2VnRXh0ZW50ICsgYjAgKSApO1xuXHRcdFx0XHRcdFx0XHRzMSA9ICggczAgPiAwICkgPyBzZWdFeHRlbnQgOiBNYXRoLm1pbiggTWF0aC5tYXgoIC0gc2VnRXh0ZW50LCAtIGIxICksIHNlZ0V4dGVudCApO1xuXHRcdFx0XHRcdFx0XHRzcXJEaXN0ID0gLSBzMCAqIHMwICsgczEgKiAoIHMxICsgMiAqIGIxICkgKyBjO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIFJheSBhbmQgc2VnbWVudCBhcmUgcGFyYWxsZWwuXG5cblx0XHRcdFx0XHRzMSA9ICggYTAxID4gMCApID8gLSBzZWdFeHRlbnQgOiBzZWdFeHRlbnQ7XG5cdFx0XHRcdFx0czAgPSBNYXRoLm1heCggMCwgLSAoIGEwMSAqIHMxICsgYjAgKSApO1xuXHRcdFx0XHRcdHNxckRpc3QgPSAtIHMwICogczAgKyBzMSAqICggczEgKyAyICogYjEgKSArIGM7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggb3B0aW9uYWxQb2ludE9uUmF5ICkge1xuXG5cdFx0XHRcdFx0b3B0aW9uYWxQb2ludE9uUmF5LmNvcHkoIHRoaXMuZGlyZWN0aW9uICkubXVsdGlwbHlTY2FsYXIoIHMwICkuYWRkKCB0aGlzLm9yaWdpbiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIG9wdGlvbmFsUG9pbnRPblNlZ21lbnQgKSB7XG5cblx0XHRcdFx0XHRvcHRpb25hbFBvaW50T25TZWdtZW50LmNvcHkoIHNlZ0RpciApLm11bHRpcGx5U2NhbGFyKCBzMSApLmFkZCggc2VnQ2VudGVyICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBzcXJEaXN0O1xuXG5cdFx0XHR9O1xuXG5cdFx0fSgpLFxuXG5cblx0XHRpc0ludGVyc2VjdGlvblNwaGVyZTogZnVuY3Rpb24gKCBzcGhlcmUgKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLmRpc3RhbmNlVG9Qb2ludCggc3BoZXJlLmNlbnRlciApIDw9IHNwaGVyZS5yYWRpdXM7XG5cblx0XHR9LFxuXG5cdFx0aW50ZXJzZWN0U3BoZXJlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdC8vIGZyb20gaHR0cDovL3d3dy5zY3JhdGNoYXBpeGVsLmNvbS9sZXNzb25zLzNkLWJhc2ljLWxlc3NvbnMvbGVzc29uLTctaW50ZXJzZWN0aW5nLXNpbXBsZS1zaGFwZXMvcmF5LXNwaGVyZS1pbnRlcnNlY3Rpb24vXG5cblx0XHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiAoIHNwaGVyZSwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHRcdFx0djEuc3ViVmVjdG9ycyggc3BoZXJlLmNlbnRlciwgdGhpcy5vcmlnaW4gKTtcblxuXHRcdFx0XHR2YXIgdGNhID0gdjEuZG90KCB0aGlzLmRpcmVjdGlvbiApO1xuXG5cdFx0XHRcdHZhciBkMiA9IHYxLmRvdCggdjEgKSAtIHRjYSAqIHRjYTtcblxuXHRcdFx0XHR2YXIgcmFkaXVzMiA9IHNwaGVyZS5yYWRpdXMgKiBzcGhlcmUucmFkaXVzO1xuXG5cdFx0XHRcdGlmICggZDIgPiByYWRpdXMyICkgcmV0dXJuIG51bGw7XG5cblx0XHRcdFx0dmFyIHRoYyA9IE1hdGguc3FydCggcmFkaXVzMiAtIGQyICk7XG5cblx0XHRcdFx0Ly8gdDAgPSBmaXJzdCBpbnRlcnNlY3QgcG9pbnQgLSBlbnRyYW5jZSBvbiBmcm9udCBvZiBzcGhlcmVcblx0XHRcdFx0dmFyIHQwID0gdGNhIC0gdGhjO1xuXG5cdFx0XHRcdC8vIHQxID0gc2Vjb25kIGludGVyc2VjdCBwb2ludCAtIGV4aXQgcG9pbnQgb24gYmFjayBvZiBzcGhlcmVcblx0XHRcdFx0dmFyIHQxID0gdGNhICsgdGhjO1xuXG5cdFx0XHRcdC8vIHRlc3QgdG8gc2VlIGlmIGJvdGggdDAgYW5kIHQxIGFyZSBiZWhpbmQgdGhlIHJheSAtIGlmIHNvLCByZXR1cm4gbnVsbFxuXHRcdFx0XHRpZiAoIHQwIDwgMCAmJiB0MSA8IDAgKSByZXR1cm4gbnVsbDtcblxuXHRcdFx0XHQvLyB0ZXN0IHRvIHNlZSBpZiB0MCBpcyBiZWhpbmQgdGhlIHJheTpcblx0XHRcdFx0Ly8gaWYgaXQgaXMsIHRoZSByYXkgaXMgaW5zaWRlIHRoZSBzcGhlcmUsIHNvIHJldHVybiB0aGUgc2Vjb25kIGV4aXQgcG9pbnQgc2NhbGVkIGJ5IHQxLFxuXHRcdFx0XHQvLyBpbiBvcmRlciB0byBhbHdheXMgcmV0dXJuIGFuIGludGVyc2VjdCBwb2ludCB0aGF0IGlzIGluIGZyb250IG9mIHRoZSByYXkuXG5cdFx0XHRcdGlmICggdDAgPCAwICkgcmV0dXJuIHRoaXMuYXQoIHQxLCBvcHRpb25hbFRhcmdldCApO1xuXG5cdFx0XHRcdC8vIGVsc2UgdDAgaXMgaW4gZnJvbnQgb2YgdGhlIHJheSwgc28gcmV0dXJuIHRoZSBmaXJzdCBjb2xsaXNpb24gcG9pbnQgc2NhbGVkIGJ5IHQwXG5cdFx0XHRcdHJldHVybiB0aGlzLmF0KCB0MCwgb3B0aW9uYWxUYXJnZXQgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSgpLFxuXG5cdFx0aXNJbnRlcnNlY3Rpb25QbGFuZTogZnVuY3Rpb24gKCBwbGFuZSApIHtcblxuXHRcdFx0Ly8gY2hlY2sgaWYgdGhlIHJheSBsaWVzIG9uIHRoZSBwbGFuZSBmaXJzdFxuXG5cdFx0XHR2YXIgZGlzdFRvUG9pbnQgPSBwbGFuZS5kaXN0YW5jZVRvUG9pbnQoIHRoaXMub3JpZ2luICk7XG5cblx0XHRcdGlmICggZGlzdFRvUG9pbnQgPT09IDAgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIGRlbm9taW5hdG9yID0gcGxhbmUubm9ybWFsLmRvdCggdGhpcy5kaXJlY3Rpb24gKTtcblxuXHRcdFx0aWYgKCBkZW5vbWluYXRvciAqIGRpc3RUb1BvaW50IDwgMCApIHtcblxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyByYXkgb3JpZ2luIGlzIGJlaGluZCB0aGUgcGxhbmUgKGFuZCBpcyBwb2ludGluZyBiZWhpbmQgaXQpXG5cblx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdH0sXG5cblx0XHRkaXN0YW5jZVRvUGxhbmU6IGZ1bmN0aW9uICggcGxhbmUgKSB7XG5cblx0XHRcdHZhciBkZW5vbWluYXRvciA9IHBsYW5lLm5vcm1hbC5kb3QoIHRoaXMuZGlyZWN0aW9uICk7XG5cdFx0XHRpZiAoIGRlbm9taW5hdG9yID09PSAwICkge1xuXG5cdFx0XHRcdC8vIGxpbmUgaXMgY29wbGFuYXIsIHJldHVybiBvcmlnaW5cblx0XHRcdFx0aWYgKCBwbGFuZS5kaXN0YW5jZVRvUG9pbnQoIHRoaXMub3JpZ2luICkgPT09IDAgKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gMDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTnVsbCBpcyBwcmVmZXJhYmxlIHRvIHVuZGVmaW5lZCBzaW5jZSB1bmRlZmluZWQgbWVhbnMuLi4uIGl0IGlzIHVuZGVmaW5lZFxuXG5cdFx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciB0ID0gLSAoIHRoaXMub3JpZ2luLmRvdCggcGxhbmUubm9ybWFsICkgKyBwbGFuZS5jb25zdGFudCApIC8gZGVub21pbmF0b3I7XG5cblx0XHRcdC8vIFJldHVybiBpZiB0aGUgcmF5IG5ldmVyIGludGVyc2VjdHMgdGhlIHBsYW5lXG5cblx0XHRcdHJldHVybiB0ID49IDAgPyB0IDogIG51bGw7XG5cblx0XHR9LFxuXG5cdFx0aW50ZXJzZWN0UGxhbmU6IGZ1bmN0aW9uICggcGxhbmUsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0XHR2YXIgdCA9IHRoaXMuZGlzdGFuY2VUb1BsYW5lKCBwbGFuZSApO1xuXG5cdFx0XHRpZiAoIHQgPT09IG51bGwgKSB7XG5cblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXMuYXQoIHQsIG9wdGlvbmFsVGFyZ2V0ICk7XG5cblx0XHR9LFxuXG5cdFx0aXNJbnRlcnNlY3Rpb25Cb3g6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIHYgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKCBib3ggKSB7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXMuaW50ZXJzZWN0Qm94KCBib3gsIHYgKSAhPT0gbnVsbDtcblxuXHRcdFx0fTtcblxuXHRcdH0oKSxcblxuXHRcdGludGVyc2VjdEJveDogZnVuY3Rpb24gKCBib3gsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0XHQvLyBodHRwOi8vd3d3LnNjcmF0Y2hhcGl4ZWwuY29tL2xlc3NvbnMvM2QtYmFzaWMtbGVzc29ucy9sZXNzb24tNy1pbnRlcnNlY3Rpbmctc2ltcGxlLXNoYXBlcy9yYXktYm94LWludGVyc2VjdGlvbi9cblxuXHRcdFx0dmFyIHRtaW4sIHRtYXgsIHR5bWluLCB0eW1heCwgdHptaW4sIHR6bWF4O1xuXG5cdFx0XHR2YXIgaW52ZGlyeCA9IDEgLyB0aGlzLmRpcmVjdGlvbi54LFxuXHRcdFx0XHRpbnZkaXJ5ID0gMSAvIHRoaXMuZGlyZWN0aW9uLnksXG5cdFx0XHRcdGludmRpcnogPSAxIC8gdGhpcy5kaXJlY3Rpb24uejtcblxuXHRcdFx0dmFyIG9yaWdpbiA9IHRoaXMub3JpZ2luO1xuXG5cdFx0XHRpZiAoIGludmRpcnggPj0gMCApIHtcblxuXHRcdFx0XHR0bWluID0gKCBib3gubWluLnggLSBvcmlnaW4ueCApICogaW52ZGlyeDtcblx0XHRcdFx0dG1heCA9ICggYm94Lm1heC54IC0gb3JpZ2luLnggKSAqIGludmRpcng7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dG1pbiA9ICggYm94Lm1heC54IC0gb3JpZ2luLnggKSAqIGludmRpcng7XG5cdFx0XHRcdHRtYXggPSAoIGJveC5taW4ueCAtIG9yaWdpbi54ICkgKiBpbnZkaXJ4O1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggaW52ZGlyeSA+PSAwICkge1xuXG5cdFx0XHRcdHR5bWluID0gKCBib3gubWluLnkgLSBvcmlnaW4ueSApICogaW52ZGlyeTtcblx0XHRcdFx0dHltYXggPSAoIGJveC5tYXgueSAtIG9yaWdpbi55ICkgKiBpbnZkaXJ5O1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHR5bWluID0gKCBib3gubWF4LnkgLSBvcmlnaW4ueSApICogaW52ZGlyeTtcblx0XHRcdFx0dHltYXggPSAoIGJveC5taW4ueSAtIG9yaWdpbi55ICkgKiBpbnZkaXJ5O1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggKCB0bWluID4gdHltYXggKSB8fCAoIHR5bWluID4gdG1heCApICkgcmV0dXJuIG51bGw7XG5cblx0XHRcdC8vIFRoZXNlIGxpbmVzIGFsc28gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIHRtaW4gb3IgdG1heCBpcyBOYU5cblx0XHRcdC8vIChyZXN1bHQgb2YgMCAqIEluZmluaXR5KS4geCAhPT0geCByZXR1cm5zIHRydWUgaWYgeCBpcyBOYU5cblxuXHRcdFx0aWYgKCB0eW1pbiA+IHRtaW4gfHwgdG1pbiAhPT0gdG1pbiApIHRtaW4gPSB0eW1pbjtcblxuXHRcdFx0aWYgKCB0eW1heCA8IHRtYXggfHwgdG1heCAhPT0gdG1heCApIHRtYXggPSB0eW1heDtcblxuXHRcdFx0aWYgKCBpbnZkaXJ6ID49IDAgKSB7XG5cblx0XHRcdFx0dHptaW4gPSAoIGJveC5taW4ueiAtIG9yaWdpbi56ICkgKiBpbnZkaXJ6O1xuXHRcdFx0XHR0em1heCA9ICggYm94Lm1heC56IC0gb3JpZ2luLnogKSAqIGludmRpcno7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dHptaW4gPSAoIGJveC5tYXgueiAtIG9yaWdpbi56ICkgKiBpbnZkaXJ6O1xuXHRcdFx0XHR0em1heCA9ICggYm94Lm1pbi56IC0gb3JpZ2luLnogKSAqIGludmRpcno7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCAoIHRtaW4gPiB0em1heCApIHx8ICggdHptaW4gPiB0bWF4ICkgKSByZXR1cm4gbnVsbDtcblxuXHRcdFx0aWYgKCB0em1pbiA+IHRtaW4gfHwgdG1pbiAhPT0gdG1pbiApIHRtaW4gPSB0em1pbjtcblxuXHRcdFx0aWYgKCB0em1heCA8IHRtYXggfHwgdG1heCAhPT0gdG1heCApIHRtYXggPSB0em1heDtcblxuXHRcdFx0Ly9yZXR1cm4gcG9pbnQgY2xvc2VzdCB0byB0aGUgcmF5IChwb3NpdGl2ZSBzaWRlKVxuXG5cdFx0XHRpZiAoIHRtYXggPCAwICkgcmV0dXJuIG51bGw7XG5cblx0XHRcdHJldHVybiB0aGlzLmF0KCB0bWluID49IDAgPyB0bWluIDogdG1heCwgb3B0aW9uYWxUYXJnZXQgKTtcblxuXHRcdH0sXG5cblx0XHRpbnRlcnNlY3RUcmlhbmdsZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHQvLyBDb21wdXRlIHRoZSBvZmZzZXQgb3JpZ2luLCBlZGdlcywgYW5kIG5vcm1hbC5cblx0XHRcdHZhciBkaWZmID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHRcdHZhciBlZGdlMSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0XHR2YXIgZWRnZTIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdFx0dmFyIG5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiAoIGEsIGIsIGMsIGJhY2tmYWNlQ3VsbGluZywgb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHRcdFx0Ly8gZnJvbSBodHRwOi8vd3d3Lmdlb21ldHJpY3Rvb2xzLmNvbS9MaWJNYXRoZW1hdGljcy9JbnRlcnNlY3Rpb24vV201SW50clJheTNUcmlhbmdsZTMuY3BwXG5cblx0XHRcdFx0ZWRnZTEuc3ViVmVjdG9ycyggYiwgYSApO1xuXHRcdFx0XHRlZGdlMi5zdWJWZWN0b3JzKCBjLCBhICk7XG5cdFx0XHRcdG5vcm1hbC5jcm9zc1ZlY3RvcnMoIGVkZ2UxLCBlZGdlMiApO1xuXG5cdFx0XHRcdC8vIFNvbHZlIFEgKyB0KkQgPSBiMSpFMSArIGIyKkUyIChRID0ga0RpZmYsIEQgPSByYXkgZGlyZWN0aW9uLFxuXHRcdFx0XHQvLyBFMSA9IGtFZGdlMSwgRTIgPSBrRWRnZTIsIE4gPSBDcm9zcyhFMSxFMikpIGJ5XG5cdFx0XHRcdC8vICAgfERvdChELE4pfCpiMSA9IHNpZ24oRG90KEQsTikpKkRvdChELENyb3NzKFEsRTIpKVxuXHRcdFx0XHQvLyAgIHxEb3QoRCxOKXwqYjIgPSBzaWduKERvdChELE4pKSpEb3QoRCxDcm9zcyhFMSxRKSlcblx0XHRcdFx0Ly8gICB8RG90KEQsTil8KnQgPSAtc2lnbihEb3QoRCxOKSkqRG90KFEsTilcblx0XHRcdFx0dmFyIERkTiA9IHRoaXMuZGlyZWN0aW9uLmRvdCggbm9ybWFsICk7XG5cdFx0XHRcdHZhciBzaWduO1xuXG5cdFx0XHRcdGlmICggRGROID4gMCApIHtcblxuXHRcdFx0XHRcdGlmICggYmFja2ZhY2VDdWxsaW5nICkgcmV0dXJuIG51bGw7XG5cdFx0XHRcdFx0c2lnbiA9IDE7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggRGROIDwgMCApIHtcblxuXHRcdFx0XHRcdHNpZ24gPSAtIDE7XG5cdFx0XHRcdFx0RGROID0gLSBEZE47XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkaWZmLnN1YlZlY3RvcnMoIHRoaXMub3JpZ2luLCBhICk7XG5cdFx0XHRcdHZhciBEZFF4RTIgPSBzaWduICogdGhpcy5kaXJlY3Rpb24uZG90KCBlZGdlMi5jcm9zc1ZlY3RvcnMoIGRpZmYsIGVkZ2UyICkgKTtcblxuXHRcdFx0XHQvLyBiMSA8IDAsIG5vIGludGVyc2VjdGlvblxuXHRcdFx0XHRpZiAoIERkUXhFMiA8IDAgKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIERkRTF4USA9IHNpZ24gKiB0aGlzLmRpcmVjdGlvbi5kb3QoIGVkZ2UxLmNyb3NzKCBkaWZmICkgKTtcblxuXHRcdFx0XHQvLyBiMiA8IDAsIG5vIGludGVyc2VjdGlvblxuXHRcdFx0XHRpZiAoIERkRTF4USA8IDAgKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gYjErYjIgPiAxLCBubyBpbnRlcnNlY3Rpb25cblx0XHRcdFx0aWYgKCBEZFF4RTIgKyBEZEUxeFEgPiBEZE4gKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTGluZSBpbnRlcnNlY3RzIHRyaWFuZ2xlLCBjaGVjayBpZiByYXkgZG9lcy5cblx0XHRcdFx0dmFyIFFkTiA9IC0gc2lnbiAqIGRpZmYuZG90KCBub3JtYWwgKTtcblxuXHRcdFx0XHQvLyB0IDwgMCwgbm8gaW50ZXJzZWN0aW9uXG5cdFx0XHRcdGlmICggUWROIDwgMCApIHtcblxuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSYXkgaW50ZXJzZWN0cyB0cmlhbmdsZS5cblx0XHRcdFx0cmV0dXJuIHRoaXMuYXQoIFFkTiAvIERkTiwgb3B0aW9uYWxUYXJnZXQgKTtcblxuXHRcdFx0fTtcblxuXHRcdH0oKSxcblxuXHRcdGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCBtYXRyaXg0ICkge1xuXG5cdFx0XHR0aGlzLmRpcmVjdGlvbi5hZGQoIHRoaXMub3JpZ2luICkuYXBwbHlNYXRyaXg0KCBtYXRyaXg0ICk7XG5cdFx0XHR0aGlzLm9yaWdpbi5hcHBseU1hdHJpeDQoIG1hdHJpeDQgKTtcblx0XHRcdHRoaXMuZGlyZWN0aW9uLnN1YiggdGhpcy5vcmlnaW4gKTtcblx0XHRcdHRoaXMuZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRlcXVhbHM6IGZ1bmN0aW9uICggcmF5ICkge1xuXG5cdFx0XHRyZXR1cm4gcmF5Lm9yaWdpbi5lcXVhbHMoIHRoaXMub3JpZ2luICkgJiYgcmF5LmRpcmVjdGlvbi5lcXVhbHMoIHRoaXMuZGlyZWN0aW9uICk7XG5cblx0XHR9XG5cblx0fTtcblxuXHQvLyBGaWxlOnNyYy9tYXRoL1NwaGVyZS5qc1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqL1xuXG5cdFRIUkVFLlNwaGVyZSA9IGZ1bmN0aW9uICggY2VudGVyLCByYWRpdXMgKSB7XG5cblx0XHR0aGlzLmNlbnRlciA9ICggY2VudGVyICE9PSB1bmRlZmluZWQgKSA/IGNlbnRlciA6IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0dGhpcy5yYWRpdXMgPSAoIHJhZGl1cyAhPT0gdW5kZWZpbmVkICkgPyByYWRpdXMgOiAwO1xuXG5cdH07XG5cblx0VEhSRUUuU3BoZXJlLnByb3RvdHlwZSA9IHtcblxuXHRcdGNvbnN0cnVjdG9yOiBUSFJFRS5TcGhlcmUsXG5cblx0XHRzZXQ6IGZ1bmN0aW9uICggY2VudGVyLCByYWRpdXMgKSB7XG5cblx0XHRcdHRoaXMuY2VudGVyLmNvcHkoIGNlbnRlciApO1xuXHRcdFx0dGhpcy5yYWRpdXMgPSByYWRpdXM7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHNldEZyb21Qb2ludHM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIGJveCA9IG5ldyBUSFJFRS5Cb3gzKCk7XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiAoIHBvaW50cywgb3B0aW9uYWxDZW50ZXIgKSB7XG5cblx0XHRcdFx0dmFyIGNlbnRlciA9IHRoaXMuY2VudGVyO1xuXG5cdFx0XHRcdGlmICggb3B0aW9uYWxDZW50ZXIgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGNlbnRlci5jb3B5KCBvcHRpb25hbENlbnRlciApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRib3guc2V0RnJvbVBvaW50cyggcG9pbnRzICkuY2VudGVyKCBjZW50ZXIgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIG1heFJhZGl1c1NxID0gMDtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0bWF4UmFkaXVzU3EgPSBNYXRoLm1heCggbWF4UmFkaXVzU3EsIGNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZCggcG9pbnRzWyBpIF0gKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLnJhZGl1cyA9IE1hdGguc3FydCggbWF4UmFkaXVzU3EgKTtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdFx0fTtcblxuXHRcdH0oKSxcblxuXHRcdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuXHRcdH0sXG5cblx0XHRjb3B5OiBmdW5jdGlvbiAoIHNwaGVyZSApIHtcblxuXHRcdFx0dGhpcy5jZW50ZXIuY29weSggc3BoZXJlLmNlbnRlciApO1xuXHRcdFx0dGhpcy5yYWRpdXMgPSBzcGhlcmUucmFkaXVzO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRlbXB0eTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gKCB0aGlzLnJhZGl1cyA8PSAwICk7XG5cblx0XHR9LFxuXG5cdFx0Y29udGFpbnNQb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcblxuXHRcdFx0cmV0dXJuICggcG9pbnQuZGlzdGFuY2VUb1NxdWFyZWQoIHRoaXMuY2VudGVyICkgPD0gKCB0aGlzLnJhZGl1cyAqIHRoaXMucmFkaXVzICkgKTtcblxuXHRcdH0sXG5cblx0XHRkaXN0YW5jZVRvUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XG5cblx0XHRcdHJldHVybiAoIHBvaW50LmRpc3RhbmNlVG8oIHRoaXMuY2VudGVyICkgLSB0aGlzLnJhZGl1cyApO1xuXG5cdFx0fSxcblxuXHRcdGludGVyc2VjdHNTcGhlcmU6IGZ1bmN0aW9uICggc3BoZXJlICkge1xuXG5cdFx0XHR2YXIgcmFkaXVzU3VtID0gdGhpcy5yYWRpdXMgKyBzcGhlcmUucmFkaXVzO1xuXG5cdFx0XHRyZXR1cm4gc3BoZXJlLmNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZCggdGhpcy5jZW50ZXIgKSA8PSAoIHJhZGl1c1N1bSAqIHJhZGl1c1N1bSApO1xuXG5cdFx0fSxcblxuXHRcdGNsYW1wUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0XHR2YXIgZGVsdGFMZW5ndGhTcSA9IHRoaXMuY2VudGVyLmRpc3RhbmNlVG9TcXVhcmVkKCBwb2ludCApO1xuXG5cdFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHRcdHJlc3VsdC5jb3B5KCBwb2ludCApO1xuXG5cdFx0XHRpZiAoIGRlbHRhTGVuZ3RoU3EgPiAoIHRoaXMucmFkaXVzICogdGhpcy5yYWRpdXMgKSApIHtcblxuXHRcdFx0XHRyZXN1bHQuc3ViKCB0aGlzLmNlbnRlciApLm5vcm1hbGl6ZSgpO1xuXHRcdFx0XHRyZXN1bHQubXVsdGlwbHlTY2FsYXIoIHRoaXMucmFkaXVzICkuYWRkKCB0aGlzLmNlbnRlciApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cblx0XHR9LFxuXG5cdFx0Z2V0Qm91bmRpbmdCb3g6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHRcdHZhciBib3ggPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuQm94MygpO1xuXG5cdFx0XHRib3guc2V0KCB0aGlzLmNlbnRlciwgdGhpcy5jZW50ZXIgKTtcblx0XHRcdGJveC5leHBhbmRCeVNjYWxhciggdGhpcy5yYWRpdXMgKTtcblxuXHRcdFx0cmV0dXJuIGJveDtcblxuXHRcdH0sXG5cblx0XHRhcHBseU1hdHJpeDQ6IGZ1bmN0aW9uICggbWF0cml4ICkge1xuXG5cdFx0XHR0aGlzLmNlbnRlci5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xuXHRcdFx0dGhpcy5yYWRpdXMgPSB0aGlzLnJhZGl1cyAqIG1hdHJpeC5nZXRNYXhTY2FsZU9uQXhpcygpO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHR0cmFuc2xhdGU6IGZ1bmN0aW9uICggb2Zmc2V0ICkge1xuXG5cdFx0XHR0aGlzLmNlbnRlci5hZGQoIG9mZnNldCApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRlcXVhbHM6IGZ1bmN0aW9uICggc3BoZXJlICkge1xuXG5cdFx0XHRyZXR1cm4gc3BoZXJlLmNlbnRlci5lcXVhbHMoIHRoaXMuY2VudGVyICkgJiYgKCBzcGhlcmUucmFkaXVzID09PSB0aGlzLnJhZGl1cyApO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0Ly8gRmlsZTpzcmMvbWF0aC9GcnVzdHVtLmpzXG5cblx0LyoqXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG5cdCAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cblx0ICovXG5cblx0VEhSRUUuRnJ1c3R1bSA9IGZ1bmN0aW9uICggcDAsIHAxLCBwMiwgcDMsIHA0LCBwNSApIHtcblxuXHRcdHRoaXMucGxhbmVzID0gW1xuXG5cdFx0XHQoIHAwICE9PSB1bmRlZmluZWQgKSA/IHAwIDogbmV3IFRIUkVFLlBsYW5lKCksXG5cdFx0XHQoIHAxICE9PSB1bmRlZmluZWQgKSA/IHAxIDogbmV3IFRIUkVFLlBsYW5lKCksXG5cdFx0XHQoIHAyICE9PSB1bmRlZmluZWQgKSA/IHAyIDogbmV3IFRIUkVFLlBsYW5lKCksXG5cdFx0XHQoIHAzICE9PSB1bmRlZmluZWQgKSA/IHAzIDogbmV3IFRIUkVFLlBsYW5lKCksXG5cdFx0XHQoIHA0ICE9PSB1bmRlZmluZWQgKSA/IHA0IDogbmV3IFRIUkVFLlBsYW5lKCksXG5cdFx0XHQoIHA1ICE9PSB1bmRlZmluZWQgKSA/IHA1IDogbmV3IFRIUkVFLlBsYW5lKClcblxuXHRcdF07XG5cblx0fTtcblxuXHRUSFJFRS5GcnVzdHVtLnByb3RvdHlwZSA9IHtcblxuXHRcdGNvbnN0cnVjdG9yOiBUSFJFRS5GcnVzdHVtLFxuXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHAwLCBwMSwgcDIsIHAzLCBwNCwgcDUgKSB7XG5cblx0XHRcdHZhciBwbGFuZXMgPSB0aGlzLnBsYW5lcztcblxuXHRcdFx0cGxhbmVzWyAwIF0uY29weSggcDAgKTtcblx0XHRcdHBsYW5lc1sgMSBdLmNvcHkoIHAxICk7XG5cdFx0XHRwbGFuZXNbIDIgXS5jb3B5KCBwMiApO1xuXHRcdFx0cGxhbmVzWyAzIF0uY29weSggcDMgKTtcblx0XHRcdHBsYW5lc1sgNCBdLmNvcHkoIHA0ICk7XG5cdFx0XHRwbGFuZXNbIDUgXS5jb3B5KCBwNSApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cblx0XHR9LFxuXG5cdFx0Y29weTogZnVuY3Rpb24gKCBmcnVzdHVtICkge1xuXG5cdFx0XHR2YXIgcGxhbmVzID0gdGhpcy5wbGFuZXM7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XG5cblx0XHRcdFx0cGxhbmVzWyBpIF0uY29weSggZnJ1c3R1bS5wbGFuZXNbIGkgXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHNldEZyb21NYXRyaXg6IGZ1bmN0aW9uICggbSApIHtcblxuXHRcdFx0dmFyIHBsYW5lcyA9IHRoaXMucGxhbmVzO1xuXHRcdFx0dmFyIG1lID0gbS5lbGVtZW50cztcblx0XHRcdHZhciBtZTAgPSBtZVsgMCBdLCBtZTEgPSBtZVsgMSBdLCBtZTIgPSBtZVsgMiBdLCBtZTMgPSBtZVsgMyBdO1xuXHRcdFx0dmFyIG1lNCA9IG1lWyA0IF0sIG1lNSA9IG1lWyA1IF0sIG1lNiA9IG1lWyA2IF0sIG1lNyA9IG1lWyA3IF07XG5cdFx0XHR2YXIgbWU4ID0gbWVbIDggXSwgbWU5ID0gbWVbIDkgXSwgbWUxMCA9IG1lWyAxMCBdLCBtZTExID0gbWVbIDExIF07XG5cdFx0XHR2YXIgbWUxMiA9IG1lWyAxMiBdLCBtZTEzID0gbWVbIDEzIF0sIG1lMTQgPSBtZVsgMTQgXSwgbWUxNSA9IG1lWyAxNSBdO1xuXG5cdFx0XHRwbGFuZXNbIDAgXS5zZXRDb21wb25lbnRzKCBtZTMgLSBtZTAsIG1lNyAtIG1lNCwgbWUxMSAtIG1lOCwgbWUxNSAtIG1lMTIgKS5ub3JtYWxpemUoKTtcblx0XHRcdHBsYW5lc1sgMSBdLnNldENvbXBvbmVudHMoIG1lMyArIG1lMCwgbWU3ICsgbWU0LCBtZTExICsgbWU4LCBtZTE1ICsgbWUxMiApLm5vcm1hbGl6ZSgpO1xuXHRcdFx0cGxhbmVzWyAyIF0uc2V0Q29tcG9uZW50cyggbWUzICsgbWUxLCBtZTcgKyBtZTUsIG1lMTEgKyBtZTksIG1lMTUgKyBtZTEzICkubm9ybWFsaXplKCk7XG5cdFx0XHRwbGFuZXNbIDMgXS5zZXRDb21wb25lbnRzKCBtZTMgLSBtZTEsIG1lNyAtIG1lNSwgbWUxMSAtIG1lOSwgbWUxNSAtIG1lMTMgKS5ub3JtYWxpemUoKTtcblx0XHRcdHBsYW5lc1sgNCBdLnNldENvbXBvbmVudHMoIG1lMyAtIG1lMiwgbWU3IC0gbWU2LCBtZTExIC0gbWUxMCwgbWUxNSAtIG1lMTQgKS5ub3JtYWxpemUoKTtcblx0XHRcdHBsYW5lc1sgNSBdLnNldENvbXBvbmVudHMoIG1lMyArIG1lMiwgbWU3ICsgbWU2LCBtZTExICsgbWUxMCwgbWUxNSArIG1lMTQgKS5ub3JtYWxpemUoKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0aW50ZXJzZWN0c09iamVjdDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgc3BoZXJlID0gbmV3IFRIUkVFLlNwaGVyZSgpO1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cblx0XHRcdFx0dmFyIGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xuXG5cdFx0XHRcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKSBnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblxuXHRcdFx0XHRzcGhlcmUuY29weSggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgKTtcblx0XHRcdFx0c3BoZXJlLmFwcGx5TWF0cml4NCggb2JqZWN0Lm1hdHJpeFdvcmxkICk7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXMuaW50ZXJzZWN0c1NwaGVyZSggc3BoZXJlICk7XG5cblx0XHRcdH07XG5cblx0XHR9KCksXG5cblx0XHRpbnRlcnNlY3RzU3BoZXJlOiBmdW5jdGlvbiAoIHNwaGVyZSApIHtcblxuXHRcdFx0dmFyIHBsYW5lcyA9IHRoaXMucGxhbmVzO1xuXHRcdFx0dmFyIGNlbnRlciA9IHNwaGVyZS5jZW50ZXI7XG5cdFx0XHR2YXIgbmVnUmFkaXVzID0gLSBzcGhlcmUucmFkaXVzO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBkaXN0YW5jZSA9IHBsYW5lc1sgaSBdLmRpc3RhbmNlVG9Qb2ludCggY2VudGVyICk7XG5cblx0XHRcdFx0aWYgKCBkaXN0YW5jZSA8IG5lZ1JhZGl1cyApIHtcblxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHR9LFxuXG5cdFx0aW50ZXJzZWN0c0JveDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgcDEgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuXHRcdFx0XHRwMiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiAoIGJveCApIHtcblxuXHRcdFx0XHR2YXIgcGxhbmVzID0gdGhpcy5wbGFuZXM7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgNiA7IGkgKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgcGxhbmUgPSBwbGFuZXNbIGkgXTtcblxuXHRcdFx0XHRcdHAxLnggPSBwbGFuZS5ub3JtYWwueCA+IDAgPyBib3gubWluLnggOiBib3gubWF4Lng7XG5cdFx0XHRcdFx0cDIueCA9IHBsYW5lLm5vcm1hbC54ID4gMCA/IGJveC5tYXgueCA6IGJveC5taW4ueDtcblx0XHRcdFx0XHRwMS55ID0gcGxhbmUubm9ybWFsLnkgPiAwID8gYm94Lm1pbi55IDogYm94Lm1heC55O1xuXHRcdFx0XHRcdHAyLnkgPSBwbGFuZS5ub3JtYWwueSA+IDAgPyBib3gubWF4LnkgOiBib3gubWluLnk7XG5cdFx0XHRcdFx0cDEueiA9IHBsYW5lLm5vcm1hbC56ID4gMCA/IGJveC5taW4ueiA6IGJveC5tYXguejtcblx0XHRcdFx0XHRwMi56ID0gcGxhbmUubm9ybWFsLnogPiAwID8gYm94Lm1heC56IDogYm94Lm1pbi56O1xuXG5cdFx0XHRcdFx0dmFyIGQxID0gcGxhbmUuZGlzdGFuY2VUb1BvaW50KCBwMSApO1xuXHRcdFx0XHRcdHZhciBkMiA9IHBsYW5lLmRpc3RhbmNlVG9Qb2ludCggcDIgKTtcblxuXHRcdFx0XHRcdC8vIGlmIGJvdGggb3V0c2lkZSBwbGFuZSwgbm8gaW50ZXJzZWN0aW9uXG5cblx0XHRcdFx0XHRpZiAoIGQxIDwgMCAmJiBkMiA8IDAgKSB7XG5cblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHRcdH07XG5cblx0XHR9KCksXG5cblxuXHRcdGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XG5cblx0XHRcdHZhciBwbGFuZXMgPSB0aGlzLnBsYW5lcztcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSArKyApIHtcblxuXHRcdFx0XHRpZiAoIHBsYW5lc1sgaSBdLmRpc3RhbmNlVG9Qb2ludCggcG9pbnQgKSA8IDAgKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0Ly8gRmlsZTpzcmMvbWF0aC9QbGFuZS5qc1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXG5cdCAqL1xuXG5cdFRIUkVFLlBsYW5lID0gZnVuY3Rpb24gKCBub3JtYWwsIGNvbnN0YW50ICkge1xuXG5cdFx0dGhpcy5ub3JtYWwgPSAoIG5vcm1hbCAhPT0gdW5kZWZpbmVkICkgPyBub3JtYWwgOiBuZXcgVEhSRUUuVmVjdG9yMyggMSwgMCwgMCApO1xuXHRcdHRoaXMuY29uc3RhbnQgPSAoIGNvbnN0YW50ICE9PSB1bmRlZmluZWQgKSA/IGNvbnN0YW50IDogMDtcblxuXHR9O1xuXG5cdFRIUkVFLlBsYW5lLnByb3RvdHlwZSA9IHtcblxuXHRcdGNvbnN0cnVjdG9yOiBUSFJFRS5QbGFuZSxcblxuXHRcdHNldDogZnVuY3Rpb24gKCBub3JtYWwsIGNvbnN0YW50ICkge1xuXG5cdFx0XHR0aGlzLm5vcm1hbC5jb3B5KCBub3JtYWwgKTtcblx0XHRcdHRoaXMuY29uc3RhbnQgPSBjb25zdGFudDtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0c2V0Q29tcG9uZW50czogZnVuY3Rpb24gKCB4LCB5LCB6LCB3ICkge1xuXG5cdFx0XHR0aGlzLm5vcm1hbC5zZXQoIHgsIHksIHogKTtcblx0XHRcdHRoaXMuY29uc3RhbnQgPSB3O1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRzZXRGcm9tTm9ybWFsQW5kQ29wbGFuYXJQb2ludDogZnVuY3Rpb24gKCBub3JtYWwsIHBvaW50ICkge1xuXG5cdFx0XHR0aGlzLm5vcm1hbC5jb3B5KCBub3JtYWwgKTtcblx0XHRcdHRoaXMuY29uc3RhbnQgPSAtIHBvaW50LmRvdCggdGhpcy5ub3JtYWwgKTtcdC8vIG11c3QgYmUgdGhpcy5ub3JtYWwsIG5vdCBub3JtYWwsIGFzIHRoaXMubm9ybWFsIGlzIG5vcm1hbGl6ZWRcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0c2V0RnJvbUNvcGxhbmFyUG9pbnRzOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0XHR2YXIgdjIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKCBhLCBiLCBjICkge1xuXG5cdFx0XHRcdHZhciBub3JtYWwgPSB2MS5zdWJWZWN0b3JzKCBjLCBiICkuY3Jvc3MoIHYyLnN1YlZlY3RvcnMoIGEsIGIgKSApLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHRcdC8vIFE6IHNob3VsZCBhbiBlcnJvciBiZSB0aHJvd24gaWYgbm9ybWFsIGlzIHplcm8gKGUuZy4gZGVnZW5lcmF0ZSBwbGFuZSk/XG5cblx0XHRcdFx0dGhpcy5zZXRGcm9tTm9ybWFsQW5kQ29wbGFuYXJQb2ludCggbm9ybWFsLCBhICk7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdH07XG5cblx0XHR9KCksXG5cblx0XHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cblx0XHR9LFxuXG5cdFx0Y29weTogZnVuY3Rpb24gKCBwbGFuZSApIHtcblxuXHRcdFx0dGhpcy5ub3JtYWwuY29weSggcGxhbmUubm9ybWFsICk7XG5cdFx0XHR0aGlzLmNvbnN0YW50ID0gcGxhbmUuY29uc3RhbnQ7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdG5vcm1hbGl6ZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHQvLyBOb3RlOiB3aWxsIGxlYWQgdG8gYSBkaXZpZGUgYnkgemVybyBpZiB0aGUgcGxhbmUgaXMgaW52YWxpZC5cblxuXHRcdFx0dmFyIGludmVyc2VOb3JtYWxMZW5ndGggPSAxLjAgLyB0aGlzLm5vcm1hbC5sZW5ndGgoKTtcblx0XHRcdHRoaXMubm9ybWFsLm11bHRpcGx5U2NhbGFyKCBpbnZlcnNlTm9ybWFsTGVuZ3RoICk7XG5cdFx0XHR0aGlzLmNvbnN0YW50ICo9IGludmVyc2VOb3JtYWxMZW5ndGg7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdG5lZ2F0ZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR0aGlzLmNvbnN0YW50ICo9IC0gMTtcblx0XHRcdHRoaXMubm9ybWFsLm5lZ2F0ZSgpO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRkaXN0YW5jZVRvUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLm5vcm1hbC5kb3QoIHBvaW50ICkgKyB0aGlzLmNvbnN0YW50O1xuXG5cdFx0fSxcblxuXHRcdGRpc3RhbmNlVG9TcGhlcmU6IGZ1bmN0aW9uICggc3BoZXJlICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5kaXN0YW5jZVRvUG9pbnQoIHNwaGVyZS5jZW50ZXIgKSAtIHNwaGVyZS5yYWRpdXM7XG5cblx0XHR9LFxuXG5cdFx0cHJvamVjdFBvaW50OiBmdW5jdGlvbiAoIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMub3J0aG9Qb2ludCggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkuc3ViKCBwb2ludCApLm5lZ2F0ZSgpO1xuXG5cdFx0fSxcblxuXHRcdG9ydGhvUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0XHR2YXIgcGVycGVuZGljdWxhck1hZ25pdHVkZSA9IHRoaXMuZGlzdGFuY2VUb1BvaW50KCBwb2ludCApO1xuXG5cdFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHRcdHJldHVybiByZXN1bHQuY29weSggdGhpcy5ub3JtYWwgKS5tdWx0aXBseVNjYWxhciggcGVycGVuZGljdWxhck1hZ25pdHVkZSApO1xuXG5cdFx0fSxcblxuXHRcdGlzSW50ZXJzZWN0aW9uTGluZTogZnVuY3Rpb24gKCBsaW5lICkge1xuXG5cdFx0XHQvLyBOb3RlOiB0aGlzIHRlc3RzIGlmIGEgbGluZSBpbnRlcnNlY3RzIHRoZSBwbGFuZSwgbm90IHdoZXRoZXIgaXQgKG9yIGl0cyBlbmQtcG9pbnRzKSBhcmUgY29wbGFuYXIgd2l0aCBpdC5cblxuXHRcdFx0dmFyIHN0YXJ0U2lnbiA9IHRoaXMuZGlzdGFuY2VUb1BvaW50KCBsaW5lLnN0YXJ0ICk7XG5cdFx0XHR2YXIgZW5kU2lnbiA9IHRoaXMuZGlzdGFuY2VUb1BvaW50KCBsaW5lLmVuZCApO1xuXG5cdFx0XHRyZXR1cm4gKCBzdGFydFNpZ24gPCAwICYmIGVuZFNpZ24gPiAwICkgfHwgKCBlbmRTaWduIDwgMCAmJiBzdGFydFNpZ24gPiAwICk7XG5cblx0XHR9LFxuXG5cdFx0aW50ZXJzZWN0TGluZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKCBsaW5lLCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdFx0XHR2YXIgZGlyZWN0aW9uID0gbGluZS5kZWx0YSggdjEgKTtcblxuXHRcdFx0XHR2YXIgZGVub21pbmF0b3IgPSB0aGlzLm5vcm1hbC5kb3QoIGRpcmVjdGlvbiApO1xuXG5cdFx0XHRcdGlmICggZGVub21pbmF0b3IgPT09IDAgKSB7XG5cblx0XHRcdFx0XHQvLyBsaW5lIGlzIGNvcGxhbmFyLCByZXR1cm4gb3JpZ2luXG5cdFx0XHRcdFx0aWYgKCB0aGlzLmRpc3RhbmNlVG9Qb2ludCggbGluZS5zdGFydCApID09PSAwICkge1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0LmNvcHkoIGxpbmUuc3RhcnQgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFVuc3VyZSBpZiB0aGlzIGlzIHRoZSBjb3JyZWN0IG1ldGhvZCB0byBoYW5kbGUgdGhpcyBjYXNlLlxuXHRcdFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciB0ID0gLSAoIGxpbmUuc3RhcnQuZG90KCB0aGlzLm5vcm1hbCApICsgdGhpcy5jb25zdGFudCApIC8gZGVub21pbmF0b3I7XG5cblx0XHRcdFx0aWYgKCB0IDwgMCB8fCB0ID4gMSApIHtcblxuXHRcdFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiByZXN1bHQuY29weSggZGlyZWN0aW9uICkubXVsdGlwbHlTY2FsYXIoIHQgKS5hZGQoIGxpbmUuc3RhcnQgKTtcblxuXHRcdFx0fTtcblxuXHRcdH0oKSxcblxuXG5cdFx0Y29wbGFuYXJQb2ludDogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0XHRyZXR1cm4gcmVzdWx0LmNvcHkoIHRoaXMubm9ybWFsICkubXVsdGlwbHlTY2FsYXIoIC0gdGhpcy5jb25zdGFudCApO1xuXG5cdFx0fSxcblxuXHRcdGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdFx0dmFyIHYyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHRcdHZhciBtMSA9IG5ldyBUSFJFRS5NYXRyaXgzKCk7XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiAoIG1hdHJpeCwgb3B0aW9uYWxOb3JtYWxNYXRyaXggKSB7XG5cblx0XHRcdFx0Ly8gY29tcHV0ZSBuZXcgbm9ybWFsIGJhc2VkIG9uIHRoZW9yeSBoZXJlOlxuXHRcdFx0XHQvLyBodHRwOi8vd3d3LnNvbmdoby5jYS9vcGVuZ2wvZ2xfbm9ybWFsdHJhbnNmb3JtLmh0bWxcblx0XHRcdFx0dmFyIG5vcm1hbE1hdHJpeCA9IG9wdGlvbmFsTm9ybWFsTWF0cml4IHx8IG0xLmdldE5vcm1hbE1hdHJpeCggbWF0cml4ICk7XG5cdFx0XHRcdHZhciBuZXdOb3JtYWwgPSB2MS5jb3B5KCB0aGlzLm5vcm1hbCApLmFwcGx5TWF0cml4Myggbm9ybWFsTWF0cml4ICk7XG5cblx0XHRcdFx0dmFyIG5ld0NvcGxhbmFyUG9pbnQgPSB0aGlzLmNvcGxhbmFyUG9pbnQoIHYyICk7XG5cdFx0XHRcdG5ld0NvcGxhbmFyUG9pbnQuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcblxuXHRcdFx0XHR0aGlzLnNldEZyb21Ob3JtYWxBbmRDb3BsYW5hclBvaW50KCBuZXdOb3JtYWwsIG5ld0NvcGxhbmFyUG9pbnQgKTtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdFx0fTtcblxuXHRcdH0oKSxcblxuXHRcdHRyYW5zbGF0ZTogZnVuY3Rpb24gKCBvZmZzZXQgKSB7XG5cblx0XHRcdHRoaXMuY29uc3RhbnQgPSB0aGlzLmNvbnN0YW50IC0gb2Zmc2V0LmRvdCggdGhpcy5ub3JtYWwgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0ZXF1YWxzOiBmdW5jdGlvbiAoIHBsYW5lICkge1xuXG5cdFx0XHRyZXR1cm4gcGxhbmUubm9ybWFsLmVxdWFscyggdGhpcy5ub3JtYWwgKSAmJiAoIHBsYW5lLmNvbnN0YW50ID09PSB0aGlzLmNvbnN0YW50ICk7XG5cblx0XHR9XG5cblx0fTtcblxuXHQvLyBGaWxlOnNyYy9tYXRoL01hdGguanNcblxuXHQvKipcblx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICovXG5cblx0VEhSRUUuTWF0aCA9IHtcblxuXHRcdGdlbmVyYXRlVVVJRDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHQvLyBodHRwOi8vd3d3LmJyb29mYS5jb20vVG9vbHMvTWF0aC51dWlkLmh0bVxuXG5cdFx0XHR2YXIgY2hhcnMgPSAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXonLnNwbGl0KCAnJyApO1xuXHRcdFx0dmFyIHV1aWQgPSBuZXcgQXJyYXkoIDM2ICk7XG5cdFx0XHR2YXIgcm5kID0gMCwgcjtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCAzNjsgaSArKyApIHtcblxuXHRcdFx0XHRcdGlmICggaSA9PT0gOCB8fCBpID09PSAxMyB8fCBpID09PSAxOCB8fCBpID09PSAyMyApIHtcblxuXHRcdFx0XHRcdFx0dXVpZFsgaSBdID0gJy0nO1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggaSA9PT0gMTQgKSB7XG5cblx0XHRcdFx0XHRcdHV1aWRbIGkgXSA9ICc0JztcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdGlmICggcm5kIDw9IDB4MDIgKSBybmQgPSAweDIwMDAwMDAgKyAoIE1hdGgucmFuZG9tKCkgKiAweDEwMDAwMDAgKSB8IDA7XG5cdFx0XHRcdFx0XHRyID0gcm5kICYgMHhmO1xuXHRcdFx0XHRcdFx0cm5kID0gcm5kID4+IDQ7XG5cdFx0XHRcdFx0XHR1dWlkWyBpIF0gPSBjaGFyc1sgKCBpID09PSAxOSApID8gKCByICYgMHgzICkgfCAweDggOiByIF07XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB1dWlkLmpvaW4oICcnICk7XG5cblx0XHRcdH07XG5cblx0XHR9KCksXG5cblx0XHRjbGFtcDogZnVuY3Rpb24gKCB2YWx1ZSwgbWluLCBtYXggKSB7XG5cblx0XHRcdHJldHVybiBNYXRoLm1heCggbWluLCBNYXRoLm1pbiggbWF4LCB2YWx1ZSApICk7XG5cblx0XHR9LFxuXG5cdFx0Ly8gY29tcHV0ZSBldWNsaWRpYW4gbW9kdWxvIG9mIG0gJSBuXG5cdFx0Ly8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTW9kdWxvX29wZXJhdGlvblxuXG5cdFx0ZXVjbGlkZWFuTW9kdWxvOiBmdW5jdGlvbiAoIG4sIG0gKSB7XG5cblx0XHRcdHJldHVybiAoICggbiAlIG0gKSArIG0gKSAlIG07XG5cblx0XHR9LFxuXG5cdFx0Ly8gTGluZWFyIG1hcHBpbmcgZnJvbSByYW5nZSA8YTEsIGEyPiB0byByYW5nZSA8YjEsIGIyPlxuXG5cdFx0bWFwTGluZWFyOiBmdW5jdGlvbiAoIHgsIGExLCBhMiwgYjEsIGIyICkge1xuXG5cdFx0XHRyZXR1cm4gYjEgKyAoIHggLSBhMSApICogKCBiMiAtIGIxICkgLyAoIGEyIC0gYTEgKTtcblxuXHRcdH0sXG5cblx0XHQvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Ntb290aHN0ZXBcblxuXHRcdHNtb290aHN0ZXA6IGZ1bmN0aW9uICggeCwgbWluLCBtYXggKSB7XG5cblx0XHRcdGlmICggeCA8PSBtaW4gKSByZXR1cm4gMDtcblx0XHRcdGlmICggeCA+PSBtYXggKSByZXR1cm4gMTtcblxuXHRcdFx0eCA9ICggeCAtIG1pbiApIC8gKCBtYXggLSBtaW4gKTtcblxuXHRcdFx0cmV0dXJuIHggKiB4ICogKCAzIC0gMiAqIHggKTtcblxuXHRcdH0sXG5cblx0XHRzbW9vdGhlcnN0ZXA6IGZ1bmN0aW9uICggeCwgbWluLCBtYXggKSB7XG5cblx0XHRcdGlmICggeCA8PSBtaW4gKSByZXR1cm4gMDtcblx0XHRcdGlmICggeCA+PSBtYXggKSByZXR1cm4gMTtcblxuXHRcdFx0eCA9ICggeCAtIG1pbiApIC8gKCBtYXggLSBtaW4gKTtcblxuXHRcdFx0cmV0dXJuIHggKiB4ICogeCAqICggeCAqICggeCAqIDYgLSAxNSApICsgMTAgKTtcblxuXHRcdH0sXG5cblx0XHQvLyBSYW5kb20gZmxvYXQgZnJvbSA8MCwgMT4gd2l0aCAxNiBiaXRzIG9mIHJhbmRvbW5lc3Ncblx0XHQvLyAoc3RhbmRhcmQgTWF0aC5yYW5kb20oKSBjcmVhdGVzIHJlcGV0aXRpdmUgcGF0dGVybnMgd2hlbiBhcHBsaWVkIG92ZXIgbGFyZ2VyIHNwYWNlKVxuXG5cdFx0cmFuZG9tMTY6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuICggNjUyODAgKiBNYXRoLnJhbmRvbSgpICsgMjU1ICogTWF0aC5yYW5kb20oKSApIC8gNjU1MzU7XG5cblx0XHR9LFxuXG5cdFx0Ly8gUmFuZG9tIGludGVnZXIgZnJvbSA8bG93LCBoaWdoPiBpbnRlcnZhbFxuXG5cdFx0cmFuZEludDogZnVuY3Rpb24gKCBsb3csIGhpZ2ggKSB7XG5cblx0XHRcdHJldHVybiBsb3cgKyBNYXRoLmZsb29yKCBNYXRoLnJhbmRvbSgpICogKCBoaWdoIC0gbG93ICsgMSApICk7XG5cblx0XHR9LFxuXG5cdFx0Ly8gUmFuZG9tIGZsb2F0IGZyb20gPGxvdywgaGlnaD4gaW50ZXJ2YWxcblxuXHRcdHJhbmRGbG9hdDogZnVuY3Rpb24gKCBsb3csIGhpZ2ggKSB7XG5cblx0XHRcdHJldHVybiBsb3cgKyBNYXRoLnJhbmRvbSgpICogKCBoaWdoIC0gbG93ICk7XG5cblx0XHR9LFxuXG5cdFx0Ly8gUmFuZG9tIGZsb2F0IGZyb20gPC1yYW5nZS8yLCByYW5nZS8yPiBpbnRlcnZhbFxuXG5cdFx0cmFuZEZsb2F0U3ByZWFkOiBmdW5jdGlvbiAoIHJhbmdlICkge1xuXG5cdFx0XHRyZXR1cm4gcmFuZ2UgKiAoIDAuNSAtIE1hdGgucmFuZG9tKCkgKTtcblxuXHRcdH0sXG5cblx0XHRkZWdUb1JhZDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgZGVncmVlVG9SYWRpYW5zRmFjdG9yID0gTWF0aC5QSSAvIDE4MDtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uICggZGVncmVlcyApIHtcblxuXHRcdFx0XHRyZXR1cm4gZGVncmVlcyAqIGRlZ3JlZVRvUmFkaWFuc0ZhY3RvcjtcblxuXHRcdFx0fTtcblxuXHRcdH0oKSxcblxuXHRcdHJhZFRvRGVnOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciByYWRpYW5Ub0RlZ3JlZXNGYWN0b3IgPSAxODAgLyBNYXRoLlBJO1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKCByYWRpYW5zICkge1xuXG5cdFx0XHRcdHJldHVybiByYWRpYW5zICogcmFkaWFuVG9EZWdyZWVzRmFjdG9yO1xuXG5cdFx0XHR9O1xuXG5cdFx0fSgpLFxuXG5cdFx0aXNQb3dlck9mVHdvOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHRyZXR1cm4gKCB2YWx1ZSAmICggdmFsdWUgLSAxICkgKSA9PT0gMCAmJiB2YWx1ZSAhPT0gMDtcblxuXHRcdH0sXG5cblx0XHRuZWFyZXN0UG93ZXJPZlR3bzogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdFx0cmV0dXJuIE1hdGgucG93KCAyLCBNYXRoLnJvdW5kKCBNYXRoLmxvZyggdmFsdWUgKSAvIE1hdGguTE4yICkgKTtcblxuXHRcdH0sXG5cblx0XHRuZXh0UG93ZXJPZlR3bzogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdFx0dmFsdWUgLS07XG5cdFx0XHR2YWx1ZSB8PSB2YWx1ZSA+PiAxO1xuXHRcdFx0dmFsdWUgfD0gdmFsdWUgPj4gMjtcblx0XHRcdHZhbHVlIHw9IHZhbHVlID4+IDQ7XG5cdFx0XHR2YWx1ZSB8PSB2YWx1ZSA+PiA4O1xuXHRcdFx0dmFsdWUgfD0gdmFsdWUgPj4gMTY7XG5cdFx0XHR2YWx1ZSArKztcblxuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0Ly8gRmlsZTpzcmMvbWF0aC9TcGxpbmUuanNcblxuXHQvKipcblx0ICogU3BsaW5lIGZyb20gVHdlZW4uanMsIHNsaWdodGx5IG9wdGltaXplZCAoYW5kIHRyYXNoZWQpXG5cdCAqIGh0dHA6Ly9zb2xlLmdpdGh1Yi5jb20vdHdlZW4uanMvZXhhbXBsZXMvMDVfc3BsaW5lLmh0bWxcblx0ICpcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cblx0ICovXG5cblx0VEhSRUUuU3BsaW5lID0gZnVuY3Rpb24gKCBwb2ludHMgKSB7XG5cblx0XHR0aGlzLnBvaW50cyA9IHBvaW50cztcblxuXHRcdHZhciBjID0gW10sIHYzID0geyB4OiAwLCB5OiAwLCB6OiAwIH0sXG5cdFx0cG9pbnQsIGludFBvaW50LCB3ZWlnaHQsIHcyLCB3Myxcblx0XHRwYSwgcGIsIHBjLCBwZDtcblxuXHRcdHRoaXMuaW5pdEZyb21BcnJheSA9IGZ1bmN0aW9uICggYSApIHtcblxuXHRcdFx0dGhpcy5wb2ludHMgPSBbXTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0dGhpcy5wb2ludHNbIGkgXSA9IHsgeDogYVsgaSBdWyAwIF0sIHk6IGFbIGkgXVsgMSBdLCB6OiBhWyBpIF1bIDIgXSB9O1xuXG5cdFx0XHR9XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5nZXRQb2ludCA9IGZ1bmN0aW9uICggayApIHtcblxuXHRcdFx0cG9pbnQgPSAoIHRoaXMucG9pbnRzLmxlbmd0aCAtIDEgKSAqIGs7XG5cdFx0XHRpbnRQb2ludCA9IE1hdGguZmxvb3IoIHBvaW50ICk7XG5cdFx0XHR3ZWlnaHQgPSBwb2ludCAtIGludFBvaW50O1xuXG5cdFx0XHRjWyAwIF0gPSBpbnRQb2ludCA9PT0gMCA/IGludFBvaW50IDogaW50UG9pbnQgLSAxO1xuXHRcdFx0Y1sgMSBdID0gaW50UG9pbnQ7XG5cdFx0XHRjWyAyIF0gPSBpbnRQb2ludCAgPiB0aGlzLnBvaW50cy5sZW5ndGggLSAyID8gdGhpcy5wb2ludHMubGVuZ3RoIC0gMSA6IGludFBvaW50ICsgMTtcblx0XHRcdGNbIDMgXSA9IGludFBvaW50ICA+IHRoaXMucG9pbnRzLmxlbmd0aCAtIDMgPyB0aGlzLnBvaW50cy5sZW5ndGggLSAxIDogaW50UG9pbnQgKyAyO1xuXG5cdFx0XHRwYSA9IHRoaXMucG9pbnRzWyBjWyAwIF0gXTtcblx0XHRcdHBiID0gdGhpcy5wb2ludHNbIGNbIDEgXSBdO1xuXHRcdFx0cGMgPSB0aGlzLnBvaW50c1sgY1sgMiBdIF07XG5cdFx0XHRwZCA9IHRoaXMucG9pbnRzWyBjWyAzIF0gXTtcblxuXHRcdFx0dzIgPSB3ZWlnaHQgKiB3ZWlnaHQ7XG5cdFx0XHR3MyA9IHdlaWdodCAqIHcyO1xuXG5cdFx0XHR2My54ID0gaW50ZXJwb2xhdGUoIHBhLngsIHBiLngsIHBjLngsIHBkLngsIHdlaWdodCwgdzIsIHczICk7XG5cdFx0XHR2My55ID0gaW50ZXJwb2xhdGUoIHBhLnksIHBiLnksIHBjLnksIHBkLnksIHdlaWdodCwgdzIsIHczICk7XG5cdFx0XHR2My56ID0gaW50ZXJwb2xhdGUoIHBhLnosIHBiLnosIHBjLnosIHBkLnosIHdlaWdodCwgdzIsIHczICk7XG5cblx0XHRcdHJldHVybiB2MztcblxuXHRcdH07XG5cblx0XHR0aGlzLmdldENvbnRyb2xQb2ludHNBcnJheSA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIGksIHAsIGwgPSB0aGlzLnBvaW50cy5sZW5ndGgsXG5cdFx0XHRcdGNvb3JkcyA9IFtdO1xuXG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0cCA9IHRoaXMucG9pbnRzWyBpIF07XG5cdFx0XHRcdGNvb3Jkc1sgaSBdID0gWyBwLngsIHAueSwgcC56IF07XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGNvb3JkcztcblxuXHRcdH07XG5cblx0XHQvLyBhcHByb3hpbWF0ZSBsZW5ndGggYnkgc3VtbWluZyBsaW5lYXIgc2VnbWVudHNcblxuXHRcdHRoaXMuZ2V0TGVuZ3RoID0gZnVuY3Rpb24gKCBuU3ViRGl2aXNpb25zICkge1xuXG5cdFx0XHR2YXIgaSwgaW5kZXgsIG5TYW1wbGVzLCBwb3NpdGlvbixcblx0XHRcdFx0cG9pbnQgPSAwLCBpbnRQb2ludCA9IDAsIG9sZEludFBvaW50ID0gMCxcblx0XHRcdFx0b2xkUG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuXHRcdFx0XHR0bXBWZWMgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuXHRcdFx0XHRjaHVua0xlbmd0aHMgPSBbXSxcblx0XHRcdFx0dG90YWxMZW5ndGggPSAwO1xuXG5cdFx0XHQvLyBmaXJzdCBwb2ludCBoYXMgMCBsZW5ndGhcblxuXHRcdFx0Y2h1bmtMZW5ndGhzWyAwIF0gPSAwO1xuXG5cdFx0XHRpZiAoICEgblN1YkRpdmlzaW9ucyApIG5TdWJEaXZpc2lvbnMgPSAxMDA7XG5cblx0XHRcdG5TYW1wbGVzID0gdGhpcy5wb2ludHMubGVuZ3RoICogblN1YkRpdmlzaW9ucztcblxuXHRcdFx0b2xkUG9zaXRpb24uY29weSggdGhpcy5wb2ludHNbIDAgXSApO1xuXG5cdFx0XHRmb3IgKCBpID0gMTsgaSA8IG5TYW1wbGVzOyBpICsrICkge1xuXG5cdFx0XHRcdGluZGV4ID0gaSAvIG5TYW1wbGVzO1xuXG5cdFx0XHRcdHBvc2l0aW9uID0gdGhpcy5nZXRQb2ludCggaW5kZXggKTtcblx0XHRcdFx0dG1wVmVjLmNvcHkoIHBvc2l0aW9uICk7XG5cblx0XHRcdFx0dG90YWxMZW5ndGggKz0gdG1wVmVjLmRpc3RhbmNlVG8oIG9sZFBvc2l0aW9uICk7XG5cblx0XHRcdFx0b2xkUG9zaXRpb24uY29weSggcG9zaXRpb24gKTtcblxuXHRcdFx0XHRwb2ludCA9ICggdGhpcy5wb2ludHMubGVuZ3RoIC0gMSApICogaW5kZXg7XG5cdFx0XHRcdGludFBvaW50ID0gTWF0aC5mbG9vciggcG9pbnQgKTtcblxuXHRcdFx0XHRpZiAoIGludFBvaW50ICE9PSBvbGRJbnRQb2ludCApIHtcblxuXHRcdFx0XHRcdGNodW5rTGVuZ3Roc1sgaW50UG9pbnQgXSA9IHRvdGFsTGVuZ3RoO1xuXHRcdFx0XHRcdG9sZEludFBvaW50ID0gaW50UG9pbnQ7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGxhc3QgcG9pbnQgZW5kcyB3aXRoIHRvdGFsIGxlbmd0aFxuXG5cdFx0XHRjaHVua0xlbmd0aHNbIGNodW5rTGVuZ3Rocy5sZW5ndGggXSA9IHRvdGFsTGVuZ3RoO1xuXG5cdFx0XHRyZXR1cm4geyBjaHVua3M6IGNodW5rTGVuZ3RocywgdG90YWw6IHRvdGFsTGVuZ3RoIH07XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5yZXBhcmFtZXRyaXplQnlBcmNMZW5ndGggPSBmdW5jdGlvbiAoIHNhbXBsaW5nQ29lZiApIHtcblxuXHRcdFx0dmFyIGksIGosXG5cdFx0XHRcdGluZGV4LCBpbmRleEN1cnJlbnQsIGluZGV4TmV4dCxcblx0XHRcdFx0cmVhbERpc3RhbmNlLFxuXHRcdFx0XHRzYW1wbGluZywgcG9zaXRpb24sXG5cdFx0XHRcdG5ld3BvaW50cyA9IFtdLFxuXHRcdFx0XHR0bXBWZWMgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuXHRcdFx0XHRzbCA9IHRoaXMuZ2V0TGVuZ3RoKCk7XG5cblx0XHRcdG5ld3BvaW50cy5wdXNoKCB0bXBWZWMuY29weSggdGhpcy5wb2ludHNbIDAgXSApLmNsb25lKCkgKTtcblxuXHRcdFx0Zm9yICggaSA9IDE7IGkgPCB0aGlzLnBvaW50cy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0Ly90bXBWZWMuY29weSggdGhpcy5wb2ludHNbIGkgLSAxIF0gKTtcblx0XHRcdFx0Ly9saW5lYXJEaXN0YW5jZSA9IHRtcFZlYy5kaXN0YW5jZVRvKCB0aGlzLnBvaW50c1sgaSBdICk7XG5cblx0XHRcdFx0cmVhbERpc3RhbmNlID0gc2wuY2h1bmtzWyBpIF0gLSBzbC5jaHVua3NbIGkgLSAxIF07XG5cblx0XHRcdFx0c2FtcGxpbmcgPSBNYXRoLmNlaWwoIHNhbXBsaW5nQ29lZiAqIHJlYWxEaXN0YW5jZSAvIHNsLnRvdGFsICk7XG5cblx0XHRcdFx0aW5kZXhDdXJyZW50ID0gKCBpIC0gMSApIC8gKCB0aGlzLnBvaW50cy5sZW5ndGggLSAxICk7XG5cdFx0XHRcdGluZGV4TmV4dCA9IGkgLyAoIHRoaXMucG9pbnRzLmxlbmd0aCAtIDEgKTtcblxuXHRcdFx0XHRmb3IgKCBqID0gMTsgaiA8IHNhbXBsaW5nIC0gMTsgaiArKyApIHtcblxuXHRcdFx0XHRcdGluZGV4ID0gaW5kZXhDdXJyZW50ICsgaiAqICggMSAvIHNhbXBsaW5nICkgKiAoIGluZGV4TmV4dCAtIGluZGV4Q3VycmVudCApO1xuXG5cdFx0XHRcdFx0cG9zaXRpb24gPSB0aGlzLmdldFBvaW50KCBpbmRleCApO1xuXHRcdFx0XHRcdG5ld3BvaW50cy5wdXNoKCB0bXBWZWMuY29weSggcG9zaXRpb24gKS5jbG9uZSgpICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdG5ld3BvaW50cy5wdXNoKCB0bXBWZWMuY29weSggdGhpcy5wb2ludHNbIGkgXSApLmNsb25lKCkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnBvaW50cyA9IG5ld3BvaW50cztcblxuXHRcdH07XG5cblx0XHQvLyBDYXRtdWxsLVJvbVxuXG5cdFx0ZnVuY3Rpb24gaW50ZXJwb2xhdGUoIHAwLCBwMSwgcDIsIHAzLCB0LCB0MiwgdDMgKSB7XG5cblx0XHRcdHZhciB2MCA9ICggcDIgLSBwMCApICogMC41LFxuXHRcdFx0XHR2MSA9ICggcDMgLSBwMSApICogMC41O1xuXG5cdFx0XHRyZXR1cm4gKCAyICogKCBwMSAtIHAyICkgKyB2MCArIHYxICkgKiB0MyArICggLSAzICogKCBwMSAtIHAyICkgLSAyICogdjAgLSB2MSApICogdDIgKyB2MCAqIHQgKyBwMTtcblxuXHRcdH1cblxuXHR9O1xuXG5cdC8vIEZpbGU6c3JjL21hdGgvVHJpYW5nbGUuanNcblxuXHQvKipcblx0ICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuXHQgKi9cblxuXHRUSFJFRS5UcmlhbmdsZSA9IGZ1bmN0aW9uICggYSwgYiwgYyApIHtcblxuXHRcdHRoaXMuYSA9ICggYSAhPT0gdW5kZWZpbmVkICkgPyBhIDogbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHR0aGlzLmIgPSAoIGIgIT09IHVuZGVmaW5lZCApID8gYiA6IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0dGhpcy5jID0gKCBjICE9PSB1bmRlZmluZWQgKSA/IGMgOiBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdH07XG5cblx0VEhSRUUuVHJpYW5nbGUubm9ybWFsID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHYwID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiAoIGEsIGIsIGMsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdFx0cmVzdWx0LnN1YlZlY3RvcnMoIGMsIGIgKTtcblx0XHRcdHYwLnN1YlZlY3RvcnMoIGEsIGIgKTtcblx0XHRcdHJlc3VsdC5jcm9zcyggdjAgKTtcblxuXHRcdFx0dmFyIHJlc3VsdExlbmd0aFNxID0gcmVzdWx0Lmxlbmd0aFNxKCk7XG5cdFx0XHRpZiAoIHJlc3VsdExlbmd0aFNxID4gMCApIHtcblxuXHRcdFx0XHRyZXR1cm4gcmVzdWx0Lm11bHRpcGx5U2NhbGFyKCAxIC8gTWF0aC5zcXJ0KCByZXN1bHRMZW5ndGhTcSApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHJlc3VsdC5zZXQoIDAsIDAsIDAgKTtcblxuXHRcdH07XG5cblx0fSgpO1xuXG5cdC8vIHN0YXRpYy9pbnN0YW5jZSBtZXRob2QgdG8gY2FsY3VsYXRlIGJhcnljZW50cmljIGNvb3JkaW5hdGVzXG5cdC8vIGJhc2VkIG9uOiBodHRwOi8vd3d3LmJsYWNrcGF3bi5jb20vdGV4dHMvcG9pbnRpbnBvbHkvZGVmYXVsdC5odG1sXG5cdFRIUkVFLlRyaWFuZ2xlLmJhcnljb29yZEZyb21Qb2ludCA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB2MCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHR2YXIgdjIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggcG9pbnQsIGEsIGIsIGMsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0XHR2MC5zdWJWZWN0b3JzKCBjLCBhICk7XG5cdFx0XHR2MS5zdWJWZWN0b3JzKCBiLCBhICk7XG5cdFx0XHR2Mi5zdWJWZWN0b3JzKCBwb2ludCwgYSApO1xuXG5cdFx0XHR2YXIgZG90MDAgPSB2MC5kb3QoIHYwICk7XG5cdFx0XHR2YXIgZG90MDEgPSB2MC5kb3QoIHYxICk7XG5cdFx0XHR2YXIgZG90MDIgPSB2MC5kb3QoIHYyICk7XG5cdFx0XHR2YXIgZG90MTEgPSB2MS5kb3QoIHYxICk7XG5cdFx0XHR2YXIgZG90MTIgPSB2MS5kb3QoIHYyICk7XG5cblx0XHRcdHZhciBkZW5vbSA9ICggZG90MDAgKiBkb3QxMSAtIGRvdDAxICogZG90MDEgKTtcblxuXHRcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRcdC8vIGNvbGxpbmVhciBvciBzaW5ndWxhciB0cmlhbmdsZVxuXHRcdFx0aWYgKCBkZW5vbSA9PT0gMCApIHtcblxuXHRcdFx0XHQvLyBhcmJpdHJhcnkgbG9jYXRpb24gb3V0c2lkZSBvZiB0cmlhbmdsZT9cblx0XHRcdFx0Ly8gbm90IHN1cmUgaWYgdGhpcyBpcyB0aGUgYmVzdCBpZGVhLCBtYXliZSBzaG91bGQgYmUgcmV0dXJuaW5nIHVuZGVmaW5lZFxuXHRcdFx0XHRyZXR1cm4gcmVzdWx0LnNldCggLSAyLCAtIDEsIC0gMSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBpbnZEZW5vbSA9IDEgLyBkZW5vbTtcblx0XHRcdHZhciB1ID0gKCBkb3QxMSAqIGRvdDAyIC0gZG90MDEgKiBkb3QxMiApICogaW52RGVub207XG5cdFx0XHR2YXIgdiA9ICggZG90MDAgKiBkb3QxMiAtIGRvdDAxICogZG90MDIgKSAqIGludkRlbm9tO1xuXG5cdFx0XHQvLyBiYXJ5Y2VudHJpYyBjb29yZGluYXRlcyBtdXN0IGFsd2F5cyBzdW0gdG8gMVxuXHRcdFx0cmV0dXJuIHJlc3VsdC5zZXQoIDEgLSB1IC0gdiwgdiwgdSApO1xuXG5cdFx0fTtcblxuXHR9KCk7XG5cblx0VEhSRUUuVHJpYW5nbGUuY29udGFpbnNQb2ludCA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBwb2ludCwgYSwgYiwgYyApIHtcblxuXHRcdFx0dmFyIHJlc3VsdCA9IFRIUkVFLlRyaWFuZ2xlLmJhcnljb29yZEZyb21Qb2ludCggcG9pbnQsIGEsIGIsIGMsIHYxICk7XG5cblx0XHRcdHJldHVybiAoIHJlc3VsdC54ID49IDAgKSAmJiAoIHJlc3VsdC55ID49IDAgKSAmJiAoICggcmVzdWx0LnggKyByZXN1bHQueSApIDw9IDEgKTtcblxuXHRcdH07XG5cblx0fSgpO1xuXG5cdFRIUkVFLlRyaWFuZ2xlLnByb3RvdHlwZSA9IHtcblxuXHRcdGNvbnN0cnVjdG9yOiBUSFJFRS5UcmlhbmdsZSxcblxuXHRcdHNldDogZnVuY3Rpb24gKCBhLCBiLCBjICkge1xuXG5cdFx0XHR0aGlzLmEuY29weSggYSApO1xuXHRcdFx0dGhpcy5iLmNvcHkoIGIgKTtcblx0XHRcdHRoaXMuYy5jb3B5KCBjICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHNldEZyb21Qb2ludHNBbmRJbmRpY2VzOiBmdW5jdGlvbiAoIHBvaW50cywgaTAsIGkxLCBpMiApIHtcblxuXHRcdFx0dGhpcy5hLmNvcHkoIHBvaW50c1sgaTAgXSApO1xuXHRcdFx0dGhpcy5iLmNvcHkoIHBvaW50c1sgaTEgXSApO1xuXHRcdFx0dGhpcy5jLmNvcHkoIHBvaW50c1sgaTIgXSApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cblx0XHR9LFxuXG5cdFx0Y29weTogZnVuY3Rpb24gKCB0cmlhbmdsZSApIHtcblxuXHRcdFx0dGhpcy5hLmNvcHkoIHRyaWFuZ2xlLmEgKTtcblx0XHRcdHRoaXMuYi5jb3B5KCB0cmlhbmdsZS5iICk7XG5cdFx0XHR0aGlzLmMuY29weSggdHJpYW5nbGUuYyApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRhcmVhOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciB2MCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0XHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdHYwLnN1YlZlY3RvcnMoIHRoaXMuYywgdGhpcy5iICk7XG5cdFx0XHRcdHYxLnN1YlZlY3RvcnMoIHRoaXMuYSwgdGhpcy5iICk7XG5cblx0XHRcdFx0cmV0dXJuIHYwLmNyb3NzKCB2MSApLmxlbmd0aCgpICogMC41O1xuXG5cdFx0XHR9O1xuXG5cdFx0fSgpLFxuXG5cdFx0bWlkcG9pbnQ6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdFx0cmV0dXJuIHJlc3VsdC5hZGRWZWN0b3JzKCB0aGlzLmEsIHRoaXMuYiApLmFkZCggdGhpcy5jICkubXVsdGlwbHlTY2FsYXIoIDEgLyAzICk7XG5cblx0XHR9LFxuXG5cdFx0bm9ybWFsOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0XHRyZXR1cm4gVEhSRUUuVHJpYW5nbGUubm9ybWFsKCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5jLCBvcHRpb25hbFRhcmdldCApO1xuXG5cdFx0fSxcblxuXHRcdHBsYW5lOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlBsYW5lKCk7XG5cblx0XHRcdHJldHVybiByZXN1bHQuc2V0RnJvbUNvcGxhbmFyUG9pbnRzKCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5jICk7XG5cblx0XHR9LFxuXG5cdFx0YmFyeWNvb3JkRnJvbVBvaW50OiBmdW5jdGlvbiAoIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdFx0cmV0dXJuIFRIUkVFLlRyaWFuZ2xlLmJhcnljb29yZEZyb21Qb2ludCggcG9pbnQsIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMsIG9wdGlvbmFsVGFyZ2V0ICk7XG5cblx0XHR9LFxuXG5cdFx0Y29udGFpbnNQb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcblxuXHRcdFx0cmV0dXJuIFRIUkVFLlRyaWFuZ2xlLmNvbnRhaW5zUG9pbnQoIHBvaW50LCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5jICk7XG5cblx0XHR9LFxuXG5cdFx0ZXF1YWxzOiBmdW5jdGlvbiAoIHRyaWFuZ2xlICkge1xuXG5cdFx0XHRyZXR1cm4gdHJpYW5nbGUuYS5lcXVhbHMoIHRoaXMuYSApICYmIHRyaWFuZ2xlLmIuZXF1YWxzKCB0aGlzLmIgKSAmJiB0cmlhbmdsZS5jLmVxdWFscyggdGhpcy5jICk7XG5cblx0XHR9XG5cblx0fTtcblxuXHQvLyBGaWxlOnNyYy9jb3JlL0NoYW5uZWxzLmpzXG5cblx0LyoqXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqL1xuXG5cdFRIUkVFLkNoYW5uZWxzID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy5tYXNrID0gMTtcblxuXHR9O1xuXG5cdFRIUkVFLkNoYW5uZWxzLnByb3RvdHlwZSA9IHtcblxuXHRcdGNvbnN0cnVjdG9yOiBUSFJFRS5DaGFubmVscyxcblxuXHRcdHNldDogZnVuY3Rpb24gKCBjaGFubmVsICkge1xuXG5cdFx0XHR0aGlzLm1hc2sgPSAxIDw8IGNoYW5uZWw7XG5cblx0XHR9LFxuXG5cdFx0ZW5hYmxlOiBmdW5jdGlvbiAoIGNoYW5uZWwgKSB7XG5cblx0XHRcdHRoaXMubWFzayB8PSAxIDw8IGNoYW5uZWw7XG5cblx0XHR9LFxuXG5cdFx0dG9nZ2xlOiBmdW5jdGlvbiAoIGNoYW5uZWwgKSB7XG5cblx0XHRcdHRoaXMubWFzayBePSAxIDw8IGNoYW5uZWw7XG5cblx0XHR9LFxuXG5cdFx0ZGlzYWJsZTogZnVuY3Rpb24gKCBjaGFubmVsICkge1xuXG5cdFx0XHR0aGlzLm1hc2sgJj0gfiAoIDEgPDwgY2hhbm5lbCApO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0Ly8gRmlsZTpzcmMvY29yZS9DbG9jay5qc1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuXHQgKi9cblxuXHRUSFJFRS5DbG9jayA9IGZ1bmN0aW9uICggYXV0b1N0YXJ0ICkge1xuXG5cdFx0dGhpcy5hdXRvU3RhcnQgPSAoIGF1dG9TdGFydCAhPT0gdW5kZWZpbmVkICkgPyBhdXRvU3RhcnQgOiB0cnVlO1xuXG5cdFx0dGhpcy5zdGFydFRpbWUgPSAwO1xuXHRcdHRoaXMub2xkVGltZSA9IDA7XG5cdFx0dGhpcy5lbGFwc2VkVGltZSA9IDA7XG5cblx0XHR0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcblxuXHR9O1xuXG5cdFRIUkVFLkNsb2NrLnByb3RvdHlwZSA9IHtcblxuXHRcdGNvbnN0cnVjdG9yOiBUSFJFRS5DbG9jayxcblxuXHRcdHN0YXJ0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHRoaXMuc3RhcnRUaW1lID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcblxuXHRcdFx0dGhpcy5vbGRUaW1lID0gdGhpcy5zdGFydFRpbWU7XG5cdFx0XHR0aGlzLnJ1bm5pbmcgPSB0cnVlO1xuXG5cdFx0fSxcblxuXHRcdHN0b3A6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dGhpcy5nZXRFbGFwc2VkVGltZSgpO1xuXHRcdFx0dGhpcy5ydW5uaW5nID0gZmFsc2U7XG5cblx0XHR9LFxuXG5cdFx0Z2V0RWxhcHNlZFRpbWU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dGhpcy5nZXREZWx0YSgpO1xuXHRcdFx0cmV0dXJuIHRoaXMuZWxhcHNlZFRpbWU7XG5cblx0XHR9LFxuXG5cdFx0Z2V0RGVsdGE6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIGRpZmYgPSAwO1xuXG5cdFx0XHRpZiAoIHRoaXMuYXV0b1N0YXJ0ICYmICEgdGhpcy5ydW5uaW5nICkge1xuXG5cdFx0XHRcdHRoaXMuc3RhcnQoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHRoaXMucnVubmluZyApIHtcblxuXHRcdFx0XHR2YXIgbmV3VGltZSA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG5cblx0XHRcdFx0ZGlmZiA9IDAuMDAxICogKCBuZXdUaW1lIC0gdGhpcy5vbGRUaW1lICk7XG5cdFx0XHRcdHRoaXMub2xkVGltZSA9IG5ld1RpbWU7XG5cblx0XHRcdFx0dGhpcy5lbGFwc2VkVGltZSArPSBkaWZmO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkaWZmO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0Ly8gRmlsZTpzcmMvY29yZS9FdmVudERpc3BhdGNoZXIuanNcblxuXHQvKipcblx0ICogaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi9ldmVudGRpc3BhdGNoZXIuanMvXG5cdCAqL1xuXG5cdFRIUkVFLkV2ZW50RGlzcGF0Y2hlciA9IGZ1bmN0aW9uICgpIHt9O1xuXG5cdFRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUgPSB7XG5cblx0XHRjb25zdHJ1Y3RvcjogVEhSRUUuRXZlbnREaXNwYXRjaGVyLFxuXG5cdFx0YXBwbHk6IGZ1bmN0aW9uICggb2JqZWN0ICkge1xuXG5cdFx0XHRvYmplY3QuYWRkRXZlbnRMaXN0ZW5lciA9IFRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lcjtcblx0XHRcdG9iamVjdC5oYXNFdmVudExpc3RlbmVyID0gVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5oYXNFdmVudExpc3RlbmVyO1xuXHRcdFx0b2JqZWN0LnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBUSFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXI7XG5cdFx0XHRvYmplY3QuZGlzcGF0Y2hFdmVudCA9IFRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuZGlzcGF0Y2hFdmVudDtcblxuXHRcdH0sXG5cblx0XHRhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAoIHR5cGUsIGxpc3RlbmVyICkge1xuXG5cdFx0XHRpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICkgdGhpcy5fbGlzdGVuZXJzID0ge307XG5cblx0XHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG5cblx0XHRcdGlmICggbGlzdGVuZXJzWyB0eXBlIF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRsaXN0ZW5lcnNbIHR5cGUgXSA9IFtdO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbGlzdGVuZXJzWyB0eXBlIF0uaW5kZXhPZiggbGlzdGVuZXIgKSA9PT0gLSAxICkge1xuXG5cdFx0XHRcdGxpc3RlbmVyc1sgdHlwZSBdLnB1c2goIGxpc3RlbmVyICk7XG5cblx0XHRcdH1cblxuXHRcdH0sXG5cblx0XHRoYXNFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAoIHR5cGUsIGxpc3RlbmVyICkge1xuXG5cdFx0XHRpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuXG5cdFx0XHRpZiAoIGxpc3RlbmVyc1sgdHlwZSBdICE9PSB1bmRlZmluZWQgJiYgbGlzdGVuZXJzWyB0eXBlIF0uaW5kZXhPZiggbGlzdGVuZXIgKSAhPT0gLSAxICkge1xuXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdH0sXG5cblx0XHRyZW1vdmVFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAoIHR5cGUsIGxpc3RlbmVyICkge1xuXG5cdFx0XHRpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuXG5cdFx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuXHRcdFx0dmFyIGxpc3RlbmVyQXJyYXkgPSBsaXN0ZW5lcnNbIHR5cGUgXTtcblxuXHRcdFx0aWYgKCBsaXN0ZW5lckFycmF5ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0dmFyIGluZGV4ID0gbGlzdGVuZXJBcnJheS5pbmRleE9mKCBsaXN0ZW5lciApO1xuXG5cdFx0XHRcdGlmICggaW5kZXggIT09IC0gMSApIHtcblxuXHRcdFx0XHRcdGxpc3RlbmVyQXJyYXkuc3BsaWNlKCBpbmRleCwgMSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fSxcblxuXHRcdGRpc3BhdGNoRXZlbnQ6IGZ1bmN0aW9uICggZXZlbnQgKSB7XG5cblx0XHRcdGlmICggdGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQgKSByZXR1cm47XG5cblx0XHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG5cdFx0XHR2YXIgbGlzdGVuZXJBcnJheSA9IGxpc3RlbmVyc1sgZXZlbnQudHlwZSBdO1xuXG5cdFx0XHRpZiAoIGxpc3RlbmVyQXJyYXkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRldmVudC50YXJnZXQgPSB0aGlzO1xuXG5cdFx0XHRcdHZhciBhcnJheSA9IFtdO1xuXHRcdFx0XHR2YXIgbGVuZ3RoID0gbGlzdGVuZXJBcnJheS5sZW5ndGg7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdFx0YXJyYXlbIGkgXSA9IGxpc3RlbmVyQXJyYXlbIGkgXTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdFx0YXJyYXlbIGkgXS5jYWxsKCB0aGlzLCBldmVudCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH07XG5cblx0Ly8gRmlsZTpzcmMvY29yZS9SYXljYXN0ZXIuanNcblxuXHQvKipcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cblx0ICogQGF1dGhvciBzdGVwaG9taSAvIGh0dHA6Ly9zdGVwaGFuZWdpbmllci5jb20vXG5cdCAqL1xuXG5cdCggZnVuY3Rpb24gKCBUSFJFRSApIHtcblxuXHRcdFRIUkVFLlJheWNhc3RlciA9IGZ1bmN0aW9uICggb3JpZ2luLCBkaXJlY3Rpb24sIG5lYXIsIGZhciApIHtcblxuXHRcdFx0dGhpcy5yYXkgPSBuZXcgVEhSRUUuUmF5KCBvcmlnaW4sIGRpcmVjdGlvbiApO1xuXHRcdFx0Ly8gZGlyZWN0aW9uIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZCAoZm9yIGFjY3VyYXRlIGRpc3RhbmNlIGNhbGN1bGF0aW9ucylcblxuXHRcdFx0dGhpcy5uZWFyID0gbmVhciB8fCAwO1xuXHRcdFx0dGhpcy5mYXIgPSBmYXIgfHwgSW5maW5pdHk7XG5cblx0XHRcdHRoaXMucGFyYW1zID0ge1xuXHRcdFx0XHRNZXNoOiB7fSxcblx0XHRcdFx0TGluZToge30sXG5cdFx0XHRcdExPRDoge30sXG5cdFx0XHRcdFBvaW50czogeyB0aHJlc2hvbGQ6IDEgfSxcblx0XHRcdFx0U3ByaXRlOiB7fVxuXHRcdFx0fTtcblxuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIHRoaXMucGFyYW1zLCB7XG5cdFx0XHRcdFBvaW50Q2xvdWQ6IHtcblx0XHRcdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlJheWNhc3RlcjogcGFyYW1zLlBvaW50Q2xvdWQgaGFzIGJlZW4gcmVuYW1lZCB0byBwYXJhbXMuUG9pbnRzLicgKTtcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzLlBvaW50cztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBkZXNjU29ydCggYSwgYiApIHtcblxuXHRcdFx0cmV0dXJuIGEuZGlzdGFuY2UgLSBiLmRpc3RhbmNlO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaW50ZXJzZWN0T2JqZWN0KCBvYmplY3QsIHJheWNhc3RlciwgaW50ZXJzZWN0cywgcmVjdXJzaXZlICkge1xuXG5cdFx0XHRpZiAoIG9iamVjdC52aXNpYmxlID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdFx0b2JqZWN0LnJheWNhc3QoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApO1xuXG5cdFx0XHRpZiAoIHJlY3Vyc2l2ZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHR2YXIgY2hpbGRyZW4gPSBvYmplY3QuY2hpbGRyZW47XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdGludGVyc2VjdE9iamVjdCggY2hpbGRyZW5bIGkgXSwgcmF5Y2FzdGVyLCBpbnRlcnNlY3RzLCB0cnVlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvL1xuXG5cdFx0VEhSRUUuUmF5Y2FzdGVyLnByb3RvdHlwZSA9IHtcblxuXHRcdFx0Y29uc3RydWN0b3I6IFRIUkVFLlJheWNhc3RlcixcblxuXHRcdFx0bGluZVByZWNpc2lvbjogMSxcblxuXHRcdFx0c2V0OiBmdW5jdGlvbiAoIG9yaWdpbiwgZGlyZWN0aW9uICkge1xuXG5cdFx0XHRcdC8vIGRpcmVjdGlvbiBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWQgKGZvciBhY2N1cmF0ZSBkaXN0YW5jZSBjYWxjdWxhdGlvbnMpXG5cblx0XHRcdFx0dGhpcy5yYXkuc2V0KCBvcmlnaW4sIGRpcmVjdGlvbiApO1xuXG5cdFx0XHR9LFxuXG5cdFx0XHRzZXRGcm9tQ2FtZXJhOiBmdW5jdGlvbiAoIGNvb3JkcywgY2FtZXJhICkge1xuXG5cdFx0XHRcdGlmICggY2FtZXJhIGluc3RhbmNlb2YgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEgKSB7XG5cblx0XHRcdFx0XHR0aGlzLnJheS5vcmlnaW4uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBjYW1lcmEubWF0cml4V29ybGQgKTtcblx0XHRcdFx0XHR0aGlzLnJheS5kaXJlY3Rpb24uc2V0KCBjb29yZHMueCwgY29vcmRzLnksIDAuNSApLnVucHJvamVjdCggY2FtZXJhICkuc3ViKCB0aGlzLnJheS5vcmlnaW4gKS5ub3JtYWxpemUoKTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBjYW1lcmEgaW5zdGFuY2VvZiBUSFJFRS5PcnRob2dyYXBoaWNDYW1lcmEgKSB7XG5cblx0XHRcdFx0XHR0aGlzLnJheS5vcmlnaW4uc2V0KCBjb29yZHMueCwgY29vcmRzLnksIC0gMSApLnVucHJvamVjdCggY2FtZXJhICk7XG5cdFx0XHRcdFx0dGhpcy5yYXkuZGlyZWN0aW9uLnNldCggMCwgMCwgLSAxICkudHJhbnNmb3JtRGlyZWN0aW9uKCBjYW1lcmEubWF0cml4V29ybGQgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlJheWNhc3RlcjogVW5zdXBwb3J0ZWQgY2FtZXJhIHR5cGUuJyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSxcblxuXHRcdFx0aW50ZXJzZWN0T2JqZWN0OiBmdW5jdGlvbiAoIG9iamVjdCwgcmVjdXJzaXZlICkge1xuXG5cdFx0XHRcdHZhciBpbnRlcnNlY3RzID0gW107XG5cblx0XHRcdFx0aW50ZXJzZWN0T2JqZWN0KCBvYmplY3QsIHRoaXMsIGludGVyc2VjdHMsIHJlY3Vyc2l2ZSApO1xuXG5cdFx0XHRcdGludGVyc2VjdHMuc29ydCggZGVzY1NvcnQgKTtcblxuXHRcdFx0XHRyZXR1cm4gaW50ZXJzZWN0cztcblxuXHRcdFx0fSxcblxuXHRcdFx0aW50ZXJzZWN0T2JqZWN0czogZnVuY3Rpb24gKCBvYmplY3RzLCByZWN1cnNpdmUgKSB7XG5cblx0XHRcdFx0dmFyIGludGVyc2VjdHMgPSBbXTtcblxuXHRcdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIG9iamVjdHMgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5SYXljYXN0ZXIuaW50ZXJzZWN0T2JqZWN0czogb2JqZWN0cyBpcyBub3QgYW4gQXJyYXkuJyApO1xuXHRcdFx0XHRcdHJldHVybiBpbnRlcnNlY3RzO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBvYmplY3RzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRpbnRlcnNlY3RPYmplY3QoIG9iamVjdHNbIGkgXSwgdGhpcywgaW50ZXJzZWN0cywgcmVjdXJzaXZlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGludGVyc2VjdHMuc29ydCggZGVzY1NvcnQgKTtcblxuXHRcdFx0XHRyZXR1cm4gaW50ZXJzZWN0cztcblxuXHRcdFx0fVxuXG5cdFx0fTtcblxuXHR9KCBUSFJFRSApICk7XG5cblx0Ly8gRmlsZTpzcmMvY29yZS9PYmplY3QzRC5qc1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuXHQgKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuXHQgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcblx0ICogQGF1dGhvciBlbGVwaGFudGF0d29yayAvIHd3dy5lbGVwaGFudGF0d29yay5jaFxuXHQgKi9cblxuXHRUSFJFRS5PYmplY3QzRCA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ2lkJywgeyB2YWx1ZTogVEhSRUUuT2JqZWN0M0RJZENvdW50ICsrIH0gKTtcblxuXHRcdHRoaXMudXVpZCA9IFRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCk7XG5cblx0XHR0aGlzLm5hbWUgPSAnJztcblx0XHR0aGlzLnR5cGUgPSAnT2JqZWN0M0QnO1xuXG5cdFx0dGhpcy5wYXJlbnQgPSBudWxsO1xuXHRcdHRoaXMuY2hhbm5lbHMgPSBuZXcgVEhSRUUuQ2hhbm5lbHMoKTtcblx0XHR0aGlzLmNoaWxkcmVuID0gW107XG5cblx0XHR0aGlzLnVwID0gVEhSRUUuT2JqZWN0M0QuRGVmYXVsdFVwLmNsb25lKCk7XG5cblx0XHR2YXIgcG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdHZhciByb3RhdGlvbiA9IG5ldyBUSFJFRS5FdWxlcigpO1xuXHRcdHZhciBxdWF0ZXJuaW9uID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcblx0XHR2YXIgc2NhbGUgPSBuZXcgVEhSRUUuVmVjdG9yMyggMSwgMSwgMSApO1xuXG5cdFx0ZnVuY3Rpb24gb25Sb3RhdGlvbkNoYW5nZSgpIHtcblxuXHRcdFx0cXVhdGVybmlvbi5zZXRGcm9tRXVsZXIoIHJvdGF0aW9uLCBmYWxzZSApO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25RdWF0ZXJuaW9uQ2hhbmdlKCkge1xuXG5cdFx0XHRyb3RhdGlvbi5zZXRGcm9tUXVhdGVybmlvbiggcXVhdGVybmlvbiwgdW5kZWZpbmVkLCBmYWxzZSApO1xuXG5cdFx0fVxuXG5cdFx0cm90YXRpb24ub25DaGFuZ2UoIG9uUm90YXRpb25DaGFuZ2UgKTtcblx0XHRxdWF0ZXJuaW9uLm9uQ2hhbmdlKCBvblF1YXRlcm5pb25DaGFuZ2UgKTtcblxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCB0aGlzLCB7XG5cdFx0XHRwb3NpdGlvbjoge1xuXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHR2YWx1ZTogcG9zaXRpb25cblx0XHRcdH0sXG5cdFx0XHRyb3RhdGlvbjoge1xuXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHR2YWx1ZTogcm90YXRpb25cblx0XHRcdH0sXG5cdFx0XHRxdWF0ZXJuaW9uOiB7XG5cdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRcdHZhbHVlOiBxdWF0ZXJuaW9uXG5cdFx0XHR9LFxuXHRcdFx0c2NhbGU6IHtcblx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0dmFsdWU6IHNjYWxlXG5cdFx0XHR9LFxuXHRcdFx0bW9kZWxWaWV3TWF0cml4OiB7XG5cdFx0XHRcdHZhbHVlOiBuZXcgVEhSRUUuTWF0cml4NCgpXG5cdFx0XHR9LFxuXHRcdFx0bm9ybWFsTWF0cml4OiB7XG5cdFx0XHRcdHZhbHVlOiBuZXcgVEhSRUUuTWF0cml4MygpXG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cdFx0dGhpcy5yb3RhdGlvbkF1dG9VcGRhdGUgPSB0cnVlO1xuXG5cdFx0dGhpcy5tYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXHRcdHRoaXMubWF0cml4V29ybGQgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG5cdFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gVEhSRUUuT2JqZWN0M0QuRGVmYXVsdE1hdHJpeEF1dG9VcGRhdGU7XG5cdFx0dGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gZmFsc2U7XG5cblx0XHR0aGlzLnZpc2libGUgPSB0cnVlO1xuXG5cdFx0dGhpcy5jYXN0U2hhZG93ID0gZmFsc2U7XG5cdFx0dGhpcy5yZWNlaXZlU2hhZG93ID0gZmFsc2U7XG5cblx0XHR0aGlzLmZydXN0dW1DdWxsZWQgPSB0cnVlO1xuXHRcdHRoaXMucmVuZGVyT3JkZXIgPSAwO1xuXG5cdFx0dGhpcy51c2VyRGF0YSA9IHt9O1xuXG5cdH07XG5cblx0VEhSRUUuT2JqZWN0M0QuRGVmYXVsdFVwID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDEsIDAgKTtcblx0VEhSRUUuT2JqZWN0M0QuRGVmYXVsdE1hdHJpeEF1dG9VcGRhdGUgPSB0cnVlO1xuXG5cdFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSA9IHtcblxuXHRcdGNvbnN0cnVjdG9yOiBUSFJFRS5PYmplY3QzRCxcblxuXHRcdGdldCBldWxlck9yZGVyICgpIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0M0Q6IC5ldWxlck9yZGVyIGlzIG5vdyAucm90YXRpb24ub3JkZXIuJyApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5yb3RhdGlvbi5vcmRlcjtcblxuXHRcdH0sXG5cblx0XHRzZXQgZXVsZXJPcmRlciAoIHZhbHVlICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3QzRDogLmV1bGVyT3JkZXIgaXMgbm93IC5yb3RhdGlvbi5vcmRlci4nICk7XG5cblx0XHRcdHRoaXMucm90YXRpb24ub3JkZXIgPSB2YWx1ZTtcblxuXHRcdH0sXG5cblx0XHRnZXQgdXNlUXVhdGVybmlvbiAoKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdDNEOiAudXNlUXVhdGVybmlvbiBoYXMgYmVlbiByZW1vdmVkLiBUaGUgbGlicmFyeSBub3cgdXNlcyBxdWF0ZXJuaW9ucyBieSBkZWZhdWx0LicgKTtcblxuXHRcdH0sXG5cblx0XHRzZXQgdXNlUXVhdGVybmlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3QzRDogLnVzZVF1YXRlcm5pb24gaGFzIGJlZW4gcmVtb3ZlZC4gVGhlIGxpYnJhcnkgbm93IHVzZXMgcXVhdGVybmlvbnMgYnkgZGVmYXVsdC4nICk7XG5cblx0XHR9LFxuXG5cdFx0c2V0IHJlbmRlckRlcHRoICggdmFsdWUgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdDNEOiAucmVuZGVyRGVwdGggaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIC5yZW5kZXJPcmRlciwgaW5zdGVhZC4nICk7XG5cblx0XHR9LFxuXG5cdFx0Ly9cblxuXHRcdGFwcGx5TWF0cml4OiBmdW5jdGlvbiAoIG1hdHJpeCApIHtcblxuXHRcdFx0dGhpcy5tYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggbWF0cml4LCB0aGlzLm1hdHJpeCApO1xuXG5cdFx0XHR0aGlzLm1hdHJpeC5kZWNvbXBvc2UoIHRoaXMucG9zaXRpb24sIHRoaXMucXVhdGVybmlvbiwgdGhpcy5zY2FsZSApO1xuXG5cdFx0fSxcblxuXHRcdHNldFJvdGF0aW9uRnJvbUF4aXNBbmdsZTogZnVuY3Rpb24gKCBheGlzLCBhbmdsZSApIHtcblxuXHRcdFx0Ly8gYXNzdW1lcyBheGlzIGlzIG5vcm1hbGl6ZWRcblxuXHRcdFx0dGhpcy5xdWF0ZXJuaW9uLnNldEZyb21BeGlzQW5nbGUoIGF4aXMsIGFuZ2xlICk7XG5cblx0XHR9LFxuXG5cdFx0c2V0Um90YXRpb25Gcm9tRXVsZXI6IGZ1bmN0aW9uICggZXVsZXIgKSB7XG5cblx0XHRcdHRoaXMucXVhdGVybmlvbi5zZXRGcm9tRXVsZXIoIGV1bGVyLCB0cnVlICk7XG5cblx0XHR9LFxuXG5cdFx0c2V0Um90YXRpb25Gcm9tTWF0cml4OiBmdW5jdGlvbiAoIG0gKSB7XG5cblx0XHRcdC8vIGFzc3VtZXMgdGhlIHVwcGVyIDN4MyBvZiBtIGlzIGEgcHVyZSByb3RhdGlvbiBtYXRyaXggKGkuZSwgdW5zY2FsZWQpXG5cblx0XHRcdHRoaXMucXVhdGVybmlvbi5zZXRGcm9tUm90YXRpb25NYXRyaXgoIG0gKTtcblxuXHRcdH0sXG5cblx0XHRzZXRSb3RhdGlvbkZyb21RdWF0ZXJuaW9uOiBmdW5jdGlvbiAoIHEgKSB7XG5cblx0XHRcdC8vIGFzc3VtZXMgcSBpcyBub3JtYWxpemVkXG5cblx0XHRcdHRoaXMucXVhdGVybmlvbi5jb3B5KCBxICk7XG5cblx0XHR9LFxuXG5cdFx0cm90YXRlT25BeGlzOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdC8vIHJvdGF0ZSBvYmplY3Qgb24gYXhpcyBpbiBvYmplY3Qgc3BhY2Vcblx0XHRcdC8vIGF4aXMgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXG5cblx0XHRcdHZhciBxMSA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiAoIGF4aXMsIGFuZ2xlICkge1xuXG5cdFx0XHRcdHExLnNldEZyb21BeGlzQW5nbGUoIGF4aXMsIGFuZ2xlICk7XG5cblx0XHRcdFx0dGhpcy5xdWF0ZXJuaW9uLm11bHRpcGx5KCBxMSApO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0XHR9O1xuXG5cdFx0fSgpLFxuXG5cdFx0cm90YXRlWDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMyggMSwgMCwgMCApO1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKCBhbmdsZSApIHtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcy5yb3RhdGVPbkF4aXMoIHYxLCBhbmdsZSApO1xuXG5cdFx0XHR9O1xuXG5cdFx0fSgpLFxuXG5cdFx0cm90YXRlWTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMSwgMCApO1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKCBhbmdsZSApIHtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcy5yb3RhdGVPbkF4aXMoIHYxLCBhbmdsZSApO1xuXG5cdFx0XHR9O1xuXG5cdFx0fSgpLFxuXG5cdFx0cm90YXRlWjogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMCwgMSApO1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKCBhbmdsZSApIHtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcy5yb3RhdGVPbkF4aXMoIHYxLCBhbmdsZSApO1xuXG5cdFx0XHR9O1xuXG5cdFx0fSgpLFxuXG5cdFx0dHJhbnNsYXRlT25BeGlzOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdC8vIHRyYW5zbGF0ZSBvYmplY3QgYnkgZGlzdGFuY2UgYWxvbmcgYXhpcyBpbiBvYmplY3Qgc3BhY2Vcblx0XHRcdC8vIGF4aXMgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXG5cblx0XHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiAoIGF4aXMsIGRpc3RhbmNlICkge1xuXG5cdFx0XHRcdHYxLmNvcHkoIGF4aXMgKS5hcHBseVF1YXRlcm5pb24oIHRoaXMucXVhdGVybmlvbiApO1xuXG5cdFx0XHRcdHRoaXMucG9zaXRpb24uYWRkKCB2MS5tdWx0aXBseVNjYWxhciggZGlzdGFuY2UgKSApO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0XHR9O1xuXG5cdFx0fSgpLFxuXG5cdFx0dHJhbnNsYXRlOiBmdW5jdGlvbiAoIGRpc3RhbmNlLCBheGlzICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3QzRDogLnRyYW5zbGF0ZSgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSAudHJhbnNsYXRlT25BeGlzKCBheGlzLCBkaXN0YW5jZSApIGluc3RlYWQuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKCBheGlzLCBkaXN0YW5jZSApO1xuXG5cdFx0fSxcblxuXHRcdHRyYW5zbGF0ZVg6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoIDEsIDAsIDAgKTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uICggZGlzdGFuY2UgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKCB2MSwgZGlzdGFuY2UgKTtcblxuXHRcdFx0fTtcblxuXHRcdH0oKSxcblxuXHRcdHRyYW5zbGF0ZVk6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDEsIDAgKTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uICggZGlzdGFuY2UgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKCB2MSwgZGlzdGFuY2UgKTtcblxuXHRcdFx0fTtcblxuXHRcdH0oKSxcblxuXHRcdHRyYW5zbGF0ZVo6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIDEgKTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uICggZGlzdGFuY2UgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKCB2MSwgZGlzdGFuY2UgKTtcblxuXHRcdFx0fTtcblxuXHRcdH0oKSxcblxuXHRcdGxvY2FsVG9Xb3JsZDogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XG5cblx0XHRcdHJldHVybiB2ZWN0b3IuYXBwbHlNYXRyaXg0KCB0aGlzLm1hdHJpeFdvcmxkICk7XG5cblx0XHR9LFxuXG5cdFx0d29ybGRUb0xvY2FsOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciBtMSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiAoIHZlY3RvciApIHtcblxuXHRcdFx0XHRyZXR1cm4gdmVjdG9yLmFwcGx5TWF0cml4NCggbTEuZ2V0SW52ZXJzZSggdGhpcy5tYXRyaXhXb3JsZCApICk7XG5cblx0XHRcdH07XG5cblx0XHR9KCksXG5cblx0XHRsb29rQXQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Ly8gVGhpcyByb3V0aW5lIGRvZXMgbm90IHN1cHBvcnQgb2JqZWN0cyB3aXRoIHJvdGF0ZWQgYW5kL29yIHRyYW5zbGF0ZWQgcGFyZW50KHMpXG5cblx0XHRcdHZhciBtMSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiAoIHZlY3RvciApIHtcblxuXHRcdFx0XHRtMS5sb29rQXQoIHZlY3RvciwgdGhpcy5wb3NpdGlvbiwgdGhpcy51cCApO1xuXG5cdFx0XHRcdHRoaXMucXVhdGVybmlvbi5zZXRGcm9tUm90YXRpb25NYXRyaXgoIG0xICk7XG5cblx0XHRcdH07XG5cblx0XHR9KCksXG5cblx0XHRhZGQ6IGZ1bmN0aW9uICggb2JqZWN0ICkge1xuXG5cdFx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPiAxICkge1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0XHR0aGlzLmFkZCggYXJndW1lbnRzWyBpIF0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBvYmplY3QgPT09IHRoaXMgKSB7XG5cblx0XHRcdFx0Y29uc29sZS5lcnJvciggXCJUSFJFRS5PYmplY3QzRC5hZGQ6IG9iamVjdCBjYW4ndCBiZSBhZGRlZCBhcyBhIGNoaWxkIG9mIGl0c2VsZi5cIiwgb2JqZWN0ICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuT2JqZWN0M0QgKSB7XG5cblx0XHRcdFx0aWYgKCBvYmplY3QucGFyZW50ICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0b2JqZWN0LnBhcmVudC5yZW1vdmUoIG9iamVjdCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRvYmplY3QucGFyZW50ID0gdGhpcztcblx0XHRcdFx0b2JqZWN0LmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2FkZGVkJyB9ICk7XG5cblx0XHRcdFx0dGhpcy5jaGlsZHJlbi5wdXNoKCBvYmplY3QgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCBcIlRIUkVFLk9iamVjdDNELmFkZDogb2JqZWN0IG5vdCBhbiBpbnN0YW5jZSBvZiBUSFJFRS5PYmplY3QzRC5cIiwgb2JqZWN0ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0cmVtb3ZlOiBmdW5jdGlvbiAoIG9iamVjdCApIHtcblxuXHRcdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMSApIHtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdFx0dGhpcy5yZW1vdmUoIGFyZ3VtZW50c1sgaSBdICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBpbmRleCA9IHRoaXMuY2hpbGRyZW4uaW5kZXhPZiggb2JqZWN0ICk7XG5cblx0XHRcdGlmICggaW5kZXggIT09IC0gMSApIHtcblxuXHRcdFx0XHRvYmplY3QucGFyZW50ID0gbnVsbDtcblxuXHRcdFx0XHRvYmplY3QuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAncmVtb3ZlZCcgfSApO1xuXG5cdFx0XHRcdHRoaXMuY2hpbGRyZW4uc3BsaWNlKCBpbmRleCwgMSApO1xuXG5cdFx0XHR9XG5cblx0XHR9LFxuXG5cdFx0Z2V0Q2hpbGRCeU5hbWU6IGZ1bmN0aW9uICggbmFtZSApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0M0Q6IC5nZXRDaGlsZEJ5TmFtZSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmdldE9iamVjdEJ5TmFtZSgpLicgKTtcblx0XHRcdHJldHVybiB0aGlzLmdldE9iamVjdEJ5TmFtZSggbmFtZSApO1xuXG5cdFx0fSxcblxuXHRcdGdldE9iamVjdEJ5SWQ6IGZ1bmN0aW9uICggaWQgKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLmdldE9iamVjdEJ5UHJvcGVydHkoICdpZCcsIGlkICk7XG5cblx0XHR9LFxuXG5cdFx0Z2V0T2JqZWN0QnlOYW1lOiBmdW5jdGlvbiAoIG5hbWUgKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLmdldE9iamVjdEJ5UHJvcGVydHkoICduYW1lJywgbmFtZSApO1xuXG5cdFx0fSxcblxuXHRcdGdldE9iamVjdEJ5UHJvcGVydHk6IGZ1bmN0aW9uICggbmFtZSwgdmFsdWUgKSB7XG5cblx0XHRcdGlmICggdGhpc1sgbmFtZSBdID09PSB2YWx1ZSApIHJldHVybiB0aGlzO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlblsgaSBdO1xuXHRcdFx0XHR2YXIgb2JqZWN0ID0gY2hpbGQuZ2V0T2JqZWN0QnlQcm9wZXJ0eSggbmFtZSwgdmFsdWUgKTtcblxuXHRcdFx0XHRpZiAoIG9iamVjdCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0cmV0dXJuIG9iamVjdDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblxuXHRcdH0sXG5cblx0XHRnZXRXb3JsZFBvc2l0aW9uOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdFx0dGhpcy51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xuXG5cdFx0XHRyZXR1cm4gcmVzdWx0LnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG5cdFx0fSxcblxuXHRcdGdldFdvcmxkUXVhdGVybmlvbjogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgcG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdFx0dmFyIHNjYWxlID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHRcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG5cblx0XHRcdFx0dGhpcy51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xuXG5cdFx0XHRcdHRoaXMubWF0cml4V29ybGQuZGVjb21wb3NlKCBwb3NpdGlvbiwgcmVzdWx0LCBzY2FsZSApO1xuXG5cdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cblx0XHRcdH07XG5cblx0XHR9KCksXG5cblx0XHRnZXRXb3JsZFJvdGF0aW9uOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciBxdWF0ZXJuaW9uID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHRcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5FdWxlcigpO1xuXG5cdFx0XHRcdHRoaXMuZ2V0V29ybGRRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICk7XG5cblx0XHRcdFx0cmV0dXJuIHJlc3VsdC5zZXRGcm9tUXVhdGVybmlvbiggcXVhdGVybmlvbiwgdGhpcy5yb3RhdGlvbi5vcmRlciwgZmFsc2UgKTtcblxuXHRcdFx0fTtcblxuXHRcdH0oKSxcblxuXHRcdGdldFdvcmxkU2NhbGU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIHBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHRcdHZhciBxdWF0ZXJuaW9uID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHRcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRcdFx0dGhpcy51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xuXG5cdFx0XHRcdHRoaXMubWF0cml4V29ybGQuZGVjb21wb3NlKCBwb3NpdGlvbiwgcXVhdGVybmlvbiwgcmVzdWx0ICk7XG5cblx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblxuXHRcdFx0fTtcblxuXHRcdH0oKSxcblxuXHRcdGdldFdvcmxkRGlyZWN0aW9uOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciBxdWF0ZXJuaW9uID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHRcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRcdFx0dGhpcy5nZXRXb3JsZFF1YXRlcm5pb24oIHF1YXRlcm5pb24gKTtcblxuXHRcdFx0XHRyZXR1cm4gcmVzdWx0LnNldCggMCwgMCwgMSApLmFwcGx5UXVhdGVybmlvbiggcXVhdGVybmlvbiApO1xuXG5cdFx0XHR9O1xuXG5cdFx0fSgpLFxuXG5cdFx0cmF5Y2FzdDogZnVuY3Rpb24gKCkge30sXG5cblx0XHR0cmF2ZXJzZTogZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcblxuXHRcdFx0Y2FsbGJhY2soIHRoaXMgKTtcblxuXHRcdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRjaGlsZHJlblsgaSBdLnRyYXZlcnNlKCBjYWxsYmFjayApO1xuXG5cdFx0XHR9XG5cblx0XHR9LFxuXG5cdFx0dHJhdmVyc2VWaXNpYmxlOiBmdW5jdGlvbiAoIGNhbGxiYWNrICkge1xuXG5cdFx0XHRpZiAoIHRoaXMudmlzaWJsZSA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRcdGNhbGxiYWNrKCB0aGlzICk7XG5cblx0XHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y2hpbGRyZW5bIGkgXS50cmF2ZXJzZVZpc2libGUoIGNhbGxiYWNrICk7XG5cblx0XHRcdH1cblxuXHRcdH0sXG5cblx0XHR0cmF2ZXJzZUFuY2VzdG9yczogZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcblxuXHRcdFx0dmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xuXG5cdFx0XHRpZiAoIHBhcmVudCAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRjYWxsYmFjayggcGFyZW50ICk7XG5cblx0XHRcdFx0cGFyZW50LnRyYXZlcnNlQW5jZXN0b3JzKCBjYWxsYmFjayApO1xuXG5cdFx0XHR9XG5cblx0XHR9LFxuXG5cdFx0dXBkYXRlTWF0cml4OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHRoaXMubWF0cml4LmNvbXBvc2UoIHRoaXMucG9zaXRpb24sIHRoaXMucXVhdGVybmlvbiwgdGhpcy5zY2FsZSApO1xuXG5cdFx0XHR0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0fSxcblxuXHRcdHVwZGF0ZU1hdHJpeFdvcmxkOiBmdW5jdGlvbiAoIGZvcmNlICkge1xuXG5cdFx0XHRpZiAoIHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9PT0gdHJ1ZSApIHRoaXMudXBkYXRlTWF0cml4KCk7XG5cblx0XHRcdGlmICggdGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID09PSB0cnVlIHx8IGZvcmNlID09PSB0cnVlICkge1xuXG5cdFx0XHRcdGlmICggdGhpcy5wYXJlbnQgPT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHR0aGlzLm1hdHJpeFdvcmxkLmNvcHkoIHRoaXMubWF0cml4ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHRoaXMubWF0cml4V29ybGQubXVsdGlwbHlNYXRyaWNlcyggdGhpcy5wYXJlbnQubWF0cml4V29ybGQsIHRoaXMubWF0cml4ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0XHRcdGZvcmNlID0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyB1cGRhdGUgY2hpbGRyZW5cblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHRoaXMuY2hpbGRyZW5bIGkgXS51cGRhdGVNYXRyaXhXb3JsZCggZm9yY2UgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSxcblxuXHRcdHRvSlNPTjogZnVuY3Rpb24gKCBtZXRhICkge1xuXG5cdFx0XHR2YXIgaXNSb290T2JqZWN0ID0gKCBtZXRhID09PSB1bmRlZmluZWQgKTtcblxuXHRcdFx0dmFyIG91dHB1dCA9IHt9O1xuXG5cdFx0XHQvLyBtZXRhIGlzIGEgaGFzaCB1c2VkIHRvIGNvbGxlY3QgZ2VvbWV0cmllcywgbWF0ZXJpYWxzLlxuXHRcdFx0Ly8gbm90IHByb3ZpZGluZyBpdCBpbXBsaWVzIHRoYXQgdGhpcyBpcyB0aGUgcm9vdCBvYmplY3Rcblx0XHRcdC8vIGJlaW5nIHNlcmlhbGl6ZWQuXG5cdFx0XHRpZiAoIGlzUm9vdE9iamVjdCApIHtcblxuXHRcdFx0XHQvLyBpbml0aWFsaXplIG1ldGEgb2JqXG5cdFx0XHRcdG1ldGEgPSB7XG5cdFx0XHRcdFx0Z2VvbWV0cmllczoge30sXG5cdFx0XHRcdFx0bWF0ZXJpYWxzOiB7fSxcblx0XHRcdFx0XHR0ZXh0dXJlczoge30sXG5cdFx0XHRcdFx0aW1hZ2VzOiB7fVxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdG91dHB1dC5tZXRhZGF0YSA9IHtcblx0XHRcdFx0XHR2ZXJzaW9uOiA0LjQsXG5cdFx0XHRcdFx0dHlwZTogJ09iamVjdCcsXG5cdFx0XHRcdFx0Z2VuZXJhdG9yOiAnT2JqZWN0M0QudG9KU09OJ1xuXHRcdFx0XHR9O1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHN0YW5kYXJkIE9iamVjdDNEIHNlcmlhbGl6YXRpb25cblxuXHRcdFx0dmFyIG9iamVjdCA9IHt9O1xuXG5cdFx0XHRvYmplY3QudXVpZCA9IHRoaXMudXVpZDtcblx0XHRcdG9iamVjdC50eXBlID0gdGhpcy50eXBlO1xuXG5cdFx0XHRpZiAoIHRoaXMubmFtZSAhPT0gJycgKSBvYmplY3QubmFtZSA9IHRoaXMubmFtZTtcblx0XHRcdGlmICggSlNPTi5zdHJpbmdpZnkoIHRoaXMudXNlckRhdGEgKSAhPT0gJ3t9JyApIG9iamVjdC51c2VyRGF0YSA9IHRoaXMudXNlckRhdGE7XG5cdFx0XHRpZiAoIHRoaXMuY2FzdFNoYWRvdyA9PT0gdHJ1ZSApIG9iamVjdC5jYXN0U2hhZG93ID0gdHJ1ZTtcblx0XHRcdGlmICggdGhpcy5yZWNlaXZlU2hhZG93ID09PSB0cnVlICkgb2JqZWN0LnJlY2VpdmVTaGFkb3cgPSB0cnVlO1xuXHRcdFx0aWYgKCB0aGlzLnZpc2libGUgPT09IGZhbHNlICkgb2JqZWN0LnZpc2libGUgPSBmYWxzZTtcblxuXHRcdFx0b2JqZWN0Lm1hdHJpeCA9IHRoaXMubWF0cml4LnRvQXJyYXkoKTtcblxuXHRcdFx0Ly9cblxuXHRcdFx0aWYgKCB0aGlzLmdlb21ldHJ5ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0aWYgKCBtZXRhLmdlb21ldHJpZXNbIHRoaXMuZ2VvbWV0cnkudXVpZCBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRtZXRhLmdlb21ldHJpZXNbIHRoaXMuZ2VvbWV0cnkudXVpZCBdID0gdGhpcy5nZW9tZXRyeS50b0pTT04oIG1ldGEgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0b2JqZWN0Lmdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeS51dWlkO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggdGhpcy5tYXRlcmlhbCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGlmICggbWV0YS5tYXRlcmlhbHNbIHRoaXMubWF0ZXJpYWwudXVpZCBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRtZXRhLm1hdGVyaWFsc1sgdGhpcy5tYXRlcmlhbC51dWlkIF0gPSB0aGlzLm1hdGVyaWFsLnRvSlNPTiggbWV0YSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRvYmplY3QubWF0ZXJpYWwgPSB0aGlzLm1hdGVyaWFsLnV1aWQ7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly9cblxuXHRcdFx0aWYgKCB0aGlzLmNoaWxkcmVuLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0b2JqZWN0LmNoaWxkcmVuID0gW107XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRvYmplY3QuY2hpbGRyZW4ucHVzaCggdGhpcy5jaGlsZHJlblsgaSBdLnRvSlNPTiggbWV0YSApLm9iamVjdCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGlzUm9vdE9iamVjdCApIHtcblxuXHRcdFx0XHR2YXIgZ2VvbWV0cmllcyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEuZ2VvbWV0cmllcyApO1xuXHRcdFx0XHR2YXIgbWF0ZXJpYWxzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS5tYXRlcmlhbHMgKTtcblx0XHRcdFx0dmFyIHRleHR1cmVzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS50ZXh0dXJlcyApO1xuXHRcdFx0XHR2YXIgaW1hZ2VzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS5pbWFnZXMgKTtcblxuXHRcdFx0XHRpZiAoIGdlb21ldHJpZXMubGVuZ3RoID4gMCApIG91dHB1dC5nZW9tZXRyaWVzID0gZ2VvbWV0cmllcztcblx0XHRcdFx0aWYgKCBtYXRlcmlhbHMubGVuZ3RoID4gMCApIG91dHB1dC5tYXRlcmlhbHMgPSBtYXRlcmlhbHM7XG5cdFx0XHRcdGlmICggdGV4dHVyZXMubGVuZ3RoID4gMCApIG91dHB1dC50ZXh0dXJlcyA9IHRleHR1cmVzO1xuXHRcdFx0XHRpZiAoIGltYWdlcy5sZW5ndGggPiAwICkgb3V0cHV0LmltYWdlcyA9IGltYWdlcztcblxuXHRcdFx0fVxuXG5cdFx0XHRvdXRwdXQub2JqZWN0ID0gb2JqZWN0O1xuXG5cdFx0XHRyZXR1cm4gb3V0cHV0O1xuXG5cdFx0XHQvLyBleHRyYWN0IGRhdGEgZnJvbSB0aGUgY2FjaGUgaGFzaFxuXHRcdFx0Ly8gcmVtb3ZlIG1ldGFkYXRhIG9uIGVhY2ggaXRlbVxuXHRcdFx0Ly8gYW5kIHJldHVybiBhcyBhcnJheVxuXHRcdFx0ZnVuY3Rpb24gZXh0cmFjdEZyb21DYWNoZSAoIGNhY2hlICkge1xuXG5cdFx0XHRcdHZhciB2YWx1ZXMgPSBbXTtcblx0XHRcdFx0Zm9yICggdmFyIGtleSBpbiBjYWNoZSApIHtcblxuXHRcdFx0XHRcdHZhciBkYXRhID0gY2FjaGVbIGtleSBdO1xuXHRcdFx0XHRcdGRlbGV0ZSBkYXRhLm1ldGFkYXRhO1xuXHRcdFx0XHRcdHZhbHVlcy5wdXNoKCBkYXRhICk7XG5cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXG5cdFx0XHR9XG5cblx0XHR9LFxuXG5cdFx0Y2xvbmU6IGZ1bmN0aW9uICggcmVjdXJzaXZlICkge1xuXG5cdFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzLCByZWN1cnNpdmUgKTtcblxuXHRcdH0sXG5cblx0XHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSwgcmVjdXJzaXZlICkge1xuXG5cdFx0XHRpZiAoIHJlY3Vyc2l2ZSA9PT0gdW5kZWZpbmVkICkgcmVjdXJzaXZlID0gdHJ1ZTtcblxuXHRcdFx0dGhpcy5uYW1lID0gc291cmNlLm5hbWU7XG5cblx0XHRcdHRoaXMudXAuY29weSggc291cmNlLnVwICk7XG5cblx0XHRcdHRoaXMucG9zaXRpb24uY29weSggc291cmNlLnBvc2l0aW9uICk7XG5cdFx0XHR0aGlzLnF1YXRlcm5pb24uY29weSggc291cmNlLnF1YXRlcm5pb24gKTtcblx0XHRcdHRoaXMuc2NhbGUuY29weSggc291cmNlLnNjYWxlICk7XG5cblx0XHRcdHRoaXMucm90YXRpb25BdXRvVXBkYXRlID0gc291cmNlLnJvdGF0aW9uQXV0b1VwZGF0ZTtcblxuXHRcdFx0dGhpcy5tYXRyaXguY29weSggc291cmNlLm1hdHJpeCApO1xuXHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5jb3B5KCBzb3VyY2UubWF0cml4V29ybGQgKTtcblxuXHRcdFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gc291cmNlLm1hdHJpeEF1dG9VcGRhdGU7XG5cdFx0XHR0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSBzb3VyY2UubWF0cml4V29ybGROZWVkc1VwZGF0ZTtcblxuXHRcdFx0dGhpcy52aXNpYmxlID0gc291cmNlLnZpc2libGU7XG5cblx0XHRcdHRoaXMuY2FzdFNoYWRvdyA9IHNvdXJjZS5jYXN0U2hhZG93O1xuXHRcdFx0dGhpcy5yZWNlaXZlU2hhZG93ID0gc291cmNlLnJlY2VpdmVTaGFkb3c7XG5cblx0XHRcdHRoaXMuZnJ1c3R1bUN1bGxlZCA9IHNvdXJjZS5mcnVzdHVtQ3VsbGVkO1xuXHRcdFx0dGhpcy5yZW5kZXJPcmRlciA9IHNvdXJjZS5yZW5kZXJPcmRlcjtcblxuXHRcdFx0dGhpcy51c2VyRGF0YSA9IEpTT04ucGFyc2UoIEpTT04uc3RyaW5naWZ5KCBzb3VyY2UudXNlckRhdGEgKSApO1xuXG5cdFx0XHRpZiAoIHJlY3Vyc2l2ZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBzb3VyY2UuY2hpbGRyZW4ubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIGNoaWxkID0gc291cmNlLmNoaWxkcmVuWyBpIF07XG5cdFx0XHRcdFx0dGhpcy5hZGQoIGNoaWxkLmNsb25lKCkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9XG5cblx0fTtcblxuXHRUSFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmFwcGx5KCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblxuXHRUSFJFRS5PYmplY3QzRElkQ291bnQgPSAwO1xuXG5cdC8vIEZpbGU6c3JjL2NvcmUvRmFjZTMuanNcblxuXHQvKipcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cblx0ICovXG5cblx0VEhSRUUuRmFjZTMgPSBmdW5jdGlvbiAoIGEsIGIsIGMsIG5vcm1hbCwgY29sb3IsIG1hdGVyaWFsSW5kZXggKSB7XG5cblx0XHR0aGlzLmEgPSBhO1xuXHRcdHRoaXMuYiA9IGI7XG5cdFx0dGhpcy5jID0gYztcblxuXHRcdHRoaXMubm9ybWFsID0gbm9ybWFsIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yMyA/IG5vcm1hbCA6IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0dGhpcy52ZXJ0ZXhOb3JtYWxzID0gQXJyYXkuaXNBcnJheSggbm9ybWFsICkgPyBub3JtYWwgOiBbXTtcblxuXHRcdHRoaXMuY29sb3IgPSBjb2xvciBpbnN0YW5jZW9mIFRIUkVFLkNvbG9yID8gY29sb3IgOiBuZXcgVEhSRUUuQ29sb3IoKTtcblx0XHR0aGlzLnZlcnRleENvbG9ycyA9IEFycmF5LmlzQXJyYXkoIGNvbG9yICkgPyBjb2xvciA6IFtdO1xuXG5cdFx0dGhpcy5tYXRlcmlhbEluZGV4ID0gbWF0ZXJpYWxJbmRleCAhPT0gdW5kZWZpbmVkID8gbWF0ZXJpYWxJbmRleCA6IDA7XG5cblx0fTtcblxuXHRUSFJFRS5GYWNlMy5wcm90b3R5cGUgPSB7XG5cblx0XHRjb25zdHJ1Y3RvcjogVEhSRUUuRmFjZTMsXG5cblx0XHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cblx0XHR9LFxuXG5cdFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cblx0XHRcdHRoaXMuYSA9IHNvdXJjZS5hO1xuXHRcdFx0dGhpcy5iID0gc291cmNlLmI7XG5cdFx0XHR0aGlzLmMgPSBzb3VyY2UuYztcblxuXHRcdFx0dGhpcy5ub3JtYWwuY29weSggc291cmNlLm5vcm1hbCApO1xuXHRcdFx0dGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcblxuXHRcdFx0dGhpcy5tYXRlcmlhbEluZGV4ID0gc291cmNlLm1hdGVyaWFsSW5kZXg7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBzb3VyY2UudmVydGV4Tm9ybWFscy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHR0aGlzLnZlcnRleE5vcm1hbHNbIGkgXSA9IHNvdXJjZS52ZXJ0ZXhOb3JtYWxzWyBpIF0uY2xvbmUoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gc291cmNlLnZlcnRleENvbG9ycy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHR0aGlzLnZlcnRleENvbG9yc1sgaSBdID0gc291cmNlLnZlcnRleENvbG9yc1sgaSBdLmNsb25lKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9XG5cblx0fTtcblxuXHQvLyBGaWxlOnNyYy9jb3JlL0ZhY2U0LmpzXG5cblx0LyoqXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqL1xuXG5cdFRIUkVFLkZhY2U0ID0gZnVuY3Rpb24gKCBhLCBiLCBjLCBkLCBub3JtYWwsIGNvbG9yLCBtYXRlcmlhbEluZGV4ICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuRmFjZTQgaGFzIGJlZW4gcmVtb3ZlZC4gQSBUSFJFRS5GYWNlMyB3aWxsIGJlIGNyZWF0ZWQgaW5zdGVhZC4nICk7XG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgYywgbm9ybWFsLCBjb2xvciwgbWF0ZXJpYWxJbmRleCApO1xuXG5cdH07XG5cblx0Ly8gRmlsZTpzcmMvY29yZS9CdWZmZXJBdHRyaWJ1dGUuanNcblxuXHQvKipcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICovXG5cblx0VEhSRUUuQnVmZmVyQXR0cmlidXRlID0gZnVuY3Rpb24gKCBhcnJheSwgaXRlbVNpemUgKSB7XG5cblx0XHR0aGlzLnV1aWQgPSBUSFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpO1xuXG5cdFx0dGhpcy5hcnJheSA9IGFycmF5O1xuXHRcdHRoaXMuaXRlbVNpemUgPSBpdGVtU2l6ZTtcblxuXHRcdHRoaXMuZHluYW1pYyA9IGZhbHNlO1xuXHRcdHRoaXMudXBkYXRlUmFuZ2UgPSB7IG9mZnNldDogMCwgY291bnQ6IC0gMSB9O1xuXG5cdFx0dGhpcy52ZXJzaW9uID0gMDtcblxuXHR9O1xuXG5cdFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgPSB7XG5cblx0XHRjb25zdHJ1Y3RvcjogVEhSRUUuQnVmZmVyQXR0cmlidXRlLFxuXG5cdFx0Z2V0IGxlbmd0aCgpIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyQXR0cmlidXRlOiAubGVuZ3RoIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgLmNvdW50LicgKTtcblx0XHRcdHJldHVybiB0aGlzLmFycmF5Lmxlbmd0aDtcblxuXHRcdH0sXG5cblx0XHRnZXQgY291bnQoKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLmFycmF5Lmxlbmd0aCAvIHRoaXMuaXRlbVNpemU7XG5cblx0XHR9LFxuXG5cdFx0c2V0IG5lZWRzVXBkYXRlKCB2YWx1ZSApIHtcblxuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gdHJ1ZSApIHRoaXMudmVyc2lvbiArKztcblxuXHRcdH0sXG5cblx0XHRzZXREeW5hbWljOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHR0aGlzLmR5bmFtaWMgPSB2YWx1ZTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cblx0XHRcdHRoaXMuYXJyYXkgPSBuZXcgc291cmNlLmFycmF5LmNvbnN0cnVjdG9yKCBzb3VyY2UuYXJyYXkgKTtcblx0XHRcdHRoaXMuaXRlbVNpemUgPSBzb3VyY2UuaXRlbVNpemU7XG5cblx0XHRcdHRoaXMuZHluYW1pYyA9IHNvdXJjZS5keW5hbWljO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRjb3B5QXQ6IGZ1bmN0aW9uICggaW5kZXgxLCBhdHRyaWJ1dGUsIGluZGV4MiApIHtcblxuXHRcdFx0aW5kZXgxICo9IHRoaXMuaXRlbVNpemU7XG5cdFx0XHRpbmRleDIgKj0gYXR0cmlidXRlLml0ZW1TaXplO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLml0ZW1TaXplOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR0aGlzLmFycmF5WyBpbmRleDEgKyBpIF0gPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4MiArIGkgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRjb3B5QXJyYXk6IGZ1bmN0aW9uICggYXJyYXkgKSB7XG5cblx0XHRcdHRoaXMuYXJyYXkuc2V0KCBhcnJheSApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRjb3B5Q29sb3JzQXJyYXk6IGZ1bmN0aW9uICggY29sb3JzICkge1xuXG5cdFx0XHR2YXIgYXJyYXkgPSB0aGlzLmFycmF5LCBvZmZzZXQgPSAwO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBjb2xvcnMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgY29sb3IgPSBjb2xvcnNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGNvbG9yID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJBdHRyaWJ1dGUuY29weUNvbG9yc0FycmF5KCk6IGNvbG9yIGlzIHVuZGVmaW5lZCcsIGkgKTtcblx0XHRcdFx0XHRjb2xvciA9IG5ldyBUSFJFRS5Db2xvcigpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSBjb2xvci5yO1xuXHRcdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSBjb2xvci5nO1xuXHRcdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSBjb2xvci5iO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGNvcHlJbmRpY2VzQXJyYXk6IGZ1bmN0aW9uICggaW5kaWNlcyApIHtcblxuXHRcdFx0dmFyIGFycmF5ID0gdGhpcy5hcnJheSwgb2Zmc2V0ID0gMDtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gaW5kaWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBpbmRleCA9IGluZGljZXNbIGkgXTtcblxuXHRcdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSBpbmRleC5hO1xuXHRcdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSBpbmRleC5iO1xuXHRcdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSBpbmRleC5jO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGNvcHlWZWN0b3Iyc0FycmF5OiBmdW5jdGlvbiAoIHZlY3RvcnMgKSB7XG5cblx0XHRcdHZhciBhcnJheSA9IHRoaXMuYXJyYXksIG9mZnNldCA9IDA7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHZlY3RvcnMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgdmVjdG9yID0gdmVjdG9yc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggdmVjdG9yID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJBdHRyaWJ1dGUuY29weVZlY3RvcjJzQXJyYXkoKTogdmVjdG9yIGlzIHVuZGVmaW5lZCcsIGkgKTtcblx0XHRcdFx0XHR2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSB2ZWN0b3IueDtcblx0XHRcdFx0YXJyYXlbIG9mZnNldCArKyBdID0gdmVjdG9yLnk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0Y29weVZlY3RvcjNzQXJyYXk6IGZ1bmN0aW9uICggdmVjdG9ycyApIHtcblxuXHRcdFx0dmFyIGFycmF5ID0gdGhpcy5hcnJheSwgb2Zmc2V0ID0gMDtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdmVjdG9ycy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciB2ZWN0b3IgPSB2ZWN0b3JzWyBpIF07XG5cblx0XHRcdFx0aWYgKCB2ZWN0b3IgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckF0dHJpYnV0ZS5jb3B5VmVjdG9yM3NBcnJheSgpOiB2ZWN0b3IgaXMgdW5kZWZpbmVkJywgaSApO1xuXHRcdFx0XHRcdHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGFycmF5WyBvZmZzZXQgKysgXSA9IHZlY3Rvci54O1xuXHRcdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSB2ZWN0b3IueTtcblx0XHRcdFx0YXJyYXlbIG9mZnNldCArKyBdID0gdmVjdG9yLno7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0Y29weVZlY3RvcjRzQXJyYXk6IGZ1bmN0aW9uICggdmVjdG9ycyApIHtcblxuXHRcdFx0dmFyIGFycmF5ID0gdGhpcy5hcnJheSwgb2Zmc2V0ID0gMDtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdmVjdG9ycy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciB2ZWN0b3IgPSB2ZWN0b3JzWyBpIF07XG5cblx0XHRcdFx0aWYgKCB2ZWN0b3IgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckF0dHJpYnV0ZS5jb3B5VmVjdG9yNHNBcnJheSgpOiB2ZWN0b3IgaXMgdW5kZWZpbmVkJywgaSApO1xuXHRcdFx0XHRcdHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3I0KCk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGFycmF5WyBvZmZzZXQgKysgXSA9IHZlY3Rvci54O1xuXHRcdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSB2ZWN0b3IueTtcblx0XHRcdFx0YXJyYXlbIG9mZnNldCArKyBdID0gdmVjdG9yLno7XG5cdFx0XHRcdGFycmF5WyBvZmZzZXQgKysgXSA9IHZlY3Rvci53O1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSwgb2Zmc2V0ICkge1xuXG5cdFx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuXHRcdFx0dGhpcy5hcnJheS5zZXQoIHZhbHVlLCBvZmZzZXQgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0Z2V0WDogZnVuY3Rpb24gKCBpbmRleCApIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSBdO1xuXG5cdFx0fSxcblxuXHRcdHNldFg6IGZ1bmN0aW9uICggaW5kZXgsIHggKSB7XG5cblx0XHRcdHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSBdID0geDtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0Z2V0WTogZnVuY3Rpb24gKCBpbmRleCApIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDEgXTtcblxuXHRcdH0sXG5cblx0XHRzZXRZOiBmdW5jdGlvbiAoIGluZGV4LCB5ICkge1xuXG5cdFx0XHR0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAxIF0gPSB5O1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRnZXRaOiBmdW5jdGlvbiAoIGluZGV4ICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMiBdO1xuXG5cdFx0fSxcblxuXHRcdHNldFo6IGZ1bmN0aW9uICggaW5kZXgsIHogKSB7XG5cblx0XHRcdHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDIgXSA9IHo7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGdldFc6IGZ1bmN0aW9uICggaW5kZXggKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAzIF07XG5cblx0XHR9LFxuXG5cdFx0c2V0VzogZnVuY3Rpb24gKCBpbmRleCwgdyApIHtcblxuXHRcdFx0dGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMyBdID0gdztcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0c2V0WFk6IGZ1bmN0aW9uICggaW5kZXgsIHgsIHkgKSB7XG5cblx0XHRcdGluZGV4ICo9IHRoaXMuaXRlbVNpemU7XG5cblx0XHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMCBdID0geDtcblx0XHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMSBdID0geTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0c2V0WFlaOiBmdW5jdGlvbiAoIGluZGV4LCB4LCB5LCB6ICkge1xuXG5cdFx0XHRpbmRleCAqPSB0aGlzLml0ZW1TaXplO1xuXG5cdFx0XHR0aGlzLmFycmF5WyBpbmRleCArIDAgXSA9IHg7XG5cdFx0XHR0aGlzLmFycmF5WyBpbmRleCArIDEgXSA9IHk7XG5cdFx0XHR0aGlzLmFycmF5WyBpbmRleCArIDIgXSA9IHo7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHNldFhZWlc6IGZ1bmN0aW9uICggaW5kZXgsIHgsIHksIHosIHcgKSB7XG5cblx0XHRcdGluZGV4ICo9IHRoaXMuaXRlbVNpemU7XG5cblx0XHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMCBdID0geDtcblx0XHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMSBdID0geTtcblx0XHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMiBdID0gejtcblx0XHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMyBdID0gdztcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0Ly9cblxuXHRUSFJFRS5JbnQ4QXR0cmlidXRlID0gZnVuY3Rpb24gKCBhcnJheSwgaXRlbVNpemUgKSB7XG5cblx0XHRyZXR1cm4gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IEludDhBcnJheSggYXJyYXkgKSwgaXRlbVNpemUgKTtcblxuXHR9O1xuXG5cdFRIUkVFLlVpbnQ4QXR0cmlidXRlID0gZnVuY3Rpb24gKCBhcnJheSwgaXRlbVNpemUgKSB7XG5cblx0XHRyZXR1cm4gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IFVpbnQ4QXJyYXkoIGFycmF5ICksIGl0ZW1TaXplICk7XG5cblx0fTtcblxuXHRUSFJFRS5VaW50OENsYW1wZWRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoIGFycmF5LCBpdGVtU2l6ZSApIHtcblxuXHRcdHJldHVybiBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgVWludDhDbGFtcGVkQXJyYXkoIGFycmF5ICksIGl0ZW1TaXplICk7XG5cblx0fTtcblxuXHRUSFJFRS5JbnQxNkF0dHJpYnV0ZSA9IGZ1bmN0aW9uICggYXJyYXksIGl0ZW1TaXplICkge1xuXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBJbnQxNkFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSApO1xuXG5cdH07XG5cblx0VEhSRUUuVWludDE2QXR0cmlidXRlID0gZnVuY3Rpb24gKCBhcnJheSwgaXRlbVNpemUgKSB7XG5cblx0XHRyZXR1cm4gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IFVpbnQxNkFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSApO1xuXG5cdH07XG5cblx0VEhSRUUuSW50MzJBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoIGFycmF5LCBpdGVtU2l6ZSApIHtcblxuXHRcdHJldHVybiBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgSW50MzJBcnJheSggYXJyYXkgKSwgaXRlbVNpemUgKTtcblxuXHR9O1xuXG5cdFRIUkVFLlVpbnQzMkF0dHJpYnV0ZSA9IGZ1bmN0aW9uICggYXJyYXksIGl0ZW1TaXplICkge1xuXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBVaW50MzJBcnJheSggYXJyYXkgKSwgaXRlbVNpemUgKTtcblxuXHR9O1xuXG5cdFRIUkVFLkZsb2F0MzJBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoIGFycmF5LCBpdGVtU2l6ZSApIHtcblxuXHRcdHJldHVybiBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSApO1xuXG5cdH07XG5cblx0VEhSRUUuRmxvYXQ2NEF0dHJpYnV0ZSA9IGZ1bmN0aW9uICggYXJyYXksIGl0ZW1TaXplICkge1xuXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBGbG9hdDY0QXJyYXkoIGFycmF5ICksIGl0ZW1TaXplICk7XG5cblx0fTtcblxuXG5cdC8vIERlcHJlY2F0ZWRcblxuXHRUSFJFRS5EeW5hbWljQnVmZmVyQXR0cmlidXRlID0gZnVuY3Rpb24gKCBhcnJheSwgaXRlbVNpemUgKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5EeW5hbWljQnVmZmVyQXR0cmlidXRlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCkuc2V0RHluYW1pYyggdHJ1ZSApIGluc3RlYWQuJyApO1xuXHRcdHJldHVybiBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKS5zZXREeW5hbWljKCB0cnVlICk7XG5cblx0fTtcblxuXHQvLyBGaWxlOnNyYy9jb3JlL0luc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZS5qc1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIGJlbmFhZGFtcyAvIGh0dHBzOi8vdHdpdHRlci5jb20vYmVuX2FfYWRhbXNcblx0ICovXG5cblx0VEhSRUUuSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlID0gZnVuY3Rpb24gKCBhcnJheSwgaXRlbVNpemUsIG1lc2hQZXJBdHRyaWJ1dGUgKSB7XG5cblx0XHRUSFJFRS5CdWZmZXJBdHRyaWJ1dGUuY2FsbCggdGhpcywgYXJyYXksIGl0ZW1TaXplICk7XG5cblx0XHR0aGlzLm1lc2hQZXJBdHRyaWJ1dGUgPSBtZXNoUGVyQXR0cmlidXRlIHx8IDE7XG5cblx0fTtcblxuXHRUSFJFRS5JbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSApO1xuXHRUSFJFRS5JbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlO1xuXG5cdFRIUkVFLkluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xuXG5cdFx0VEhSRUUuQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5tZXNoUGVyQXR0cmlidXRlID0gc291cmNlLm1lc2hQZXJBdHRyaWJ1dGU7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdC8vIEZpbGU6c3JjL2NvcmUvSW50ZXJsZWF2ZWRCdWZmZXIuanNcblxuXHQvKipcblx0ICogQGF1dGhvciBiZW5hYWRhbXMgLyBodHRwczovL3R3aXR0ZXIuY29tL2Jlbl9hX2FkYW1zXG5cdCAqL1xuXG5cdFRIUkVFLkludGVybGVhdmVkQnVmZmVyID0gZnVuY3Rpb24gKCBhcnJheSwgc3RyaWRlICkge1xuXG5cdFx0dGhpcy51dWlkID0gVEhSRUUuTWF0aC5nZW5lcmF0ZVVVSUQoKTtcblxuXHRcdHRoaXMuYXJyYXkgPSBhcnJheTtcblx0XHR0aGlzLnN0cmlkZSA9IHN0cmlkZTtcblxuXHRcdHRoaXMuZHluYW1pYyA9IGZhbHNlO1xuXHRcdHRoaXMudXBkYXRlUmFuZ2UgPSB7IG9mZnNldDogMCwgY291bnQ6IC0gMSB9O1xuXG5cdFx0dGhpcy52ZXJzaW9uID0gMDtcblxuXHR9O1xuXG5cdFRIUkVFLkludGVybGVhdmVkQnVmZmVyLnByb3RvdHlwZSA9IHtcblxuXHRcdGNvbnN0cnVjdG9yOiBUSFJFRS5JbnRlcmxlYXZlZEJ1ZmZlcixcblxuXHRcdGdldCBsZW5ndGggKCkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5hcnJheS5sZW5ndGg7XG5cblx0XHR9LFxuXG5cdFx0Z2V0IGNvdW50ICgpIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuYXJyYXkubGVuZ3RoIC8gdGhpcy5zdHJpZGU7XG5cblx0XHR9LFxuXG5cdFx0c2V0IG5lZWRzVXBkYXRlKCB2YWx1ZSApIHtcblxuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gdHJ1ZSApIHRoaXMudmVyc2lvbiArKztcblxuXHRcdH0sXG5cblx0XHRzZXREeW5hbWljOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHR0aGlzLmR5bmFtaWMgPSB2YWx1ZTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cblx0XHRcdHRoaXMuYXJyYXkgPSBuZXcgc291cmNlLmFycmF5LmNvbnN0cnVjdG9yKCBzb3VyY2UuYXJyYXkgKTtcblx0XHRcdHRoaXMuc3RyaWRlID0gc291cmNlLnN0cmlkZTtcblx0XHRcdHRoaXMuZHluYW1pYyA9IHNvdXJjZS5keW5hbWljO1xuXG5cdFx0fSxcblxuXHRcdGNvcHlBdDogZnVuY3Rpb24gKCBpbmRleDEsIGF0dHJpYnV0ZSwgaW5kZXgyICkge1xuXG5cdFx0XHRpbmRleDEgKj0gdGhpcy5zdHJpZGU7XG5cdFx0XHRpbmRleDIgKj0gYXR0cmlidXRlLnN0cmlkZTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5zdHJpZGU7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHRoaXMuYXJyYXlbIGluZGV4MSArIGkgXSA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXgyICsgaSBdO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSwgb2Zmc2V0ICkge1xuXG5cdFx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuXHRcdFx0dGhpcy5hcnJheS5zZXQoIHZhbHVlLCBvZmZzZXQgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0Ly8gRmlsZTpzcmMvY29yZS9JbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlci5qc1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIGJlbmFhZGFtcyAvIGh0dHBzOi8vdHdpdHRlci5jb20vYmVuX2FfYWRhbXNcblx0ICovXG5cblx0VEhSRUUuSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIgPSBmdW5jdGlvbiAoIGFycmF5LCBzdHJpZGUsIG1lc2hQZXJBdHRyaWJ1dGUgKSB7XG5cblx0XHRUSFJFRS5JbnRlcmxlYXZlZEJ1ZmZlci5jYWxsKCB0aGlzLCBhcnJheSwgc3RyaWRlICk7XG5cblx0XHR0aGlzLm1lc2hQZXJBdHRyaWJ1dGUgPSBtZXNoUGVyQXR0cmlidXRlIHx8IDE7XG5cblx0fTtcblxuXHRUSFJFRS5JbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5JbnRlcmxlYXZlZEJ1ZmZlci5wcm90b3R5cGUgKTtcblx0VEhSRUUuSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXI7XG5cblx0VEhSRUUuSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuXHRcdFRIUkVFLkludGVybGVhdmVkQnVmZmVyLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5tZXNoUGVyQXR0cmlidXRlID0gc291cmNlLm1lc2hQZXJBdHRyaWJ1dGU7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdC8vIEZpbGU6c3JjL2NvcmUvSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUuanNcblxuXHQvKipcblx0ICogQGF1dGhvciBiZW5hYWRhbXMgLyBodHRwczovL3R3aXR0ZXIuY29tL2Jlbl9hX2FkYW1zXG5cdCAqL1xuXG5cdFRIUkVFLkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlID0gZnVuY3Rpb24gKCBpbnRlcmxlYXZlZEJ1ZmZlciwgaXRlbVNpemUsIG9mZnNldCApIHtcblxuXHRcdHRoaXMudXVpZCA9IFRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCk7XG5cblx0XHR0aGlzLmRhdGEgPSBpbnRlcmxlYXZlZEJ1ZmZlcjtcblx0XHR0aGlzLml0ZW1TaXplID0gaXRlbVNpemU7XG5cdFx0dGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG5cblx0fTtcblxuXG5cdFRIUkVFLkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSA9IHtcblxuXHRcdGNvbnN0cnVjdG9yOiBUSFJFRS5JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSxcblxuXHRcdGdldCBsZW5ndGgoKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckF0dHJpYnV0ZTogLmxlbmd0aCBoYXMgYmVlbiBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIC5jb3VudC4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5hcnJheS5sZW5ndGg7XG5cblx0XHR9LFxuXG5cdFx0Z2V0IGNvdW50KCkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5kYXRhLmFycmF5Lmxlbmd0aCAvIHRoaXMuZGF0YS5zdHJpZGU7XG5cblx0XHR9LFxuXG5cdFx0c2V0WDogZnVuY3Rpb24gKCBpbmRleCwgeCApIHtcblxuXHRcdFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCBdID0geDtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0c2V0WTogZnVuY3Rpb24gKCBpbmRleCwgeSApIHtcblxuXHRcdFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCArIDEgXSA9IHk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHNldFo6IGZ1bmN0aW9uICggaW5kZXgsIHogKSB7XG5cblx0XHRcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgKyAyIF0gPSB6O1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRzZXRXOiBmdW5jdGlvbiAoIGluZGV4LCB3ICkge1xuXG5cdFx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgMyBdID0gdztcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0Z2V0WDogZnVuY3Rpb24gKCBpbmRleCApIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgXTtcblxuXHRcdH0sXG5cblx0XHRnZXRZOiBmdW5jdGlvbiAoIGluZGV4ICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5kYXRhLmFycmF5WyBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCArIDEgXTtcblxuXHRcdH0sXG5cblx0XHRnZXRaOiBmdW5jdGlvbiAoIGluZGV4ICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5kYXRhLmFycmF5WyBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCArIDIgXTtcblxuXHRcdH0sXG5cblx0XHRnZXRXOiBmdW5jdGlvbiAoIGluZGV4ICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5kYXRhLmFycmF5WyBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCArIDMgXTtcblxuXHRcdH0sXG5cblx0XHRzZXRYWTogZnVuY3Rpb24gKCBpbmRleCwgeCwgeSApIHtcblxuXHRcdFx0aW5kZXggPSBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldDtcblxuXHRcdFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDAgXSA9IHg7XG5cdFx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMSBdID0geTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0c2V0WFlaOiBmdW5jdGlvbiAoIGluZGV4LCB4LCB5LCB6ICkge1xuXG5cdFx0XHRpbmRleCA9IGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0O1xuXG5cdFx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMCBdID0geDtcblx0XHRcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyAxIF0gPSB5O1xuXHRcdFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDIgXSA9IHo7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHNldFhZWlc6IGZ1bmN0aW9uICggaW5kZXgsIHgsIHksIHosIHcgKSB7XG5cblx0XHRcdGluZGV4ID0gaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQ7XG5cblx0XHRcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyAwIF0gPSB4O1xuXHRcdFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDEgXSA9IHk7XG5cdFx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMiBdID0gejtcblx0XHRcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyAzIF0gPSB3O1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH1cblxuXHR9O1xuXG5cdC8vIEZpbGU6c3JjL2NvcmUvR2VvbWV0cnkuanNcblxuXHQvKipcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICogQGF1dGhvciBraWxlIC8gaHR0cDovL2tpbGUuc3RyYXZhZ2FuemEub3JnL1xuXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuXHQgKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuXHQgKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXG5cdCAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cblx0ICovXG5cblx0VEhSRUUuR2VvbWV0cnkgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsICdpZCcsIHsgdmFsdWU6IFRIUkVFLkdlb21ldHJ5SWRDb3VudCArKyB9ICk7XG5cblx0XHR0aGlzLnV1aWQgPSBUSFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpO1xuXG5cdFx0dGhpcy5uYW1lID0gJyc7XG5cdFx0dGhpcy50eXBlID0gJ0dlb21ldHJ5JztcblxuXHRcdHRoaXMudmVydGljZXMgPSBbXTtcblx0XHR0aGlzLmNvbG9ycyA9IFtdO1xuXHRcdHRoaXMuZmFjZXMgPSBbXTtcblx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnMgPSBbIFtdIF07XG5cblx0XHR0aGlzLm1vcnBoVGFyZ2V0cyA9IFtdO1xuXHRcdHRoaXMubW9ycGhOb3JtYWxzID0gW107XG5cblx0XHR0aGlzLnNraW5XZWlnaHRzID0gW107XG5cdFx0dGhpcy5za2luSW5kaWNlcyA9IFtdO1xuXG5cdFx0dGhpcy5saW5lRGlzdGFuY2VzID0gW107XG5cblx0XHR0aGlzLmJvdW5kaW5nQm94ID0gbnVsbDtcblx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbnVsbDtcblxuXHRcdC8vIHVwZGF0ZSBmbGFnc1xuXG5cdFx0dGhpcy52ZXJ0aWNlc05lZWRVcGRhdGUgPSBmYWxzZTtcblx0XHR0aGlzLmVsZW1lbnRzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuXHRcdHRoaXMudXZzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuXHRcdHRoaXMubm9ybWFsc05lZWRVcGRhdGUgPSBmYWxzZTtcblx0XHR0aGlzLmNvbG9yc05lZWRVcGRhdGUgPSBmYWxzZTtcblx0XHR0aGlzLmxpbmVEaXN0YW5jZXNOZWVkVXBkYXRlID0gZmFsc2U7XG5cdFx0dGhpcy5ncm91cHNOZWVkVXBkYXRlID0gZmFsc2U7XG5cblx0fTtcblxuXHRUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgPSB7XG5cblx0XHRjb25zdHJ1Y3RvcjogVEhSRUUuR2VvbWV0cnksXG5cblx0XHRhcHBseU1hdHJpeDogZnVuY3Rpb24gKCBtYXRyaXggKSB7XG5cblx0XHRcdHZhciBub3JtYWxNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4MygpLmdldE5vcm1hbE1hdHJpeCggbWF0cml4ICk7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciB2ZXJ0ZXggPSB0aGlzLnZlcnRpY2VzWyBpIF07XG5cdFx0XHRcdHZlcnRleC5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBmYWNlID0gdGhpcy5mYWNlc1sgaSBdO1xuXHRcdFx0XHRmYWNlLm5vcm1hbC5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBmYWNlLnZlcnRleE5vcm1hbHMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cblx0XHRcdFx0XHRmYWNlLnZlcnRleE5vcm1hbHNbIGogXS5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHRoaXMuYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XG5cblx0XHRcdFx0dGhpcy5jb21wdXRlQm91bmRpbmdCb3goKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHRoaXMuYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0dGhpcy5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnZlcnRpY2VzTmVlZFVwZGF0ZSA9IHRydWU7XG5cdFx0XHR0aGlzLm5vcm1hbHNOZWVkVXBkYXRlID0gdHJ1ZTtcblxuXHRcdH0sXG5cblx0XHRyb3RhdGVYOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdC8vIHJvdGF0ZSBnZW9tZXRyeSBhcm91bmQgd29ybGQgeC1heGlzXG5cblx0XHRcdHZhciBtMTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIHJvdGF0ZVgoIGFuZ2xlICkge1xuXG5cdFx0XHRcdGlmICggbTEgPT09IHVuZGVmaW5lZCApIG0xID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuXHRcdFx0XHRtMS5tYWtlUm90YXRpb25YKCBhbmdsZSApO1xuXG5cdFx0XHRcdHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdH07XG5cblx0XHR9KCksXG5cblx0XHRyb3RhdGVZOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdC8vIHJvdGF0ZSBnZW9tZXRyeSBhcm91bmQgd29ybGQgeS1heGlzXG5cblx0XHRcdHZhciBtMTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIHJvdGF0ZVkoIGFuZ2xlICkge1xuXG5cdFx0XHRcdGlmICggbTEgPT09IHVuZGVmaW5lZCApIG0xID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuXHRcdFx0XHRtMS5tYWtlUm90YXRpb25ZKCBhbmdsZSApO1xuXG5cdFx0XHRcdHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdH07XG5cblx0XHR9KCksXG5cblx0XHRyb3RhdGVaOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdC8vIHJvdGF0ZSBnZW9tZXRyeSBhcm91bmQgd29ybGQgei1heGlzXG5cblx0XHRcdHZhciBtMTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIHJvdGF0ZVooIGFuZ2xlICkge1xuXG5cdFx0XHRcdGlmICggbTEgPT09IHVuZGVmaW5lZCApIG0xID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuXHRcdFx0XHRtMS5tYWtlUm90YXRpb25aKCBhbmdsZSApO1xuXG5cdFx0XHRcdHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdH07XG5cblx0XHR9KCksXG5cblx0XHR0cmFuc2xhdGU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Ly8gdHJhbnNsYXRlIGdlb21ldHJ5XG5cblx0XHRcdHZhciBtMTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIHRyYW5zbGF0ZSggeCwgeSwgeiApIHtcblxuXHRcdFx0XHRpZiAoIG0xID09PSB1bmRlZmluZWQgKSBtMSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cblx0XHRcdFx0bTEubWFrZVRyYW5zbGF0aW9uKCB4LCB5LCB6ICk7XG5cblx0XHRcdFx0dGhpcy5hcHBseU1hdHJpeCggbTEgKTtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdFx0fTtcblxuXHRcdH0oKSxcblxuXHRcdHNjYWxlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdC8vIHNjYWxlIGdlb21ldHJ5XG5cblx0XHRcdHZhciBtMTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIHNjYWxlKCB4LCB5LCB6ICkge1xuXG5cdFx0XHRcdGlmICggbTEgPT09IHVuZGVmaW5lZCApIG0xID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuXHRcdFx0XHRtMS5tYWtlU2NhbGUoIHgsIHksIHogKTtcblxuXHRcdFx0XHR0aGlzLmFwcGx5TWF0cml4KCBtMSApO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0XHR9O1xuXG5cdFx0fSgpLFxuXG5cdFx0bG9va0F0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciBvYmo7XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiBsb29rQXQoIHZlY3RvciApIHtcblxuXHRcdFx0XHRpZiAoIG9iaiA9PT0gdW5kZWZpbmVkICkgb2JqID0gbmV3IFRIUkVFLk9iamVjdDNEKCk7XG5cblx0XHRcdFx0b2JqLmxvb2tBdCggdmVjdG9yICk7XG5cblx0XHRcdFx0b2JqLnVwZGF0ZU1hdHJpeCgpO1xuXG5cdFx0XHRcdHRoaXMuYXBwbHlNYXRyaXgoIG9iai5tYXRyaXggKTtcblxuXHRcdFx0fTtcblxuXHRcdH0oKSxcblxuXHRcdGZyb21CdWZmZXJHZW9tZXRyeTogZnVuY3Rpb24gKCBnZW9tZXRyeSApIHtcblxuXHRcdFx0dmFyIHNjb3BlID0gdGhpcztcblxuXHRcdFx0dmFyIGluZGljZXMgPSBnZW9tZXRyeS5pbmRleCAhPT0gbnVsbCA/IGdlb21ldHJ5LmluZGV4LmFycmF5IDogdW5kZWZpbmVkO1xuXHRcdFx0dmFyIGF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xuXG5cdFx0XHR2YXIgdmVydGljZXMgPSBhdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xuXHRcdFx0dmFyIG5vcm1hbHMgPSBhdHRyaWJ1dGVzLm5vcm1hbCAhPT0gdW5kZWZpbmVkID8gYXR0cmlidXRlcy5ub3JtYWwuYXJyYXkgOiB1bmRlZmluZWQ7XG5cdFx0XHR2YXIgY29sb3JzID0gYXR0cmlidXRlcy5jb2xvciAhPT0gdW5kZWZpbmVkID8gYXR0cmlidXRlcy5jb2xvci5hcnJheSA6IHVuZGVmaW5lZDtcblx0XHRcdHZhciB1dnMgPSBhdHRyaWJ1dGVzLnV2ICE9PSB1bmRlZmluZWQgPyBhdHRyaWJ1dGVzLnV2LmFycmF5IDogdW5kZWZpbmVkO1xuXHRcdFx0dmFyIHV2czIgPSBhdHRyaWJ1dGVzLnV2MiAhPT0gdW5kZWZpbmVkID8gYXR0cmlidXRlcy51djIuYXJyYXkgOiB1bmRlZmluZWQ7XG5cblx0XHRcdGlmICggdXZzMiAhPT0gdW5kZWZpbmVkICkgdGhpcy5mYWNlVmVydGV4VXZzWyAxIF0gPSBbXTtcblxuXHRcdFx0dmFyIHRlbXBOb3JtYWxzID0gW107XG5cdFx0XHR2YXIgdGVtcFVWcyA9IFtdO1xuXHRcdFx0dmFyIHRlbXBVVnMyID0gW107XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgaiA9IDAsIGsgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoOyBpICs9IDMsIGogKz0gMiwgayArPSA0ICkge1xuXG5cdFx0XHRcdHNjb3BlLnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCB2ZXJ0aWNlc1sgaSBdLCB2ZXJ0aWNlc1sgaSArIDEgXSwgdmVydGljZXNbIGkgKyAyIF0gKSApO1xuXG5cdFx0XHRcdGlmICggbm9ybWFscyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0dGVtcE5vcm1hbHMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoIG5vcm1hbHNbIGkgXSwgbm9ybWFsc1sgaSArIDEgXSwgbm9ybWFsc1sgaSArIDIgXSApICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggY29sb3JzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRzY29wZS5jb2xvcnMucHVzaCggbmV3IFRIUkVFLkNvbG9yKCBjb2xvcnNbIGkgXSwgY29sb3JzWyBpICsgMSBdLCBjb2xvcnNbIGkgKyAyIF0gKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHV2cyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0dGVtcFVWcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggdXZzWyBqIF0sIHV2c1sgaiArIDEgXSApICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggdXZzMiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0dGVtcFVWczIucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoIHV2czJbIGogXSwgdXZzMlsgaiArIDEgXSApICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGFkZEZhY2UoIGEsIGIsIGMgKSB7XG5cblx0XHRcdFx0dmFyIHZlcnRleE5vcm1hbHMgPSBub3JtYWxzICE9PSB1bmRlZmluZWQgPyBbIHRlbXBOb3JtYWxzWyBhIF0uY2xvbmUoKSwgdGVtcE5vcm1hbHNbIGIgXS5jbG9uZSgpLCB0ZW1wTm9ybWFsc1sgYyBdLmNsb25lKCkgXSA6IFtdO1xuXHRcdFx0XHR2YXIgdmVydGV4Q29sb3JzID0gY29sb3JzICE9PSB1bmRlZmluZWQgPyBbIHNjb3BlLmNvbG9yc1sgYSBdLmNsb25lKCksIHNjb3BlLmNvbG9yc1sgYiBdLmNsb25lKCksIHNjb3BlLmNvbG9yc1sgYyBdLmNsb25lKCkgXSA6IFtdO1xuXG5cdFx0XHRcdHZhciBmYWNlID0gbmV3IFRIUkVFLkZhY2UzKCBhLCBiLCBjLCB2ZXJ0ZXhOb3JtYWxzLCB2ZXJ0ZXhDb2xvcnMgKTtcblxuXHRcdFx0XHRzY29wZS5mYWNlcy5wdXNoKCBmYWNlICk7XG5cblx0XHRcdFx0aWYgKCB1dnMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdHNjb3BlLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHRlbXBVVnNbIGEgXS5jbG9uZSgpLCB0ZW1wVVZzWyBiIF0uY2xvbmUoKSwgdGVtcFVWc1sgYyBdLmNsb25lKCkgXSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHV2czIgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdHNjb3BlLmZhY2VWZXJ0ZXhVdnNbIDEgXS5wdXNoKCBbIHRlbXBVVnMyWyBhIF0uY2xvbmUoKSwgdGVtcFVWczJbIGIgXS5jbG9uZSgpLCB0ZW1wVVZzMlsgYyBdLmNsb25lKCkgXSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fTtcblxuXHRcdFx0aWYgKCBpbmRpY2VzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0dmFyIGdyb3VwcyA9IGdlb21ldHJ5Lmdyb3VwcztcblxuXHRcdFx0XHRpZiAoIGdyb3Vwcy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0dmFyIGdyb3VwID0gZ3JvdXBzWyBpIF07XG5cblx0XHRcdFx0XHRcdHZhciBzdGFydCA9IGdyb3VwLnN0YXJ0O1xuXHRcdFx0XHRcdFx0dmFyIGNvdW50ID0gZ3JvdXAuY291bnQ7XG5cblx0XHRcdFx0XHRcdGZvciAoIHZhciBqID0gc3RhcnQsIGpsID0gc3RhcnQgKyBjb3VudDsgaiA8IGpsOyBqICs9IDMgKSB7XG5cblx0XHRcdFx0XHRcdFx0YWRkRmFjZSggaW5kaWNlc1sgaiBdLCBpbmRpY2VzWyBqICsgMSBdLCBpbmRpY2VzWyBqICsgMiBdICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgaW5kaWNlcy5sZW5ndGg7IGkgKz0gMyApIHtcblxuXHRcdFx0XHRcdFx0YWRkRmFjZSggaW5kaWNlc1sgaSBdLCBpbmRpY2VzWyBpICsgMSBdLCBpbmRpY2VzWyBpICsgMiBdICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aCAvIDM7IGkgKz0gMyApIHtcblxuXHRcdFx0XHRcdGFkZEZhY2UoIGksIGkgKyAxLCBpICsgMiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xuXG5cdFx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nQm94ICE9PSBudWxsICkge1xuXG5cdFx0XHRcdHRoaXMuYm91bmRpbmdCb3ggPSBnZW9tZXRyeS5ib3VuZGluZ0JveC5jbG9uZSgpO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlLmNsb25lKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0Y2VudGVyOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHRoaXMuY29tcHV0ZUJvdW5kaW5nQm94KCk7XG5cblx0XHRcdHZhciBvZmZzZXQgPSB0aGlzLmJvdW5kaW5nQm94LmNlbnRlcigpLm5lZ2F0ZSgpO1xuXG5cdFx0XHR0aGlzLnRyYW5zbGF0ZSggb2Zmc2V0LngsIG9mZnNldC55LCBvZmZzZXQueiApO1xuXG5cdFx0XHRyZXR1cm4gb2Zmc2V0O1xuXG5cdFx0fSxcblxuXHRcdG5vcm1hbGl6ZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR0aGlzLmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXG5cdFx0XHR2YXIgY2VudGVyID0gdGhpcy5ib3VuZGluZ1NwaGVyZS5jZW50ZXI7XG5cdFx0XHR2YXIgcmFkaXVzID0gdGhpcy5ib3VuZGluZ1NwaGVyZS5yYWRpdXM7XG5cblx0XHRcdHZhciBzID0gcmFkaXVzID09PSAwID8gMSA6IDEuMCAvIHJhZGl1cztcblxuXHRcdFx0dmFyIG1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cdFx0XHRtYXRyaXguc2V0KFxuXHRcdFx0XHRzLCAwLCAwLCAtIHMgKiBjZW50ZXIueCxcblx0XHRcdFx0MCwgcywgMCwgLSBzICogY2VudGVyLnksXG5cdFx0XHRcdDAsIDAsIHMsIC0gcyAqIGNlbnRlci56LFxuXHRcdFx0XHQwLCAwLCAwLCAxXG5cdFx0XHQpO1xuXG5cdFx0XHR0aGlzLmFwcGx5TWF0cml4KCBtYXRyaXggKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0Y29tcHV0ZUZhY2VOb3JtYWxzOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciBjYiA9IG5ldyBUSFJFRS5WZWN0b3IzKCksIGFiID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdFx0Zm9yICggdmFyIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cblx0XHRcdFx0dmFyIGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XG5cblx0XHRcdFx0dmFyIHZBID0gdGhpcy52ZXJ0aWNlc1sgZmFjZS5hIF07XG5cdFx0XHRcdHZhciB2QiA9IHRoaXMudmVydGljZXNbIGZhY2UuYiBdO1xuXHRcdFx0XHR2YXIgdkMgPSB0aGlzLnZlcnRpY2VzWyBmYWNlLmMgXTtcblxuXHRcdFx0XHRjYi5zdWJWZWN0b3JzKCB2QywgdkIgKTtcblx0XHRcdFx0YWIuc3ViVmVjdG9ycyggdkEsIHZCICk7XG5cdFx0XHRcdGNiLmNyb3NzKCBhYiApO1xuXG5cdFx0XHRcdGNiLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHRcdGZhY2Uubm9ybWFsLmNvcHkoIGNiICk7XG5cblx0XHRcdH1cblxuXHRcdH0sXG5cblx0XHRjb21wdXRlVmVydGV4Tm9ybWFsczogZnVuY3Rpb24gKCBhcmVhV2VpZ2h0ZWQgKSB7XG5cblx0XHRcdHZhciB2LCB2bCwgZiwgZmwsIGZhY2UsIHZlcnRpY2VzO1xuXG5cdFx0XHR2ZXJ0aWNlcyA9IG5ldyBBcnJheSggdGhpcy52ZXJ0aWNlcy5sZW5ndGggKTtcblxuXHRcdFx0Zm9yICggdiA9IDAsIHZsID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IHYgPCB2bDsgdiArKyApIHtcblxuXHRcdFx0XHR2ZXJ0aWNlc1sgdiBdID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGFyZWFXZWlnaHRlZCApIHtcblxuXHRcdFx0XHQvLyB2ZXJ0ZXggbm9ybWFscyB3ZWlnaHRlZCBieSB0cmlhbmdsZSBhcmVhc1xuXHRcdFx0XHQvLyBodHRwOi8vd3d3LmlxdWlsZXpsZXMub3JnL3d3dy9hcnRpY2xlcy9ub3JtYWxzL25vcm1hbHMuaHRtXG5cblx0XHRcdFx0dmFyIHZBLCB2QiwgdkM7XG5cdFx0XHRcdHZhciBjYiA9IG5ldyBUSFJFRS5WZWN0b3IzKCksIGFiID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdFx0XHRmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG5cdFx0XHRcdFx0ZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcblxuXHRcdFx0XHRcdHZBID0gdGhpcy52ZXJ0aWNlc1sgZmFjZS5hIF07XG5cdFx0XHRcdFx0dkIgPSB0aGlzLnZlcnRpY2VzWyBmYWNlLmIgXTtcblx0XHRcdFx0XHR2QyA9IHRoaXMudmVydGljZXNbIGZhY2UuYyBdO1xuXG5cdFx0XHRcdFx0Y2Iuc3ViVmVjdG9ycyggdkMsIHZCICk7XG5cdFx0XHRcdFx0YWIuc3ViVmVjdG9ycyggdkEsIHZCICk7XG5cdFx0XHRcdFx0Y2IuY3Jvc3MoIGFiICk7XG5cblx0XHRcdFx0XHR2ZXJ0aWNlc1sgZmFjZS5hIF0uYWRkKCBjYiApO1xuXHRcdFx0XHRcdHZlcnRpY2VzWyBmYWNlLmIgXS5hZGQoIGNiICk7XG5cdFx0XHRcdFx0dmVydGljZXNbIGZhY2UuYyBdLmFkZCggY2IgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Zm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcblxuXHRcdFx0XHRcdGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XG5cblx0XHRcdFx0XHR2ZXJ0aWNlc1sgZmFjZS5hIF0uYWRkKCBmYWNlLm5vcm1hbCApO1xuXHRcdFx0XHRcdHZlcnRpY2VzWyBmYWNlLmIgXS5hZGQoIGZhY2Uubm9ybWFsICk7XG5cdFx0XHRcdFx0dmVydGljZXNbIGZhY2UuYyBdLmFkZCggZmFjZS5ub3JtYWwgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggdiA9IDAsIHZsID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IHYgPCB2bDsgdiArKyApIHtcblxuXHRcdFx0XHR2ZXJ0aWNlc1sgdiBdLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cblx0XHRcdFx0ZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcblxuXHRcdFx0XHR2YXIgdmVydGV4Tm9ybWFscyA9IGZhY2UudmVydGV4Tm9ybWFscztcblxuXHRcdFx0XHRpZiAoIHZlcnRleE5vcm1hbHMubGVuZ3RoID09PSAzICkge1xuXG5cdFx0XHRcdFx0dmVydGV4Tm9ybWFsc1sgMCBdLmNvcHkoIHZlcnRpY2VzWyBmYWNlLmEgXSApO1xuXHRcdFx0XHRcdHZlcnRleE5vcm1hbHNbIDEgXS5jb3B5KCB2ZXJ0aWNlc1sgZmFjZS5iIF0gKTtcblx0XHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzWyAyIF0uY29weSggdmVydGljZXNbIGZhY2UuYyBdICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHZlcnRleE5vcm1hbHNbIDAgXSA9IHZlcnRpY2VzWyBmYWNlLmEgXS5jbG9uZSgpO1xuXHRcdFx0XHRcdHZlcnRleE5vcm1hbHNbIDEgXSA9IHZlcnRpY2VzWyBmYWNlLmIgXS5jbG9uZSgpO1xuXHRcdFx0XHRcdHZlcnRleE5vcm1hbHNbIDIgXSA9IHZlcnRpY2VzWyBmYWNlLmMgXS5jbG9uZSgpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fSxcblxuXHRcdGNvbXB1dGVNb3JwaE5vcm1hbHM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIGksIGlsLCBmLCBmbCwgZmFjZTtcblxuXHRcdFx0Ly8gc2F2ZSBvcmlnaW5hbCBub3JtYWxzXG5cdFx0XHQvLyAtIGNyZWF0ZSB0ZW1wIHZhcmlhYmxlcyBvbiBmaXJzdCBhY2Nlc3Ncblx0XHRcdC8vICAgb3RoZXJ3aXNlIGp1c3QgY29weSAoZm9yIGZhc3RlciByZXBlYXRlZCBjYWxscylcblxuXHRcdFx0Zm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcblxuXHRcdFx0XHRmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xuXG5cdFx0XHRcdGlmICggISBmYWNlLl9fb3JpZ2luYWxGYWNlTm9ybWFsICkge1xuXG5cdFx0XHRcdFx0ZmFjZS5fX29yaWdpbmFsRmFjZU5vcm1hbCA9IGZhY2Uubm9ybWFsLmNsb25lKCk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGZhY2UuX19vcmlnaW5hbEZhY2VOb3JtYWwuY29weSggZmFjZS5ub3JtYWwgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCAhIGZhY2UuX19vcmlnaW5hbFZlcnRleE5vcm1hbHMgKSBmYWNlLl9fb3JpZ2luYWxWZXJ0ZXhOb3JtYWxzID0gW107XG5cblx0XHRcdFx0Zm9yICggaSA9IDAsIGlsID0gZmFjZS52ZXJ0ZXhOb3JtYWxzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0aWYgKCAhIGZhY2UuX19vcmlnaW5hbFZlcnRleE5vcm1hbHNbIGkgXSApIHtcblxuXHRcdFx0XHRcdFx0ZmFjZS5fX29yaWdpbmFsVmVydGV4Tm9ybWFsc1sgaSBdID0gZmFjZS52ZXJ0ZXhOb3JtYWxzWyBpIF0uY2xvbmUoKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdGZhY2UuX19vcmlnaW5hbFZlcnRleE5vcm1hbHNbIGkgXS5jb3B5KCBmYWNlLnZlcnRleE5vcm1hbHNbIGkgXSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyB1c2UgdGVtcCBnZW9tZXRyeSB0byBjb21wdXRlIGZhY2UgYW5kIHZlcnRleCBub3JtYWxzIGZvciBlYWNoIG1vcnBoXG5cblx0XHRcdHZhciB0bXBHZW8gPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcblx0XHRcdHRtcEdlby5mYWNlcyA9IHRoaXMuZmFjZXM7XG5cblx0XHRcdGZvciAoIGkgPSAwLCBpbCA9IHRoaXMubW9ycGhUYXJnZXRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdC8vIGNyZWF0ZSBvbiBmaXJzdCBhY2Nlc3NcblxuXHRcdFx0XHRpZiAoICEgdGhpcy5tb3JwaE5vcm1hbHNbIGkgXSApIHtcblxuXHRcdFx0XHRcdHRoaXMubW9ycGhOb3JtYWxzWyBpIF0gPSB7fTtcblx0XHRcdFx0XHR0aGlzLm1vcnBoTm9ybWFsc1sgaSBdLmZhY2VOb3JtYWxzID0gW107XG5cdFx0XHRcdFx0dGhpcy5tb3JwaE5vcm1hbHNbIGkgXS52ZXJ0ZXhOb3JtYWxzID0gW107XG5cblx0XHRcdFx0XHR2YXIgZHN0Tm9ybWFsc0ZhY2UgPSB0aGlzLm1vcnBoTm9ybWFsc1sgaSBdLmZhY2VOb3JtYWxzO1xuXHRcdFx0XHRcdHZhciBkc3ROb3JtYWxzVmVydGV4ID0gdGhpcy5tb3JwaE5vcm1hbHNbIGkgXS52ZXJ0ZXhOb3JtYWxzO1xuXG5cdFx0XHRcdFx0dmFyIGZhY2VOb3JtYWwsIHZlcnRleE5vcm1hbHM7XG5cblx0XHRcdFx0XHRmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG5cdFx0XHRcdFx0XHRmYWNlTm9ybWFsID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHRcdFx0XHRcdHZlcnRleE5vcm1hbHMgPSB7IGE6IG5ldyBUSFJFRS5WZWN0b3IzKCksIGI6IG5ldyBUSFJFRS5WZWN0b3IzKCksIGM6IG5ldyBUSFJFRS5WZWN0b3IzKCkgfTtcblxuXHRcdFx0XHRcdFx0ZHN0Tm9ybWFsc0ZhY2UucHVzaCggZmFjZU5vcm1hbCApO1xuXHRcdFx0XHRcdFx0ZHN0Tm9ybWFsc1ZlcnRleC5wdXNoKCB2ZXJ0ZXhOb3JtYWxzICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBtb3JwaE5vcm1hbHMgPSB0aGlzLm1vcnBoTm9ybWFsc1sgaSBdO1xuXG5cdFx0XHRcdC8vIHNldCB2ZXJ0aWNlcyB0byBtb3JwaCB0YXJnZXRcblxuXHRcdFx0XHR0bXBHZW8udmVydGljZXMgPSB0aGlzLm1vcnBoVGFyZ2V0c1sgaSBdLnZlcnRpY2VzO1xuXG5cdFx0XHRcdC8vIGNvbXB1dGUgbW9ycGggbm9ybWFsc1xuXG5cdFx0XHRcdHRtcEdlby5jb21wdXRlRmFjZU5vcm1hbHMoKTtcblx0XHRcdFx0dG1wR2VvLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XG5cblx0XHRcdFx0Ly8gc3RvcmUgbW9ycGggbm9ybWFsc1xuXG5cdFx0XHRcdHZhciBmYWNlTm9ybWFsLCB2ZXJ0ZXhOb3JtYWxzO1xuXG5cdFx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cblx0XHRcdFx0XHRmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xuXG5cdFx0XHRcdFx0ZmFjZU5vcm1hbCA9IG1vcnBoTm9ybWFscy5mYWNlTm9ybWFsc1sgZiBdO1xuXHRcdFx0XHRcdHZlcnRleE5vcm1hbHMgPSBtb3JwaE5vcm1hbHMudmVydGV4Tm9ybWFsc1sgZiBdO1xuXG5cdFx0XHRcdFx0ZmFjZU5vcm1hbC5jb3B5KCBmYWNlLm5vcm1hbCApO1xuXG5cdFx0XHRcdFx0dmVydGV4Tm9ybWFscy5hLmNvcHkoIGZhY2UudmVydGV4Tm9ybWFsc1sgMCBdICk7XG5cdFx0XHRcdFx0dmVydGV4Tm9ybWFscy5iLmNvcHkoIGZhY2UudmVydGV4Tm9ybWFsc1sgMSBdICk7XG5cdFx0XHRcdFx0dmVydGV4Tm9ybWFscy5jLmNvcHkoIGZhY2UudmVydGV4Tm9ybWFsc1sgMiBdICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHJlc3RvcmUgb3JpZ2luYWwgbm9ybWFsc1xuXG5cdFx0XHRmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG5cdFx0XHRcdGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XG5cblx0XHRcdFx0ZmFjZS5ub3JtYWwgPSBmYWNlLl9fb3JpZ2luYWxGYWNlTm9ybWFsO1xuXHRcdFx0XHRmYWNlLnZlcnRleE5vcm1hbHMgPSBmYWNlLl9fb3JpZ2luYWxWZXJ0ZXhOb3JtYWxzO1xuXG5cdFx0XHR9XG5cblx0XHR9LFxuXG5cdFx0Y29tcHV0ZVRhbmdlbnRzOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkdlb21ldHJ5OiAuY29tcHV0ZVRhbmdlbnRzKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG5cblx0XHR9LFxuXG5cdFx0Y29tcHV0ZUxpbmVEaXN0YW5jZXM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIGQgPSAwO1xuXHRcdFx0dmFyIHZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlcztcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHZlcnRpY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdGlmICggaSA+IDAgKSB7XG5cblx0XHRcdFx0XHRkICs9IHZlcnRpY2VzWyBpIF0uZGlzdGFuY2VUbyggdmVydGljZXNbIGkgLSAxIF0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5saW5lRGlzdGFuY2VzWyBpIF0gPSBkO1xuXG5cdFx0XHR9XG5cblx0XHR9LFxuXG5cdFx0Y29tcHV0ZUJvdW5kaW5nQm94OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGlmICggdGhpcy5ib3VuZGluZ0JveCA9PT0gbnVsbCApIHtcblxuXHRcdFx0XHR0aGlzLmJvdW5kaW5nQm94ID0gbmV3IFRIUkVFLkJveDMoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmJvdW5kaW5nQm94LnNldEZyb21Qb2ludHMoIHRoaXMudmVydGljZXMgKTtcblxuXHRcdH0sXG5cblx0XHRjb21wdXRlQm91bmRpbmdTcGhlcmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0aWYgKCB0aGlzLmJvdW5kaW5nU3BoZXJlID09PSBudWxsICkge1xuXG5cdFx0XHRcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgVEhSRUUuU3BoZXJlKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5ib3VuZGluZ1NwaGVyZS5zZXRGcm9tUG9pbnRzKCB0aGlzLnZlcnRpY2VzICk7XG5cblx0XHR9LFxuXG5cdFx0bWVyZ2U6IGZ1bmN0aW9uICggZ2VvbWV0cnksIG1hdHJpeCwgbWF0ZXJpYWxJbmRleE9mZnNldCApIHtcblxuXHRcdFx0aWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5ID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuR2VvbWV0cnkubWVyZ2UoKTogZ2VvbWV0cnkgbm90IGFuIGluc3RhbmNlIG9mIFRIUkVFLkdlb21ldHJ5LicsIGdlb21ldHJ5ICk7XG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgbm9ybWFsTWF0cml4LFxuXHRcdFx0dmVydGV4T2Zmc2V0ID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGgsXG5cdFx0XHR2ZXJ0aWNlczEgPSB0aGlzLnZlcnRpY2VzLFxuXHRcdFx0dmVydGljZXMyID0gZ2VvbWV0cnkudmVydGljZXMsXG5cdFx0XHRmYWNlczEgPSB0aGlzLmZhY2VzLFxuXHRcdFx0ZmFjZXMyID0gZ2VvbWV0cnkuZmFjZXMsXG5cdFx0XHR1dnMxID0gdGhpcy5mYWNlVmVydGV4VXZzWyAwIF0sXG5cdFx0XHR1dnMyID0gZ2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgMCBdO1xuXG5cdFx0XHRpZiAoIG1hdGVyaWFsSW5kZXhPZmZzZXQgPT09IHVuZGVmaW5lZCApIG1hdGVyaWFsSW5kZXhPZmZzZXQgPSAwO1xuXG5cdFx0XHRpZiAoIG1hdHJpeCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdG5vcm1hbE1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXgzKCkuZ2V0Tm9ybWFsTWF0cml4KCBtYXRyaXggKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyB2ZXJ0aWNlc1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdmVydGljZXMyLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciB2ZXJ0ZXggPSB2ZXJ0aWNlczJbIGkgXTtcblxuXHRcdFx0XHR2YXIgdmVydGV4Q29weSA9IHZlcnRleC5jbG9uZSgpO1xuXG5cdFx0XHRcdGlmICggbWF0cml4ICE9PSB1bmRlZmluZWQgKSB2ZXJ0ZXhDb3B5LmFwcGx5TWF0cml4NCggbWF0cml4ICk7XG5cblx0XHRcdFx0dmVydGljZXMxLnB1c2goIHZlcnRleENvcHkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBmYWNlc1xuXG5cdFx0XHRmb3IgKCBpID0gMCwgaWwgPSBmYWNlczIubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGZhY2UgPSBmYWNlczJbIGkgXSwgZmFjZUNvcHksIG5vcm1hbCwgY29sb3IsXG5cdFx0XHRcdGZhY2VWZXJ0ZXhOb3JtYWxzID0gZmFjZS52ZXJ0ZXhOb3JtYWxzLFxuXHRcdFx0XHRmYWNlVmVydGV4Q29sb3JzID0gZmFjZS52ZXJ0ZXhDb2xvcnM7XG5cblx0XHRcdFx0ZmFjZUNvcHkgPSBuZXcgVEhSRUUuRmFjZTMoIGZhY2UuYSArIHZlcnRleE9mZnNldCwgZmFjZS5iICsgdmVydGV4T2Zmc2V0LCBmYWNlLmMgKyB2ZXJ0ZXhPZmZzZXQgKTtcblx0XHRcdFx0ZmFjZUNvcHkubm9ybWFsLmNvcHkoIGZhY2Uubm9ybWFsICk7XG5cblx0XHRcdFx0aWYgKCBub3JtYWxNYXRyaXggIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGZhY2VDb3B5Lm5vcm1hbC5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gZmFjZVZlcnRleE5vcm1hbHMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cblx0XHRcdFx0XHRub3JtYWwgPSBmYWNlVmVydGV4Tm9ybWFsc1sgaiBdLmNsb25lKCk7XG5cblx0XHRcdFx0XHRpZiAoIG5vcm1hbE1hdHJpeCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRub3JtYWwuYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGZhY2VDb3B5LnZlcnRleE5vcm1hbHMucHVzaCggbm9ybWFsICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZhY2VDb3B5LmNvbG9yLmNvcHkoIGZhY2UuY29sb3IgKTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gZmFjZVZlcnRleENvbG9ycy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHRcdGNvbG9yID0gZmFjZVZlcnRleENvbG9yc1sgaiBdO1xuXHRcdFx0XHRcdGZhY2VDb3B5LnZlcnRleENvbG9ycy5wdXNoKCBjb2xvci5jbG9uZSgpICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZhY2VDb3B5Lm1hdGVyaWFsSW5kZXggPSBmYWNlLm1hdGVyaWFsSW5kZXggKyBtYXRlcmlhbEluZGV4T2Zmc2V0O1xuXG5cdFx0XHRcdGZhY2VzMS5wdXNoKCBmYWNlQ29weSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHV2c1xuXG5cdFx0XHRmb3IgKCBpID0gMCwgaWwgPSB1dnMyLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciB1diA9IHV2czJbIGkgXSwgdXZDb3B5ID0gW107XG5cblx0XHRcdFx0aWYgKCB1diA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSB1di5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHRcdHV2Q29weS5wdXNoKCB1dlsgaiBdLmNsb25lKCkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dXZzMS5wdXNoKCB1dkNvcHkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSxcblxuXHRcdG1lcmdlTWVzaDogZnVuY3Rpb24gKCBtZXNoICkge1xuXG5cdFx0XHRpZiAoIG1lc2ggaW5zdGFuY2VvZiBUSFJFRS5NZXNoID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuR2VvbWV0cnkubWVyZ2VNZXNoKCk6IG1lc2ggbm90IGFuIGluc3RhbmNlIG9mIFRIUkVFLk1lc2guJywgbWVzaCApO1xuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdH1cblxuXHRcdFx0bWVzaC5tYXRyaXhBdXRvVXBkYXRlICYmIG1lc2gudXBkYXRlTWF0cml4KCk7XG5cblx0XHRcdHRoaXMubWVyZ2UoIG1lc2guZ2VvbWV0cnksIG1lc2gubWF0cml4ICk7XG5cblx0XHR9LFxuXG5cdFx0Lypcblx0XHQgKiBDaGVja3MgZm9yIGR1cGxpY2F0ZSB2ZXJ0aWNlcyB3aXRoIGhhc2htYXAuXG5cdFx0ICogRHVwbGljYXRlZCB2ZXJ0aWNlcyBhcmUgcmVtb3ZlZFxuXHRcdCAqIGFuZCBmYWNlcycgdmVydGljZXMgYXJlIHVwZGF0ZWQuXG5cdFx0ICovXG5cblx0XHRtZXJnZVZlcnRpY2VzOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciB2ZXJ0aWNlc01hcCA9IHt9OyAvLyBIYXNobWFwIGZvciBsb29raW5nIHVwIHZlcnRpY2VzIGJ5IHBvc2l0aW9uIGNvb3JkaW5hdGVzIChhbmQgbWFraW5nIHN1cmUgdGhleSBhcmUgdW5pcXVlKVxuXHRcdFx0dmFyIHVuaXF1ZSA9IFtdLCBjaGFuZ2VzID0gW107XG5cblx0XHRcdHZhciB2LCBrZXk7XG5cdFx0XHR2YXIgcHJlY2lzaW9uUG9pbnRzID0gNDsgLy8gbnVtYmVyIG9mIGRlY2ltYWwgcG9pbnRzLCBlLmcuIDQgZm9yIGVwc2lsb24gb2YgMC4wMDAxXG5cdFx0XHR2YXIgcHJlY2lzaW9uID0gTWF0aC5wb3coIDEwLCBwcmVjaXNpb25Qb2ludHMgKTtcblx0XHRcdHZhciBpLCBpbCwgZmFjZTtcblx0XHRcdHZhciBpbmRpY2VzLCBqLCBqbDtcblxuXHRcdFx0Zm9yICggaSA9IDAsIGlsID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHR2ID0gdGhpcy52ZXJ0aWNlc1sgaSBdO1xuXHRcdFx0XHRrZXkgPSBNYXRoLnJvdW5kKCB2LnggKiBwcmVjaXNpb24gKSArICdfJyArIE1hdGgucm91bmQoIHYueSAqIHByZWNpc2lvbiApICsgJ18nICsgTWF0aC5yb3VuZCggdi56ICogcHJlY2lzaW9uICk7XG5cblx0XHRcdFx0aWYgKCB2ZXJ0aWNlc01hcFsga2V5IF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdHZlcnRpY2VzTWFwWyBrZXkgXSA9IGk7XG5cdFx0XHRcdFx0dW5pcXVlLnB1c2goIHRoaXMudmVydGljZXNbIGkgXSApO1xuXHRcdFx0XHRcdGNoYW5nZXNbIGkgXSA9IHVuaXF1ZS5sZW5ndGggLSAxO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvL2NvbnNvbGUubG9nKCdEdXBsaWNhdGUgdmVydGV4IGZvdW5kLiAnLCBpLCAnIGNvdWxkIGJlIHVzaW5nICcsIHZlcnRpY2VzTWFwW2tleV0pO1xuXHRcdFx0XHRcdGNoYW5nZXNbIGkgXSA9IGNoYW5nZXNbIHZlcnRpY2VzTWFwWyBrZXkgXSBdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cblx0XHRcdC8vIGlmIGZhY2VzIGFyZSBjb21wbGV0ZWx5IGRlZ2VuZXJhdGUgYWZ0ZXIgbWVyZ2luZyB2ZXJ0aWNlcywgd2Vcblx0XHRcdC8vIGhhdmUgdG8gcmVtb3ZlIHRoZW0gZnJvbSB0aGUgZ2VvbWV0cnkuXG5cdFx0XHR2YXIgZmFjZUluZGljZXNUb1JlbW92ZSA9IFtdO1xuXG5cdFx0XHRmb3IgKCBpID0gMCwgaWwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdGZhY2UgPSB0aGlzLmZhY2VzWyBpIF07XG5cblx0XHRcdFx0ZmFjZS5hID0gY2hhbmdlc1sgZmFjZS5hIF07XG5cdFx0XHRcdGZhY2UuYiA9IGNoYW5nZXNbIGZhY2UuYiBdO1xuXHRcdFx0XHRmYWNlLmMgPSBjaGFuZ2VzWyBmYWNlLmMgXTtcblxuXHRcdFx0XHRpbmRpY2VzID0gWyBmYWNlLmEsIGZhY2UuYiwgZmFjZS5jIF07XG5cblx0XHRcdFx0dmFyIGR1cEluZGV4ID0gLSAxO1xuXG5cdFx0XHRcdC8vIGlmIGFueSBkdXBsaWNhdGUgdmVydGljZXMgYXJlIGZvdW5kIGluIGEgRmFjZTNcblx0XHRcdFx0Ly8gd2UgaGF2ZSB0byByZW1vdmUgdGhlIGZhY2UgYXMgbm90aGluZyBjYW4gYmUgc2F2ZWRcblx0XHRcdFx0Zm9yICggdmFyIG4gPSAwOyBuIDwgMzsgbiArKyApIHtcblxuXHRcdFx0XHRcdGlmICggaW5kaWNlc1sgbiBdID09PSBpbmRpY2VzWyAoIG4gKyAxICkgJSAzIF0gKSB7XG5cblx0XHRcdFx0XHRcdGR1cEluZGV4ID0gbjtcblx0XHRcdFx0XHRcdGZhY2VJbmRpY2VzVG9SZW1vdmUucHVzaCggaSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIGkgPSBmYWNlSW5kaWNlc1RvUmVtb3ZlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtLSApIHtcblxuXHRcdFx0XHR2YXIgaWR4ID0gZmFjZUluZGljZXNUb1JlbW92ZVsgaSBdO1xuXG5cdFx0XHRcdHRoaXMuZmFjZXMuc3BsaWNlKCBpZHgsIDEgKTtcblxuXHRcdFx0XHRmb3IgKCBqID0gMCwgamwgPSB0aGlzLmZhY2VWZXJ0ZXhVdnMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cblx0XHRcdFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIGogXS5zcGxpY2UoIGlkeCwgMSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBVc2UgdW5pcXVlIHNldCBvZiB2ZXJ0aWNlc1xuXG5cdFx0XHR2YXIgZGlmZiA9IHRoaXMudmVydGljZXMubGVuZ3RoIC0gdW5pcXVlLmxlbmd0aDtcblx0XHRcdHRoaXMudmVydGljZXMgPSB1bmlxdWU7XG5cdFx0XHRyZXR1cm4gZGlmZjtcblxuXHRcdH0sXG5cblx0XHRzb3J0RmFjZXNCeU1hdGVyaWFsSW5kZXg6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIGZhY2VzID0gdGhpcy5mYWNlcztcblx0XHRcdHZhciBsZW5ndGggPSBmYWNlcy5sZW5ndGg7XG5cblx0XHRcdC8vIHRhZyBmYWNlc1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0ZmFjZXNbIGkgXS5faWQgPSBpO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHNvcnQgZmFjZXNcblxuXHRcdFx0ZnVuY3Rpb24gbWF0ZXJpYWxJbmRleFNvcnQoIGEsIGIgKSB7XG5cblx0XHRcdFx0cmV0dXJuIGEubWF0ZXJpYWxJbmRleCAtIGIubWF0ZXJpYWxJbmRleDtcblxuXHRcdFx0fVxuXG5cdFx0XHRmYWNlcy5zb3J0KCBtYXRlcmlhbEluZGV4U29ydCApO1xuXG5cdFx0XHQvLyBzb3J0IHV2c1xuXG5cdFx0XHR2YXIgdXZzMSA9IHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdO1xuXHRcdFx0dmFyIHV2czIgPSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDEgXTtcblxuXHRcdFx0dmFyIG5ld1V2czEsIG5ld1V2czI7XG5cblx0XHRcdGlmICggdXZzMSAmJiB1dnMxLmxlbmd0aCA9PT0gbGVuZ3RoICkgbmV3VXZzMSA9IFtdO1xuXHRcdFx0aWYgKCB1dnMyICYmIHV2czIubGVuZ3RoID09PSBsZW5ndGggKSBuZXdVdnMyID0gW107XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgaWQgPSBmYWNlc1sgaSBdLl9pZDtcblxuXHRcdFx0XHRpZiAoIG5ld1V2czEgKSBuZXdVdnMxLnB1c2goIHV2czFbIGlkIF0gKTtcblx0XHRcdFx0aWYgKCBuZXdVdnMyICkgbmV3VXZzMi5wdXNoKCB1dnMyWyBpZCBdICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBuZXdVdnMxICkgdGhpcy5mYWNlVmVydGV4VXZzWyAwIF0gPSBuZXdVdnMxO1xuXHRcdFx0aWYgKCBuZXdVdnMyICkgdGhpcy5mYWNlVmVydGV4VXZzWyAxIF0gPSBuZXdVdnMyO1xuXG5cdFx0fSxcblxuXHRcdHRvSlNPTjogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgZGF0YSA9IHtcblx0XHRcdFx0bWV0YWRhdGE6IHtcblx0XHRcdFx0XHR2ZXJzaW9uOiA0LjQsXG5cdFx0XHRcdFx0dHlwZTogJ0dlb21ldHJ5Jyxcblx0XHRcdFx0XHRnZW5lcmF0b3I6ICdHZW9tZXRyeS50b0pTT04nXG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdC8vIHN0YW5kYXJkIEdlb21ldHJ5IHNlcmlhbGl6YXRpb25cblxuXHRcdFx0ZGF0YS51dWlkID0gdGhpcy51dWlkO1xuXHRcdFx0ZGF0YS50eXBlID0gdGhpcy50eXBlO1xuXHRcdFx0aWYgKCB0aGlzLm5hbWUgIT09ICcnICkgZGF0YS5uYW1lID0gdGhpcy5uYW1lO1xuXG5cdFx0XHRpZiAoIHRoaXMucGFyYW1ldGVycyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHZhciBwYXJhbWV0ZXJzID0gdGhpcy5wYXJhbWV0ZXJzO1xuXG5cdFx0XHRcdGZvciAoIHZhciBrZXkgaW4gcGFyYW1ldGVycyApIHtcblxuXHRcdFx0XHRcdGlmICggcGFyYW1ldGVyc1sga2V5IF0gIT09IHVuZGVmaW5lZCApIGRhdGFbIGtleSBdID0gcGFyYW1ldGVyc1sga2V5IF07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBkYXRhO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciB2ZXJ0aWNlcyA9IFtdO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgdmVydGV4ID0gdGhpcy52ZXJ0aWNlc1sgaSBdO1xuXHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIGZhY2VzID0gW107XG5cdFx0XHR2YXIgbm9ybWFscyA9IFtdO1xuXHRcdFx0dmFyIG5vcm1hbHNIYXNoID0ge307XG5cdFx0XHR2YXIgY29sb3JzID0gW107XG5cdFx0XHR2YXIgY29sb3JzSGFzaCA9IHt9O1xuXHRcdFx0dmFyIHV2cyA9IFtdO1xuXHRcdFx0dmFyIHV2c0hhc2ggPSB7fTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5mYWNlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGZhY2UgPSB0aGlzLmZhY2VzWyBpIF07XG5cblx0XHRcdFx0dmFyIGhhc01hdGVyaWFsID0gZmFsc2U7IC8vIGZhY2UubWF0ZXJpYWxJbmRleCAhPT0gdW5kZWZpbmVkO1xuXHRcdFx0XHR2YXIgaGFzRmFjZVV2ID0gZmFsc2U7IC8vIGRlcHJlY2F0ZWRcblx0XHRcdFx0dmFyIGhhc0ZhY2VWZXJ0ZXhVdiA9IHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdWyBpIF0gIT09IHVuZGVmaW5lZDtcblx0XHRcdFx0dmFyIGhhc0ZhY2VOb3JtYWwgPSBmYWNlLm5vcm1hbC5sZW5ndGgoKSA+IDA7XG5cdFx0XHRcdHZhciBoYXNGYWNlVmVydGV4Tm9ybWFsID0gZmFjZS52ZXJ0ZXhOb3JtYWxzLmxlbmd0aCA+IDA7XG5cdFx0XHRcdHZhciBoYXNGYWNlQ29sb3IgPSBmYWNlLmNvbG9yLnIgIT09IDEgfHwgZmFjZS5jb2xvci5nICE9PSAxIHx8IGZhY2UuY29sb3IuYiAhPT0gMTtcblx0XHRcdFx0dmFyIGhhc0ZhY2VWZXJ0ZXhDb2xvciA9IGZhY2UudmVydGV4Q29sb3JzLmxlbmd0aCA+IDA7XG5cblx0XHRcdFx0dmFyIGZhY2VUeXBlID0gMDtcblxuXHRcdFx0XHRmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDAsIDAgKTtcblx0XHRcdFx0ZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCAxLCBoYXNNYXRlcmlhbCApO1xuXHRcdFx0XHRmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDIsIGhhc0ZhY2VVdiApO1xuXHRcdFx0XHRmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDMsIGhhc0ZhY2VWZXJ0ZXhVdiApO1xuXHRcdFx0XHRmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDQsIGhhc0ZhY2VOb3JtYWwgKTtcblx0XHRcdFx0ZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCA1LCBoYXNGYWNlVmVydGV4Tm9ybWFsICk7XG5cdFx0XHRcdGZhY2VUeXBlID0gc2V0Qml0KCBmYWNlVHlwZSwgNiwgaGFzRmFjZUNvbG9yICk7XG5cdFx0XHRcdGZhY2VUeXBlID0gc2V0Qml0KCBmYWNlVHlwZSwgNywgaGFzRmFjZVZlcnRleENvbG9yICk7XG5cblx0XHRcdFx0ZmFjZXMucHVzaCggZmFjZVR5cGUgKTtcblx0XHRcdFx0ZmFjZXMucHVzaCggZmFjZS5hLCBmYWNlLmIsIGZhY2UuYyApO1xuXG5cdFx0XHRcdGlmICggaGFzRmFjZVZlcnRleFV2ICkge1xuXG5cdFx0XHRcdFx0dmFyIGZhY2VWZXJ0ZXhVdnMgPSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXVsgaSBdO1xuXG5cdFx0XHRcdFx0ZmFjZXMucHVzaChcblx0XHRcdFx0XHRcdGdldFV2SW5kZXgoIGZhY2VWZXJ0ZXhVdnNbIDAgXSApLFxuXHRcdFx0XHRcdFx0Z2V0VXZJbmRleCggZmFjZVZlcnRleFV2c1sgMSBdICksXG5cdFx0XHRcdFx0XHRnZXRVdkluZGV4KCBmYWNlVmVydGV4VXZzWyAyIF0gKVxuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggaGFzRmFjZU5vcm1hbCApIHtcblxuXHRcdFx0XHRcdGZhY2VzLnB1c2goIGdldE5vcm1hbEluZGV4KCBmYWNlLm5vcm1hbCApICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggaGFzRmFjZVZlcnRleE5vcm1hbCApIHtcblxuXHRcdFx0XHRcdHZhciB2ZXJ0ZXhOb3JtYWxzID0gZmFjZS52ZXJ0ZXhOb3JtYWxzO1xuXG5cdFx0XHRcdFx0ZmFjZXMucHVzaChcblx0XHRcdFx0XHRcdGdldE5vcm1hbEluZGV4KCB2ZXJ0ZXhOb3JtYWxzWyAwIF0gKSxcblx0XHRcdFx0XHRcdGdldE5vcm1hbEluZGV4KCB2ZXJ0ZXhOb3JtYWxzWyAxIF0gKSxcblx0XHRcdFx0XHRcdGdldE5vcm1hbEluZGV4KCB2ZXJ0ZXhOb3JtYWxzWyAyIF0gKVxuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggaGFzRmFjZUNvbG9yICkge1xuXG5cdFx0XHRcdFx0ZmFjZXMucHVzaCggZ2V0Q29sb3JJbmRleCggZmFjZS5jb2xvciApICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggaGFzRmFjZVZlcnRleENvbG9yICkge1xuXG5cdFx0XHRcdFx0dmFyIHZlcnRleENvbG9ycyA9IGZhY2UudmVydGV4Q29sb3JzO1xuXG5cdFx0XHRcdFx0ZmFjZXMucHVzaChcblx0XHRcdFx0XHRcdGdldENvbG9ySW5kZXgoIHZlcnRleENvbG9yc1sgMCBdICksXG5cdFx0XHRcdFx0XHRnZXRDb2xvckluZGV4KCB2ZXJ0ZXhDb2xvcnNbIDEgXSApLFxuXHRcdFx0XHRcdFx0Z2V0Q29sb3JJbmRleCggdmVydGV4Q29sb3JzWyAyIF0gKVxuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIHNldEJpdCggdmFsdWUsIHBvc2l0aW9uLCBlbmFibGVkICkge1xuXG5cdFx0XHRcdHJldHVybiBlbmFibGVkID8gdmFsdWUgfCAoIDEgPDwgcG9zaXRpb24gKSA6IHZhbHVlICYgKCB+ICggMSA8PCBwb3NpdGlvbiApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gZ2V0Tm9ybWFsSW5kZXgoIG5vcm1hbCApIHtcblxuXHRcdFx0XHR2YXIgaGFzaCA9IG5vcm1hbC54LnRvU3RyaW5nKCkgKyBub3JtYWwueS50b1N0cmluZygpICsgbm9ybWFsLnoudG9TdHJpbmcoKTtcblxuXHRcdFx0XHRpZiAoIG5vcm1hbHNIYXNoWyBoYXNoIF0gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdHJldHVybiBub3JtYWxzSGFzaFsgaGFzaCBdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRub3JtYWxzSGFzaFsgaGFzaCBdID0gbm9ybWFscy5sZW5ndGggLyAzO1xuXHRcdFx0XHRub3JtYWxzLnB1c2goIG5vcm1hbC54LCBub3JtYWwueSwgbm9ybWFsLnogKTtcblxuXHRcdFx0XHRyZXR1cm4gbm9ybWFsc0hhc2hbIGhhc2ggXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBnZXRDb2xvckluZGV4KCBjb2xvciApIHtcblxuXHRcdFx0XHR2YXIgaGFzaCA9IGNvbG9yLnIudG9TdHJpbmcoKSArIGNvbG9yLmcudG9TdHJpbmcoKSArIGNvbG9yLmIudG9TdHJpbmcoKTtcblxuXHRcdFx0XHRpZiAoIGNvbG9yc0hhc2hbIGhhc2ggXSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0cmV0dXJuIGNvbG9yc0hhc2hbIGhhc2ggXTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29sb3JzSGFzaFsgaGFzaCBdID0gY29sb3JzLmxlbmd0aDtcblx0XHRcdFx0Y29sb3JzLnB1c2goIGNvbG9yLmdldEhleCgpICk7XG5cblx0XHRcdFx0cmV0dXJuIGNvbG9yc0hhc2hbIGhhc2ggXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBnZXRVdkluZGV4KCB1diApIHtcblxuXHRcdFx0XHR2YXIgaGFzaCA9IHV2LngudG9TdHJpbmcoKSArIHV2LnkudG9TdHJpbmcoKTtcblxuXHRcdFx0XHRpZiAoIHV2c0hhc2hbIGhhc2ggXSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0cmV0dXJuIHV2c0hhc2hbIGhhc2ggXTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dXZzSGFzaFsgaGFzaCBdID0gdXZzLmxlbmd0aCAvIDI7XG5cdFx0XHRcdHV2cy5wdXNoKCB1di54LCB1di55ICk7XG5cblx0XHRcdFx0cmV0dXJuIHV2c0hhc2hbIGhhc2ggXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRkYXRhLmRhdGEgPSB7fTtcblxuXHRcdFx0ZGF0YS5kYXRhLnZlcnRpY2VzID0gdmVydGljZXM7XG5cdFx0XHRkYXRhLmRhdGEubm9ybWFscyA9IG5vcm1hbHM7XG5cdFx0XHRpZiAoIGNvbG9ycy5sZW5ndGggPiAwICkgZGF0YS5kYXRhLmNvbG9ycyA9IGNvbG9ycztcblx0XHRcdGlmICggdXZzLmxlbmd0aCA+IDAgKSBkYXRhLmRhdGEudXZzID0gWyB1dnMgXTsgLy8gdGVtcG9yYWwgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuXHRcdFx0ZGF0YS5kYXRhLmZhY2VzID0gZmFjZXM7XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXG5cdFx0fSxcblxuXHRcdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuXHRcdH0sXG5cblx0XHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuXHRcdFx0dGhpcy52ZXJ0aWNlcyA9IFtdO1xuXHRcdFx0dGhpcy5mYWNlcyA9IFtdO1xuXHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzID0gWyBbXSBdO1xuXG5cdFx0XHR2YXIgdmVydGljZXMgPSBzb3VyY2UudmVydGljZXM7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSB2ZXJ0aWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHR0aGlzLnZlcnRpY2VzLnB1c2goIHZlcnRpY2VzWyBpIF0uY2xvbmUoKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBmYWNlcyA9IHNvdXJjZS5mYWNlcztcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGZhY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdHRoaXMuZmFjZXMucHVzaCggZmFjZXNbIGkgXS5jbG9uZSgpICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHNvdXJjZS5mYWNlVmVydGV4VXZzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBmYWNlVmVydGV4VXZzID0gc291cmNlLmZhY2VWZXJ0ZXhVdnNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIHRoaXMuZmFjZVZlcnRleFV2c1sgaSBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIGkgXSA9IFtdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gZmFjZVZlcnRleFV2cy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHRcdHZhciB1dnMgPSBmYWNlVmVydGV4VXZzWyBqIF0sIHV2c0NvcHkgPSBbXTtcblxuXHRcdFx0XHRcdGZvciAoIHZhciBrID0gMCwga2wgPSB1dnMubGVuZ3RoOyBrIDwga2w7IGsgKysgKSB7XG5cblx0XHRcdFx0XHRcdHZhciB1diA9IHV2c1sgayBdO1xuXG5cdFx0XHRcdFx0XHR1dnNDb3B5LnB1c2goIHV2LmNsb25lKCkgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgaSBdLnB1c2goIHV2c0NvcHkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0ZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc3Bvc2UnIH0gKTtcblxuXHRcdH1cblxuXHR9O1xuXG5cdFRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYXBwbHkoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xuXG5cdFRIUkVFLkdlb21ldHJ5SWRDb3VudCA9IDA7XG5cblx0Ly8gRmlsZTpzcmMvY29yZS9EaXJlY3RHZW9tZXRyeS5qc1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuXHQgKi9cblxuXHRUSFJFRS5EaXJlY3RHZW9tZXRyeSA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ2lkJywgeyB2YWx1ZTogVEhSRUUuR2VvbWV0cnlJZENvdW50ICsrIH0gKTtcblxuXHRcdHRoaXMudXVpZCA9IFRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCk7XG5cblx0XHR0aGlzLm5hbWUgPSAnJztcblx0XHR0aGlzLnR5cGUgPSAnRGlyZWN0R2VvbWV0cnknO1xuXG5cdFx0dGhpcy5pbmRpY2VzID0gW107XG5cdFx0dGhpcy52ZXJ0aWNlcyA9IFtdO1xuXHRcdHRoaXMubm9ybWFscyA9IFtdO1xuXHRcdHRoaXMuY29sb3JzID0gW107XG5cdFx0dGhpcy51dnMgPSBbXTtcblx0XHR0aGlzLnV2czIgPSBbXTtcblxuXHRcdHRoaXMuZ3JvdXBzID0gW107XG5cblx0XHR0aGlzLm1vcnBoVGFyZ2V0cyA9IHt9O1xuXG5cdFx0dGhpcy5za2luV2VpZ2h0cyA9IFtdO1xuXHRcdHRoaXMuc2tpbkluZGljZXMgPSBbXTtcblxuXHRcdC8vIHRoaXMubGluZURpc3RhbmNlcyA9IFtdO1xuXG5cdFx0dGhpcy5ib3VuZGluZ0JveCA9IG51bGw7XG5cdFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG51bGw7XG5cblx0XHQvLyB1cGRhdGUgZmxhZ3NcblxuXHRcdHRoaXMudmVydGljZXNOZWVkVXBkYXRlID0gZmFsc2U7XG5cdFx0dGhpcy5ub3JtYWxzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuXHRcdHRoaXMuY29sb3JzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuXHRcdHRoaXMudXZzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuXHRcdHRoaXMuZ3JvdXBzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuXG5cdH07XG5cblx0VEhSRUUuRGlyZWN0R2VvbWV0cnkucHJvdG90eXBlID0ge1xuXG5cdFx0Y29uc3RydWN0b3I6IFRIUkVFLkRpcmVjdEdlb21ldHJ5LFxuXG5cdFx0Y29tcHV0ZUJvdW5kaW5nQm94OiBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUuY29tcHV0ZUJvdW5kaW5nQm94LFxuXHRcdGNvbXB1dGVCb3VuZGluZ1NwaGVyZTogVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlLmNvbXB1dGVCb3VuZGluZ1NwaGVyZSxcblxuXHRcdGNvbXB1dGVGYWNlTm9ybWFsczogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5EaXJlY3RHZW9tZXRyeTogY29tcHV0ZUZhY2VOb3JtYWxzKCkgaXMgbm90IGEgbWV0aG9kIG9mIHRoaXMgdHlwZSBvZiBnZW9tZXRyeS4nICk7XG5cblx0XHR9LFxuXG5cdFx0Y29tcHV0ZVZlcnRleE5vcm1hbHM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuRGlyZWN0R2VvbWV0cnk6IGNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCkgaXMgbm90IGEgbWV0aG9kIG9mIHRoaXMgdHlwZSBvZiBnZW9tZXRyeS4nICk7XG5cblx0XHR9LFxuXG5cdFx0Y29tcHV0ZUdyb3VwczogZnVuY3Rpb24gKCBnZW9tZXRyeSApIHtcblxuXHRcdFx0dmFyIGdyb3VwO1xuXHRcdFx0dmFyIGdyb3VwcyA9IFtdO1xuXHRcdFx0dmFyIG1hdGVyaWFsSW5kZXg7XG5cblx0XHRcdHZhciBmYWNlcyA9IGdlb21ldHJ5LmZhY2VzO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBmYWNlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGZhY2UgPSBmYWNlc1sgaSBdO1xuXG5cdFx0XHRcdC8vIG1hdGVyaWFsc1xuXG5cdFx0XHRcdGlmICggZmFjZS5tYXRlcmlhbEluZGV4ICE9PSBtYXRlcmlhbEluZGV4ICkge1xuXG5cdFx0XHRcdFx0bWF0ZXJpYWxJbmRleCA9IGZhY2UubWF0ZXJpYWxJbmRleDtcblxuXHRcdFx0XHRcdGlmICggZ3JvdXAgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0Z3JvdXAuY291bnQgPSAoIGkgKiAzICkgLSBncm91cC5zdGFydDtcblx0XHRcdFx0XHRcdGdyb3Vwcy5wdXNoKCBncm91cCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Z3JvdXAgPSB7XG5cdFx0XHRcdFx0XHRzdGFydDogaSAqIDMsXG5cdFx0XHRcdFx0XHRtYXRlcmlhbEluZGV4OiBtYXRlcmlhbEluZGV4XG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBncm91cCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGdyb3VwLmNvdW50ID0gKCBpICogMyApIC0gZ3JvdXAuc3RhcnQ7XG5cdFx0XHRcdGdyb3Vwcy5wdXNoKCBncm91cCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuZ3JvdXBzID0gZ3JvdXBzO1xuXG5cdFx0fSxcblxuXHRcdGZyb21HZW9tZXRyeTogZnVuY3Rpb24gKCBnZW9tZXRyeSApIHtcblxuXHRcdFx0dmFyIGZhY2VzID0gZ2VvbWV0cnkuZmFjZXM7XG5cdFx0XHR2YXIgdmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcblx0XHRcdHZhciBmYWNlVmVydGV4VXZzID0gZ2VvbWV0cnkuZmFjZVZlcnRleFV2cztcblxuXHRcdFx0dmFyIGhhc0ZhY2VWZXJ0ZXhVdiA9IGZhY2VWZXJ0ZXhVdnNbIDAgXSAmJiBmYWNlVmVydGV4VXZzWyAwIF0ubGVuZ3RoID4gMDtcblx0XHRcdHZhciBoYXNGYWNlVmVydGV4VXYyID0gZmFjZVZlcnRleFV2c1sgMSBdICYmIGZhY2VWZXJ0ZXhVdnNbIDEgXS5sZW5ndGggPiAwO1xuXG5cdFx0XHQvLyBtb3JwaHNcblxuXHRcdFx0dmFyIG1vcnBoVGFyZ2V0cyA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cztcblx0XHRcdHZhciBtb3JwaFRhcmdldHNMZW5ndGggPSBtb3JwaFRhcmdldHMubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIG1vcnBoVGFyZ2V0c0xlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0dmFyIG1vcnBoVGFyZ2V0c1Bvc2l0aW9uID0gW107XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbW9ycGhUYXJnZXRzTGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdFx0bW9ycGhUYXJnZXRzUG9zaXRpb25bIGkgXSA9IFtdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLm1vcnBoVGFyZ2V0cy5wb3NpdGlvbiA9IG1vcnBoVGFyZ2V0c1Bvc2l0aW9uO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBtb3JwaE5vcm1hbHMgPSBnZW9tZXRyeS5tb3JwaE5vcm1hbHM7XG5cdFx0XHR2YXIgbW9ycGhOb3JtYWxzTGVuZ3RoID0gbW9ycGhOb3JtYWxzLmxlbmd0aDtcblxuXHRcdFx0aWYgKCBtb3JwaE5vcm1hbHNMZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdHZhciBtb3JwaFRhcmdldHNOb3JtYWwgPSBbXTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBtb3JwaE5vcm1hbHNMZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRtb3JwaFRhcmdldHNOb3JtYWxbIGkgXSA9IFtdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLm1vcnBoVGFyZ2V0cy5ub3JtYWwgPSBtb3JwaFRhcmdldHNOb3JtYWw7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gc2tpbnNcblxuXHRcdFx0dmFyIHNraW5JbmRpY2VzID0gZ2VvbWV0cnkuc2tpbkluZGljZXM7XG5cdFx0XHR2YXIgc2tpbldlaWdodHMgPSBnZW9tZXRyeS5za2luV2VpZ2h0cztcblxuXHRcdFx0dmFyIGhhc1NraW5JbmRpY2VzID0gc2tpbkluZGljZXMubGVuZ3RoID09PSB2ZXJ0aWNlcy5sZW5ndGg7XG5cdFx0XHR2YXIgaGFzU2tpbldlaWdodHMgPSBza2luV2VpZ2h0cy5sZW5ndGggPT09IHZlcnRpY2VzLmxlbmd0aDtcblxuXHRcdFx0Ly9cblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZmFjZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBmYWNlID0gZmFjZXNbIGkgXTtcblxuXHRcdFx0XHR0aGlzLnZlcnRpY2VzLnB1c2goIHZlcnRpY2VzWyBmYWNlLmEgXSwgdmVydGljZXNbIGZhY2UuYiBdLCB2ZXJ0aWNlc1sgZmFjZS5jIF0gKTtcblxuXHRcdFx0XHR2YXIgdmVydGV4Tm9ybWFscyA9IGZhY2UudmVydGV4Tm9ybWFscztcblxuXHRcdFx0XHRpZiAoIHZlcnRleE5vcm1hbHMubGVuZ3RoID09PSAzICkge1xuXG5cdFx0XHRcdFx0dGhpcy5ub3JtYWxzLnB1c2goIHZlcnRleE5vcm1hbHNbIDAgXSwgdmVydGV4Tm9ybWFsc1sgMSBdLCB2ZXJ0ZXhOb3JtYWxzWyAyIF0gKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dmFyIG5vcm1hbCA9IGZhY2Uubm9ybWFsO1xuXG5cdFx0XHRcdFx0dGhpcy5ub3JtYWxzLnB1c2goIG5vcm1hbCwgbm9ybWFsLCBub3JtYWwgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIHZlcnRleENvbG9ycyA9IGZhY2UudmVydGV4Q29sb3JzO1xuXG5cdFx0XHRcdGlmICggdmVydGV4Q29sb3JzLmxlbmd0aCA9PT0gMyApIHtcblxuXHRcdFx0XHRcdHRoaXMuY29sb3JzLnB1c2goIHZlcnRleENvbG9yc1sgMCBdLCB2ZXJ0ZXhDb2xvcnNbIDEgXSwgdmVydGV4Q29sb3JzWyAyIF0gKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dmFyIGNvbG9yID0gZmFjZS5jb2xvcjtcblxuXHRcdFx0XHRcdHRoaXMuY29sb3JzLnB1c2goIGNvbG9yLCBjb2xvciwgY29sb3IgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBoYXNGYWNlVmVydGV4VXYgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHR2YXIgdmVydGV4VXZzID0gZmFjZVZlcnRleFV2c1sgMCBdWyBpIF07XG5cblx0XHRcdFx0XHRpZiAoIHZlcnRleFV2cyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHR0aGlzLnV2cy5wdXNoKCB2ZXJ0ZXhVdnNbIDAgXSwgdmVydGV4VXZzWyAxIF0sIHZlcnRleFV2c1sgMiBdICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5EaXJlY3RHZW9tZXRyeS5mcm9tR2VvbWV0cnkoKTogVW5kZWZpbmVkIHZlcnRleFV2ICcsIGkgKTtcblxuXHRcdFx0XHRcdFx0dGhpcy51dnMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoKSwgbmV3IFRIUkVFLlZlY3RvcjIoKSwgbmV3IFRIUkVFLlZlY3RvcjIoKSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGhhc0ZhY2VWZXJ0ZXhVdjIgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHR2YXIgdmVydGV4VXZzID0gZmFjZVZlcnRleFV2c1sgMSBdWyBpIF07XG5cblx0XHRcdFx0XHRpZiAoIHZlcnRleFV2cyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHR0aGlzLnV2czIucHVzaCggdmVydGV4VXZzWyAwIF0sIHZlcnRleFV2c1sgMSBdLCB2ZXJ0ZXhVdnNbIDIgXSApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuRGlyZWN0R2VvbWV0cnkuZnJvbUdlb21ldHJ5KCk6IFVuZGVmaW5lZCB2ZXJ0ZXhVdjIgJywgaSApO1xuXG5cdFx0XHRcdFx0XHR0aGlzLnV2czIucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoKSwgbmV3IFRIUkVFLlZlY3RvcjIoKSwgbmV3IFRIUkVFLlZlY3RvcjIoKSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBtb3JwaHNcblxuXHRcdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCBtb3JwaFRhcmdldHNMZW5ndGg7IGogKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgbW9ycGhUYXJnZXQgPSBtb3JwaFRhcmdldHNbIGogXS52ZXJ0aWNlcztcblxuXHRcdFx0XHRcdG1vcnBoVGFyZ2V0c1Bvc2l0aW9uWyBqIF0ucHVzaCggbW9ycGhUYXJnZXRbIGZhY2UuYSBdLCBtb3JwaFRhcmdldFsgZmFjZS5iIF0sIG1vcnBoVGFyZ2V0WyBmYWNlLmMgXSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCBtb3JwaE5vcm1hbHNMZW5ndGg7IGogKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgbW9ycGhOb3JtYWwgPSBtb3JwaE5vcm1hbHNbIGogXS52ZXJ0ZXhOb3JtYWxzWyBpIF07XG5cblx0XHRcdFx0XHRtb3JwaFRhcmdldHNOb3JtYWxbIGogXS5wdXNoKCBtb3JwaE5vcm1hbC5hLCBtb3JwaE5vcm1hbC5iLCBtb3JwaE5vcm1hbC5jICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHNraW5zXG5cblx0XHRcdFx0aWYgKCBoYXNTa2luSW5kaWNlcyApIHtcblxuXHRcdFx0XHRcdHRoaXMuc2tpbkluZGljZXMucHVzaCggc2tpbkluZGljZXNbIGZhY2UuYSBdLCBza2luSW5kaWNlc1sgZmFjZS5iIF0sIHNraW5JbmRpY2VzWyBmYWNlLmMgXSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGhhc1NraW5XZWlnaHRzICkge1xuXG5cdFx0XHRcdFx0dGhpcy5za2luV2VpZ2h0cy5wdXNoKCBza2luV2VpZ2h0c1sgZmFjZS5hIF0sIHNraW5XZWlnaHRzWyBmYWNlLmIgXSwgc2tpbldlaWdodHNbIGZhY2UuYyBdICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuY29tcHV0ZUdyb3VwcyggZ2VvbWV0cnkgKTtcblxuXHRcdFx0dGhpcy52ZXJ0aWNlc05lZWRVcGRhdGUgPSBnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGU7XG5cdFx0XHR0aGlzLm5vcm1hbHNOZWVkVXBkYXRlID0gZ2VvbWV0cnkubm9ybWFsc05lZWRVcGRhdGU7XG5cdFx0XHR0aGlzLmNvbG9yc05lZWRVcGRhdGUgPSBnZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlO1xuXHRcdFx0dGhpcy51dnNOZWVkVXBkYXRlID0gZ2VvbWV0cnkudXZzTmVlZFVwZGF0ZTtcblx0XHRcdHRoaXMuZ3JvdXBzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5Lmdyb3Vwc05lZWRVcGRhdGU7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdkaXNwb3NlJyB9ICk7XG5cblx0XHR9XG5cblx0fTtcblxuXHRUSFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmFwcGx5KCBUSFJFRS5EaXJlY3RHZW9tZXRyeS5wcm90b3R5cGUgKTtcblxuXHQvLyBGaWxlOnNyYy9jb3JlL0J1ZmZlckdlb21ldHJ5LmpzXG5cblx0LyoqXG5cdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqL1xuXG5cdFRIUkVFLkJ1ZmZlckdlb21ldHJ5ID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnaWQnLCB7IHZhbHVlOiBUSFJFRS5HZW9tZXRyeUlkQ291bnQgKysgfSApO1xuXG5cdFx0dGhpcy51dWlkID0gVEhSRUUuTWF0aC5nZW5lcmF0ZVVVSUQoKTtcblxuXHRcdHRoaXMubmFtZSA9ICcnO1xuXHRcdHRoaXMudHlwZSA9ICdCdWZmZXJHZW9tZXRyeSc7XG5cblx0XHR0aGlzLmluZGV4ID0gbnVsbDtcblx0XHR0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcblxuXHRcdHRoaXMubW9ycGhBdHRyaWJ1dGVzID0ge307XG5cblx0XHR0aGlzLmdyb3VwcyA9IFtdO1xuXG5cdFx0dGhpcy5ib3VuZGluZ0JveCA9IG51bGw7XG5cdFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG51bGw7XG5cblx0XHR0aGlzLmRyYXdSYW5nZSA9IHsgc3RhcnQ6IDAsIGNvdW50OiBJbmZpbml0eSB9O1xuXG5cdH07XG5cblx0VEhSRUUuQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0ge1xuXG5cdFx0Y29uc3RydWN0b3I6IFRIUkVFLkJ1ZmZlckdlb21ldHJ5LFxuXG5cdFx0YWRkSW5kZXg6IGZ1bmN0aW9uICggaW5kZXggKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5OiAuYWRkSW5kZXgoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5zZXRJbmRleCgpLicgKTtcblx0XHRcdHRoaXMuc2V0SW5kZXgoIGluZGV4ICk7XG5cblx0XHR9LFxuXG5cdFx0Z2V0SW5kZXg6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuaW5kZXg7XG5cblx0XHR9LFxuXG5cdFx0c2V0SW5kZXg6IGZ1bmN0aW9uICggaW5kZXggKSB7XG5cblx0XHRcdHRoaXMuaW5kZXggPSBpbmRleDtcblxuXHRcdH0sXG5cblx0XHRhZGRBdHRyaWJ1dGU6IGZ1bmN0aW9uICggbmFtZSwgYXR0cmlidXRlICkge1xuXG5cdFx0XHRpZiAoIGF0dHJpYnV0ZSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSA9PT0gZmFsc2UgJiYgYXR0cmlidXRlIGluc3RhbmNlb2YgVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5OiAuYWRkQXR0cmlidXRlKCkgbm93IGV4cGVjdHMgKCBuYW1lLCBhdHRyaWJ1dGUgKS4nICk7XG5cblx0XHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoIG5hbWUsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGFyZ3VtZW50c1sgMSBdLCBhcmd1bWVudHNbIDIgXSApICk7XG5cblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbmFtZSA9PT0gJ2luZGV4JyApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeS5hZGRBdHRyaWJ1dGU6IFVzZSAuc2V0SW5kZXgoKSBmb3IgaW5kZXggYXR0cmlidXRlLicgKTtcblx0XHRcdFx0dGhpcy5zZXRJbmRleCggYXR0cmlidXRlICk7XG5cblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuYXR0cmlidXRlc1sgbmFtZSBdID0gYXR0cmlidXRlO1xuXG5cdFx0fSxcblxuXHRcdGdldEF0dHJpYnV0ZTogZnVuY3Rpb24gKCBuYW1lICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzWyBuYW1lIF07XG5cblx0XHR9LFxuXG5cdFx0cmVtb3ZlQXR0cmlidXRlOiBmdW5jdGlvbiAoIG5hbWUgKSB7XG5cblx0XHRcdGRlbGV0ZSB0aGlzLmF0dHJpYnV0ZXNbIG5hbWUgXTtcblxuXHRcdH0sXG5cblx0XHRnZXQgZHJhd2NhbGxzKCkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5kcmF3Y2FsbHMgaGFzIGJlZW4gcmVuYW1lZCB0byAuZ3JvdXBzLicgKTtcblx0XHRcdHJldHVybiB0aGlzLmdyb3VwcztcblxuXHRcdH0sXG5cblx0XHRnZXQgb2Zmc2V0cygpIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5vZmZzZXRzIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmdyb3Vwcy4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5ncm91cHM7XG5cblx0XHR9LFxuXG5cdFx0YWRkRHJhd0NhbGw6IGZ1bmN0aW9uICggc3RhcnQsIGNvdW50LCBpbmRleE9mZnNldCApIHtcblxuXHRcdFx0aWYgKCBpbmRleE9mZnNldCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5OiAuYWRkRHJhd0NhbGwoKSBubyBsb25nZXIgc3VwcG9ydHMgaW5kZXhPZmZzZXQuJyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5OiAuYWRkRHJhd0NhbGwoKSBpcyBub3cgLmFkZEdyb3VwKCkuJyApO1xuXHRcdFx0dGhpcy5hZGRHcm91cCggc3RhcnQsIGNvdW50ICk7XG5cblx0XHR9LFxuXG5cdFx0Y2xlYXJEcmF3Q2FsbHM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5jbGVhckRyYXdDYWxscygpIGlzIG5vdyAuY2xlYXJHcm91cHMoKS4nICk7XG5cdFx0XHR0aGlzLmNsZWFyR3JvdXBzKCk7XG5cblx0XHR9LFxuXG5cdFx0YWRkR3JvdXA6IGZ1bmN0aW9uICggc3RhcnQsIGNvdW50LCBtYXRlcmlhbEluZGV4ICkge1xuXG5cdFx0XHR0aGlzLmdyb3Vwcy5wdXNoKCB7XG5cblx0XHRcdFx0c3RhcnQ6IHN0YXJ0LFxuXHRcdFx0XHRjb3VudDogY291bnQsXG5cdFx0XHRcdG1hdGVyaWFsSW5kZXg6IG1hdGVyaWFsSW5kZXggIT09IHVuZGVmaW5lZCA/IG1hdGVyaWFsSW5kZXggOiAwXG5cblx0XHRcdH0gKTtcblxuXHRcdH0sXG5cblx0XHRjbGVhckdyb3VwczogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR0aGlzLmdyb3VwcyA9IFtdO1xuXG5cdFx0fSxcblxuXHRcdHNldERyYXdSYW5nZTogZnVuY3Rpb24gKCBzdGFydCwgY291bnQgKSB7XG5cblx0XHRcdHRoaXMuZHJhd1JhbmdlLnN0YXJ0ID0gc3RhcnQ7XG5cdFx0XHR0aGlzLmRyYXdSYW5nZS5jb3VudCA9IGNvdW50O1xuXG5cdFx0fSxcblxuXHRcdGFwcGx5TWF0cml4OiBmdW5jdGlvbiAoIG1hdHJpeCApIHtcblxuXHRcdFx0dmFyIHBvc2l0aW9uID0gdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG5cdFx0XHRpZiAoIHBvc2l0aW9uICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0bWF0cml4LmFwcGx5VG9WZWN0b3IzQXJyYXkoIHBvc2l0aW9uLmFycmF5ICk7XG5cdFx0XHRcdHBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgbm9ybWFsID0gdGhpcy5hdHRyaWJ1dGVzLm5vcm1hbDtcblxuXHRcdFx0aWYgKCBub3JtYWwgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHR2YXIgbm9ybWFsTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDMoKS5nZXROb3JtYWxNYXRyaXgoIG1hdHJpeCApO1xuXG5cdFx0XHRcdG5vcm1hbE1hdHJpeC5hcHBseVRvVmVjdG9yM0FycmF5KCBub3JtYWwuYXJyYXkgKTtcblx0XHRcdFx0bm9ybWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHRoaXMuYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XG5cblx0XHRcdFx0dGhpcy5jb21wdXRlQm91bmRpbmdCb3goKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHRoaXMuYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0dGhpcy5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblxuXHRcdFx0fVxuXG5cdFx0fSxcblxuXHRcdHJvdGF0ZVg6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Ly8gcm90YXRlIGdlb21ldHJ5IGFyb3VuZCB3b3JsZCB4LWF4aXNcblxuXHRcdFx0dmFyIG0xO1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gcm90YXRlWCggYW5nbGUgKSB7XG5cblx0XHRcdFx0aWYgKCBtMSA9PT0gdW5kZWZpbmVkICkgbTEgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG5cdFx0XHRcdG0xLm1ha2VSb3RhdGlvblgoIGFuZ2xlICk7XG5cblx0XHRcdFx0dGhpcy5hcHBseU1hdHJpeCggbTEgKTtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdFx0fTtcblxuXHRcdH0oKSxcblxuXHRcdHJvdGF0ZVk6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Ly8gcm90YXRlIGdlb21ldHJ5IGFyb3VuZCB3b3JsZCB5LWF4aXNcblxuXHRcdFx0dmFyIG0xO1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gcm90YXRlWSggYW5nbGUgKSB7XG5cblx0XHRcdFx0aWYgKCBtMSA9PT0gdW5kZWZpbmVkICkgbTEgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG5cdFx0XHRcdG0xLm1ha2VSb3RhdGlvblkoIGFuZ2xlICk7XG5cblx0XHRcdFx0dGhpcy5hcHBseU1hdHJpeCggbTEgKTtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdFx0fTtcblxuXHRcdH0oKSxcblxuXHRcdHJvdGF0ZVo6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Ly8gcm90YXRlIGdlb21ldHJ5IGFyb3VuZCB3b3JsZCB6LWF4aXNcblxuXHRcdFx0dmFyIG0xO1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gcm90YXRlWiggYW5nbGUgKSB7XG5cblx0XHRcdFx0aWYgKCBtMSA9PT0gdW5kZWZpbmVkICkgbTEgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG5cdFx0XHRcdG0xLm1ha2VSb3RhdGlvblooIGFuZ2xlICk7XG5cblx0XHRcdFx0dGhpcy5hcHBseU1hdHJpeCggbTEgKTtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdFx0fTtcblxuXHRcdH0oKSxcblxuXHRcdHRyYW5zbGF0ZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHQvLyB0cmFuc2xhdGUgZ2VvbWV0cnlcblxuXHRcdFx0dmFyIG0xO1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gdHJhbnNsYXRlKCB4LCB5LCB6ICkge1xuXG5cdFx0XHRcdGlmICggbTEgPT09IHVuZGVmaW5lZCApIG0xID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuXHRcdFx0XHRtMS5tYWtlVHJhbnNsYXRpb24oIHgsIHksIHogKTtcblxuXHRcdFx0XHR0aGlzLmFwcGx5TWF0cml4KCBtMSApO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0XHR9O1xuXG5cdFx0fSgpLFxuXG5cdFx0c2NhbGU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Ly8gc2NhbGUgZ2VvbWV0cnlcblxuXHRcdFx0dmFyIG0xO1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gc2NhbGUoIHgsIHksIHogKSB7XG5cblx0XHRcdFx0aWYgKCBtMSA9PT0gdW5kZWZpbmVkICkgbTEgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG5cdFx0XHRcdG0xLm1ha2VTY2FsZSggeCwgeSwgeiApO1xuXG5cdFx0XHRcdHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdH07XG5cblx0XHR9KCksXG5cblx0XHRsb29rQXQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIG9iajtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIGxvb2tBdCggdmVjdG9yICkge1xuXG5cdFx0XHRcdGlmICggb2JqID09PSB1bmRlZmluZWQgKSBvYmogPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcblxuXHRcdFx0XHRvYmoubG9va0F0KCB2ZWN0b3IgKTtcblxuXHRcdFx0XHRvYmoudXBkYXRlTWF0cml4KCk7XG5cblx0XHRcdFx0dGhpcy5hcHBseU1hdHJpeCggb2JqLm1hdHJpeCApO1xuXG5cdFx0XHR9O1xuXG5cdFx0fSgpLFxuXG5cdFx0Y2VudGVyOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHRoaXMuY29tcHV0ZUJvdW5kaW5nQm94KCk7XG5cblx0XHRcdHZhciBvZmZzZXQgPSB0aGlzLmJvdW5kaW5nQm94LmNlbnRlcigpLm5lZ2F0ZSgpO1xuXG5cdFx0XHR0aGlzLnRyYW5zbGF0ZSggb2Zmc2V0LngsIG9mZnNldC55LCBvZmZzZXQueiApO1xuXG5cdFx0XHRyZXR1cm4gb2Zmc2V0O1xuXG5cdFx0fSxcblxuXHRcdHNldEZyb21PYmplY3Q6IGZ1bmN0aW9uICggb2JqZWN0ICkge1xuXG5cdFx0XHQvLyBjb25zb2xlLmxvZyggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LnNldEZyb21PYmplY3QoKS4gQ29udmVydGluZycsIG9iamVjdCwgdGhpcyApO1xuXG5cdFx0XHR2YXIgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XG5cblx0XHRcdGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuUG9pbnRzIHx8IG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkxpbmUgKSB7XG5cblx0XHRcdFx0dmFyIHBvc2l0aW9ucyA9IG5ldyBUSFJFRS5GbG9hdDMyQXR0cmlidXRlKCBnZW9tZXRyeS52ZXJ0aWNlcy5sZW5ndGggKiAzLCAzICk7XG5cdFx0XHRcdHZhciBjb2xvcnMgPSBuZXcgVEhSRUUuRmxvYXQzMkF0dHJpYnV0ZSggZ2VvbWV0cnkuY29sb3JzLmxlbmd0aCAqIDMsIDMgKTtcblxuXHRcdFx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgcG9zaXRpb25zLmNvcHlWZWN0b3Izc0FycmF5KCBnZW9tZXRyeS52ZXJ0aWNlcyApICk7XG5cdFx0XHRcdHRoaXMuYWRkQXR0cmlidXRlKCAnY29sb3InLCBjb2xvcnMuY29weUNvbG9yc0FycmF5KCBnZW9tZXRyeS5jb2xvcnMgKSApO1xuXG5cdFx0XHRcdGlmICggZ2VvbWV0cnkubGluZURpc3RhbmNlcyAmJiBnZW9tZXRyeS5saW5lRGlzdGFuY2VzLmxlbmd0aCA9PT0gZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoICkge1xuXG5cdFx0XHRcdFx0dmFyIGxpbmVEaXN0YW5jZXMgPSBuZXcgVEhSRUUuRmxvYXQzMkF0dHJpYnV0ZSggZ2VvbWV0cnkubGluZURpc3RhbmNlcy5sZW5ndGgsIDEgKTtcblxuXHRcdFx0XHRcdHRoaXMuYWRkQXR0cmlidXRlKCAnbGluZURpc3RhbmNlJywgbGluZURpc3RhbmNlcy5jb3B5QXJyYXkoIGdlb21ldHJ5LmxpbmVEaXN0YW5jZXMgKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlLmNsb25lKCk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHR0aGlzLmJvdW5kaW5nQm94ID0gZ2VvbWV0cnkuYm91bmRpbmdCb3guY2xvbmUoKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggKSB7XG5cblx0XHRcdFx0aWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5ICkge1xuXG5cdFx0XHRcdFx0dGhpcy5mcm9tR2VvbWV0cnkoIGdlb21ldHJ5ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHVwZGF0ZUZyb21PYmplY3Q6IGZ1bmN0aW9uICggb2JqZWN0ICkge1xuXG5cdFx0XHR2YXIgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XG5cblx0XHRcdGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTWVzaCApIHtcblxuXHRcdFx0XHR2YXIgZGlyZWN0ID0gZ2VvbWV0cnkuX19kaXJlY3RHZW9tZXRyeTtcblxuXHRcdFx0XHRpZiAoIGRpcmVjdCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuZnJvbUdlb21ldHJ5KCBnZW9tZXRyeSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkaXJlY3QudmVydGljZXNOZWVkVXBkYXRlID0gZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlO1xuXHRcdFx0XHRkaXJlY3Qubm9ybWFsc05lZWRVcGRhdGUgPSBnZW9tZXRyeS5ub3JtYWxzTmVlZFVwZGF0ZTtcblx0XHRcdFx0ZGlyZWN0LmNvbG9yc05lZWRVcGRhdGUgPSBnZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlO1xuXHRcdFx0XHRkaXJlY3QudXZzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5LnV2c05lZWRVcGRhdGU7XG5cdFx0XHRcdGRpcmVjdC5ncm91cHNOZWVkVXBkYXRlID0gZ2VvbWV0cnkuZ3JvdXBzTmVlZFVwZGF0ZTtcblxuXHRcdFx0XHRnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPSBmYWxzZTtcblx0XHRcdFx0Z2VvbWV0cnkubm9ybWFsc05lZWRVcGRhdGUgPSBmYWxzZTtcblx0XHRcdFx0Z2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuXHRcdFx0XHRnZW9tZXRyeS51dnNOZWVkVXBkYXRlID0gZmFsc2U7XG5cdFx0XHRcdGdlb21ldHJ5Lmdyb3Vwc05lZWRVcGRhdGUgPSBmYWxzZTtcblxuXHRcdFx0XHRnZW9tZXRyeSA9IGRpcmVjdDtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHR2YXIgYXR0cmlidXRlID0gdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG5cdFx0XHRcdGlmICggYXR0cmlidXRlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRhdHRyaWJ1dGUuY29weVZlY3RvcjNzQXJyYXkoIGdlb21ldHJ5LnZlcnRpY2VzICk7XG5cdFx0XHRcdFx0YXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Z2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gZmFsc2U7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBnZW9tZXRyeS5ub3JtYWxzTmVlZFVwZGF0ZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHR2YXIgYXR0cmlidXRlID0gdGhpcy5hdHRyaWJ1dGVzLm5vcm1hbDtcblxuXHRcdFx0XHRpZiAoIGF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0YXR0cmlidXRlLmNvcHlWZWN0b3Izc0FycmF5KCBnZW9tZXRyeS5ub3JtYWxzICk7XG5cdFx0XHRcdFx0YXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Z2VvbWV0cnkubm9ybWFsc05lZWRVcGRhdGUgPSBmYWxzZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0dmFyIGF0dHJpYnV0ZSA9IHRoaXMuYXR0cmlidXRlcy5jb2xvcjtcblxuXHRcdFx0XHRpZiAoIGF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0YXR0cmlidXRlLmNvcHlDb2xvcnNBcnJheSggZ2VvbWV0cnkuY29sb3JzICk7XG5cdFx0XHRcdFx0YXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Z2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggZ2VvbWV0cnkudXZzTmVlZFVwZGF0ZSApIHtcblxuXHRcdFx0XHRcdHZhciBhdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZXMudXY7XG5cblx0XHRcdFx0XHRpZiAoIGF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRcdGF0dHJpYnV0ZS5jb3B5VmVjdG9yMnNBcnJheSggZ2VvbWV0cnkudXZzICk7XG5cdFx0XHRcdFx0XHRcdGF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRnZW9tZXRyeS51dnNOZWVkVXBkYXRlID0gZmFsc2U7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBnZW9tZXRyeS5saW5lRGlzdGFuY2VzTmVlZFVwZGF0ZSApIHtcblxuXHRcdFx0XHR2YXIgYXR0cmlidXRlID0gdGhpcy5hdHRyaWJ1dGVzLmxpbmVEaXN0YW5jZTtcblxuXHRcdFx0XHRpZiAoIGF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0YXR0cmlidXRlLmNvcHlBcnJheSggZ2VvbWV0cnkubGluZURpc3RhbmNlcyApO1xuXHRcdFx0XHRcdGF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGdlb21ldHJ5LmxpbmVEaXN0YW5jZXNOZWVkVXBkYXRlID0gZmFsc2U7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBnZW9tZXRyeS5ncm91cHNOZWVkVXBkYXRlICkge1xuXG5cdFx0XHRcdGdlb21ldHJ5LmNvbXB1dGVHcm91cHMoIG9iamVjdC5nZW9tZXRyeSApO1xuXHRcdFx0XHR0aGlzLmdyb3VwcyA9IGdlb21ldHJ5Lmdyb3VwcztcblxuXHRcdFx0XHRnZW9tZXRyeS5ncm91cHNOZWVkVXBkYXRlID0gZmFsc2U7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0ZnJvbUdlb21ldHJ5OiBmdW5jdGlvbiAoIGdlb21ldHJ5ICkge1xuXG5cdFx0XHRnZW9tZXRyeS5fX2RpcmVjdEdlb21ldHJ5ID0gbmV3IFRIUkVFLkRpcmVjdEdlb21ldHJ5KCkuZnJvbUdlb21ldHJ5KCBnZW9tZXRyeSApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5mcm9tRGlyZWN0R2VvbWV0cnkoIGdlb21ldHJ5Ll9fZGlyZWN0R2VvbWV0cnkgKTtcblxuXHRcdH0sXG5cblx0XHRmcm9tRGlyZWN0R2VvbWV0cnk6IGZ1bmN0aW9uICggZ2VvbWV0cnkgKSB7XG5cblx0XHRcdHZhciBwb3NpdGlvbnMgPSBuZXcgRmxvYXQzMkFycmF5KCBnZW9tZXRyeS52ZXJ0aWNlcy5sZW5ndGggKiAzICk7XG5cdFx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25zLCAzICkuY29weVZlY3RvcjNzQXJyYXkoIGdlb21ldHJ5LnZlcnRpY2VzICkgKTtcblxuXHRcdFx0aWYgKCBnZW9tZXRyeS5ub3JtYWxzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0dmFyIG5vcm1hbHMgPSBuZXcgRmxvYXQzMkFycmF5KCBnZW9tZXRyeS5ub3JtYWxzLmxlbmd0aCAqIDMgKTtcblx0XHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkuY29weVZlY3RvcjNzQXJyYXkoIGdlb21ldHJ5Lm5vcm1hbHMgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggZ2VvbWV0cnkuY29sb3JzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0dmFyIGNvbG9ycyA9IG5ldyBGbG9hdDMyQXJyYXkoIGdlb21ldHJ5LmNvbG9ycy5sZW5ndGggKiAzICk7XG5cdFx0XHRcdHRoaXMuYWRkQXR0cmlidXRlKCAnY29sb3InLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBjb2xvcnMsIDMgKS5jb3B5Q29sb3JzQXJyYXkoIGdlb21ldHJ5LmNvbG9ycyApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBnZW9tZXRyeS51dnMubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHR2YXIgdXZzID0gbmV3IEZsb2F0MzJBcnJheSggZ2VvbWV0cnkudXZzLmxlbmd0aCAqIDIgKTtcblx0XHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICd1dicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApLmNvcHlWZWN0b3Iyc0FycmF5KCBnZW9tZXRyeS51dnMgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggZ2VvbWV0cnkudXZzMi5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdHZhciB1dnMyID0gbmV3IEZsb2F0MzJBcnJheSggZ2VvbWV0cnkudXZzMi5sZW5ndGggKiAyICk7XG5cdFx0XHRcdHRoaXMuYWRkQXR0cmlidXRlKCAndXYyJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggdXZzMiwgMiApLmNvcHlWZWN0b3Iyc0FycmF5KCBnZW9tZXRyeS51dnMyICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGdlb21ldHJ5LmluZGljZXMubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHR2YXIgVHlwZUFycmF5ID0gZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoID4gNjU1MzUgPyBVaW50MzJBcnJheSA6IFVpbnQxNkFycmF5O1xuXHRcdFx0XHR2YXIgaW5kaWNlcyA9IG5ldyBUeXBlQXJyYXkoIGdlb21ldHJ5LmluZGljZXMubGVuZ3RoICogMyApO1xuXHRcdFx0XHR0aGlzLnNldEluZGV4KCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBpbmRpY2VzLCAxICkuY29weUluZGljZXNBcnJheSggZ2VvbWV0cnkuaW5kaWNlcyApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gZ3JvdXBzXG5cblx0XHRcdHRoaXMuZ3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzO1xuXG5cdFx0XHQvLyBtb3JwaHNcblxuXHRcdFx0Zm9yICggdmFyIG5hbWUgaW4gZ2VvbWV0cnkubW9ycGhUYXJnZXRzICkge1xuXG5cdFx0XHRcdHZhciBhcnJheSA9IFtdO1xuXHRcdFx0XHR2YXIgbW9ycGhUYXJnZXRzID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzWyBuYW1lIF07XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gbW9ycGhUYXJnZXRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgbW9ycGhUYXJnZXQgPSBtb3JwaFRhcmdldHNbIGkgXTtcblxuXHRcdFx0XHRcdHZhciBhdHRyaWJ1dGUgPSBuZXcgVEhSRUUuRmxvYXQzMkF0dHJpYnV0ZSggbW9ycGhUYXJnZXQubGVuZ3RoICogMywgMyApO1xuXG5cdFx0XHRcdFx0YXJyYXkucHVzaCggYXR0cmlidXRlLmNvcHlWZWN0b3Izc0FycmF5KCBtb3JwaFRhcmdldCApICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMubW9ycGhBdHRyaWJ1dGVzWyBuYW1lIF0gPSBhcnJheTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBza2lubmluZ1xuXG5cdFx0XHRpZiAoIGdlb21ldHJ5LnNraW5JbmRpY2VzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0dmFyIHNraW5JbmRpY2VzID0gbmV3IFRIUkVFLkZsb2F0MzJBdHRyaWJ1dGUoIGdlb21ldHJ5LnNraW5JbmRpY2VzLmxlbmd0aCAqIDQsIDQgKTtcblx0XHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdza2luSW5kZXgnLCBza2luSW5kaWNlcy5jb3B5VmVjdG9yNHNBcnJheSggZ2VvbWV0cnkuc2tpbkluZGljZXMgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggZ2VvbWV0cnkuc2tpbldlaWdodHMubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHR2YXIgc2tpbldlaWdodHMgPSBuZXcgVEhSRUUuRmxvYXQzMkF0dHJpYnV0ZSggZ2VvbWV0cnkuc2tpbldlaWdodHMubGVuZ3RoICogNCwgNCApO1xuXHRcdFx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3NraW5XZWlnaHQnLCBza2luV2VpZ2h0cy5jb3B5VmVjdG9yNHNBcnJheSggZ2VvbWV0cnkuc2tpbldlaWdodHMgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vXG5cblx0XHRcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlLmNsb25lKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHR0aGlzLmJvdW5kaW5nQm94ID0gZ2VvbWV0cnkuYm91bmRpbmdCb3guY2xvbmUoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRjb21wdXRlQm91bmRpbmdCb3g6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0aWYgKCB0aGlzLmJvdW5kaW5nQm94ID09PSBudWxsICkge1xuXG5cdFx0XHRcdFx0dGhpcy5ib3VuZGluZ0JveCA9IG5ldyBUSFJFRS5Cb3gzKCk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBwb3NpdGlvbnMgPSB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XG5cblx0XHRcdFx0aWYgKCBwb3NpdGlvbnMgKSB7XG5cblx0XHRcdFx0XHR2YXIgYmIgPSB0aGlzLmJvdW5kaW5nQm94O1xuXHRcdFx0XHRcdGJiLm1ha2VFbXB0eSgpO1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHBvc2l0aW9ucy5sZW5ndGg7IGkgPCBpbDsgaSArPSAzICkge1xuXG5cdFx0XHRcdFx0XHR2ZWN0b3IuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGkgKTtcblx0XHRcdFx0XHRcdGJiLmV4cGFuZEJ5UG9pbnQoIHZlY3RvciApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHBvc2l0aW9ucyA9PT0gdW5kZWZpbmVkIHx8IHBvc2l0aW9ucy5sZW5ndGggPT09IDAgKSB7XG5cblx0XHRcdFx0XHR0aGlzLmJvdW5kaW5nQm94Lm1pbi5zZXQoIDAsIDAsIDAgKTtcblx0XHRcdFx0XHR0aGlzLmJvdW5kaW5nQm94Lm1heC5zZXQoIDAsIDAsIDAgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBpc05hTiggdGhpcy5ib3VuZGluZ0JveC5taW4ueCApIHx8IGlzTmFOKCB0aGlzLmJvdW5kaW5nQm94Lm1pbi55ICkgfHwgaXNOYU4oIHRoaXMuYm91bmRpbmdCb3gubWluLnogKSApIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5CdWZmZXJHZW9tZXRyeS5jb21wdXRlQm91bmRpbmdCb3g6IENvbXB1dGVkIG1pbi9tYXggaGF2ZSBOYU4gdmFsdWVzLiBUaGUgXCJwb3NpdGlvblwiIGF0dHJpYnV0ZSBpcyBsaWtlbHkgdG8gaGF2ZSBOYU4gdmFsdWVzLicsIHRoaXMgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH07XG5cblx0XHR9KCksXG5cblx0XHRjb21wdXRlQm91bmRpbmdTcGhlcmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIGJveCA9IG5ldyBUSFJFRS5Cb3gzKCk7XG5cdFx0XHR2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRpZiAoIHRoaXMuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbmV3IFRIUkVFLlNwaGVyZSgpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgcG9zaXRpb25zID0gdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xuXG5cdFx0XHRcdGlmICggcG9zaXRpb25zICkge1xuXG5cdFx0XHRcdFx0Ym94Lm1ha2VFbXB0eSgpO1xuXG5cdFx0XHRcdFx0dmFyIGNlbnRlciA9IHRoaXMuYm91bmRpbmdTcGhlcmUuY2VudGVyO1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHBvc2l0aW9ucy5sZW5ndGg7IGkgPCBpbDsgaSArPSAzICkge1xuXG5cdFx0XHRcdFx0XHR2ZWN0b3IuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGkgKTtcblx0XHRcdFx0XHRcdGJveC5leHBhbmRCeVBvaW50KCB2ZWN0b3IgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJveC5jZW50ZXIoIGNlbnRlciApO1xuXG5cdFx0XHRcdFx0Ly8gaG9waW5nIHRvIGZpbmQgYSBib3VuZGluZ1NwaGVyZSB3aXRoIGEgcmFkaXVzIHNtYWxsZXIgdGhhbiB0aGVcblx0XHRcdFx0XHQvLyBib3VuZGluZ1NwaGVyZSBvZiB0aGUgYm91bmRpbmdCb3g6IHNxcnQoMykgc21hbGxlciBpbiB0aGUgYmVzdCBjYXNlXG5cblx0XHRcdFx0XHR2YXIgbWF4UmFkaXVzU3EgPSAwO1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHBvc2l0aW9ucy5sZW5ndGg7IGkgPCBpbDsgaSArPSAzICkge1xuXG5cdFx0XHRcdFx0XHR2ZWN0b3IuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGkgKTtcblx0XHRcdFx0XHRcdG1heFJhZGl1c1NxID0gTWF0aC5tYXgoIG1heFJhZGl1c1NxLCBjZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQoIHZlY3RvciApICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlLnJhZGl1cyA9IE1hdGguc3FydCggbWF4UmFkaXVzU3EgKTtcblxuXHRcdFx0XHRcdGlmICggaXNOYU4oIHRoaXMuYm91bmRpbmdTcGhlcmUucmFkaXVzICkgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5CdWZmZXJHZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTogQ29tcHV0ZWQgcmFkaXVzIGlzIE5hTi4gVGhlIFwicG9zaXRpb25cIiBhdHRyaWJ1dGUgaXMgbGlrZWx5IHRvIGhhdmUgTmFOIHZhbHVlcy4nLCB0aGlzICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9O1xuXG5cdFx0fSgpLFxuXG5cdFx0Y29tcHV0ZUZhY2VOb3JtYWxzOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cblx0XHR9LFxuXG5cdFx0Y29tcHV0ZVZlcnRleE5vcm1hbHM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIGluZGV4ID0gdGhpcy5pbmRleDtcblx0XHRcdHZhciBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzO1xuXHRcdFx0dmFyIGdyb3VwcyA9IHRoaXMuZ3JvdXBzO1xuXG5cdFx0XHRpZiAoIGF0dHJpYnV0ZXMucG9zaXRpb24gKSB7XG5cblx0XHRcdFx0dmFyIHBvc2l0aW9ucyA9IGF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XG5cblx0XHRcdFx0aWYgKCBhdHRyaWJ1dGVzLm5vcm1hbCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCBwb3NpdGlvbnMubGVuZ3RoICksIDMgKSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyByZXNldCBleGlzdGluZyBub3JtYWxzIHRvIHplcm9cblxuXHRcdFx0XHRcdHZhciBub3JtYWxzID0gYXR0cmlidXRlcy5ub3JtYWwuYXJyYXk7XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gbm9ybWFscy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0bm9ybWFsc1sgaSBdID0gMDtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIG5vcm1hbHMgPSBhdHRyaWJ1dGVzLm5vcm1hbC5hcnJheTtcblxuXHRcdFx0XHR2YXIgdkEsIHZCLCB2QyxcblxuXHRcdFx0XHRwQSA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG5cdFx0XHRcdHBCID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcblx0XHRcdFx0cEMgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuXG5cdFx0XHRcdGNiID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcblx0XHRcdFx0YWIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0XHRcdC8vIGluZGV4ZWQgZWxlbWVudHNcblxuXHRcdFx0XHRpZiAoIGluZGV4ICkge1xuXG5cdFx0XHRcdFx0dmFyIGluZGljZXMgPSBpbmRleC5hcnJheTtcblxuXHRcdFx0XHRcdGlmICggZ3JvdXBzLmxlbmd0aCA9PT0gMCApIHtcblxuXHRcdFx0XHRcdFx0dGhpcy5hZGRHcm91cCggMCwgaW5kaWNlcy5sZW5ndGggKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBncm91cHMubGVuZ3RoOyBqIDwgamw7ICsrIGogKSB7XG5cblx0XHRcdFx0XHRcdHZhciBncm91cCA9IGdyb3Vwc1sgaiBdO1xuXG5cdFx0XHRcdFx0XHR2YXIgc3RhcnQgPSBncm91cC5zdGFydDtcblx0XHRcdFx0XHRcdHZhciBjb3VudCA9IGdyb3VwLmNvdW50O1xuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IHN0YXJ0LCBpbCA9IHN0YXJ0ICsgY291bnQ7IGkgPCBpbDsgaSArPSAzICkge1xuXG5cdFx0XHRcdFx0XHRcdHZBID0gaW5kaWNlc1sgaSArIDAgXSAqIDM7XG5cdFx0XHRcdFx0XHRcdHZCID0gaW5kaWNlc1sgaSArIDEgXSAqIDM7XG5cdFx0XHRcdFx0XHRcdHZDID0gaW5kaWNlc1sgaSArIDIgXSAqIDM7XG5cblx0XHRcdFx0XHRcdFx0cEEuZnJvbUFycmF5KCBwb3NpdGlvbnMsIHZBICk7XG5cdFx0XHRcdFx0XHRcdHBCLmZyb21BcnJheSggcG9zaXRpb25zLCB2QiApO1xuXHRcdFx0XHRcdFx0XHRwQy5mcm9tQXJyYXkoIHBvc2l0aW9ucywgdkMgKTtcblxuXHRcdFx0XHRcdFx0XHRjYi5zdWJWZWN0b3JzKCBwQywgcEIgKTtcblx0XHRcdFx0XHRcdFx0YWIuc3ViVmVjdG9ycyggcEEsIHBCICk7XG5cdFx0XHRcdFx0XHRcdGNiLmNyb3NzKCBhYiApO1xuXG5cdFx0XHRcdFx0XHRcdG5vcm1hbHNbIHZBIF0gKz0gY2IueDtcblx0XHRcdFx0XHRcdFx0bm9ybWFsc1sgdkEgKyAxIF0gKz0gY2IueTtcblx0XHRcdFx0XHRcdFx0bm9ybWFsc1sgdkEgKyAyIF0gKz0gY2IuejtcblxuXHRcdFx0XHRcdFx0XHRub3JtYWxzWyB2QiBdICs9IGNiLng7XG5cdFx0XHRcdFx0XHRcdG5vcm1hbHNbIHZCICsgMSBdICs9IGNiLnk7XG5cdFx0XHRcdFx0XHRcdG5vcm1hbHNbIHZCICsgMiBdICs9IGNiLno7XG5cblx0XHRcdFx0XHRcdFx0bm9ybWFsc1sgdkMgXSArPSBjYi54O1xuXHRcdFx0XHRcdFx0XHRub3JtYWxzWyB2QyArIDEgXSArPSBjYi55O1xuXHRcdFx0XHRcdFx0XHRub3JtYWxzWyB2QyArIDIgXSArPSBjYi56O1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIG5vbi1pbmRleGVkIGVsZW1lbnRzICh1bmNvbm5lY3RlZCB0cmlhbmdsZSBzb3VwKVxuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHBvc2l0aW9ucy5sZW5ndGg7IGkgPCBpbDsgaSArPSA5ICkge1xuXG5cdFx0XHRcdFx0XHRwQS5mcm9tQXJyYXkoIHBvc2l0aW9ucywgaSApO1xuXHRcdFx0XHRcdFx0cEIuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGkgKyAzICk7XG5cdFx0XHRcdFx0XHRwQy5mcm9tQXJyYXkoIHBvc2l0aW9ucywgaSArIDYgKTtcblxuXHRcdFx0XHRcdFx0Y2Iuc3ViVmVjdG9ycyggcEMsIHBCICk7XG5cdFx0XHRcdFx0XHRhYi5zdWJWZWN0b3JzKCBwQSwgcEIgKTtcblx0XHRcdFx0XHRcdGNiLmNyb3NzKCBhYiApO1xuXG5cdFx0XHRcdFx0XHRub3JtYWxzWyBpIF0gPSBjYi54O1xuXHRcdFx0XHRcdFx0bm9ybWFsc1sgaSArIDEgXSA9IGNiLnk7XG5cdFx0XHRcdFx0XHRub3JtYWxzWyBpICsgMiBdID0gY2IuejtcblxuXHRcdFx0XHRcdFx0bm9ybWFsc1sgaSArIDMgXSA9IGNiLng7XG5cdFx0XHRcdFx0XHRub3JtYWxzWyBpICsgNCBdID0gY2IueTtcblx0XHRcdFx0XHRcdG5vcm1hbHNbIGkgKyA1IF0gPSBjYi56O1xuXG5cdFx0XHRcdFx0XHRub3JtYWxzWyBpICsgNiBdID0gY2IueDtcblx0XHRcdFx0XHRcdG5vcm1hbHNbIGkgKyA3IF0gPSBjYi55O1xuXHRcdFx0XHRcdFx0bm9ybWFsc1sgaSArIDggXSA9IGNiLno7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMubm9ybWFsaXplTm9ybWFscygpO1xuXG5cdFx0XHRcdGF0dHJpYnV0ZXMubm9ybWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0fSxcblxuXHRcdGNvbXB1dGVUYW5nZW50czogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmNvbXB1dGVUYW5nZW50cygpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuXG5cdFx0fSxcblxuXHRcdGNvbXB1dGVPZmZzZXRzOiBmdW5jdGlvbiAoIHNpemUgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5OiAuY29tcHV0ZU9mZnNldHMoKSBoYXMgYmVlbiByZW1vdmVkLicpXG5cblx0XHR9LFxuXG5cdFx0bWVyZ2U6IGZ1bmN0aW9uICggZ2VvbWV0cnksIG9mZnNldCApIHtcblxuXHRcdFx0aWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5ID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnkubWVyZ2UoKTogZ2VvbWV0cnkgbm90IGFuIGluc3RhbmNlIG9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5LicsIGdlb21ldHJ5ICk7XG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuXHRcdFx0dmFyIGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XG5cblx0XHRcdGZvciAoIHZhciBrZXkgaW4gYXR0cmlidXRlcyApIHtcblxuXHRcdFx0XHRpZiAoIGdlb21ldHJ5LmF0dHJpYnV0ZXNbIGtleSBdID09PSB1bmRlZmluZWQgKSBjb250aW51ZTtcblxuXHRcdFx0XHR2YXIgYXR0cmlidXRlMSA9IGF0dHJpYnV0ZXNbIGtleSBdO1xuXHRcdFx0XHR2YXIgYXR0cmlidXRlQXJyYXkxID0gYXR0cmlidXRlMS5hcnJheTtcblxuXHRcdFx0XHR2YXIgYXR0cmlidXRlMiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXNbIGtleSBdO1xuXHRcdFx0XHR2YXIgYXR0cmlidXRlQXJyYXkyID0gYXR0cmlidXRlMi5hcnJheTtcblxuXHRcdFx0XHR2YXIgYXR0cmlidXRlU2l6ZSA9IGF0dHJpYnV0ZTIuaXRlbVNpemU7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBqID0gYXR0cmlidXRlU2l6ZSAqIG9mZnNldDsgaSA8IGF0dHJpYnV0ZUFycmF5Mi5sZW5ndGg7IGkgKyssIGogKysgKSB7XG5cblx0XHRcdFx0XHRhdHRyaWJ1dGVBcnJheTFbIGogXSA9IGF0dHJpYnV0ZUFycmF5MlsgaSBdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRub3JtYWxpemVOb3JtYWxzOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciBub3JtYWxzID0gdGhpcy5hdHRyaWJ1dGVzLm5vcm1hbC5hcnJheTtcblxuXHRcdFx0dmFyIHgsIHksIHosIG47XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBub3JtYWxzLmxlbmd0aDsgaSA8IGlsOyBpICs9IDMgKSB7XG5cblx0XHRcdFx0eCA9IG5vcm1hbHNbIGkgXTtcblx0XHRcdFx0eSA9IG5vcm1hbHNbIGkgKyAxIF07XG5cdFx0XHRcdHogPSBub3JtYWxzWyBpICsgMiBdO1xuXG5cdFx0XHRcdG4gPSAxLjAgLyBNYXRoLnNxcnQoIHggKiB4ICsgeSAqIHkgKyB6ICogeiApO1xuXG5cdFx0XHRcdG5vcm1hbHNbIGkgXSAqPSBuO1xuXHRcdFx0XHRub3JtYWxzWyBpICsgMSBdICo9IG47XG5cdFx0XHRcdG5vcm1hbHNbIGkgKyAyIF0gKj0gbjtcblxuXHRcdFx0fVxuXG5cdFx0fSxcblxuXHRcdHRvSlNPTjogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgZGF0YSA9IHtcblx0XHRcdFx0bWV0YWRhdGE6IHtcblx0XHRcdFx0XHR2ZXJzaW9uOiA0LjQsXG5cdFx0XHRcdFx0dHlwZTogJ0J1ZmZlckdlb21ldHJ5Jyxcblx0XHRcdFx0XHRnZW5lcmF0b3I6ICdCdWZmZXJHZW9tZXRyeS50b0pTT04nXG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdC8vIHN0YW5kYXJkIEJ1ZmZlckdlb21ldHJ5IHNlcmlhbGl6YXRpb25cblxuXHRcdFx0ZGF0YS51dWlkID0gdGhpcy51dWlkO1xuXHRcdFx0ZGF0YS50eXBlID0gdGhpcy50eXBlO1xuXHRcdFx0aWYgKCB0aGlzLm5hbWUgIT09ICcnICkgZGF0YS5uYW1lID0gdGhpcy5uYW1lO1xuXG5cdFx0XHRpZiAoIHRoaXMucGFyYW1ldGVycyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHZhciBwYXJhbWV0ZXJzID0gdGhpcy5wYXJhbWV0ZXJzO1xuXG5cdFx0XHRcdGZvciAoIHZhciBrZXkgaW4gcGFyYW1ldGVycyApIHtcblxuXHRcdFx0XHRcdGlmICggcGFyYW1ldGVyc1sga2V5IF0gIT09IHVuZGVmaW5lZCApIGRhdGFbIGtleSBdID0gcGFyYW1ldGVyc1sga2V5IF07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBkYXRhO1xuXG5cdFx0XHR9XG5cblx0XHRcdGRhdGEuZGF0YSA9IHsgYXR0cmlidXRlczoge30gfTtcblxuXHRcdFx0dmFyIGluZGV4ID0gdGhpcy5pbmRleDtcblxuXHRcdFx0aWYgKCBpbmRleCAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHR2YXIgYXJyYXkgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggaW5kZXguYXJyYXkgKTtcblxuXHRcdFx0XHRkYXRhLmRhdGEuaW5kZXggPSB7XG5cdFx0XHRcdFx0dHlwZTogaW5kZXguYXJyYXkuY29uc3RydWN0b3IubmFtZSxcblx0XHRcdFx0XHRhcnJheTogYXJyYXlcblx0XHRcdFx0fTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlcztcblxuXHRcdFx0Zm9yICggdmFyIGtleSBpbiBhdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRcdHZhciBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzWyBrZXkgXTtcblxuXHRcdFx0XHR2YXIgYXJyYXkgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXR0cmlidXRlLmFycmF5ICk7XG5cblx0XHRcdFx0ZGF0YS5kYXRhLmF0dHJpYnV0ZXNbIGtleSBdID0ge1xuXHRcdFx0XHRcdGl0ZW1TaXplOiBhdHRyaWJ1dGUuaXRlbVNpemUsXG5cdFx0XHRcdFx0dHlwZTogYXR0cmlidXRlLmFycmF5LmNvbnN0cnVjdG9yLm5hbWUsXG5cdFx0XHRcdFx0YXJyYXk6IGFycmF5XG5cdFx0XHRcdH07XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIGdyb3VwcyA9IHRoaXMuZ3JvdXBzO1xuXG5cdFx0XHRpZiAoIGdyb3Vwcy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdGRhdGEuZGF0YS5ncm91cHMgPSBKU09OLnBhcnNlKCBKU09OLnN0cmluZ2lmeSggZ3JvdXBzICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgYm91bmRpbmdTcGhlcmUgPSB0aGlzLmJvdW5kaW5nU3BoZXJlO1xuXG5cdFx0XHRpZiAoIGJvdW5kaW5nU3BoZXJlICE9PSBudWxsICkge1xuXG5cdFx0XHRcdGRhdGEuZGF0YS5ib3VuZGluZ1NwaGVyZSA9IHtcblx0XHRcdFx0XHRjZW50ZXI6IGJvdW5kaW5nU3BoZXJlLmNlbnRlci50b0FycmF5KCksXG5cdFx0XHRcdFx0cmFkaXVzOiBib3VuZGluZ1NwaGVyZS5yYWRpdXNcblx0XHRcdFx0fTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblxuXHRcdH0sXG5cblx0XHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cblx0XHR9LFxuXG5cdFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cblx0XHRcdHZhciBpbmRleCA9IHNvdXJjZS5pbmRleDtcblxuXHRcdFx0aWYgKCBpbmRleCAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHR0aGlzLnNldEluZGV4KCBpbmRleC5jbG9uZSgpICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIGF0dHJpYnV0ZXMgPSBzb3VyY2UuYXR0cmlidXRlcztcblxuXHRcdFx0Zm9yICggdmFyIG5hbWUgaW4gYXR0cmlidXRlcyApIHtcblxuXHRcdFx0XHR2YXIgYXR0cmlidXRlID0gYXR0cmlidXRlc1sgbmFtZSBdO1xuXHRcdFx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggbmFtZSwgYXR0cmlidXRlLmNsb25lKCkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgZ3JvdXBzID0gc291cmNlLmdyb3VwcztcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGdyb3VwID0gZ3JvdXBzWyBpIF07XG5cdFx0XHRcdHRoaXMuYWRkR3JvdXAoIGdyb3VwLnN0YXJ0LCBncm91cC5jb3VudCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdkaXNwb3NlJyB9ICk7XG5cblx0XHR9XG5cblx0fTtcblxuXHRUSFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmFwcGx5KCBUSFJFRS5CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcblxuXHRUSFJFRS5CdWZmZXJHZW9tZXRyeS5NYXhJbmRleCA9IDY1NTM1O1xuXG5cdC8vIEZpbGU6c3JjL2NvcmUvSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkuanNcblxuXHQvKipcblx0ICogQGF1dGhvciBiZW5hYWRhbXMgLyBodHRwczovL3R3aXR0ZXIuY29tL2Jlbl9hX2FkYW1zXG5cdCAqL1xuXG5cdFRIUkVFLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5ID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0VEhSRUUuQnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG5cdFx0dGhpcy50eXBlID0gJ0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5Jztcblx0XHR0aGlzLm1heEluc3RhbmNlZENvdW50ID0gdW5kZWZpbmVkO1xuXG5cdH07XG5cblx0VEhSRUUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XG5cdFRIUkVFLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5O1xuXG5cdFRIUkVFLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5hZGRHcm91cCA9IGZ1bmN0aW9uICggc3RhcnQsIGNvdW50LCBpbnN0YW5jZXMgKSB7XG5cblx0XHR0aGlzLmdyb3Vwcy5wdXNoKCB7XG5cblx0XHRcdHN0YXJ0OiBzdGFydCxcblx0XHRcdGNvdW50OiBjb3VudCxcblx0XHRcdGluc3RhbmNlczogaW5zdGFuY2VzXG5cblx0XHR9ICk7XG5cblx0fTtcblxuXHRUSFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xuXG5cdFx0dmFyIGluZGV4ID0gc291cmNlLmluZGV4O1xuXG5cdFx0aWYgKCBpbmRleCAhPT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5zZXRJbmRleCggaW5kZXguY2xvbmUoKSApO1xuXG5cdFx0fVxuXG5cdFx0dmFyIGF0dHJpYnV0ZXMgPSBzb3VyY2UuYXR0cmlidXRlcztcblxuXHRcdGZvciAoIHZhciBuYW1lIGluIGF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdHZhciBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzWyBuYW1lIF07XG5cdFx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggbmFtZSwgYXR0cmlidXRlLmNsb25lKCkgKTtcblxuXHRcdH1cblxuXHRcdHZhciBncm91cHMgPSBzb3VyY2UuZ3JvdXBzO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdHZhciBncm91cCA9IGdyb3Vwc1sgaSBdO1xuXHRcdFx0dGhpcy5hZGRHcm91cCggZ3JvdXAuc3RhcnQsIGdyb3VwLmNvdW50LCBncm91cC5pbnN0YW5jZXMgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0VEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5hcHBseSggVEhSRUUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XG5cblx0Ly8gRmlsZTpzcmMvYW5pbWF0aW9uL0FuaW1hdGlvbkFjdGlvbi5qc1xuXG5cdC8qKlxuXHQgKlxuXHQgKiBBIGNsaXAgdGhhdCBoYXMgYmVlbiBleHBsaWNpdGx5IHNjaGVkdWxlZC5cblx0ICpcblx0ICogQGF1dGhvciBCZW4gSG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cblx0ICogQGF1dGhvciBEYXZpZCBTYXJubyAvIGh0dHA6Ly9saWdodGhhdXMudXMvXG5cdCAqL1xuXG5cdFRIUkVFLkFuaW1hdGlvbkFjdGlvbiA9IGZ1bmN0aW9uICggY2xpcCwgc3RhcnRUaW1lLCB0aW1lU2NhbGUsIHdlaWdodCwgbG9vcCApIHtcblxuXHRcdGlmICggY2xpcCA9PT0gdW5kZWZpbmVkICkgdGhyb3cgbmV3IEVycm9yKCAnY2xpcCBpcyBudWxsJyApO1xuXHRcdHRoaXMuY2xpcCA9IGNsaXA7XG5cdFx0dGhpcy5sb2NhbFJvb3QgPSBudWxsO1xuXHRcdHRoaXMuc3RhcnRUaW1lID0gc3RhcnRUaW1lIHx8IDA7XG5cdFx0dGhpcy50aW1lU2NhbGUgPSB0aW1lU2NhbGUgfHwgMTtcblx0XHR0aGlzLndlaWdodCA9IHdlaWdodCB8fCAxO1xuXHRcdHRoaXMubG9vcCA9IGxvb3AgfHwgVEhSRUUuTG9vcFJlcGVhdDtcblx0XHR0aGlzLmxvb3BDb3VudCA9IDA7XG5cdFx0dGhpcy5lbmFibGVkID0gdHJ1ZTtcdC8vIGFsbG93IGZvciBlYXN5IGRpc2FibGluZyBvZiB0aGUgYWN0aW9uLlxuXG5cdFx0dGhpcy5hY3Rpb25UaW1lID0gLSB0aGlzLnN0YXJ0VGltZTtcblx0XHR0aGlzLmNsaXBUaW1lID0gMDtcblxuXHRcdHRoaXMucHJvcGVydHlCaW5kaW5ncyA9IFtdO1xuXHR9O1xuXG5cdC8qXG5cdFRIUkVFLkxvb3BPbmNlID0gMjIwMDtcblx0VEhSRUUuTG9vcFJlcGVhdCA9IDIyMDE7XG5cdFRIUkVFLkxvb3BQaW5nUGluZyA9IDIyMDI7XG5cdCovXG5cblx0VEhSRUUuQW5pbWF0aW9uQWN0aW9uLnByb3RvdHlwZSA9IHtcblxuXHRcdGNvbnN0cnVjdG9yOiBUSFJFRS5BbmltYXRpb25BY3Rpb24sXG5cblx0XHRzZXRMb2NhbFJvb3Q6IGZ1bmN0aW9uKCBsb2NhbFJvb3QgKSB7XG5cblx0XHRcdHRoaXMubG9jYWxSb290ID0gbG9jYWxSb290O1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHR1cGRhdGVUaW1lOiBmdW5jdGlvbiggY2xpcERlbHRhVGltZSApIHtcblxuXHRcdFx0dmFyIHByZXZpb3VzQ2xpcFRpbWUgPSB0aGlzLmNsaXBUaW1lO1xuXHQgICBcdFx0dmFyIHByZXZpb3VzTG9vcENvdW50ID0gdGhpcy5sb29wQ291bnQ7XG5cdCAgIFx0XHR2YXIgcHJldmlvdXNBY3Rpb25UaW1lID0gdGhpcy5hY3Rpb25UaW1lO1xuXG5cdFx0XHR2YXIgZHVyYXRpb24gPSB0aGlzLmNsaXAuZHVyYXRpb247XG5cblx0XHRcdHRoaXMuYWN0aW9uVGltZSA9IHRoaXMuYWN0aW9uVGltZSArIGNsaXBEZWx0YVRpbWU7XG5cblx0XHRcdGlmICggdGhpcy5sb29wID09PSBUSFJFRS5Mb29wT25jZSApIHtcblxuXHRcdFx0XHR0aGlzLmxvb3BDb3VudCA9IDA7XG5cdFx0XHRcdHRoaXMuY2xpcFRpbWUgPSBNYXRoLm1pbiggTWF0aC5tYXgoIHRoaXMuYWN0aW9uVGltZSwgMCApLCBkdXJhdGlvbiApO1xuXG5cdFx0XHRcdC8vIGlmIHRpbWUgaXMgY2hhbmdlZCBzaW5jZSBsYXN0IHRpbWUsIHNlZSBpZiB3ZSBoYXZlIGhpdCBhIHN0YXJ0L2VuZCBsaW1pdFxuXHRcdFx0XHRpZiAoIHRoaXMuY2xpcFRpbWUgIT09IHByZXZpb3VzQ2xpcFRpbWUgKSB7XG5cblx0XHRcdFx0XHRpZiAoIHRoaXMuY2xpcFRpbWUgPT09IGR1cmF0aW9uICkge1xuXG5cdFx0XHRcdFx0XHR0aGlzLm1peGVyLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2ZpbmlzaGVkJywgYWN0aW9uOiB0aGlzLCBkaXJlY3Rpb246IDEgfSApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggdGhpcy5jbGlwVGltZSA9PT0gMCApIHtcblxuXHRcdFx0XHRcdFx0dGhpcy5taXhlci5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdmaW5pc2hlZCcsIGFjdGlvbjogdGhpcywgZGlyZWN0aW9uOiAtMSB9ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cblx0XHRcdFx0cmV0dXJuIHRoaXMuY2xpcFRpbWU7XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5sb29wQ291bnQgPSBNYXRoLmZsb29yKCB0aGlzLmFjdGlvblRpbWUgLyBkdXJhdGlvbiApO1xuXG5cdFx0XHR2YXIgbmV3Q2xpcFRpbWUgPSB0aGlzLmFjdGlvblRpbWUgLSB0aGlzLmxvb3BDb3VudCAqIGR1cmF0aW9uO1xuXHRcdFx0bmV3Q2xpcFRpbWUgPSBuZXdDbGlwVGltZSAlIGR1cmF0aW9uO1xuXG5cdFx0XHQvLyBpZiB3ZSBhcmUgcGluZyBwb25nIGxvb3BpbmcsIGVuc3VyZSB0aGF0IHdlIGdvIGJhY2t3YXJkcyB3aGVuIGFwcHJvcHJpYXRlXG5cdFx0XHRpZiAoIHRoaXMubG9vcCA9PSBUSFJFRS5Mb29wUGluZ1BvbmcgKSB7XG5cblx0XHRcdFx0aWYgKCBNYXRoLmFicyggdGhpcy5sb29wQ291bnQgJSAyICkgPT09IDEgKSB7XG5cblx0XHRcdFx0XHRuZXdDbGlwVGltZSA9IGR1cmF0aW9uIC0gbmV3Q2xpcFRpbWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuY2xpcFRpbWUgPSBuZXdDbGlwVGltZTtcblxuXHRcdFx0aWYgKCB0aGlzLmxvb3BDb3VudCAhPT0gcHJldmlvdXNMb29wQ291bnQgKSB7XG5cblx0ICAgXHRcdFx0dGhpcy5taXhlci5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdsb29wJywgYWN0aW9uOiB0aGlzLCBsb29wRGVsdGE6ICggdGhpcy5sb29wQ291bnQgLSB0aGlzLmxvb3BDb3VudCApIH0gKTtcblxuXHQgICBcdFx0fVxuXG5cdFx0ICAgXHRyZXR1cm4gdGhpcy5jbGlwVGltZTtcblxuXHRcdH0sXG5cblx0XHRzeW5jV2l0aDogZnVuY3Rpb24oIGFjdGlvbiApIHtcblxuXHRcdFx0dGhpcy5hY3Rpb25UaW1lID0gYWN0aW9uLmFjdGlvblRpbWU7XG5cdFx0XHR0aGlzLnRpbWVTY2FsZSA9IGFjdGlvbi50aW1lU2NhbGU7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0sXG5cblx0XHR3YXJwVG9EdXJhdGlvbjogZnVuY3Rpb24oIGR1cmF0aW9uICkge1xuXG5cdFx0XHR0aGlzLnRpbWVTY2FsZSA9IHRoaXMuY2xpcC5kdXJhdGlvbiAvIGR1cmF0aW9uO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXG5cdFx0aW5pdDogZnVuY3Rpb24oIHRpbWUgKSB7XG5cblx0XHRcdHRoaXMuY2xpcFRpbWUgPSB0aW1lIC0gdGhpcy5zdGFydFRpbWU7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHVwZGF0ZTogZnVuY3Rpb24oIGNsaXBEZWx0YVRpbWUgKSB7XG5cblx0XHRcdHRoaXMudXBkYXRlVGltZSggY2xpcERlbHRhVGltZSApO1xuXG5cdFx0XHR2YXIgY2xpcFJlc3VsdHMgPSB0aGlzLmNsaXAuZ2V0QXQoIHRoaXMuY2xpcFRpbWUgKTtcblxuXHRcdFx0cmV0dXJuIGNsaXBSZXN1bHRzO1xuXG5cdFx0fSxcblxuXHRcdGdldFRpbWVTY2FsZUF0OiBmdW5jdGlvbiggdGltZSApIHtcblxuXHRcdFx0aWYgKCB0aGlzLnRpbWVTY2FsZS5nZXRBdCApIHtcblx0XHRcdFx0Ly8gcGFzcyBpbiB0aW1lLCBub3QgY2xpcCB0aW1lLCBhbGxvd3MgZm9yIGZhZGVpbi9mYWRlb3V0IGFjcm9zcyBtdWx0aXBsZSBsb29wcyBvZiB0aGUgY2xpcFxuXHRcdFx0XHRyZXR1cm4gdGhpcy50aW1lU2NhbGUuZ2V0QXQoIHRpbWUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcy50aW1lU2NhbGU7XG5cblx0XHR9LFxuXG5cdFx0Z2V0V2VpZ2h0QXQ6IGZ1bmN0aW9uKCB0aW1lICkge1xuXG5cdFx0XHRpZiAoIHRoaXMud2VpZ2h0LmdldEF0ICkge1xuXHRcdFx0XHQvLyBwYXNzIGluIHRpbWUsIG5vdCBjbGlwIHRpbWUsIGFsbG93cyBmb3IgZmFkZWluL2ZhZGVvdXQgYWNyb3NzIG11bHRpcGxlIGxvb3BzIG9mIHRoZSBjbGlwXG5cdFx0XHRcdHJldHVybiB0aGlzLndlaWdodC5nZXRBdCggdGltZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzLndlaWdodDtcblxuXHRcdH1cblxuXHR9O1xuXG5cdC8vIEZpbGU6c3JjL2FuaW1hdGlvbi9BbmltYXRpb25DbGlwLmpzXG5cblx0LyoqXG5cdCAqXG5cdCAqIFJldXNhYmxlIHNldCBvZiBUcmFja3MgdGhhdCByZXByZXNlbnQgYW4gYW5pbWF0aW9uLlxuXHQgKlxuXHQgKiBAYXV0aG9yIEJlbiBIb3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvL1xuXHQgKiBAYXV0aG9yIERhdmlkIFNhcm5vIC8gaHR0cDovL2xpZ2h0aGF1cy51cy9cblx0ICovXG5cblx0VEhSRUUuQW5pbWF0aW9uQ2xpcCA9IGZ1bmN0aW9uICggbmFtZSwgZHVyYXRpb24sIHRyYWNrcyApIHtcblxuXHRcdHRoaXMubmFtZSA9IG5hbWU7XG5cdFx0dGhpcy50cmFja3MgPSB0cmFja3M7XG5cdFx0dGhpcy5kdXJhdGlvbiA9ICggZHVyYXRpb24gIT09IHVuZGVmaW5lZCApID8gZHVyYXRpb24gOiAtMTtcblxuXHRcdC8vIHRoaXMgbWVhbnMgaXQgc2hvdWxkIGZpZ3VyZSBvdXQgaXRzIGR1cmF0aW9uIGJ5IHNjYW5uaW5nIHRoZSB0cmFja3Ncblx0XHRpZiAoIHRoaXMuZHVyYXRpb24gPCAwICkge1xuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy50cmFja3MubGVuZ3RoOyBpICsrICkge1xuXHRcdFx0XHR2YXIgdHJhY2sgPSB0aGlzLnRyYWNrc1tpXTtcblx0XHRcdFx0dGhpcy5kdXJhdGlvbiA9IE1hdGgubWF4KCB0cmFjay5rZXlzWyB0cmFjay5rZXlzLmxlbmd0aCAtIDEgXS50aW1lICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gbWF5YmUgb25seSBkbyB0aGVzZSBvbiBkZW1hbmQsIGFzIGRvaW5nIHRoZW0gaGVyZSBjb3VsZCBwb3RlbnRpYWxseSBzbG93IGRvd24gbG9hZGluZ1xuXHRcdC8vIGJ1dCBsZWF2aW5nIHRoZXNlIGhlcmUgZHVyaW5nIGRldmVsb3BtZW50IGFzIHRoaXMgZW5zdXJlcyBhIGxvdCBvZiB0ZXN0aW5nIG9mIHRoZXNlIGZ1bmN0aW9uc1xuXHRcdHRoaXMudHJpbSgpO1xuXHRcdHRoaXMub3B0aW1pemUoKTtcblxuXHRcdHRoaXMucmVzdWx0cyA9IFtdO1xuXG5cdH07XG5cblx0VEhSRUUuQW5pbWF0aW9uQ2xpcC5wcm90b3R5cGUgPSB7XG5cblx0XHRjb25zdHJ1Y3RvcjogVEhSRUUuQW5pbWF0aW9uQ2xpcCxcblxuXHRcdGdldEF0OiBmdW5jdGlvbiggY2xpcFRpbWUgKSB7XG5cblx0XHRcdGNsaXBUaW1lID0gTWF0aC5tYXgoIDAsIE1hdGgubWluKCBjbGlwVGltZSwgdGhpcy5kdXJhdGlvbiApICk7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMudHJhY2tzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgdHJhY2sgPSB0aGlzLnRyYWNrc1sgaSBdO1xuXG5cdFx0XHRcdHRoaXMucmVzdWx0c1sgaSBdID0gdHJhY2suZ2V0QXQoIGNsaXBUaW1lICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXMucmVzdWx0cztcblx0XHR9LFxuXG5cdFx0dHJpbTogZnVuY3Rpb24oKSB7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMudHJhY2tzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHR0aGlzLnRyYWNrc1sgaSBdLnRyaW0oIDAsIHRoaXMuZHVyYXRpb24gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRvcHRpbWl6ZTogZnVuY3Rpb24oKSB7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMudHJhY2tzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHR0aGlzLnRyYWNrc1sgaSBdLm9wdGltaXplKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9XG5cblx0fTtcblxuXG5cdFRIUkVFLkFuaW1hdGlvbkNsaXAuQ3JlYXRlRnJvbU1vcnBoVGFyZ2V0U2VxdWVuY2UgPSBmdW5jdGlvbiggbmFtZSwgbW9ycGhUYXJnZXRTZXF1ZW5jZSwgZnBzICkge1xuXG5cblx0XHR2YXIgbnVtTW9ycGhUYXJnZXRzID0gbW9ycGhUYXJnZXRTZXF1ZW5jZS5sZW5ndGg7XG5cdFx0dmFyIHRyYWNrcyA9IFtdO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbnVtTW9ycGhUYXJnZXRzOyBpICsrICkge1xuXG5cdFx0XHR2YXIga2V5cyA9IFtdO1xuXG5cdFx0XHRrZXlzLnB1c2goIHsgdGltZTogKCBpICsgbnVtTW9ycGhUYXJnZXRzIC0gMSApICUgbnVtTW9ycGhUYXJnZXRzLCB2YWx1ZTogMCB9ICk7XG5cdFx0XHRrZXlzLnB1c2goIHsgdGltZTogaSwgdmFsdWU6IDEgfSApO1xuXHRcdFx0a2V5cy5wdXNoKCB7IHRpbWU6ICggaSArIDEgKSAlIG51bU1vcnBoVGFyZ2V0cywgdmFsdWU6IDAgfSApO1xuXG5cdFx0XHRrZXlzLnNvcnQoIFRIUkVFLktleWZyYW1lVHJhY2sua2V5Q29tcGFyZXIgKTtcblxuXHRcdFx0Ly8gaWYgdGhlcmUgaXMgYSBrZXkgYXQgdGhlIGZpcnN0IGZyYW1lLCBkdXBsaWNhdGUgaXQgYXMgdGhlIGxhc3QgZnJhbWUgYXMgd2VsbCBmb3IgcGVyZmVjdCBsb29wLlxuXHRcdFx0aWYgKCBrZXlzWzBdLnRpbWUgPT09IDAgKSB7XG5cdFx0XHRcdGtleXMucHVzaCgge1xuXHRcdFx0XHRcdHRpbWU6IG51bU1vcnBoVGFyZ2V0cyxcblx0XHRcdFx0XHR2YWx1ZToga2V5c1swXS52YWx1ZVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0dHJhY2tzLnB1c2goIG5ldyBUSFJFRS5OdW1iZXJLZXlmcmFtZVRyYWNrKCAnLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1snICsgbW9ycGhUYXJnZXRTZXF1ZW5jZVtpXS5uYW1lICsgJ10nLCBrZXlzICkuc2NhbGUoIDEuMCAvIGZwcyApICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5BbmltYXRpb25DbGlwKCBuYW1lLCAtMSwgdHJhY2tzICk7XG5cblx0fTtcblxuXHRUSFJFRS5BbmltYXRpb25DbGlwLmZpbmRCeU5hbWUgPSBmdW5jdGlvbiggY2xpcEFycmF5LCBuYW1lICkge1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgY2xpcEFycmF5Lmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0aWYgKCBjbGlwQXJyYXlbaV0ubmFtZSA9PT0gbmFtZSApIHtcblxuXHRcdFx0XHRyZXR1cm4gY2xpcEFycmF5W2ldO1xuXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG51bGw7XG5cblx0fTtcblxuXHRUSFJFRS5BbmltYXRpb25DbGlwLkNyZWF0ZUNsaXBzRnJvbU1vcnBoVGFyZ2V0U2VxdWVuY2VzID0gZnVuY3Rpb24oIG1vcnBoVGFyZ2V0cywgZnBzICkge1xuXG5cdFx0dmFyIGFuaW1hdGlvblRvTW9ycGhUYXJnZXRzID0ge307XG5cblx0XHQvLyB0ZXN0ZWQgd2l0aCBodHRwczovL3JlZ2V4MTAxLmNvbS8gb24gdHJpY2sgc2VxdWVuY2VzIHN1Y2ggZmxhbWluZ29fZmx5QV8wMDMsIGZsYW1pbmdvX3J1bjFfMDAzLCBjcmRlYXRoMDA1OVxuXHRcdHZhciBwYXR0ZXJuID0gL14oW1xcdy1dKj8pKFtcXGRdKykkLztcblxuXHRcdC8vIHNvcnQgbW9ycGggdGFyZ2V0IG5hbWVzIGludG8gYW5pbWF0aW9uIGdyb3VwcyBiYXNlZCBwYXR0ZXJucyBsaWtlIFdhbGtfMDAxLCBXYWxrXzAwMiwgUnVuXzAwMSwgUnVuXzAwMlxuXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBtb3JwaFRhcmdldHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdHZhciBtb3JwaFRhcmdldCA9IG1vcnBoVGFyZ2V0c1sgaSBdO1xuXHRcdFx0dmFyIHBhcnRzID0gbW9ycGhUYXJnZXQubmFtZS5tYXRjaCggcGF0dGVybiApO1xuXG5cdFx0XHRpZiAoIHBhcnRzICYmIHBhcnRzLmxlbmd0aCA+IDEgKSB7XG5cblx0XHRcdFx0dmFyIG5hbWUgPSBwYXJ0c1sgMSBdO1xuXG5cdFx0XHRcdHZhciBhbmltYXRpb25Nb3JwaFRhcmdldHMgPSBhbmltYXRpb25Ub01vcnBoVGFyZ2V0c1sgbmFtZSBdO1xuXHRcdFx0XHRpZiAoICEgYW5pbWF0aW9uTW9ycGhUYXJnZXRzICkge1xuXHRcdFx0XHRcdGFuaW1hdGlvblRvTW9ycGhUYXJnZXRzWyBuYW1lIF0gPSBhbmltYXRpb25Nb3JwaFRhcmdldHMgPSBbXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGFuaW1hdGlvbk1vcnBoVGFyZ2V0cy5wdXNoKCBtb3JwaFRhcmdldCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHR2YXIgY2xpcHMgPSBbXTtcblxuXHRcdGZvciAoIHZhciBuYW1lIGluIGFuaW1hdGlvblRvTW9ycGhUYXJnZXRzICkge1xuXG5cdFx0XHRjbGlwcy5wdXNoKCBUSFJFRS5BbmltYXRpb25DbGlwLkNyZWF0ZUZyb21Nb3JwaFRhcmdldFNlcXVlbmNlKCBuYW1lLCBhbmltYXRpb25Ub01vcnBoVGFyZ2V0c1sgbmFtZSBdLCBmcHMgKSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBjbGlwcztcblxuXHR9O1xuXG5cdC8vIHBhcnNlIHRoZSBzdGFuZGFyZCBKU09OIGZvcm1hdCBmb3IgY2xpcHNcblx0VEhSRUUuQW5pbWF0aW9uQ2xpcC5wYXJzZSA9IGZ1bmN0aW9uKCBqc29uICkge1xuXG5cdFx0dmFyIHRyYWNrcyA9IFtdO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwganNvbi50cmFja3MubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHR0cmFja3MucHVzaCggVEhSRUUuS2V5ZnJhbWVUcmFjay5wYXJzZSgganNvbi50cmFja3NbaV0gKS5zY2FsZSggMS4wIC8ganNvbi5mcHMgKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5BbmltYXRpb25DbGlwKCBqc29uLm5hbWUsIGpzb24uZHVyYXRpb24sIHRyYWNrcyApO1xuXG5cdH07XG5cblxuXHQvLyBwYXJzZSB0aGUgYW5pbWF0aW9uLmhpZXJhcmNoeSBmb3JtYXRcblx0VEhSRUUuQW5pbWF0aW9uQ2xpcC5wYXJzZUFuaW1hdGlvbiA9IGZ1bmN0aW9uKCBhbmltYXRpb24sIGJvbmVzLCBub2RlTmFtZSApIHtcblxuXHRcdGlmICggISBhbmltYXRpb24gKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCBcIiAgbm8gYW5pbWF0aW9uIGluIEpTT05Mb2FkZXIgZGF0YVwiICk7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHR2YXIgY29udmVydFRyYWNrID0gZnVuY3Rpb24oIHRyYWNrTmFtZSwgYW5pbWF0aW9uS2V5cywgcHJvcGVydHlOYW1lLCB0cmFja1R5cGUsIGFuaW1hdGlvbktleVRvVmFsdWVGdW5jICkge1xuXG5cdFx0XHR2YXIga2V5cyA9IFtdO1xuXG5cdFx0XHRmb3IgKCB2YXIgayA9IDA7IGsgPCBhbmltYXRpb25LZXlzLmxlbmd0aDsgayArKyApIHtcblxuXHRcdFx0XHR2YXIgYW5pbWF0aW9uS2V5ID0gYW5pbWF0aW9uS2V5c1trXTtcblxuXHRcdFx0XHRpZiAoIGFuaW1hdGlvbktleVtwcm9wZXJ0eU5hbWVdICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRrZXlzLnB1c2goIHsgdGltZTogYW5pbWF0aW9uS2V5LnRpbWUsIHZhbHVlOiBhbmltYXRpb25LZXlUb1ZhbHVlRnVuYyggYW5pbWF0aW9uS2V5ICkgfSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gb25seSByZXR1cm4gdHJhY2sgaWYgdGhlcmUgYXJlIGFjdHVhbGx5IGtleXMuXG5cdFx0XHRpZiAoIGtleXMubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHRyZXR1cm4gbmV3IHRyYWNrVHlwZSggdHJhY2tOYW1lLCBrZXlzICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR9O1xuXG5cdFx0dmFyIHRyYWNrcyA9IFtdO1xuXG5cdFx0dmFyIGNsaXBOYW1lID0gYW5pbWF0aW9uLm5hbWUgfHwgJ2RlZmF1bHQnO1xuXHRcdHZhciBkdXJhdGlvbiA9IGFuaW1hdGlvbi5sZW5ndGggfHwgLTE7IC8vIGF1dG9tYXRpYyBsZW5ndGggZGV0ZXJtaW5hdGlvbiBpbiBBbmltYXRpb25DbGlwLlxuXHRcdHZhciBmcHMgPSBhbmltYXRpb24uZnBzIHx8IDMwO1xuXG5cdFx0dmFyIGhpZXJhcmNoeVRyYWNrcyA9IGFuaW1hdGlvbi5oaWVyYXJjaHkgfHwgW107XG5cblx0XHRmb3IgKCB2YXIgaCA9IDA7IGggPCBoaWVyYXJjaHlUcmFja3MubGVuZ3RoOyBoICsrICkge1xuXG5cdFx0XHR2YXIgYW5pbWF0aW9uS2V5cyA9IGhpZXJhcmNoeVRyYWNrc1sgaCBdLmtleXM7XG5cblx0XHRcdC8vIHNraXAgZW1wdHkgdHJhY2tzXG5cdFx0XHRpZiAoICEgYW5pbWF0aW9uS2V5cyB8fCBhbmltYXRpb25LZXlzLmxlbmd0aCA9PSAwICkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gcHJvY2VzcyBtb3JwaCB0YXJnZXRzIGluIGEgd2F5IGV4YWN0bHkgY29tcGF0aWJsZSB3aXRoIEFuaW1hdGlvbkhhbmRsZXIuaW5pdCggYW5pbWF0aW9uIClcblx0XHRcdGlmICggYW5pbWF0aW9uS2V5c1swXS5tb3JwaFRhcmdldHMgKSB7XG5cblx0XHRcdFx0Ly8gZmlndXJlIG91dCBhbGwgbW9ycGggdGFyZ2V0cyB1c2VkIGluIHRoaXMgdHJhY2tcblx0XHRcdFx0dmFyIG1vcnBoVGFyZ2V0TmFtZXMgPSB7fTtcblx0XHRcdFx0Zm9yICggdmFyIGsgPSAwOyBrIDwgYW5pbWF0aW9uS2V5cy5sZW5ndGg7IGsgKysgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGFuaW1hdGlvbktleXNba10ubW9ycGhUYXJnZXRzICkge1xuXHRcdFx0XHRcdFx0Zm9yICggdmFyIG0gPSAwOyBtIDwgYW5pbWF0aW9uS2V5c1trXS5tb3JwaFRhcmdldHMubGVuZ3RoOyBtICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdG1vcnBoVGFyZ2V0TmFtZXNbIGFuaW1hdGlvbktleXNba10ubW9ycGhUYXJnZXRzW21dIF0gPSAtMTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGNyZWF0ZSBhIHRyYWNrIGZvciBlYWNoIG1vcnBoIHRhcmdldCB3aXRoIGFsbCB6ZXJvIG1vcnBoVGFyZ2V0SW5mbHVlbmNlcyBleGNlcHQgZm9yIHRoZSBrZXlzIGluIHdoaWNoIHRoZSBtb3JwaFRhcmdldCBpcyBuYW1lZC5cblx0XHRcdFx0Zm9yICggdmFyIG1vcnBoVGFyZ2V0TmFtZSBpbiBtb3JwaFRhcmdldE5hbWVzICkge1xuXG5cdFx0XHRcdFx0dmFyIGtleXMgPSBbXTtcblxuXHRcdFx0XHRcdGZvciAoIHZhciBtID0gMDsgbSA8IGFuaW1hdGlvbktleXNba10ubW9ycGhUYXJnZXRzLmxlbmd0aDsgbSArKyApIHtcblxuXHRcdFx0XHRcdFx0dmFyIGFuaW1hdGlvbktleSA9IGFuaW1hdGlvbktleXNba107XG5cblx0XHRcdFx0XHRcdGtleXMucHVzaCgge1xuXHRcdFx0XHRcdFx0XHRcdHRpbWU6IGFuaW1hdGlvbktleS50aW1lLFxuXHRcdFx0XHRcdFx0XHRcdHZhbHVlOiAoKCBhbmltYXRpb25LZXkubW9ycGhUYXJnZXQgPT09IG1vcnBoVGFyZ2V0TmFtZSApID8gMSA6IDAgKVxuXHRcdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRyYWNrcy5wdXNoKCBuZXcgVEhSRUUuTnVtYmVyS2V5ZnJhbWVUcmFjayggbm9kZU5hbWUgKyAnLm1vcnBoVGFyZ2V0SW5mbHVlbmNlWycgKyBtb3JwaFRhcmdldE5hbWUgKyAnXScsIGtleXMgKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkdXJhdGlvbiA9IG1vcnBoVGFyZ2V0TmFtZXMubGVuZ3RoICogKCBmcHMgfHwgMS4wICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dmFyIGJvbmVOYW1lID0gbm9kZU5hbWUgKyAnLmJvbmVzWycgKyBib25lc1sgaCBdLm5hbWUgKyAnXSc7XG5cblx0XHRcdFx0Ly8gdHJhY2sgY29udGFpbnMgcG9zaXRpb25zLi4uXG5cdFx0XHRcdHZhciBwb3NpdGlvblRyYWNrID0gY29udmVydFRyYWNrKCBib25lTmFtZSArICcucG9zaXRpb24nLCBhbmltYXRpb25LZXlzLCAncG9zJywgVEhSRUUuVmVjdG9yS2V5ZnJhbWVUcmFjaywgZnVuY3Rpb24oIGFuaW1hdGlvbktleSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMygpLmZyb21BcnJheSggYW5pbWF0aW9uS2V5LnBvcyApXG5cdFx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdGlmICggcG9zaXRpb25UcmFjayApIHRyYWNrcy5wdXNoKCBwb3NpdGlvblRyYWNrICk7XG5cblx0XHRcdFx0Ly8gdHJhY2sgY29udGFpbnMgcXVhdGVybmlvbnMuLi5cblx0XHRcdFx0dmFyIHF1YXRlcm5pb25UcmFjayA9IGNvbnZlcnRUcmFjayggYm9uZU5hbWUgKyAnLnF1YXRlcm5pb24nLCBhbmltYXRpb25LZXlzLCAncm90JywgVEhSRUUuUXVhdGVybmlvbktleWZyYW1lVHJhY2ssIGZ1bmN0aW9uKCBhbmltYXRpb25LZXkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGFuaW1hdGlvbktleS5yb3Quc2xlcnAgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBhbmltYXRpb25LZXkucm90LmNsb25lKCk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gbmV3IFRIUkVFLlF1YXRlcm5pb24oKS5mcm9tQXJyYXkoIGFuaW1hdGlvbktleS5yb3QgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0aWYgKCBxdWF0ZXJuaW9uVHJhY2sgKSB0cmFja3MucHVzaCggcXVhdGVybmlvblRyYWNrICk7XG5cblx0XHRcdFx0Ly8gdHJhY2sgY29udGFpbnMgcXVhdGVybmlvbnMuLi5cblx0XHRcdFx0dmFyIHNjYWxlVHJhY2sgPSBjb252ZXJ0VHJhY2soIGJvbmVOYW1lICsgJy5zY2FsZScsIGFuaW1hdGlvbktleXMsICdzY2wnLCBUSFJFRS5WZWN0b3JLZXlmcmFtZVRyYWNrLCBmdW5jdGlvbiggYW5pbWF0aW9uS2V5ICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IzKCkuZnJvbUFycmF5KCBhbmltYXRpb25LZXkuc2NsIClcblx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0aWYgKCBzY2FsZVRyYWNrICkgdHJhY2tzLnB1c2goIHNjYWxlVHJhY2sgKTtcblxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggdHJhY2tzLmxlbmd0aCA9PT0gMCApIHtcblxuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR9XG5cblx0XHR2YXIgY2xpcCA9IG5ldyBUSFJFRS5BbmltYXRpb25DbGlwKCBjbGlwTmFtZSwgZHVyYXRpb24sIHRyYWNrcyApO1xuXG5cdFx0cmV0dXJuIGNsaXA7XG5cblx0fTtcblxuXHQvLyBGaWxlOnNyYy9hbmltYXRpb24vQW5pbWF0aW9uTWl4ZXIuanNcblxuXHQvKipcblx0ICpcblx0ICogTWl4ZXMgdG9nZXRoZXIgdGhlIEFuaW1hdGlvbkNsaXBzIHNjaGVkdWxlZCBieSBBbmltYXRpb25BY3Rpb25zIGFuZCBhcHBsaWVzIHRoZW0gdG8gdGhlIHJvb3QgYW5kIHN1YnRyZWVcblx0ICpcblx0ICpcblx0ICogQGF1dGhvciBCZW4gSG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cblx0ICogQGF1dGhvciBEYXZpZCBTYXJubyAvIGh0dHA6Ly9saWdodGhhdXMudXMvXG5cdCAqL1xuXG5cdFRIUkVFLkFuaW1hdGlvbk1peGVyID0gZnVuY3Rpb24oIHJvb3QgKSB7XG5cblx0XHR0aGlzLnJvb3QgPSByb290O1xuXHRcdHRoaXMudGltZSA9IDA7XG5cdFx0dGhpcy50aW1lU2NhbGUgPSAxLjA7XG5cdFx0dGhpcy5hY3Rpb25zID0gW107XG5cdFx0dGhpcy5wcm9wZXJ0eUJpbmRpbmdNYXAgPSB7fTtcblxuXHR9O1xuXG5cdFRIUkVFLkFuaW1hdGlvbk1peGVyLnByb3RvdHlwZSA9IHtcblxuXHRcdGNvbnN0cnVjdG9yOiBUSFJFRS5BbmltYXRpb25NaXhlcixcblxuXHRcdGFkZEFjdGlvbjogZnVuY3Rpb24oIGFjdGlvbiApIHtcblxuXHRcdFx0Ly8gVE9ETzogY2hlY2sgZm9yIGR1cGxpY2F0ZSBhY3Rpb24gbmFtZXM/ICBPciBwcm92aWRlIGVhY2ggYWN0aW9uIHdpdGggYSBVVUlEP1xuXG5cdFx0XHR0aGlzLmFjdGlvbnMucHVzaCggYWN0aW9uICk7XG5cdFx0XHRhY3Rpb24uaW5pdCggdGhpcy50aW1lICk7XG5cdFx0XHRhY3Rpb24ubWl4ZXIgPSB0aGlzO1xuXG5cdFx0XHR2YXIgdHJhY2tzID0gYWN0aW9uLmNsaXAudHJhY2tzO1xuXG5cdFx0XHR2YXIgcm9vdCA9IGFjdGlvbi5sb2NhbFJvb3QgfHwgdGhpcy5yb290O1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0cmFja3MubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciB0cmFjayA9IHRyYWNrc1sgaSBdO1xuXG5cdFx0XHRcdHZhciBwcm9wZXJ0eUJpbmRpbmdLZXkgPSByb290LnV1aWQgKyAnLScgKyB0cmFjay5uYW1lO1xuXHRcdFx0XHR2YXIgcHJvcGVydHlCaW5kaW5nID0gdGhpcy5wcm9wZXJ0eUJpbmRpbmdNYXBbIHByb3BlcnR5QmluZGluZ0tleSBdO1xuXG5cdFx0XHRcdGlmICggcHJvcGVydHlCaW5kaW5nID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRwcm9wZXJ0eUJpbmRpbmcgPSBuZXcgVEhSRUUuUHJvcGVydHlCaW5kaW5nKCByb290LCB0cmFjay5uYW1lICk7XG5cdFx0XHRcdFx0dGhpcy5wcm9wZXJ0eUJpbmRpbmdNYXBbIHByb3BlcnR5QmluZGluZ0tleSBdID0gcHJvcGVydHlCaW5kaW5nO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBwdXNoIGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZSB0cmFja3MuXG5cdFx0XHRcdGFjdGlvbi5wcm9wZXJ0eUJpbmRpbmdzLnB1c2goIHByb3BlcnR5QmluZGluZyApO1xuXG5cdFx0XHRcdC8vIHRyYWNrIHVzYWdlcyBvZiBzaGFyZWQgcHJvcGVydHkgYmluZGluZ3MsIGJlY2F1c2UgaWYgd2UgbGVhdmUgdG9vIG1hbnkgYXJvdW5kLCB0aGUgbWl4ZXIgY2FuIGdldCBzbG93XG5cdFx0XHRcdHByb3BlcnR5QmluZGluZy5yZWZlcmVuY2VDb3VudCArPSAxO1xuXG5cdFx0XHR9XG5cblx0XHR9LFxuXG5cdFx0cmVtb3ZlQWxsQWN0aW9uczogZnVuY3Rpb24oKSB7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuYWN0aW9ucy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0dGhpcy5hY3Rpb25zW2ldLm1peGVyID0gbnVsbDtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyB1bmJpbmQgYWxsIHByb3BlcnR5IGJpbmRpbmdzXG5cdFx0XHRmb3IgKCB2YXIgcHJvcGVyeUJpbmRpbmdLZXkgaW4gdGhpcy5wcm9wZXJ0eUJpbmRpbmdNYXAgKSB7XG5cblx0XHRcdFx0dGhpcy5wcm9wZXJ0eUJpbmRpbmdNYXBbIHByb3BlcnlCaW5kaW5nS2V5IF0udW5iaW5kKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5hY3Rpb25zID0gW107XG5cdFx0XHR0aGlzLnByb3BlcnR5QmluZGluZ01hcCA9IHt9O1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRyZW1vdmVBY3Rpb246IGZ1bmN0aW9uKCBhY3Rpb24gKSB7XG5cblx0XHRcdHZhciBpbmRleCA9IHRoaXMuYWN0aW9ucy5pbmRleE9mKCBhY3Rpb24gKTtcblxuXHRcdFx0aWYgKCBpbmRleCAhPT0gLSAxICkge1xuXG5cdFx0XHRcdHRoaXMuYWN0aW9ucy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdGFjdGlvbi5taXhlciA9IG51bGw7XG5cblx0XHRcdH1cblxuXG5cdFx0XHQvLyByZW1vdmUgdW51c2VkIHByb3BlcnR5IGJpbmRpbmdzIGJlY2F1c2UgaWYgd2UgbGVhdmUgdGhlbSBhcm91bmQgdGhlIG1peGVyIGNhbiBnZXQgc2xvd1xuXHRcdFx0dmFyIHJvb3QgPSBhY3Rpb24ubG9jYWxSb290IHx8IHRoaXMucm9vdDtcblx0XHRcdHZhciB0cmFja3MgPSBhY3Rpb24uY2xpcC50cmFja3M7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRyYWNrcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIHRyYWNrID0gdHJhY2tzWyBpIF07XG5cblx0XHRcdFx0dmFyIHByb3BlcnR5QmluZGluZ0tleSA9IHJvb3QudXVpZCArICctJyArIHRyYWNrLm5hbWU7XG5cdFx0XHRcdHZhciBwcm9wZXJ0eUJpbmRpbmcgPSB0aGlzLnByb3BlcnR5QmluZGluZ01hcFsgcHJvcGVydHlCaW5kaW5nS2V5IF07XG5cblx0XHRcdFx0cHJvcGVydHlCaW5kaW5nLnJlZmVyZW5jZUNvdW50IC09IDE7XG5cblx0XHRcdFx0aWYgKCBwcm9wZXJ0eUJpbmRpbmcucmVmZXJlbmNlQ291bnQgPD0gMCApIHtcblxuXHRcdFx0XHRcdHByb3BlcnR5QmluZGluZy51bmJpbmQoKTtcblxuXHRcdFx0XHRcdGRlbGV0ZSB0aGlzLnByb3BlcnR5QmluZGluZ01hcFsgcHJvcGVydHlCaW5kaW5nS2V5IF07XG5cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHQvLyBjYW4gYmUgb3B0aW1pemVkIGlmIG5lZWRlZFxuXHRcdGZpbmRBY3Rpb25CeU5hbWU6IGZ1bmN0aW9uKCBuYW1lICkge1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmFjdGlvbnMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdGlmICggdGhpcy5hY3Rpb25zW2ldLm5hbWUgPT09IG5hbWUgKSByZXR1cm4gdGhpcy5hY3Rpb25zW2ldO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0fSxcblxuXHRcdHBsYXk6IGZ1bmN0aW9uKCBhY3Rpb24sIG9wdGlvbmFsRmFkZUluRHVyYXRpb24gKSB7XG5cblx0XHRcdGFjdGlvbi5zdGFydFRpbWUgPSB0aGlzLnRpbWU7XG5cdFx0XHR0aGlzLmFkZEFjdGlvbiggYWN0aW9uICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGZhZGVPdXQ6IGZ1bmN0aW9uKCBhY3Rpb24sIGR1cmF0aW9uICkge1xuXG5cdFx0XHR2YXIga2V5cyA9IFtdO1xuXG5cdFx0XHRrZXlzLnB1c2goIHsgdGltZTogdGhpcy50aW1lLCB2YWx1ZTogMSB9ICk7XG5cdFx0XHRrZXlzLnB1c2goIHsgdGltZTogdGhpcy50aW1lICsgZHVyYXRpb24sIHZhbHVlOiAwIH0gKTtcblxuXHRcdFx0YWN0aW9uLndlaWdodCA9IG5ldyBUSFJFRS5OdW1iZXJLZXlmcmFtZVRyYWNrKCBcIndlaWdodFwiLCBrZXlzICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGZhZGVJbjogZnVuY3Rpb24oIGFjdGlvbiwgZHVyYXRpb24gKSB7XG5cblx0XHRcdHZhciBrZXlzID0gW107XG5cblx0XHRcdGtleXMucHVzaCggeyB0aW1lOiB0aGlzLnRpbWUsIHZhbHVlOiAwIH0gKTtcblx0XHRcdGtleXMucHVzaCggeyB0aW1lOiB0aGlzLnRpbWUgKyBkdXJhdGlvbiwgdmFsdWU6IDEgfSApO1xuXG5cdFx0XHRhY3Rpb24ud2VpZ2h0ID0gbmV3IFRIUkVFLk51bWJlcktleWZyYW1lVHJhY2soIFwid2VpZ2h0XCIsIGtleXMgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0d2FycDogZnVuY3Rpb24oIGFjdGlvbiwgc3RhcnRUaW1lU2NhbGUsIGVuZFRpbWVTY2FsZSwgZHVyYXRpb24gKSB7XG5cblx0XHRcdHZhciBrZXlzID0gW107XG5cblx0XHRcdGtleXMucHVzaCggeyB0aW1lOiB0aGlzLnRpbWUsIHZhbHVlOiBzdGFydFRpbWVTY2FsZSB9ICk7XG5cdFx0XHRrZXlzLnB1c2goIHsgdGltZTogdGhpcy50aW1lICsgZHVyYXRpb24sIHZhbHVlOiBlbmRUaW1lU2NhbGUgfSApO1xuXG5cdFx0XHRhY3Rpb24udGltZVNjYWxlID0gbmV3IFRIUkVFLk51bWJlcktleWZyYW1lVHJhY2soIFwidGltZVNjYWxlXCIsIGtleXMgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0Y3Jvc3NGYWRlOiBmdW5jdGlvbiggZmFkZU91dEFjdGlvbiwgZmFkZUluQWN0aW9uLCBkdXJhdGlvbiwgd2FycCApIHtcblxuXHRcdFx0dGhpcy5mYWRlT3V0KCBmYWRlT3V0QWN0aW9uLCBkdXJhdGlvbiApO1xuXHRcdFx0dGhpcy5mYWRlSW4oIGZhZGVJbkFjdGlvbiwgZHVyYXRpb24gKTtcblxuXHRcdFx0aWYgKCB3YXJwICkge1xuXG5cdFx0XHRcdHZhciBzdGFydEVuZFJhdGlvID0gZmFkZU91dEFjdGlvbi5jbGlwLmR1cmF0aW9uIC8gZmFkZUluQWN0aW9uLmNsaXAuZHVyYXRpb247XG5cdFx0XHRcdHZhciBlbmRTdGFydFJhdGlvID0gMS4wIC8gc3RhcnRFbmRSYXRpbztcblxuXHRcdFx0XHR0aGlzLndhcnAoIGZhZGVPdXRBY3Rpb24sIDEuMCwgc3RhcnRFbmRSYXRpbywgZHVyYXRpb24gKTtcblx0XHRcdFx0dGhpcy53YXJwKCBmYWRlSW5BY3Rpb24sIGVuZFN0YXJ0UmF0aW8sIDEuMCwgZHVyYXRpb24gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHR1cGRhdGU6IGZ1bmN0aW9uKCBkZWx0YVRpbWUgKSB7XG5cblx0XHRcdHZhciBtaXhlckRlbHRhVGltZSA9IGRlbHRhVGltZSAqIHRoaXMudGltZVNjYWxlO1xuXHRcdFx0dGhpcy50aW1lICs9IG1peGVyRGVsdGFUaW1lO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmFjdGlvbnMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBhY3Rpb24gPSB0aGlzLmFjdGlvbnNbaV07XG5cblx0XHRcdFx0dmFyIHdlaWdodCA9IGFjdGlvbi5nZXRXZWlnaHRBdCggdGhpcy50aW1lICk7XG5cblx0XHRcdFx0dmFyIGFjdGlvblRpbWVTY2FsZSA9IGFjdGlvbi5nZXRUaW1lU2NhbGVBdCggdGhpcy50aW1lICk7XG5cdFx0XHRcdHZhciBhY3Rpb25EZWx0YVRpbWUgPSBtaXhlckRlbHRhVGltZSAqIGFjdGlvblRpbWVTY2FsZTtcblxuXHRcdFx0XHR2YXIgYWN0aW9uUmVzdWx0cyA9IGFjdGlvbi51cGRhdGUoIGFjdGlvbkRlbHRhVGltZSApO1xuXG5cdFx0XHRcdGlmICggYWN0aW9uLndlaWdodCA8PSAwIHx8ICEgYWN0aW9uLmVuYWJsZWQgKSBjb250aW51ZTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCBhY3Rpb25SZXN1bHRzLmxlbmd0aDsgaiArKyApIHtcblxuXHRcdFx0XHRcdHZhciBuYW1lID0gYWN0aW9uLmNsaXAudHJhY2tzW2pdLm5hbWU7XG5cblx0XHRcdFx0XHRhY3Rpb24ucHJvcGVydHlCaW5kaW5nc1sgaiBdLmFjY3VtdWxhdGUoIGFjdGlvblJlc3VsdHNbal0sIHdlaWdodCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBhcHBseSB0byBub2Rlc1xuXHRcdFx0Zm9yICggdmFyIHByb3BlcnR5QmluZGluZ0tleSBpbiB0aGlzLnByb3BlcnR5QmluZGluZ01hcCApIHtcblxuXHRcdFx0XHR0aGlzLnByb3BlcnR5QmluZGluZ01hcFsgcHJvcGVydHlCaW5kaW5nS2V5IF0uYXBwbHkoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH1cblxuXHR9O1xuXG5cdFRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYXBwbHkoIFRIUkVFLkFuaW1hdGlvbk1peGVyLnByb3RvdHlwZSApO1xuXG5cdC8vIEZpbGU6c3JjL2FuaW1hdGlvbi9BbmltYXRpb25VdGlscy5qc1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIEJlbiBIb3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvL1xuXHQgKiBAYXV0aG9yIERhdmlkIFNhcm5vIC8gaHR0cDovL2xpZ2h0aGF1cy51cy9cblx0ICovXG5cblx0VEhSRUUuQW5pbWF0aW9uVXRpbHMgPSB7XG5cblx0XHRnZXRFcXVhbHNGdW5jOiBmdW5jdGlvbiggZXhlbXBsYXJWYWx1ZSApIHtcblxuXHRcdFx0aWYgKCBleGVtcGxhclZhbHVlLmVxdWFscyApIHtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uIGVxdWFsc19vYmplY3QoIGEsIGIgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGEuZXF1YWxzKCBiICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIGVxdWFsc19wcmltaXRpdmUoIGEsIGIgKSB7XG5cdFx0XHRcdHJldHVybiAoIGEgPT09IGIgKTtcblx0XHRcdH07XG5cblx0XHR9LFxuXG5cdFx0Y2xvbmU6IGZ1bmN0aW9uKCBleGVtcGxhclZhbHVlICkge1xuXG5cdFx0XHR2YXIgdHlwZU5hbWUgPSB0eXBlb2YgZXhlbXBsYXJWYWx1ZTtcblx0XHRcdGlmICggdHlwZU5hbWUgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRcdGlmICggZXhlbXBsYXJWYWx1ZS5jbG9uZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZXhlbXBsYXJWYWx1ZS5jbG9uZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoIFwiY2FuIG5vdCBmaWd1cmUgb3V0IGhvdyB0byBjb3B5IGV4ZW1wbGFyVmFsdWVcIiwgZXhlbXBsYXJWYWx1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZXhlbXBsYXJWYWx1ZTtcblxuXHRcdH0sXG5cblx0XHRsZXJwOiBmdW5jdGlvbiggYSwgYiwgYWxwaGEsIGludGVyVHJhY2sgKSB7XG5cblx0XHRcdHZhciBsZXJwRnVuYyA9IFRIUkVFLkFuaW1hdGlvblV0aWxzLmdldExlcnBGdW5jKCBhLCBpbnRlclRyYWNrICk7XG5cblx0XHRcdHJldHVybiBsZXJwRnVuYyggYSwgYiwgYWxwaGEgKTtcblxuXHRcdH0sXG5cblx0XHRsZXJwX29iamVjdDogZnVuY3Rpb24oIGEsIGIsIGFscGhhICkge1xuXHRcdFx0cmV0dXJuIGEubGVycCggYiwgYWxwaGEgKTtcblx0XHR9LFxuXG5cdFx0c2xlcnBfb2JqZWN0OiBmdW5jdGlvbiggYSwgYiwgYWxwaGEgKSB7XG5cdFx0XHRyZXR1cm4gYS5zbGVycCggYiwgYWxwaGEgKTtcblx0XHR9LFxuXG5cdFx0bGVycF9udW1iZXI6IGZ1bmN0aW9uKCBhLCBiLCBhbHBoYSApIHtcblx0XHRcdHJldHVybiBhICogKCAxIC0gYWxwaGEgKSArIGIgKiBhbHBoYTtcblx0XHR9LFxuXG5cdFx0bGVycF9ib29sZWFuOiBmdW5jdGlvbiggYSwgYiwgYWxwaGEgKSB7XG5cdFx0XHRyZXR1cm4gKCBhbHBoYSA8IDAuNSApID8gYSA6IGI7XG5cdFx0fSxcblxuXHRcdGxlcnBfYm9vbGVhbl9pbW1lZGlhdGU6IGZ1bmN0aW9uKCBhLCBiLCBhbHBoYSApIHtcblx0XHRcdHJldHVybiBhO1xuXHRcdH0sXG5cblx0XHRsZXJwX3N0cmluZzogZnVuY3Rpb24oIGEsIGIsIGFscGhhICkge1xuXHRcdFx0cmV0dXJuICggYWxwaGEgPCAwLjUgKSA/IGEgOiBiO1xuXHRcdH0sXG5cblx0XHRsZXJwX3N0cmluZ19pbW1lZGlhdGU6IGZ1bmN0aW9uKCBhLCBiLCBhbHBoYSApIHtcblx0IFx0XHRyZXR1cm4gYTtcblx0IFx0fSxcblxuXHRcdC8vIE5PVEU6IHRoaXMgaXMgYW4gYWNjdW11bGF0b3IgZnVuY3Rpb24gdGhhdCBtb2RpZmllcyB0aGUgZmlyc3QgYXJndW1lbnQgKGUuZy4gYSkuXHRUaGlzIGlzIHRvIG1pbmltaXplIG1lbW9yeSBhbG9jYXRpb25zLlxuXHRcdGdldExlcnBGdW5jOiBmdW5jdGlvbiggZXhlbXBsYXJWYWx1ZSwgaW50ZXJUcmFjayApIHtcblxuXHRcdFx0aWYgKCBleGVtcGxhclZhbHVlID09PSB1bmRlZmluZWQgfHwgZXhlbXBsYXJWYWx1ZSA9PT0gbnVsbCApIHRocm93IG5ldyBFcnJvciggXCJleGFtcGxhclZhbHVlIGlzIG51bGxcIiApO1xuXG5cdFx0XHR2YXIgdHlwZU5hbWUgPSB0eXBlb2YgZXhlbXBsYXJWYWx1ZTtcblxuXHRcdFx0c3dpdGNoKCB0eXBlTmFtZSApIHtcblxuXHRcdFx0XHRjYXNlIFwib2JqZWN0XCI6XG5cdFx0XHRcdFx0aWYgKCBleGVtcGxhclZhbHVlLmxlcnAgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gVEhSRUUuQW5pbWF0aW9uVXRpbHMubGVycF9vYmplY3Q7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBleGVtcGxhclZhbHVlLnNsZXJwICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIFRIUkVFLkFuaW1hdGlvblV0aWxzLnNsZXJwX29iamVjdDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBcIm51bWJlclwiOlxuXHRcdFx0XHRcdHJldHVybiBUSFJFRS5BbmltYXRpb25VdGlscy5sZXJwX251bWJlcjtcblxuXHRcdFx0XHRjYXNlIFwiYm9vbGVhblwiOlxuXHRcdFx0XHRcdGlmICggaW50ZXJUcmFjayApIHtcblx0XHRcdFx0XHRcdHJldHVybiBUSFJFRS5BbmltYXRpb25VdGlscy5sZXJwX2Jvb2xlYW47XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJldHVybiBUSFJFRS5BbmltYXRpb25VdGlscy5sZXJwX2Jvb2xlYW5faW1tZWRpYXRlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRjYXNlIFwic3RyaW5nXCI6XG5cdFx0XHRcdFx0aWYgKCBpbnRlclRyYWNrICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIFRIUkVFLkFuaW1hdGlvblV0aWxzLmxlcnBfc3RyaW5nO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gVEhSRUUuQW5pbWF0aW9uVXRpbHMubGVycF9zdHJpbmdfaW1tZWRpYXRlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH07XG5cblx0Ly8gRmlsZTpzcmMvYW5pbWF0aW9uL0tleWZyYW1lVHJhY2suanNcblxuXHQvKipcblx0ICpcblx0ICogQSBUcmFjayB0aGF0IHJldHVybnMgYSBrZXlmcmFtZSBpbnRlcnBvbGF0ZWQgdmFsdWUsIGN1cnJlbnRseSBsaW5lYXJseSBpbnRlcnBvbGF0ZWRcblx0ICpcblx0ICogQGF1dGhvciBCZW4gSG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cblx0ICogQGF1dGhvciBEYXZpZCBTYXJubyAvIGh0dHA6Ly9saWdodGhhdXMudXMvXG5cdCAqL1xuXG5cdFRIUkVFLktleWZyYW1lVHJhY2sgPSBmdW5jdGlvbiAoIG5hbWUsIGtleXMgKSB7XG5cblx0XHRpZiAoIG5hbWUgPT09IHVuZGVmaW5lZCApIHRocm93IG5ldyBFcnJvciggXCJ0cmFjayBuYW1lIGlzIHVuZGVmaW5lZFwiICk7XG5cdFx0aWYgKCBrZXlzID09PSB1bmRlZmluZWQgfHwga2V5cy5sZW5ndGggPT09IDAgKSB0aHJvdyBuZXcgRXJyb3IoIFwibm8ga2V5cyBpbiB0cmFjayBuYW1lZCBcIiArIG5hbWUgKTtcblxuXHRcdHRoaXMubmFtZSA9IG5hbWU7XG5cdFx0dGhpcy5rZXlzID0ga2V5cztcdC8vIHRpbWUgaW4gc2Vjb25kcywgdmFsdWUgYXMgdmFsdWVcblxuXHRcdC8vIHRoZSBpbmRleCBvZiB0aGUgbGFzdCByZXN1bHQsIHVzZWQgYXMgYSBzdGFydGluZyBwb2ludCBmb3IgbG9jYWwgc2VhcmNoLlxuXHRcdHRoaXMubGFzdEluZGV4ID0gMDtcblxuXHRcdHRoaXMudmFsaWRhdGUoKTtcblx0XHR0aGlzLm9wdGltaXplKCk7XG5cblx0fTtcblxuXHRUSFJFRS5LZXlmcmFtZVRyYWNrLnByb3RvdHlwZSA9IHtcblxuXHRcdGNvbnN0cnVjdG9yOiBUSFJFRS5LZXlmcmFtZVRyYWNrLFxuXG5cdFx0Z2V0QXQ6IGZ1bmN0aW9uKCB0aW1lICkge1xuXG5cblx0XHRcdC8vIHRoaXMgY2FuIG5vdCBnbyBoaWdoZXIgdGhhbiB0aGlzLmtleXMubGVuZ3RoLlxuXHRcdFx0d2hpbGUoICggdGhpcy5sYXN0SW5kZXggPCB0aGlzLmtleXMubGVuZ3RoICkgJiYgKCB0aW1lID49IHRoaXMua2V5c1t0aGlzLmxhc3RJbmRleF0udGltZSApICkge1xuXHRcdFx0XHR0aGlzLmxhc3RJbmRleCArKztcblx0XHRcdH07XG5cblx0XHRcdC8vIHRoaXMgY2FuIG5vdCBnbyBsb3dlciB0aGFuIDAuXG5cdFx0XHR3aGlsZSggKCB0aGlzLmxhc3RJbmRleCA+IDAgKSAmJiAoIHRpbWUgPCB0aGlzLmtleXNbdGhpcy5sYXN0SW5kZXggLSAxXS50aW1lICkgKSB7XG5cdFx0XHRcdHRoaXMubGFzdEluZGV4IC0tO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHRoaXMubGFzdEluZGV4ID49IHRoaXMua2V5cy5sZW5ndGggKSB7XG5cblx0XHRcdFx0dGhpcy5zZXRSZXN1bHQoIHRoaXMua2V5c1sgdGhpcy5rZXlzLmxlbmd0aCAtIDEgXS52YWx1ZSApO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzLnJlc3VsdDtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHRoaXMubGFzdEluZGV4ID09PSAwICkge1xuXG5cdFx0XHRcdHRoaXMuc2V0UmVzdWx0KCB0aGlzLmtleXNbIDAgXS52YWx1ZSApO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzLnJlc3VsdDtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgcHJldktleSA9IHRoaXMua2V5c1sgdGhpcy5sYXN0SW5kZXggLSAxIF07XG5cdFx0XHR0aGlzLnNldFJlc3VsdCggcHJldktleS52YWx1ZSApO1xuXG5cdFx0XHQvLyBpZiB0cnVlLCBtZWFucyB0aGF0IHByZXYvY3VycmVudCBrZXlzIGFyZSBpZGVudGljYWwsIHRodXMgbm8gaW50ZXJwb2xhdGlvbiByZXF1aXJlZC5cblx0XHRcdGlmICggcHJldktleS5jb25zdGFudFRvTmV4dCApIHtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcy5yZXN1bHQ7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gbGluZWFyIGludGVycG9sYXRpb24gdG8gc3RhcnQgd2l0aFxuXHRcdFx0dmFyIGN1cnJlbnRLZXkgPSB0aGlzLmtleXNbIHRoaXMubGFzdEluZGV4IF07XG5cdFx0XHR2YXIgYWxwaGEgPSAoIHRpbWUgLSBwcmV2S2V5LnRpbWUgKSAvICggY3VycmVudEtleS50aW1lIC0gcHJldktleS50aW1lICk7XG5cdFx0XHR0aGlzLnJlc3VsdCA9IHRoaXMubGVycFZhbHVlcyggdGhpcy5yZXN1bHQsIGN1cnJlbnRLZXkudmFsdWUsIGFscGhhICk7XG5cblx0XHRcdHJldHVybiB0aGlzLnJlc3VsdDtcblxuXHRcdH0sXG5cblx0XHQvLyBtb3ZlIGFsbCBrZXlmcmFtZXMgZWl0aGVyIGZvcndhcmRzIG9yIGJhY2t3YXJkcyBpbiB0aW1lXG5cdFx0c2hpZnQ6IGZ1bmN0aW9uKCB0aW1lT2Zmc2V0ICkge1xuXG5cdFx0XHRpZiAoIHRpbWVPZmZzZXQgIT09IDAuMCApIHtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmtleXMubGVuZ3RoOyBpICsrICkge1xuXHRcdFx0XHRcdHRoaXMua2V5c1tpXS50aW1lICs9IHRpbWVPZmZzZXQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHQvLyBzY2FsZSBhbGwga2V5ZnJhbWUgdGltZXMgYnkgYSBmYWN0b3IgKHVzZWZ1bCBmb3IgZnJhbWUgPC0+IHNlY29uZHMgY29udmVyc2lvbnMpXG5cdFx0c2NhbGU6IGZ1bmN0aW9uKCB0aW1lU2NhbGUgKSB7XG5cblx0XHRcdGlmICggdGltZVNjYWxlICE9PSAxLjAgKSB7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5rZXlzLmxlbmd0aDsgaSArKyApIHtcblx0XHRcdFx0XHR0aGlzLmtleXNbaV0udGltZSAqPSB0aW1lU2NhbGU7XG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHQvLyByZW1vdmVzIGtleWZyYW1lcyBiZWZvcmUgYW5kIGFmdGVyIGFuaW1hdGlvbiB3aXRob3V0IGNoYW5naW5nIGFueSB2YWx1ZXMgd2l0aGluIHRoZSByYW5nZSBbc3RhcnRUaW1lLCBlbmRUaW1lXS5cblx0XHQvLyBJTVBPUlRBTlQ6IFdlIGRvIG5vdCBzaGlmdCBhcm91bmQga2V5cyB0byB0aGUgc3RhcnQgb2YgdGhlIHRyYWNrIHRpbWUsIGJlY2F1c2UgZm9yIGludGVycG9sYXRlZCBrZXlzIHRoaXMgd2lsbCBjaGFuZ2UgdGhlaXIgdmFsdWVzXG5cdCBcdHRyaW06IGZ1bmN0aW9uKCBzdGFydFRpbWUsIGVuZFRpbWUgKSB7XG5cblx0XHRcdHZhciBmaXJzdEtleXNUb1JlbW92ZSA9IDA7XG5cdFx0XHRmb3IgKCB2YXIgaSA9IDE7IGkgPCB0aGlzLmtleXMubGVuZ3RoOyBpICsrICkge1xuXHRcdFx0XHRpZiAoIHRoaXMua2V5c1tpXSA8PSBzdGFydFRpbWUgKSB7XG5cdFx0XHRcdFx0Zmlyc3RLZXlzVG9SZW1vdmUgKys7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dmFyIGxhc3RLZXlzVG9SZW1vdmUgPSAwO1xuXHRcdFx0Zm9yICggdmFyIGkgPSB0aGlzLmtleXMubGVuZ3RoIC0gMjsgaSA+IDA7IGkgKysgKSB7XG5cdFx0XHRcdGlmICggdGhpcy5rZXlzW2ldID49IGVuZFRpbWUgKSB7XG5cdFx0XHRcdFx0bGFzdEtleXNUb1JlbW92ZSArKztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyByZW1vdmUgbGFzdCBrZXlzIGZpcnN0IGJlY2F1c2UgaXQgZG9lc24ndCBhZmZlY3QgdGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBrZXlzICh0aGUgb3RoZXJ3YXkgYXJvdW5kIGRvZXNuJ3Qgd29yayBhcyBlYXNpbHkpXG5cdFx0XHRpZiAoICggZmlyc3RLZXlzVG9SZW1vdmUgKyBsYXN0S2V5c1RvUmVtb3ZlICkgPiAwICkge1xuXHRcdFx0XHR0aGlzLmtleXMgPSB0aGlzLmtleXMuc3BsaWNlKCBmaXJzdEtleXNUb1JlbW92ZSwgdGhpcy5rZXlzLmxlbmd0aCAtIGxhc3RLZXlzVG9SZW1vdmUgLSBmaXJzdEtleXNUb1JlbW92ZSApOztcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0LyogTk9URTogVGhpcyBpcyBjb21tZW50ZWQgb3V0IGJlY2F1c2Ugd2UgcmVhbGx5IHNob3VsZG4ndCBoYXZlIHRvIGhhbmRsZSB1bnNvcnRlZCBrZXkgbGlzdHNcblx0XHQgICAgICAgICBUcmFja3Mgd2l0aCBvdXQgb2Ygb3JkZXIga2V5cyBzaG91bGQgYmUgY29uc2lkZXJlZCB0byBiZSBpbnZhbGlkLiAgLSBiaG91c3RvblxuXHRcdHNvcnQ6IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHR0aGlzLmtleXMuc29ydCggVEhSRUUuS2V5ZnJhbWVUcmFjay5rZXlDb21wYXJlciApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sKi9cblxuXHRcdC8vIGVuc3VyZSB3ZSBkbyBub3QgZ2V0IGEgR2FyYmFnZUluR2FyYmFnZU91dCBzaXR1YXRpb24sIG1ha2Ugc3VyZSB0cmFja3MgYXJlIGF0IGxlYXN0IG1pbmltYWxseSB2aWFibGVcblx0XHQvLyBPbmUgY291bGQgZXZlbnR1YWxseSBlbnN1cmUgdGhhdCBhbGwga2V5LnZhbHVlcyBpbiBhIHRyYWNrIGFyZSBhbGwgb2YgdGhlIHNhbWUgdHlwZSAob3RoZXJ3aXNlIGludGVycG9sYXRpb24gbWFrZXMgbm8gc2Vuc2UuKVxuXHRcdHZhbGlkYXRlOiBmdW5jdGlvbigpIHtcblxuXHRcdFx0dmFyIHByZXZLZXkgPSBudWxsO1xuXG5cdFx0XHRpZiAoIHRoaXMua2V5cy5sZW5ndGggPT09IDAgKSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoIFwiICB0cmFjayBpcyBlbXB0eSwgbm8ga2V5c1wiLCB0aGlzICk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5rZXlzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgY3VycktleSA9IHRoaXMua2V5c1tpXTtcblxuXHRcdFx0XHRpZiAoICEgY3VycktleSApIHtcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCBcIiAga2V5IGlzIG51bGwgaW4gdHJhY2tcIiwgdGhpcywgaSApO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggKCB0eXBlb2YgY3VycktleS50aW1lICkgIT09ICdudW1iZXInIHx8IGlzTmFOKCBjdXJyS2V5LnRpbWUgKSApIHtcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCBcIiAga2V5LnRpbWUgaXMgbm90IGEgdmFsaWQgbnVtYmVyXCIsIHRoaXMsIGksIGN1cnJLZXkgKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGN1cnJLZXkudmFsdWUgPT09IHVuZGVmaW5lZCB8fCBjdXJyS2V5LnZhbHVlID09PSBudWxsKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvciggXCIgIGtleS52YWx1ZSBpcyBudWxsIGluIHRyYWNrXCIsIHRoaXMsIGksIGN1cnJLZXkgKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHByZXZLZXkgJiYgcHJldktleS50aW1lID4gY3VycktleS50aW1lICkge1xuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoIFwiICBrZXkudGltZSBpcyBsZXNzIHRoYW4gcHJldmlvdXMga2V5IHRpbWUsIG91dCBvZiBvcmRlciBrZXlzXCIsIHRoaXMsIGksIGN1cnJLZXksIHByZXZLZXkgKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRwcmV2S2V5ID0gY3VycktleTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHQvLyBjdXJyZW50bHkgb25seSByZW1vdmVzIGVxdWl2YWxlbnQgc2VxdWVudGlhbCBrZXlzICgwLDAsMCwwLDEsMSwxLDAsMCwwLDAsMCwwLDApIC0tPiAoMCwwLDEsMSwwLDApLCB3aGljaCBhcmUgY29tbW9uIGluIG1vcnBoIHRhcmdldCBhbmltYXRpb25zXG5cdFx0b3B0aW1pemU6IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHR2YXIgbmV3S2V5cyA9IFtdO1xuXHRcdFx0dmFyIHByZXZLZXkgPSB0aGlzLmtleXNbMF07XG5cdFx0XHRuZXdLZXlzLnB1c2goIHByZXZLZXkgKTtcblxuXHRcdFx0dmFyIGVxdWFsc0Z1bmMgPSBUSFJFRS5BbmltYXRpb25VdGlscy5nZXRFcXVhbHNGdW5jKCBwcmV2S2V5LnZhbHVlICk7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMTsgaSA8IHRoaXMua2V5cy5sZW5ndGggLSAxOyBpICsrICkge1xuXHRcdFx0XHR2YXIgY3VycktleSA9IHRoaXMua2V5c1tpXTtcblx0XHRcdFx0dmFyIG5leHRLZXkgPSB0aGlzLmtleXNbaSsxXTtcblxuXHRcdFx0XHQvLyBpZiBwcmV2S2V5ICYgY3VycktleSBhcmUgdGhlIHNhbWUgdGltZSwgcmVtb3ZlIGN1cnJLZXkuICBJZiB5b3Ugd2FudCBpbW1lZGlhdGUgYWRqYWNlbnQga2V5cywgdXNlIGFuIGVwc2lsb24gb2Zmc2V0XG5cdFx0XHRcdC8vIGl0IGlzIG5vdCBwb3NzaWJsZSB0byBoYXZlIHR3byBrZXlzIGF0IHRoZSBzYW1lIHRpbWUgYXMgd2Ugc29ydCB0aGVtLiAgVGhlIHNvcnQgaXMgbm90IHN0YWJsZSBvbiBrZXlzIHdpdGggdGhlIHNhbWUgdGltZS5cblx0XHRcdFx0aWYgKCAoIHByZXZLZXkudGltZSA9PT0gY3VycktleS50aW1lICkgKSB7XG5cblx0XHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gcmVtb3ZlIGNvbXBsZXRlbHkgdW5uZWNlc3Nhcnkga2V5ZnJhbWVzIHRoYXQgYXJlIHRoZSBzYW1lIGFzIHRoZWlyIHByZXYgYW5kIG5leHQga2V5c1xuXHRcdFx0XHRpZiAoIHRoaXMuY29tcGFyZVZhbHVlcyggcHJldktleS52YWx1ZSwgY3VycktleS52YWx1ZSApICYmIHRoaXMuY29tcGFyZVZhbHVlcyggY3VycktleS52YWx1ZSwgbmV4dEtleS52YWx1ZSApICkge1xuXG5cdFx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGRldGVybWluZSBpZiBpbnRlcnBvbGF0aW9uIGlzIHJlcXVpcmVkXG5cdFx0XHRcdHByZXZLZXkuY29uc3RhbnRUb05leHQgPSB0aGlzLmNvbXBhcmVWYWx1ZXMoIHByZXZLZXkudmFsdWUsIGN1cnJLZXkudmFsdWUgKTtcblxuXHRcdFx0XHRuZXdLZXlzLnB1c2goIGN1cnJLZXkgKTtcblx0XHRcdFx0cHJldktleSA9IGN1cnJLZXk7XG5cdFx0XHR9XG5cdFx0XHRuZXdLZXlzLnB1c2goIHRoaXMua2V5c1sgdGhpcy5rZXlzLmxlbmd0aCAtIDEgXSApO1xuXG5cdFx0XHR0aGlzLmtleXMgPSBuZXdLZXlzO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH1cblxuXHR9O1xuXG5cdFRIUkVFLktleWZyYW1lVHJhY2sua2V5Q29tcGFyZXIgPSBmdW5jdGlvbiBrZXlDb21wYXJhdG9yKGtleTAsIGtleTEpIHtcblx0XHRyZXR1cm4ga2V5MC50aW1lIC0ga2V5MS50aW1lO1xuXHR9O1xuXG5cdFRIUkVFLktleWZyYW1lVHJhY2sucGFyc2UgPSBmdW5jdGlvbigganNvbiApIHtcblxuXHRcdGlmICgganNvbi50eXBlID09PSB1bmRlZmluZWQgKSB0aHJvdyBuZXcgRXJyb3IoIFwidHJhY2sgdHlwZSB1bmRlZmluZWQsIGNhbiBub3QgcGFyc2VcIiApO1xuXG5cdFx0dmFyIHRyYWNrVHlwZSA9IFRIUkVFLktleWZyYW1lVHJhY2suR2V0VHJhY2tUeXBlRm9yVHlwZU5hbWUoIGpzb24udHlwZSApO1xuXG5cdFx0cmV0dXJuIHRyYWNrVHlwZS5wYXJzZSgganNvbiApO1xuXG5cdH07XG5cblx0VEhSRUUuS2V5ZnJhbWVUcmFjay5HZXRUcmFja1R5cGVGb3JUeXBlTmFtZSA9IGZ1bmN0aW9uKCB0eXBlTmFtZSApIHtcblx0XHRzd2l0Y2goIHR5cGVOYW1lLnRvTG93ZXJDYXNlKCkgKSB7XG5cdFx0IFx0Y2FzZSBcInZlY3RvclwiOlxuXHRcdCBcdGNhc2UgXCJ2ZWN0b3IyXCI6XG5cdFx0IFx0Y2FzZSBcInZlY3RvcjNcIjpcblx0XHQgXHRjYXNlIFwidmVjdG9yNFwiOlxuXHRcdFx0XHRyZXR1cm4gVEhSRUUuVmVjdG9yS2V5ZnJhbWVUcmFjaztcblxuXHRcdCBcdGNhc2UgXCJxdWF0ZXJuaW9uXCI6XG5cdFx0XHRcdHJldHVybiBUSFJFRS5RdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjaztcblxuXHRcdCBcdGNhc2UgXCJpbnRlZ2VyXCI6XG5cdFx0IFx0Y2FzZSBcInNjYWxhclwiOlxuXHRcdCBcdGNhc2UgXCJkb3VibGVcIjpcblx0XHQgXHRjYXNlIFwiZmxvYXRcIjpcblx0XHQgXHRjYXNlIFwibnVtYmVyXCI6XG5cdFx0XHRcdHJldHVybiBUSFJFRS5OdW1iZXJLZXlmcmFtZVRyYWNrO1xuXG5cdFx0IFx0Y2FzZSBcImJvb2xcIjpcblx0XHQgXHRjYXNlIFwiYm9vbGVhblwiOlxuXHRcdFx0XHRyZXR1cm4gVEhSRUUuQm9vbGVhbktleWZyYW1lVHJhY2s7XG5cblx0XHQgXHRjYXNlIFwic3RyaW5nXCI6XG5cdFx0IFx0XHRyZXR1cm4gVEhSRUUuU3RyaW5nS2V5ZnJhbWVUcmFjaztcblx0XHR9O1xuXG5cdFx0dGhyb3cgbmV3IEVycm9yKCBcIlVuc3VwcG9ydGVkIHR5cGVOYW1lOiBcIiArIHR5cGVOYW1lICk7XG5cdH07XG5cblx0Ly8gRmlsZTpzcmMvYW5pbWF0aW9uL1Byb3BlcnR5QmluZGluZy5qc1xuXG5cdC8qKlxuXHQgKlxuXHQgKiBBIHRyYWNrIGJvdW5kIHRvIGEgcmVhbCB2YWx1ZSBpbiB0aGUgc2NlbmUgZ3JhcGguXG5cdCAqXG5cdCAqIEBhdXRob3IgQmVuIEhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW8vXG5cdCAqIEBhdXRob3IgRGF2aWQgU2Fybm8gLyBodHRwOi8vbGlnaHRoYXVzLnVzL1xuXHQgKi9cblxuXHRUSFJFRS5Qcm9wZXJ0eUJpbmRpbmcgPSBmdW5jdGlvbiAoIHJvb3ROb2RlLCB0cmFja05hbWUgKSB7XG5cblx0XHR0aGlzLnJvb3ROb2RlID0gcm9vdE5vZGU7XG5cdFx0dGhpcy50cmFja05hbWUgPSB0cmFja05hbWU7XG5cdFx0dGhpcy5yZWZlcmVuY2VDb3VudCA9IDA7XG5cdFx0dGhpcy5vcmlnaW5hbFZhbHVlID0gbnVsbDsgLy8gdGhlIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eSBiZWZvcmUgaXQgd2FzIGNvbnRyb2xsZWQgYnkgdGhpcyBiaW5kaW5nXG5cblx0XHR2YXIgcGFyc2VSZXN1bHRzID0gVEhSRUUuUHJvcGVydHlCaW5kaW5nLnBhcnNlVHJhY2tOYW1lKCB0cmFja05hbWUgKTtcblxuXHRcdHRoaXMuZGlyZWN0b3J5TmFtZSA9IHBhcnNlUmVzdWx0cy5kaXJlY3RvcnlOYW1lO1xuXHRcdHRoaXMubm9kZU5hbWUgPSBwYXJzZVJlc3VsdHMubm9kZU5hbWU7XG5cdFx0dGhpcy5vYmplY3ROYW1lID0gcGFyc2VSZXN1bHRzLm9iamVjdE5hbWU7XG5cdFx0dGhpcy5vYmplY3RJbmRleCA9IHBhcnNlUmVzdWx0cy5vYmplY3RJbmRleDtcblx0XHR0aGlzLnByb3BlcnR5TmFtZSA9IHBhcnNlUmVzdWx0cy5wcm9wZXJ0eU5hbWU7XG5cdFx0dGhpcy5wcm9wZXJ0eUluZGV4ID0gcGFyc2VSZXN1bHRzLnByb3BlcnR5SW5kZXg7XG5cblx0XHR0aGlzLm5vZGUgPSBUSFJFRS5Qcm9wZXJ0eUJpbmRpbmcuZmluZE5vZGUoIHJvb3ROb2RlLCB0aGlzLm5vZGVOYW1lICkgfHwgcm9vdE5vZGU7XG5cblx0XHR0aGlzLmN1bXVsYXRpdmVWYWx1ZSA9IG51bGw7XG5cdFx0dGhpcy5jdW11bGF0aXZlV2VpZ2h0ID0gMDtcblx0fTtcblxuXHRUSFJFRS5Qcm9wZXJ0eUJpbmRpbmcucHJvdG90eXBlID0ge1xuXG5cdFx0Y29uc3RydWN0b3I6IFRIUkVFLlByb3BlcnR5QmluZGluZyxcblxuXHRcdHJlc2V0OiBmdW5jdGlvbigpIHtcblxuXHRcdFx0dGhpcy5jdW11bGF0aXZlVmFsdWUgPSBudWxsO1xuXHRcdFx0dGhpcy5jdW11bGF0aXZlV2VpZ2h0ID0gMDtcblxuXHRcdH0sXG5cblx0XHRhY2N1bXVsYXRlOiBmdW5jdGlvbiggdmFsdWUsIHdlaWdodCApIHtcblxuXHRcdFx0aWYgKCAhIHRoaXMuaXNCb3VuZCApIHRoaXMuYmluZCgpO1xuXG5cdFx0XHRpZiAoIHRoaXMuY3VtdWxhdGl2ZVdlaWdodCA9PT0gMCApIHtcblxuXHRcdFx0XHRpZiAoIHdlaWdodCA+IDAgKSB7XG5cblx0XHRcdFx0XHRpZiAoIHRoaXMuY3VtdWxhdGl2ZVZhbHVlID09PSBudWxsICkge1xuXHRcdFx0XHRcdFx0dGhpcy5jdW11bGF0aXZlVmFsdWUgPSBUSFJFRS5BbmltYXRpb25VdGlscy5jbG9uZSggdmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5jdW11bGF0aXZlV2VpZ2h0ID0gd2VpZ2h0O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR2YXIgbGVycEFscGhhID0gd2VpZ2h0IC8gKCB0aGlzLmN1bXVsYXRpdmVXZWlnaHQgKyB3ZWlnaHQgKTtcblx0XHRcdFx0dGhpcy5jdW11bGF0aXZlVmFsdWUgPSB0aGlzLmxlcnBWYWx1ZSggdGhpcy5jdW11bGF0aXZlVmFsdWUsIHZhbHVlLCBsZXJwQWxwaGEgKTtcblx0XHRcdFx0dGhpcy5jdW11bGF0aXZlV2VpZ2h0ICs9IHdlaWdodDtcblxuXHRcdFx0fVxuXG5cdFx0fSxcblxuXHRcdHVuYmluZDogZnVuY3Rpb24oKSB7XG5cblx0XHRcdGlmICggISB0aGlzLmlzQm91bmQgKSByZXR1cm47XG5cblx0XHRcdHRoaXMuc2V0VmFsdWUoIHRoaXMub3JpZ2luYWxWYWx1ZSApO1xuXG5cdFx0XHR0aGlzLnNldFZhbHVlID0gbnVsbDtcblx0XHRcdHRoaXMuZ2V0VmFsdWUgPSBudWxsO1xuXHRcdFx0dGhpcy5sZXJwVmFsdWUgPSBudWxsO1xuXHRcdFx0dGhpcy5lcXVhbHNWYWx1ZSA9IG51bGw7XG5cdFx0XHR0aGlzLnRyaWdnZXJEaXJ0eSA9IG51bGw7XG5cdFx0XHR0aGlzLmlzQm91bmQgPSBmYWxzZTtcblxuXHRcdH0sXG5cblx0XHQvLyBiaW5kIHRvIHRoZSByZWFsIHByb3BlcnR5IGluIHRoZSBzY2VuZSBncmFwaCwgcmVtZW1iZXIgb3JpZ2luYWwgdmFsdWUsIG1lbW9yaXplIHZhcmlvdXMgYWNjZXNzb3JzIGZvciBzcGVlZC9pbmVmZmljaWVuY3lcblx0XHRiaW5kOiBmdW5jdGlvbigpIHtcblxuXHRcdFx0aWYgKCB0aGlzLmlzQm91bmQgKSByZXR1cm47XG5cblx0XHRcdHZhciB0YXJnZXRPYmplY3QgPSB0aGlzLm5vZGU7XG5cblx0IFx0XHQvLyBlbnN1cmUgdGhlcmUgaXMgYSB2YWx1ZSBub2RlXG5cdFx0XHRpZiAoICEgdGFyZ2V0T2JqZWN0ICkge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKCBcIiAgdHJ5aW5nIHRvIHVwZGF0ZSBub2RlIGZvciB0cmFjazogXCIgKyB0aGlzLnRyYWNrTmFtZSArIFwiIGJ1dCBpdCB3YXNuJ3QgZm91bmQuXCIgKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHRoaXMub2JqZWN0TmFtZSApIHtcblx0XHRcdFx0Ly8gc3BlY2lhbCBjYXNlIHdlcmUgd2UgbmVlZCB0byByZWFjaCBkZWVwZXIgaW50byB0aGUgaGllcmFyY2h5IHRvIGdldCB0aGUgZmFjZSBtYXRlcmlhbHMuLi4uXG5cdFx0XHRcdGlmICggdGhpcy5vYmplY3ROYW1lID09PSBcIm1hdGVyaWFsc1wiICkge1xuXHRcdFx0XHRcdGlmICggISB0YXJnZXRPYmplY3QubWF0ZXJpYWwgKSB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnICBjYW4gbm90IGJpbmQgdG8gbWF0ZXJpYWwgYXMgbm9kZSBkb2VzIG5vdCBoYXZlIGEgbWF0ZXJpYWwnLCB0aGlzICk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggISB0YXJnZXRPYmplY3QubWF0ZXJpYWwubWF0ZXJpYWxzICkge1xuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJyAgY2FuIG5vdCBiaW5kIHRvIG1hdGVyaWFsLm1hdGVyaWFscyBhcyBub2RlLm1hdGVyaWFsIGRvZXMgbm90IGhhdmUgYSBtYXRlcmlhbHMgYXJyYXknLCB0aGlzICk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRhcmdldE9iamVjdCA9IHRhcmdldE9iamVjdC5tYXRlcmlhbC5tYXRlcmlhbHM7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIHRoaXMub2JqZWN0TmFtZSA9PT0gXCJib25lc1wiICkge1xuXHRcdFx0XHRcdGlmICggISB0YXJnZXRPYmplY3Quc2tlbGV0b24gKSB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnICBjYW4gbm90IGJpbmQgdG8gYm9uZXMgYXMgbm9kZSBkb2VzIG5vdCBoYXZlIGEgc2tlbGV0b24nLCB0aGlzICk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIHBvdGVudGlhbCBmdXR1cmUgb3B0aW1pemF0aW9uOiBza2lwIHRoaXMgaWYgcHJvcGVydHlJbmRleCBpcyBhbHJlYWR5IGFuIGludGVnZXIsIGFuZCBjb252ZXJ0IHRoZSBpbnRlZ2VyIHN0cmluZyB0byBhIHRydWUgaW50ZWdlci5cblxuXHRcdFx0XHRcdHRhcmdldE9iamVjdCA9IHRhcmdldE9iamVjdC5za2VsZXRvbi5ib25lcztcblxuXHRcdFx0XHRcdC8vIHN1cHBvcnQgcmVzb2x2aW5nIG1vcnBoVGFyZ2V0IG5hbWVzIGludG8gaW5kaWNlcy5cblx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0YXJnZXRPYmplY3QubGVuZ3RoOyBpICsrICkge1xuXHRcdFx0XHRcdFx0aWYgKCB0YXJnZXRPYmplY3RbaV0ubmFtZSA9PT0gdGhpcy5vYmplY3RJbmRleCApIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5vYmplY3RJbmRleCA9IGk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGlmICggdGFyZ2V0T2JqZWN0WyB0aGlzLm9iamVjdE5hbWUgXSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJyAgY2FuIG5vdCBiaW5kIHRvIG9iamVjdE5hbWUgb2Ygbm9kZSwgdW5kZWZpbmVkJywgdGhpcyApO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0YXJnZXRPYmplY3QgPSB0YXJnZXRPYmplY3RbIHRoaXMub2JqZWN0TmFtZSBdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCB0aGlzLm9iamVjdEluZGV4ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0aWYgKCB0YXJnZXRPYmplY3RbIHRoaXMub2JqZWN0SW5kZXggXSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggXCIgIHRyeWluZyB0byBiaW5kIHRvIG9iamVjdEluZGV4IG9mIG9iamVjdE5hbWUsIGJ1dCBpcyB1bmRlZmluZWQ6XCIsIHRoaXMsIHRhcmdldE9iamVjdCApO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRhcmdldE9iamVjdCA9IHRhcmdldE9iamVjdFsgdGhpcy5vYmplY3RJbmRleCBdO1xuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHQgXHRcdC8vIHNwZWNpYWwgY2FzZSBtYXBwaW5nc1xuXHQgXHRcdHZhciBub2RlUHJvcGVydHkgPSB0YXJnZXRPYmplY3RbIHRoaXMucHJvcGVydHlOYW1lIF07XG5cdFx0XHRpZiAoICEgbm9kZVByb3BlcnR5ICkge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKCBcIiAgdHJ5aW5nIHRvIHVwZGF0ZSBwcm9wZXJ0eSBmb3IgdHJhY2s6IFwiICsgdGhpcy5ub2RlTmFtZSArICcuJyArIHRoaXMucHJvcGVydHlOYW1lICsgXCIgYnV0IGl0IHdhc24ndCBmb3VuZC5cIiwgdGFyZ2V0T2JqZWN0ICk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gYWNjZXNzIGEgc3ViIGVsZW1lbnQgb2YgdGhlIHByb3BlcnR5IGFycmF5IChvbmx5IHByaW1pdGl2ZXMgYXJlIHN1cHBvcnRlZCByaWdodCBub3cpXG5cdFx0XHRpZiAoIHRoaXMucHJvcGVydHlJbmRleCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGlmICggdGhpcy5wcm9wZXJ0eU5hbWUgPT09IFwibW9ycGhUYXJnZXRJbmZsdWVuY2VzXCIgKSB7XG5cdFx0XHRcdFx0Ly8gcG90ZW50aWFsIG9wdGltaXphdGlvbiwgc2tpcCB0aGlzIGlmIHByb3BlcnR5SW5kZXggaXMgYWxyZWFkeSBhbiBpbnRlZ2VyLCBhbmQgY29udmVydCB0aGUgaW50ZWdlciBzdHJpbmcgdG8gYSB0cnVlIGludGVnZXIuXG5cblx0XHRcdFx0XHQvLyBzdXBwb3J0IHJlc29sdmluZyBtb3JwaFRhcmdldCBuYW1lcyBpbnRvIGluZGljZXMuXG5cdFx0XHRcdFx0aWYgKCAhIHRhcmdldE9iamVjdC5nZW9tZXRyeSApIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICcgIGNhbiBub3QgYmluZCB0byBtb3JwaFRhcmdldEluZmx1ZW5jZXMgYmVjYXN1c2Ugbm9kZSBkb2VzIG5vdCBoYXZlIGEgZ2VvbWV0cnknLCB0aGlzICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggISB0YXJnZXRPYmplY3QuZ2VvbWV0cnkubW9ycGhUYXJnZXRzICkge1xuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJyAgY2FuIG5vdCBiaW5kIHRvIG1vcnBoVGFyZ2V0SW5mbHVlbmNlcyBiZWNhc3VzZSBub2RlIGRvZXMgbm90IGhhdmUgYSBnZW9tZXRyeS5tb3JwaFRhcmdldHMnLCB0aGlzICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5ub2RlLmdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5sZW5ndGg7IGkgKysgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIHRhcmdldE9iamVjdC5nZW9tZXRyeS5tb3JwaFRhcmdldHNbaV0ubmFtZSA9PT0gdGhpcy5wcm9wZXJ0eUluZGV4ICkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnByb3BlcnR5SW5kZXggPSBpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLnNldFZhbHVlID0gZnVuY3Rpb24gc2V0VmFsdWVfcHJvcGVydHlJbmRleGVkKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRpZiAoICEgdGhpcy5lcXVhbHNWYWx1ZSggbm9kZVByb3BlcnR5WyB0aGlzLnByb3BlcnR5SW5kZXggXSwgdmFsdWUgKSApIHtcblx0XHRcdFx0XHRcdG5vZGVQcm9wZXJ0eVsgdGhpcy5wcm9wZXJ0eUluZGV4IF0gPSB2YWx1ZTtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0dGhpcy5nZXRWYWx1ZSA9IGZ1bmN0aW9uIGdldFZhbHVlX3Byb3BlcnR5SW5kZXhlZCgpIHtcblx0XHRcdFx0XHRyZXR1cm4gbm9kZVByb3BlcnR5WyB0aGlzLnByb3BlcnR5SW5kZXggXTtcblx0XHRcdFx0fTtcblxuXHRcdFx0fVxuXHRcdFx0Ly8gbXVzdCB1c2UgY29weSBmb3IgT2JqZWN0M0QuRXVsZXIvUXVhdGVybmlvblxuXHRcdFx0ZWxzZSBpZiAoIG5vZGVQcm9wZXJ0eS5jb3B5ICkge1xuXG5cdFx0XHRcdHRoaXMuc2V0VmFsdWUgPSBmdW5jdGlvbiBzZXRWYWx1ZV9wcm9wZXJ0eU9iamVjdCggdmFsdWUgKSB7XG5cdFx0XHRcdFx0aWYgKCAhIHRoaXMuZXF1YWxzVmFsdWUoIG5vZGVQcm9wZXJ0eSwgdmFsdWUgKSApIHtcblx0XHRcdFx0XHRcdG5vZGVQcm9wZXJ0eS5jb3B5KCB2YWx1ZSApO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuZ2V0VmFsdWUgPSBmdW5jdGlvbiBnZXRWYWx1ZV9wcm9wZXJ0eU9iamVjdCgpIHtcblx0XHRcdFx0XHRyZXR1cm4gbm9kZVByb3BlcnR5O1xuXHRcdFx0XHR9O1xuXG5cdFx0XHR9XG5cdFx0XHQvLyBvdGhlcndpc2UganVzdCBzZXQgdGhlIHByb3BlcnR5IGRpcmVjdGx5IG9uIHRoZSBub2RlIChkbyBub3QgdXNlIG5vZGVQcm9wZXJ0eSBhcyBpdCBtYXkgbm90IGJlIGEgcmVmZXJlbmNlIG9iamVjdClcblx0XHRcdGVsc2Uge1xuXG5cdFx0XHRcdHRoaXMuc2V0VmFsdWUgPSBmdW5jdGlvbiBzZXRWYWx1ZV9wcm9wZXJ0eSggdmFsdWUgKSB7XG5cdFx0XHRcdFx0aWYgKCAhIHRoaXMuZXF1YWxzVmFsdWUoIHRhcmdldE9iamVjdFsgdGhpcy5wcm9wZXJ0eU5hbWUgXSwgdmFsdWUgKSApIHtcblx0XHRcdFx0XHRcdHRhcmdldE9iamVjdFsgdGhpcy5wcm9wZXJ0eU5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuZ2V0VmFsdWUgPSBmdW5jdGlvbiBnZXRWYWx1ZV9wcm9wZXJ0eSgpIHtcblx0XHRcdFx0XHRyZXR1cm4gdGFyZ2V0T2JqZWN0WyB0aGlzLnByb3BlcnR5TmFtZSBdO1xuXHRcdFx0XHR9O1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHRyaWdnZXIgbm9kZSBkaXJ0eVxuXHRcdFx0aWYgKCB0YXJnZXRPYmplY3QubmVlZHNVcGRhdGUgIT09IHVuZGVmaW5lZCApIHsgLy8gbWF0ZXJpYWxcblxuXHRcdFx0XHR0aGlzLnRyaWdnZXJEaXJ0eSA9IGZ1bmN0aW9uIHRyaWdnZXJEaXJ0eV9uZWVkc1VwZGF0ZSgpIHtcblx0XHRcdFx0XHR0aGlzLm5vZGUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAoIHRhcmdldE9iamVjdC5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlICE9PSB1bmRlZmluZWQgKSB7IC8vIG5vZGUgdHJhbnNmb3JtXG5cblx0XHRcdFx0dGhpcy50cmlnZ2VyRGlydHkgPSBmdW5jdGlvbiB0cmlnZ2VyRGlydHlfbWF0cml4V29ybGROZWVkc1VwZGF0ZSgpIHtcblx0XHRcdFx0XHR0YXJnZXRPYmplY3QubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLm9yaWdpbmFsVmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XG5cblx0XHRcdHRoaXMuZXF1YWxzVmFsdWUgPSBUSFJFRS5BbmltYXRpb25VdGlscy5nZXRFcXVhbHNGdW5jKCB0aGlzLm9yaWdpbmFsVmFsdWUgKTtcblx0XHRcdHRoaXMubGVycFZhbHVlID0gVEhSRUUuQW5pbWF0aW9uVXRpbHMuZ2V0TGVycEZ1bmMoIHRoaXMub3JpZ2luYWxWYWx1ZSwgdHJ1ZSApO1xuXG5cdFx0XHR0aGlzLmlzQm91bmQgPSB0cnVlO1xuXG5cdFx0fSxcblxuXHRcdGFwcGx5OiBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gZm9yIHNwZWVkIGNhcHR1cmUgdGhlIHNldHRlciBwYXR0ZXJuIGFzIGEgY2xvc3VyZSAoc29ydCBvZiBhIG1lbW9pemF0aW9uIHBhdHRlcm46IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01lbW9pemF0aW9uKVxuXHRcdFx0aWYgKCAhIHRoaXMuaXNCb3VuZCApIHRoaXMuYmluZCgpO1xuXG5cdFx0XHQvLyBlYXJseSBleGl0IGlmIHRoZXJlIGlzIG5vdGhpbmcgdG8gYXBwbHkuXG5cdFx0XHRpZiAoIHRoaXMuY3VtdWxhdGl2ZVdlaWdodCA+IDAgKSB7XG5cblx0XHRcdFx0Ly8gYmxlbmQgd2l0aCBvcmlnaW5hbCB2YWx1ZVxuXHRcdFx0XHRpZiAoIHRoaXMuY3VtdWxhdGl2ZVdlaWdodCA8IDEgKSB7XG5cblx0XHRcdFx0XHR2YXIgcmVtYWluaW5nV2VpZ2h0ID0gMSAtIHRoaXMuY3VtdWxhdGl2ZVdlaWdodDtcblx0XHRcdFx0XHR2YXIgbGVycEFscGhhID0gcmVtYWluaW5nV2VpZ2h0IC8gKCB0aGlzLmN1bXVsYXRpdmVXZWlnaHQgKyByZW1haW5pbmdXZWlnaHQgKTtcblx0XHRcdFx0XHR0aGlzLmN1bXVsYXRpdmVWYWx1ZSA9IHRoaXMubGVycFZhbHVlKCB0aGlzLmN1bXVsYXRpdmVWYWx1ZSwgdGhpcy5vcmlnaW5hbFZhbHVlLCBsZXJwQWxwaGEgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIHZhbHVlQ2hhbmdlZCA9IHRoaXMuc2V0VmFsdWUoIHRoaXMuY3VtdWxhdGl2ZVZhbHVlICk7XG5cblx0XHRcdFx0aWYgKCB2YWx1ZUNoYW5nZWQgJiYgdGhpcy50cmlnZ2VyRGlydHkgKSB7XG5cdFx0XHRcdFx0dGhpcy50cmlnZ2VyRGlydHkoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHJlc2V0IGFjY3VtdWxhdG9yXG5cdFx0XHRcdHRoaXMuY3VtdWxhdGl2ZVZhbHVlID0gbnVsbDtcblx0XHRcdFx0dGhpcy5jdW11bGF0aXZlV2VpZ2h0ID0gMDtcblxuXHRcdFx0fVxuXHRcdH1cblxuXHR9O1xuXG5cblx0VEhSRUUuUHJvcGVydHlCaW5kaW5nLnBhcnNlVHJhY2tOYW1lID0gZnVuY3Rpb24oIHRyYWNrTmFtZSApIHtcblxuXHRcdC8vIG1hdGNoZXMgc3RyaW5ncyBpbiB0aGUgZm9ybSBvZjpcblx0XHQvLyAgICBub2RlTmFtZS5wcm9wZXJ0eVxuXHRcdC8vICAgIG5vZGVOYW1lLnByb3BlcnR5W2FjY2Vzc29yXVxuXHRcdC8vICAgIG5vZGVOYW1lLm1hdGVyaWFsLnByb3BlcnR5W2FjY2Vzc29yXVxuXHRcdC8vICAgIHV1aWQucHJvcGVydHlbYWNjZXNzb3JdXG5cdFx0Ly8gICAgdXVpZC5vYmplY3ROYW1lW29iamVjdEluZGV4XS5wcm9wZXJ0eU5hbWVbcHJvcGVydHlJbmRleF1cblx0XHQvLyAgICBwYXJlbnROYW1lL25vZGVOYW1lLnByb3BlcnR5XG5cdFx0Ly8gICAgcGFyZW50TmFtZS9wYXJlbnROYW1lL25vZGVOYW1lLnByb3BlcnR5W2luZGV4XVxuXHRcdC8vXHQgIC5ib25lW0FybWF0dXJlLkRFRl9jb2ddLnBvc2l0aW9uXG5cdFx0Ly8gY3JlYXRlZCBhbmQgdGVzdGVkIHZpYSBodHRwczovL3JlZ2V4MTAxLmNvbS8jamF2YXNjcmlwdFxuXG5cdFx0dmFyIHJlID0gL14oKFtcXHddK1xcLykqKShbXFx3LVxcZF0rKT8oXFwuKFtcXHddKykoXFxbKFtcXHdcXGRcXFtcXF1cXF8uIF0rKVxcXSk/KT8oXFwuKFtcXHcuXSspKFxcWyhbXFx3XFxkXFxbXFxdXFxfLiBdKylcXF0pPykkLztcblx0XHR2YXIgbWF0Y2hlcyA9IHJlLmV4ZWModHJhY2tOYW1lKTtcblxuXHRcdGlmICggISBtYXRjaGVzICkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCBcImNhbm5vdCBwYXJzZSB0cmFja05hbWUgYXQgYWxsOiBcIiArIHRyYWNrTmFtZSApO1xuXHRcdH1cblxuXHQgICAgaWYgKG1hdGNoZXMuaW5kZXggPT09IHJlLmxhc3RJbmRleCkge1xuXHQgICAgICAgIHJlLmxhc3RJbmRleCsrO1xuXHQgICAgfVxuXG5cdFx0dmFyIHJlc3VsdHMgPSB7XG5cdFx0XHRkaXJlY3RvcnlOYW1lOiBtYXRjaGVzWzFdLFxuXHRcdFx0bm9kZU5hbWU6IG1hdGNoZXNbM10sIFx0Ly8gYWxsb3dlZCB0byBiZSBudWxsLCBzcGVjaWZpZWQgcm9vdCBub2RlLlxuXHRcdFx0b2JqZWN0TmFtZTogbWF0Y2hlc1s1XSxcblx0XHRcdG9iamVjdEluZGV4OiBtYXRjaGVzWzddLFxuXHRcdFx0cHJvcGVydHlOYW1lOiBtYXRjaGVzWzldLFxuXHRcdFx0cHJvcGVydHlJbmRleDogbWF0Y2hlc1sxMV1cdC8vIGFsbG93ZWQgdG8gYmUgbnVsbCwgc3BlY2lmaWVzIHRoYXQgdGhlIHdob2xlIHByb3BlcnR5IGlzIHNldC5cblx0XHR9O1xuXG5cdFx0aWYgKCByZXN1bHRzLnByb3BlcnR5TmFtZSA9PT0gbnVsbCB8fCByZXN1bHRzLnByb3BlcnR5TmFtZS5sZW5ndGggPT09IDAgKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoIFwiY2FuIG5vdCBwYXJzZSBwcm9wZXJ0eU5hbWUgZnJvbSB0cmFja05hbWU6IFwiICsgdHJhY2tOYW1lICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdHM7XG5cblx0fTtcblxuXHRUSFJFRS5Qcm9wZXJ0eUJpbmRpbmcuZmluZE5vZGUgPSBmdW5jdGlvbiggcm9vdCwgbm9kZU5hbWUgKSB7XG5cblx0XHRmdW5jdGlvbiBzZWFyY2hTa2VsZXRvbiggc2tlbGV0b24gKSB7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHNrZWxldG9uLmJvbmVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgYm9uZSA9IHNrZWxldG9uLmJvbmVzW2ldO1xuXG5cdFx0XHRcdGlmICggYm9uZS5uYW1lID09PSBub2RlTmFtZSApIHtcblxuXHRcdFx0XHRcdHJldHVybiBib25lO1xuXG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBzZWFyY2hOb2RlU3VidHJlZSggY2hpbGRyZW4gKSB7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgY2hpbGROb2RlID0gY2hpbGRyZW5baV07XG5cblx0XHRcdFx0aWYgKCBjaGlsZE5vZGUubmFtZSA9PT0gbm9kZU5hbWUgfHwgY2hpbGROb2RlLnV1aWQgPT09IG5vZGVOYW1lICkge1xuXG5cdFx0XHRcdFx0cmV0dXJuIGNoaWxkTm9kZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIHJlc3VsdCA9IHNlYXJjaE5vZGVTdWJ0cmVlKCBjaGlsZE5vZGUuY2hpbGRyZW4gKTtcblxuXHRcdFx0XHRpZiAoIHJlc3VsdCApIHJldHVybiByZXN1bHQ7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR9XG5cblx0XHQvL1xuXG5cdFx0aWYgKCAhIG5vZGVOYW1lIHx8IG5vZGVOYW1lID09PSBcIlwiIHx8IG5vZGVOYW1lID09PSBcInJvb3RcIiB8fCBub2RlTmFtZSA9PT0gXCIuXCIgfHwgbm9kZU5hbWUgPT09IC0xIHx8IG5vZGVOYW1lID09PSByb290Lm5hbWUgfHwgbm9kZU5hbWUgPT09IHJvb3QudXVpZCApIHtcblxuXHRcdFx0cmV0dXJuIHJvb3Q7XG5cblx0XHR9XG5cblx0XHQvLyBzZWFyY2ggaW50byBza2VsZXRvbiBib25lcy5cblx0XHRpZiAoIHJvb3Quc2tlbGV0b24gKSB7XG5cblx0XHRcdHZhciBib25lID0gc2VhcmNoU2tlbGV0b24oIHJvb3Quc2tlbGV0b24gKTtcblxuXHRcdFx0aWYgKCBib25lICkge1xuXG5cdFx0XHRcdHJldHVybiBib25lO1xuXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gc2VhcmNoIGludG8gbm9kZSBzdWJ0cmVlLlxuXHRcdGlmICggcm9vdC5jaGlsZHJlbiApIHtcblxuXHRcdFx0dmFyIHN1YlRyZWVOb2RlID0gc2VhcmNoTm9kZVN1YnRyZWUoIHJvb3QuY2hpbGRyZW4gKTtcblxuXHRcdFx0aWYgKCBzdWJUcmVlTm9kZSApIHtcblxuXHRcdFx0XHRyZXR1cm4gc3ViVHJlZU5vZGU7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gRmlsZTpzcmMvYW5pbWF0aW9uL3RyYWNrcy9WZWN0b3JLZXlmcmFtZVRyYWNrLmpzXG5cblx0LyoqXG5cdCAqXG5cdCAqIEEgVHJhY2sgdGhhdCBpbnRlcnBvbGF0ZXMgVmVjdG9yc1xuXHQgKlxuXHQgKiBAYXV0aG9yIEJlbiBIb3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvL1xuXHQgKiBAYXV0aG9yIERhdmlkIFNhcm5vIC8gaHR0cDovL2xpZ2h0aGF1cy51cy9cblx0ICovXG5cblx0VEhSRUUuVmVjdG9yS2V5ZnJhbWVUcmFjayA9IGZ1bmN0aW9uICggbmFtZSwga2V5cyApIHtcblxuXHRcdFRIUkVFLktleWZyYW1lVHJhY2suY2FsbCggdGhpcywgbmFtZSwga2V5cyApO1xuXG5cdFx0Ly8gbG9jYWwgY2FjaGUgb2YgdmFsdWUgdHlwZSB0byBhdm9pZCBhbGxvY2F0aW9ucyBkdXJpbmcgcnVudGltZS5cblx0XHR0aGlzLnJlc3VsdCA9IHRoaXMua2V5c1swXS52YWx1ZS5jbG9uZSgpO1xuXG5cdH07XG5cblx0VEhSRUUuVmVjdG9yS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5LZXlmcmFtZVRyYWNrLnByb3RvdHlwZSApO1xuXG5cdFRIUkVFLlZlY3RvcktleWZyYW1lVHJhY2sucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuVmVjdG9yS2V5ZnJhbWVUcmFjaztcblxuXHRUSFJFRS5WZWN0b3JLZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5zZXRSZXN1bHQgPSBmdW5jdGlvbiggdmFsdWUgKSB7XG5cblx0XHR0aGlzLnJlc3VsdC5jb3B5KCB2YWx1ZSApO1xuXG5cdH07XG5cblx0Ly8gbWVtb2l6YXRpb24gb2YgdGhlIGxlcnAgZnVuY3Rpb24gZm9yIHNwZWVkLlxuXHQvLyBOT1RFOiBEbyBub3Qgb3B0aW1pemUgYXMgYSBwcm90b3R5cGUgaW5pdGlhbGl6YXRpb24gY2xvc3VyZSwgYXMgdmFsdWUwIHdpbGwgYmUgZGlmZmVyZW50IG9uIGEgcGVyIGNsYXNzIGJhc2lzLlxuXHRUSFJFRS5WZWN0b3JLZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5sZXJwVmFsdWVzID0gZnVuY3Rpb24oIHZhbHVlMCwgdmFsdWUxLCBhbHBoYSApIHtcblxuXHRcdHJldHVybiB2YWx1ZTAubGVycCggdmFsdWUxLCBhbHBoYSApO1xuXG5cdH07XG5cblx0VEhSRUUuVmVjdG9yS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuY29tcGFyZVZhbHVlcyA9IGZ1bmN0aW9uKCB2YWx1ZTAsIHZhbHVlMSApIHtcblxuXHRcdHJldHVybiB2YWx1ZTAuZXF1YWxzKCB2YWx1ZTEgKTtcblxuXHR9O1xuXG5cdFRIUkVFLlZlY3RvcktleWZyYW1lVHJhY2sucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgY2xvbmVkS2V5cyA9IFtdO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5rZXlzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0dmFyIGtleSA9IHRoaXMua2V5c1tpXTtcblx0XHRcdGNsb25lZEtleXMucHVzaCgge1xuXHRcdFx0XHR0aW1lOiBrZXkudGltZSxcblx0XHRcdFx0dmFsdWU6IGtleS52YWx1ZS5jbG9uZSgpXG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5WZWN0b3JLZXlmcmFtZVRyYWNrKCB0aGlzLm5hbWUsIGNsb25lZEtleXMgKTtcblxuXHR9O1xuXG5cdFRIUkVFLlZlY3RvcktleWZyYW1lVHJhY2sucGFyc2UgPSBmdW5jdGlvbigganNvbiApIHtcblxuXHRcdHZhciBlbGVtZW50Q291bnQgPSBqc29uLmtleXNbMF0udmFsdWUubGVuZ3RoO1xuXHRcdHZhciB2YWx1ZVR5cGUgPSBUSFJFRVsgJ1ZlY3RvcicgKyBlbGVtZW50Q291bnQgXTtcblxuXHRcdHZhciBrZXlzID0gW107XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBqc29uLmtleXMubGVuZ3RoOyBpICsrICkge1xuXHRcdFx0dmFyIGpzb25LZXkgPSBqc29uLmtleXNbaV07XG5cdFx0XHRrZXlzLnB1c2goIHtcblx0XHRcdFx0dmFsdWU6IG5ldyB2YWx1ZVR5cGUoKS5mcm9tQXJyYXkoIGpzb25LZXkudmFsdWUgKSxcblx0XHRcdFx0dGltZToganNvbktleS50aW1lXG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5WZWN0b3JLZXlmcmFtZVRyYWNrKCBqc29uLm5hbWUsIGtleXMgKTtcblxuXHR9O1xuXG5cdC8vIEZpbGU6c3JjL2FuaW1hdGlvbi90cmFja3MvUXVhdGVybmlvbktleWZyYW1lVHJhY2suanNcblxuXHQvKipcblx0ICpcblx0ICogQSBUcmFjayB0aGF0IGludGVycG9sYXRlcyBRdWF0ZXJuaW9uXG5cdCAqXG5cdCAqIEBhdXRob3IgQmVuIEhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW8vXG5cdCAqIEBhdXRob3IgRGF2aWQgU2Fybm8gLyBodHRwOi8vbGlnaHRoYXVzLnVzL1xuXHQgKi9cblxuXHRUSFJFRS5RdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjayA9IGZ1bmN0aW9uICggbmFtZSwga2V5cyApIHtcblxuXHRcdFRIUkVFLktleWZyYW1lVHJhY2suY2FsbCggdGhpcywgbmFtZSwga2V5cyApO1xuXG5cdFx0Ly8gbG9jYWwgY2FjaGUgb2YgdmFsdWUgdHlwZSB0byBhdm9pZCBhbGxvY2F0aW9ucyBkdXJpbmcgcnVudGltZS5cblx0XHR0aGlzLnJlc3VsdCA9IHRoaXMua2V5c1swXS52YWx1ZS5jbG9uZSgpO1xuXG5cdH07XG5cblx0VEhSRUUuUXVhdGVybmlvbktleWZyYW1lVHJhY2sucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUgKTtcblxuXHRUSFJFRS5RdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5RdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjaztcblxuXHRUSFJFRS5RdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuc2V0UmVzdWx0ID0gZnVuY3Rpb24oIHZhbHVlICkge1xuXG5cdFx0dGhpcy5yZXN1bHQuY29weSggdmFsdWUgKTtcblxuXHR9O1xuXG5cdC8vIG1lbW9pemF0aW9uIG9mIHRoZSBsZXJwIGZ1bmN0aW9uIGZvciBzcGVlZC5cblx0Ly8gTk9URTogRG8gbm90IG9wdGltaXplIGFzIGEgcHJvdG90eXBlIGluaXRpYWxpemF0aW9uIGNsb3N1cmUsIGFzIHZhbHVlMCB3aWxsIGJlIGRpZmZlcmVudCBvbiBhIHBlciBjbGFzcyBiYXNpcy5cblx0VEhSRUUuUXVhdGVybmlvbktleWZyYW1lVHJhY2sucHJvdG90eXBlLmxlcnBWYWx1ZXMgPSBmdW5jdGlvbiggdmFsdWUwLCB2YWx1ZTEsIGFscGhhICkge1xuXG5cdFx0cmV0dXJuIHZhbHVlMC5zbGVycCggdmFsdWUxLCBhbHBoYSApO1xuXG5cdH07XG5cblx0VEhSRUUuUXVhdGVybmlvbktleWZyYW1lVHJhY2sucHJvdG90eXBlLmNvbXBhcmVWYWx1ZXMgPSBmdW5jdGlvbiggdmFsdWUwLCB2YWx1ZTEgKSB7XG5cblx0XHRyZXR1cm4gdmFsdWUwLmVxdWFscyggdmFsdWUxICk7XG5cblx0fTtcblxuXHRUSFJFRS5RdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUubXVsdGlwbHkgPSBmdW5jdGlvbiggcXVhdCApIHtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMua2V5cy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdHRoaXMua2V5c1tpXS52YWx1ZS5tdWx0aXBseSggcXVhdCApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHRUSFJFRS5RdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBjbG9uZWRLZXlzID0gW107XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmtleXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHR2YXIga2V5ID0gdGhpcy5rZXlzW2ldO1xuXHRcdFx0Y2xvbmVkS2V5cy5wdXNoKCB7XG5cdFx0XHRcdHRpbWU6IGtleS50aW1lLFxuXHRcdFx0XHR2YWx1ZToga2V5LnZhbHVlLmNsb25lKClcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbmV3IFRIUkVFLlF1YXRlcm5pb25LZXlmcmFtZVRyYWNrKCB0aGlzLm5hbWUsIGNsb25lZEtleXMgKTtcblxuXHR9O1xuXG5cdFRIUkVFLlF1YXRlcm5pb25LZXlmcmFtZVRyYWNrLnBhcnNlID0gZnVuY3Rpb24oIGpzb24gKSB7XG5cblx0XHR2YXIga2V5cyA9IFtdO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwganNvbi5rZXlzLmxlbmd0aDsgaSArKyApIHtcblx0XHRcdHZhciBqc29uS2V5ID0ganNvbi5rZXlzW2ldO1xuXHRcdFx0a2V5cy5wdXNoKCB7XG5cdFx0XHRcdHZhbHVlOiBuZXcgVEhSRUUuUXVhdGVybmlvbigpLmZyb21BcnJheSgganNvbktleS52YWx1ZSApLFxuXHRcdFx0XHR0aW1lOiBqc29uS2V5LnRpbWVcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbmV3IFRIUkVFLlF1YXRlcm5pb25LZXlmcmFtZVRyYWNrKCBqc29uLm5hbWUsIGtleXMgKTtcblxuXHR9O1xuXG5cdC8vIEZpbGU6c3JjL2FuaW1hdGlvbi90cmFja3MvU3RyaW5nS2V5ZnJhbWVUcmFjay5qc1xuXG5cdC8qKlxuXHQgKlxuXHQgKiBBIFRyYWNrIHRoYXQgaW50ZXJwb2xhdGVzIFN0cmluZ3Ncblx0ICpcblx0ICogQGF1dGhvciBCZW4gSG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cblx0ICogQGF1dGhvciBEYXZpZCBTYXJubyAvIGh0dHA6Ly9saWdodGhhdXMudXMvXG5cdCAqL1xuXG5cdFRIUkVFLlN0cmluZ0tleWZyYW1lVHJhY2sgPSBmdW5jdGlvbiAoIG5hbWUsIGtleXMgKSB7XG5cblx0XHRUSFJFRS5LZXlmcmFtZVRyYWNrLmNhbGwoIHRoaXMsIG5hbWUsIGtleXMgKTtcblxuXHRcdC8vIGxvY2FsIGNhY2hlIG9mIHZhbHVlIHR5cGUgdG8gYXZvaWQgYWxsb2NhdGlvbnMgZHVyaW5nIHJ1bnRpbWUuXG5cdFx0dGhpcy5yZXN1bHQgPSB0aGlzLmtleXNbMF0udmFsdWU7XG5cblx0fTtcblxuXHRUSFJFRS5TdHJpbmdLZXlmcmFtZVRyYWNrLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLktleWZyYW1lVHJhY2sucHJvdG90eXBlICk7XG5cblx0VEhSRUUuU3RyaW5nS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5TdHJpbmdLZXlmcmFtZVRyYWNrO1xuXG5cdFRIUkVFLlN0cmluZ0tleWZyYW1lVHJhY2sucHJvdG90eXBlLnNldFJlc3VsdCA9IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMucmVzdWx0ID0gdmFsdWU7XG5cblx0fTtcblxuXHQvLyBtZW1vaXphdGlvbiBvZiB0aGUgbGVycCBmdW5jdGlvbiBmb3Igc3BlZWQuXG5cdC8vIE5PVEU6IERvIG5vdCBvcHRpbWl6ZSBhcyBhIHByb3RvdHlwZSBpbml0aWFsaXphdGlvbiBjbG9zdXJlLCBhcyB2YWx1ZTAgd2lsbCBiZSBkaWZmZXJlbnQgb24gYSBwZXIgY2xhc3MgYmFzaXMuXG5cdFRIUkVFLlN0cmluZ0tleWZyYW1lVHJhY2sucHJvdG90eXBlLmxlcnBWYWx1ZXMgPSBmdW5jdGlvbiggdmFsdWUwLCB2YWx1ZTEsIGFscGhhICkge1xuXG5cdFx0cmV0dXJuICggYWxwaGEgPCAxLjAgKSA/IHZhbHVlMCA6IHZhbHVlMTtcblxuXHR9O1xuXG5cdFRIUkVFLlN0cmluZ0tleWZyYW1lVHJhY2sucHJvdG90eXBlLmNvbXBhcmVWYWx1ZXMgPSBmdW5jdGlvbiggdmFsdWUwLCB2YWx1ZTEgKSB7XG5cblx0XHRyZXR1cm4gKCB2YWx1ZTAgPT09IHZhbHVlMSApO1xuXG5cdH07XG5cblx0VEhSRUUuU3RyaW5nS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBjbG9uZWRLZXlzID0gW107XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmtleXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHR2YXIga2V5ID0gdGhpcy5rZXlzW2ldO1xuXHRcdFx0Y2xvbmVkS2V5cy5wdXNoKCB7XG5cdFx0XHRcdHRpbWU6IGtleS50aW1lLFxuXHRcdFx0XHR2YWx1ZToga2V5LnZhbHVlXG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5TdHJpbmdLZXlmcmFtZVRyYWNrKCB0aGlzLm5hbWUsIGNsb25lZEtleXMgKTtcblxuXHR9O1xuXG5cdFRIUkVFLlN0cmluZ0tleWZyYW1lVHJhY2sucGFyc2UgPSBmdW5jdGlvbigganNvbiApIHtcblxuXHRcdHJldHVybiBuZXcgVEhSRUUuU3RyaW5nS2V5ZnJhbWVUcmFjaygganNvbi5uYW1lLCBqc29uLmtleXMgKTtcblxuXHR9O1xuXG5cdC8vIEZpbGU6c3JjL2FuaW1hdGlvbi90cmFja3MvQm9vbGVhbktleWZyYW1lVHJhY2suanNcblxuXHQvKipcblx0ICpcblx0ICogQSBUcmFjayB0aGF0IGludGVycG9sYXRlcyBCb29sZWFuXG5cdCAqXG5cdCAqIEBhdXRob3IgQmVuIEhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW8vXG5cdCAqIEBhdXRob3IgRGF2aWQgU2Fybm8gLyBodHRwOi8vbGlnaHRoYXVzLnVzL1xuXHQgKi9cblxuXHRUSFJFRS5Cb29sZWFuS2V5ZnJhbWVUcmFjayA9IGZ1bmN0aW9uICggbmFtZSwga2V5cyApIHtcblxuXHRcdFRIUkVFLktleWZyYW1lVHJhY2suY2FsbCggdGhpcywgbmFtZSwga2V5cyApO1xuXG5cdFx0Ly8gbG9jYWwgY2FjaGUgb2YgdmFsdWUgdHlwZSB0byBhdm9pZCBhbGxvY2F0aW9ucyBkdXJpbmcgcnVudGltZS5cblx0XHR0aGlzLnJlc3VsdCA9IHRoaXMua2V5c1swXS52YWx1ZTtcblxuXHR9O1xuXG5cdFRIUkVFLkJvb2xlYW5LZXlmcmFtZVRyYWNrLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLktleWZyYW1lVHJhY2sucHJvdG90eXBlICk7XG5cblx0VEhSRUUuQm9vbGVhbktleWZyYW1lVHJhY2sucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQm9vbGVhbktleWZyYW1lVHJhY2s7XG5cblx0VEhSRUUuQm9vbGVhbktleWZyYW1lVHJhY2sucHJvdG90eXBlLnNldFJlc3VsdCA9IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMucmVzdWx0ID0gdmFsdWU7XG5cblx0fTtcblxuXHQvLyBtZW1vaXphdGlvbiBvZiB0aGUgbGVycCBmdW5jdGlvbiBmb3Igc3BlZWQuXG5cdC8vIE5PVEU6IERvIG5vdCBvcHRpbWl6ZSBhcyBhIHByb3RvdHlwZSBpbml0aWFsaXphdGlvbiBjbG9zdXJlLCBhcyB2YWx1ZTAgd2lsbCBiZSBkaWZmZXJlbnQgb24gYSBwZXIgY2xhc3MgYmFzaXMuXG5cdFRIUkVFLkJvb2xlYW5LZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5sZXJwVmFsdWVzID0gZnVuY3Rpb24oIHZhbHVlMCwgdmFsdWUxLCBhbHBoYSApIHtcblxuXHRcdHJldHVybiAoIGFscGhhIDwgMS4wICkgPyB2YWx1ZTAgOiB2YWx1ZTE7XG5cblx0fTtcblxuXHRUSFJFRS5Cb29sZWFuS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuY29tcGFyZVZhbHVlcyA9IGZ1bmN0aW9uKCB2YWx1ZTAsIHZhbHVlMSApIHtcblxuXHRcdHJldHVybiAoIHZhbHVlMCA9PT0gdmFsdWUxICk7XG5cblx0fTtcblxuXHRUSFJFRS5Cb29sZWFuS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBjbG9uZWRLZXlzID0gW107XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmtleXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHR2YXIga2V5ID0gdGhpcy5rZXlzW2ldO1xuXHRcdFx0Y2xvbmVkS2V5cy5wdXNoKCB7XG5cdFx0XHRcdHRpbWU6IGtleS50aW1lLFxuXHRcdFx0XHR2YWx1ZToga2V5LnZhbHVlXG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5Cb29sZWFuS2V5ZnJhbWVUcmFjayggdGhpcy5uYW1lLCBjbG9uZWRLZXlzICk7XG5cblx0fTtcblxuXHRUSFJFRS5Cb29sZWFuS2V5ZnJhbWVUcmFjay5wYXJzZSA9IGZ1bmN0aW9uKCBqc29uICkge1xuXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5Cb29sZWFuS2V5ZnJhbWVUcmFjaygganNvbi5uYW1lLCBqc29uLmtleXMgKTtcblxuXHR9O1xuXG5cdC8vIEZpbGU6c3JjL2FuaW1hdGlvbi90cmFja3MvTnVtYmVyS2V5ZnJhbWVUcmFjay5qc1xuXG5cdC8qKlxuXHQgKlxuXHQgKiBBIFRyYWNrIHRoYXQgaW50ZXJwb2xhdGVzIE51bWJlcnNcblx0ICpcblx0ICogQGF1dGhvciBCZW4gSG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cblx0ICogQGF1dGhvciBEYXZpZCBTYXJubyAvIGh0dHA6Ly9saWdodGhhdXMudXMvXG5cdCAqL1xuXG5cdFRIUkVFLk51bWJlcktleWZyYW1lVHJhY2sgPSBmdW5jdGlvbiAoIG5hbWUsIGtleXMgKSB7XG5cblx0XHRUSFJFRS5LZXlmcmFtZVRyYWNrLmNhbGwoIHRoaXMsIG5hbWUsIGtleXMgKTtcblxuXHRcdC8vIGxvY2FsIGNhY2hlIG9mIHZhbHVlIHR5cGUgdG8gYXZvaWQgYWxsb2NhdGlvbnMgZHVyaW5nIHJ1bnRpbWUuXG5cdFx0dGhpcy5yZXN1bHQgPSB0aGlzLmtleXNbMF0udmFsdWU7XG5cblx0fTtcblxuXHRUSFJFRS5OdW1iZXJLZXlmcmFtZVRyYWNrLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLktleWZyYW1lVHJhY2sucHJvdG90eXBlICk7XG5cblx0VEhSRUUuTnVtYmVyS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5OdW1iZXJLZXlmcmFtZVRyYWNrO1xuXG5cdFRIUkVFLk51bWJlcktleWZyYW1lVHJhY2sucHJvdG90eXBlLnNldFJlc3VsdCA9IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMucmVzdWx0ID0gdmFsdWU7XG5cblx0fTtcblxuXHQvLyBtZW1vaXphdGlvbiBvZiB0aGUgbGVycCBmdW5jdGlvbiBmb3Igc3BlZWQuXG5cdC8vIE5PVEU6IERvIG5vdCBvcHRpbWl6ZSBhcyBhIHByb3RvdHlwZSBpbml0aWFsaXphdGlvbiBjbG9zdXJlLCBhcyB2YWx1ZTAgd2lsbCBiZSBkaWZmZXJlbnQgb24gYSBwZXIgY2xhc3MgYmFzaXMuXG5cdFRIUkVFLk51bWJlcktleWZyYW1lVHJhY2sucHJvdG90eXBlLmxlcnBWYWx1ZXMgPSBmdW5jdGlvbiggdmFsdWUwLCB2YWx1ZTEsIGFscGhhICkge1xuXG5cdFx0cmV0dXJuIHZhbHVlMCAqICggMSAtIGFscGhhICkgKyB2YWx1ZTEgKiBhbHBoYTtcblxuXHR9O1xuXG5cdFRIUkVFLk51bWJlcktleWZyYW1lVHJhY2sucHJvdG90eXBlLmNvbXBhcmVWYWx1ZXMgPSBmdW5jdGlvbiggdmFsdWUwLCB2YWx1ZTEgKSB7XG5cblx0XHRyZXR1cm4gKCB2YWx1ZTAgPT09IHZhbHVlMSApO1xuXG5cdH07XG5cblx0VEhSRUUuTnVtYmVyS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBjbG9uZWRLZXlzID0gW107XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmtleXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHR2YXIga2V5ID0gdGhpcy5rZXlzW2ldO1xuXHRcdFx0Y2xvbmVkS2V5cy5wdXNoKCB7XG5cdFx0XHRcdHRpbWU6IGtleS50aW1lLFxuXHRcdFx0XHR2YWx1ZToga2V5LnZhbHVlXG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5OdW1iZXJLZXlmcmFtZVRyYWNrKCB0aGlzLm5hbWUsIGNsb25lZEtleXMgKTtcblxuXHR9O1xuXG5cdFRIUkVFLk51bWJlcktleWZyYW1lVHJhY2sucGFyc2UgPSBmdW5jdGlvbigganNvbiApIHtcblxuXHRcdHJldHVybiBuZXcgVEhSRUUuTnVtYmVyS2V5ZnJhbWVUcmFjaygganNvbi5uYW1lLCBqc29uLmtleXMgKTtcblxuXHR9O1xuXG5cdC8vIEZpbGU6c3JjL2NhbWVyYXMvQ2FtZXJhLmpzXG5cblx0LyoqXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG5cdCAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuXHQqL1xuXG5cdFRIUkVFLkNhbWVyYSA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuXHRcdHRoaXMudHlwZSA9ICdDYW1lcmEnO1xuXG5cdFx0dGhpcy5tYXRyaXhXb3JsZEludmVyc2UgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXHRcdHRoaXMucHJvamVjdGlvbk1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cblx0fTtcblxuXHRUSFJFRS5DYW1lcmEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XG5cdFRIUkVFLkNhbWVyYS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5DYW1lcmE7XG5cblx0VEhSRUUuQ2FtZXJhLnByb3RvdHlwZS5nZXRXb3JsZERpcmVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBxdWF0ZXJuaW9uID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdFx0dGhpcy5nZXRXb3JsZFF1YXRlcm5pb24oIHF1YXRlcm5pb24gKTtcblxuXHRcdFx0cmV0dXJuIHJlc3VsdC5zZXQoIDAsIDAsIC0gMSApLmFwcGx5UXVhdGVybmlvbiggcXVhdGVybmlvbiApO1xuXG5cdFx0fTtcblxuXHR9KCk7XG5cblx0VEhSRUUuQ2FtZXJhLnByb3RvdHlwZS5sb29rQXQgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHQvLyBUaGlzIHJvdXRpbmUgZG9lcyBub3Qgc3VwcG9ydCBjYW1lcmFzIHdpdGggcm90YXRlZCBhbmQvb3IgdHJhbnNsYXRlZCBwYXJlbnQocylcblxuXHRcdHZhciBtMSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XG5cblx0XHRcdG0xLmxvb2tBdCggdGhpcy5wb3NpdGlvbiwgdmVjdG9yLCB0aGlzLnVwICk7XG5cblx0XHRcdHRoaXMucXVhdGVybmlvbi5zZXRGcm9tUm90YXRpb25NYXRyaXgoIG0xICk7XG5cblx0XHR9O1xuXG5cdH0oKTtcblxuXHRUSFJFRS5DYW1lcmEucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG5cdH07XG5cblx0VEhSRUUuQ2FtZXJhLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cblx0XHRUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuXHRcdHRoaXMubWF0cml4V29ybGRJbnZlcnNlLmNvcHkoIHNvdXJjZS5tYXRyaXhXb3JsZEludmVyc2UgKTtcblx0XHR0aGlzLnByb2plY3Rpb25NYXRyaXguY29weSggc291cmNlLnByb2plY3Rpb25NYXRyaXggKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0Ly8gRmlsZTpzcmMvY2FtZXJhcy9DdWJlQ2FtZXJhLmpzXG5cblx0LyoqXG5cdCAqIENhbWVyYSBmb3IgcmVuZGVyaW5nIGN1YmUgbWFwc1xuXHQgKlx0LSByZW5kZXJzIHNjZW5lIGludG8gYXhpcy1hbGlnbmVkIGN1YmVcblx0ICpcblx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cblx0ICovXG5cblx0VEhSRUUuQ3ViZUNhbWVyYSA9IGZ1bmN0aW9uICggbmVhciwgZmFyLCBjdWJlUmVzb2x1dGlvbiApIHtcblxuXHRcdFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuXHRcdHRoaXMudHlwZSA9ICdDdWJlQ2FtZXJhJztcblxuXHRcdHZhciBmb3YgPSA5MCwgYXNwZWN0ID0gMTtcblxuXHRcdHZhciBjYW1lcmFQWCA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApO1xuXHRcdGNhbWVyYVBYLnVwLnNldCggMCwgLSAxLCAwICk7XG5cdFx0Y2FtZXJhUFgubG9va0F0KCBuZXcgVEhSRUUuVmVjdG9yMyggMSwgMCwgMCApICk7XG5cdFx0dGhpcy5hZGQoIGNhbWVyYVBYICk7XG5cblx0XHR2YXIgY2FtZXJhTlggPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKTtcblx0XHRjYW1lcmFOWC51cC5zZXQoIDAsIC0gMSwgMCApO1xuXHRcdGNhbWVyYU5YLmxvb2tBdCggbmV3IFRIUkVFLlZlY3RvcjMoIC0gMSwgMCwgMCApICk7XG5cdFx0dGhpcy5hZGQoIGNhbWVyYU5YICk7XG5cblx0XHR2YXIgY2FtZXJhUFkgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKTtcblx0XHRjYW1lcmFQWS51cC5zZXQoIDAsIDAsIDEgKTtcblx0XHRjYW1lcmFQWS5sb29rQXQoIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICkgKTtcblx0XHR0aGlzLmFkZCggY2FtZXJhUFkgKTtcblxuXHRcdHZhciBjYW1lcmFOWSA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApO1xuXHRcdGNhbWVyYU5ZLnVwLnNldCggMCwgMCwgLSAxICk7XG5cdFx0Y2FtZXJhTlkubG9va0F0KCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgLSAxLCAwICkgKTtcblx0XHR0aGlzLmFkZCggY2FtZXJhTlkgKTtcblxuXHRcdHZhciBjYW1lcmFQWiA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApO1xuXHRcdGNhbWVyYVBaLnVwLnNldCggMCwgLSAxLCAwICk7XG5cdFx0Y2FtZXJhUFoubG9va0F0KCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMCwgMSApICk7XG5cdFx0dGhpcy5hZGQoIGNhbWVyYVBaICk7XG5cblx0XHR2YXIgY2FtZXJhTlogPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKTtcblx0XHRjYW1lcmFOWi51cC5zZXQoIDAsIC0gMSwgMCApO1xuXHRcdGNhbWVyYU5aLmxvb2tBdCggbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIC0gMSApICk7XG5cdFx0dGhpcy5hZGQoIGNhbWVyYU5aICk7XG5cblx0XHR0aGlzLnJlbmRlclRhcmdldCA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmUoIGN1YmVSZXNvbHV0aW9uLCBjdWJlUmVzb2x1dGlvbiwgeyBmb3JtYXQ6IFRIUkVFLlJHQkZvcm1hdCwgbWFnRmlsdGVyOiBUSFJFRS5MaW5lYXJGaWx0ZXIsIG1pbkZpbHRlcjogVEhSRUUuTGluZWFyRmlsdGVyIH0gKTtcblxuXHRcdHRoaXMudXBkYXRlQ3ViZU1hcCA9IGZ1bmN0aW9uICggcmVuZGVyZXIsIHNjZW5lICkge1xuXG5cdFx0XHRpZiAoIHRoaXMucGFyZW50ID09PSBudWxsICkgdGhpcy51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXG5cdFx0XHR2YXIgcmVuZGVyVGFyZ2V0ID0gdGhpcy5yZW5kZXJUYXJnZXQ7XG5cdFx0XHR2YXIgZ2VuZXJhdGVNaXBtYXBzID0gcmVuZGVyVGFyZ2V0LnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzO1xuXG5cdFx0XHRyZW5kZXJUYXJnZXQudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcblxuXHRcdFx0cmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gMDtcblx0XHRcdHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYVBYLCByZW5kZXJUYXJnZXQgKTtcblxuXHRcdFx0cmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gMTtcblx0XHRcdHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYU5YLCByZW5kZXJUYXJnZXQgKTtcblxuXHRcdFx0cmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gMjtcblx0XHRcdHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYVBZLCByZW5kZXJUYXJnZXQgKTtcblxuXHRcdFx0cmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gMztcblx0XHRcdHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYU5ZLCByZW5kZXJUYXJnZXQgKTtcblxuXHRcdFx0cmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gNDtcblx0XHRcdHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYVBaLCByZW5kZXJUYXJnZXQgKTtcblxuXHRcdFx0cmVuZGVyVGFyZ2V0LnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZ2VuZXJhdGVNaXBtYXBzO1xuXG5cdFx0XHRyZW5kZXJUYXJnZXQuYWN0aXZlQ3ViZUZhY2UgPSA1O1xuXHRcdFx0cmVuZGVyZXIucmVuZGVyKCBzY2VuZSwgY2FtZXJhTlosIHJlbmRlclRhcmdldCApO1xuXG5cdFx0XHRyZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoIG51bGwgKTtcblxuXHRcdH07XG5cblx0fTtcblxuXHRUSFJFRS5DdWJlQ2FtZXJhLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xuXHRUSFJFRS5DdWJlQ2FtZXJhLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkN1YmVDYW1lcmE7XG5cblx0Ly8gRmlsZTpzcmMvY2FtZXJhcy9PcnRob2dyYXBoaWNDYW1lcmEuanNcblxuXHQvKipcblx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cblx0ICovXG5cblx0VEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhID0gZnVuY3Rpb24gKCBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIG5lYXIsIGZhciApIHtcblxuXHRcdFRIUkVFLkNhbWVyYS5jYWxsKCB0aGlzICk7XG5cblx0XHR0aGlzLnR5cGUgPSAnT3J0aG9ncmFwaGljQ2FtZXJhJztcblxuXHRcdHRoaXMuem9vbSA9IDE7XG5cblx0XHR0aGlzLmxlZnQgPSBsZWZ0O1xuXHRcdHRoaXMucmlnaHQgPSByaWdodDtcblx0XHR0aGlzLnRvcCA9IHRvcDtcblx0XHR0aGlzLmJvdHRvbSA9IGJvdHRvbTtcblxuXHRcdHRoaXMubmVhciA9ICggbmVhciAhPT0gdW5kZWZpbmVkICkgPyBuZWFyIDogMC4xO1xuXHRcdHRoaXMuZmFyID0gKCBmYXIgIT09IHVuZGVmaW5lZCApID8gZmFyIDogMjAwMDtcblxuXHRcdHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXG5cdH07XG5cblx0VEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkNhbWVyYS5wcm90b3R5cGUgKTtcblx0VEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYTtcblxuXHRUSFJFRS5PcnRob2dyYXBoaWNDYW1lcmEucHJvdG90eXBlLnVwZGF0ZVByb2plY3Rpb25NYXRyaXggPSBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgZHggPSAoIHRoaXMucmlnaHQgLSB0aGlzLmxlZnQgKSAvICggMiAqIHRoaXMuem9vbSApO1xuXHRcdHZhciBkeSA9ICggdGhpcy50b3AgLSB0aGlzLmJvdHRvbSApIC8gKCAyICogdGhpcy56b29tICk7XG5cdFx0dmFyIGN4ID0gKCB0aGlzLnJpZ2h0ICsgdGhpcy5sZWZ0ICkgLyAyO1xuXHRcdHZhciBjeSA9ICggdGhpcy50b3AgKyB0aGlzLmJvdHRvbSApIC8gMjtcblxuXHRcdHRoaXMucHJvamVjdGlvbk1hdHJpeC5tYWtlT3J0aG9ncmFwaGljKCBjeCAtIGR4LCBjeCArIGR4LCBjeSArIGR5LCBjeSAtIGR5LCB0aGlzLm5lYXIsIHRoaXMuZmFyICk7XG5cblx0fTtcblxuXHRUSFJFRS5PcnRob2dyYXBoaWNDYW1lcmEucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblx0XHRcblx0XHRUSFJFRS5DYW1lcmEucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cdFx0XG5cdFx0dGhpcy5sZWZ0ID0gc291cmNlLmxlZnQ7XG5cdFx0dGhpcy5yaWdodCA9IHNvdXJjZS5yaWdodDtcblx0XHR0aGlzLnRvcCA9IHNvdXJjZS50b3A7XG5cdFx0dGhpcy5ib3R0b20gPSBzb3VyY2UuYm90dG9tO1xuXHRcdHRoaXMubmVhciA9IHNvdXJjZS5uZWFyO1xuXHRcdHRoaXMuZmFyID0gc291cmNlLmZhcjtcblx0XHRcblx0XHR0aGlzLnpvb20gPSBzb3VyY2Uuem9vbTtcblx0XHRcblx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFxuXHR9O1xuXG5cdFRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCBtZXRhICkge1xuXG5cdFx0dmFyIGRhdGEgPSBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMsIG1ldGEgKTtcblxuXHRcdGRhdGEub2JqZWN0Lnpvb20gPSB0aGlzLnpvb207XG5cdFx0ZGF0YS5vYmplY3QubGVmdCA9IHRoaXMubGVmdDtcblx0XHRkYXRhLm9iamVjdC5yaWdodCA9IHRoaXMucmlnaHQ7XG5cdFx0ZGF0YS5vYmplY3QudG9wID0gdGhpcy50b3A7XG5cdFx0ZGF0YS5vYmplY3QuYm90dG9tID0gdGhpcy5ib3R0b207XG5cdFx0ZGF0YS5vYmplY3QubmVhciA9IHRoaXMubmVhcjtcblx0XHRkYXRhLm9iamVjdC5mYXIgPSB0aGlzLmZhcjtcblxuXHRcdHJldHVybiBkYXRhO1xuXG5cdH07XG5cblx0Ly8gRmlsZTpzcmMvY2FtZXJhcy9QZXJzcGVjdGl2ZUNhbWVyYS5qc1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuXHQgKiBAYXV0aG9yIGdyZWdnbWFuIC8gaHR0cDovL2dhbWVzLmdyZWdnbWFuLmNvbS9cblx0ICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xuXHQgKi9cblxuXHRUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSA9IGZ1bmN0aW9uICggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApIHtcblxuXHRcdFRIUkVFLkNhbWVyYS5jYWxsKCB0aGlzICk7XG5cblx0XHR0aGlzLnR5cGUgPSAnUGVyc3BlY3RpdmVDYW1lcmEnO1xuXG5cdFx0dGhpcy56b29tID0gMTtcblxuXHRcdHRoaXMuZm92ID0gZm92ICE9PSB1bmRlZmluZWQgPyBmb3YgOiA1MDtcblx0XHR0aGlzLmFzcGVjdCA9IGFzcGVjdCAhPT0gdW5kZWZpbmVkID8gYXNwZWN0IDogMTtcblx0XHR0aGlzLm5lYXIgPSBuZWFyICE9PSB1bmRlZmluZWQgPyBuZWFyIDogMC4xO1xuXHRcdHRoaXMuZmFyID0gZmFyICE9PSB1bmRlZmluZWQgPyBmYXIgOiAyMDAwO1xuXG5cdFx0dGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cblx0fTtcblxuXHRUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5DYW1lcmEucHJvdG90eXBlICk7XG5cdFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhO1xuXG5cblx0LyoqXG5cdCAqIFVzZXMgRm9jYWwgTGVuZ3RoIChpbiBtbSkgdG8gZXN0aW1hdGUgYW5kIHNldCBGT1Zcblx0ICogMzVtbSAoZnVsbC1mcmFtZSkgY2FtZXJhIGlzIHVzZWQgaWYgZnJhbWUgc2l6ZSBpcyBub3Qgc3BlY2lmaWVkO1xuXHQgKiBGb3JtdWxhIGJhc2VkIG9uIGh0dHA6Ly93d3cuYm9iYXRraW5zLmNvbS9waG90b2dyYXBoeS90ZWNobmljYWwvZmllbGRfb2Zfdmlldy5odG1sXG5cdCAqL1xuXG5cdFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhLnByb3RvdHlwZS5zZXRMZW5zID0gZnVuY3Rpb24gKCBmb2NhbExlbmd0aCwgZnJhbWVIZWlnaHQgKSB7XG5cblx0XHRpZiAoIGZyYW1lSGVpZ2h0ID09PSB1bmRlZmluZWQgKSBmcmFtZUhlaWdodCA9IDI0O1xuXG5cdFx0dGhpcy5mb3YgPSAyICogVEhSRUUuTWF0aC5yYWRUb0RlZyggTWF0aC5hdGFuKCBmcmFtZUhlaWdodCAvICggZm9jYWxMZW5ndGggKiAyICkgKSApO1xuXHRcdHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXG5cdH07XG5cblxuXHQvKipcblx0ICogU2V0cyBhbiBvZmZzZXQgaW4gYSBsYXJnZXIgZnJ1c3R1bS4gVGhpcyBpcyB1c2VmdWwgZm9yIG11bHRpLXdpbmRvdyBvclxuXHQgKiBtdWx0aS1tb25pdG9yL211bHRpLW1hY2hpbmUgc2V0dXBzLlxuXHQgKlxuXHQgKiBGb3IgZXhhbXBsZSwgaWYgeW91IGhhdmUgM3gyIG1vbml0b3JzIGFuZCBlYWNoIG1vbml0b3IgaXMgMTkyMHgxMDgwIGFuZFxuXHQgKiB0aGUgbW9uaXRvcnMgYXJlIGluIGdyaWQgbGlrZSB0aGlzXG5cdCAqXG5cdCAqICAgKy0tLSstLS0rLS0tK1xuXHQgKiAgIHwgQSB8IEIgfCBDIHxcblx0ICogICArLS0tKy0tLSstLS0rXG5cdCAqICAgfCBEIHwgRSB8IEYgfFxuXHQgKiAgICstLS0rLS0tKy0tLStcblx0ICpcblx0ICogdGhlbiBmb3IgZWFjaCBtb25pdG9yIHlvdSB3b3VsZCBjYWxsIGl0IGxpa2UgdGhpc1xuXHQgKlxuXHQgKiAgIHZhciB3ID0gMTkyMDtcblx0ICogICB2YXIgaCA9IDEwODA7XG5cdCAqICAgdmFyIGZ1bGxXaWR0aCA9IHcgKiAzO1xuXHQgKiAgIHZhciBmdWxsSGVpZ2h0ID0gaCAqIDI7XG5cdCAqXG5cdCAqICAgLS1BLS1cblx0ICogICBjYW1lcmEuc2V0T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAwLCBoICogMCwgdywgaCApO1xuXHQgKiAgIC0tQi0tXG5cdCAqICAgY2FtZXJhLnNldE9mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB3ICogMSwgaCAqIDAsIHcsIGggKTtcblx0ICogICAtLUMtLVxuXHQgKiAgIGNhbWVyYS5zZXRPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDIsIGggKiAwLCB3LCBoICk7XG5cdCAqICAgLS1ELS1cblx0ICogICBjYW1lcmEuc2V0T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAwLCBoICogMSwgdywgaCApO1xuXHQgKiAgIC0tRS0tXG5cdCAqICAgY2FtZXJhLnNldE9mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB3ICogMSwgaCAqIDEsIHcsIGggKTtcblx0ICogICAtLUYtLVxuXHQgKiAgIGNhbWVyYS5zZXRPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDIsIGggKiAxLCB3LCBoICk7XG5cdCAqXG5cdCAqICAgTm90ZSB0aGVyZSBpcyBubyByZWFzb24gbW9uaXRvcnMgaGF2ZSB0byBiZSB0aGUgc2FtZSBzaXplIG9yIGluIGEgZ3JpZC5cblx0ICovXG5cblx0VEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEucHJvdG90eXBlLnNldFZpZXdPZmZzZXQgPSBmdW5jdGlvbiAoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgeCwgeSwgd2lkdGgsIGhlaWdodCApIHtcblxuXHRcdHRoaXMuZnVsbFdpZHRoID0gZnVsbFdpZHRoO1xuXHRcdHRoaXMuZnVsbEhlaWdodCA9IGZ1bGxIZWlnaHQ7XG5cdFx0dGhpcy54ID0geDtcblx0XHR0aGlzLnkgPSB5O1xuXHRcdHRoaXMud2lkdGggPSB3aWR0aDtcblx0XHR0aGlzLmhlaWdodCA9IGhlaWdodDtcblxuXHRcdHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXG5cdH07XG5cblxuXHRUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYS5wcm90b3R5cGUudXBkYXRlUHJvamVjdGlvbk1hdHJpeCA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBmb3YgPSBUSFJFRS5NYXRoLnJhZFRvRGVnKCAyICogTWF0aC5hdGFuKCBNYXRoLnRhbiggVEhSRUUuTWF0aC5kZWdUb1JhZCggdGhpcy5mb3YgKSAqIDAuNSApIC8gdGhpcy56b29tICkgKTtcblxuXHRcdGlmICggdGhpcy5mdWxsV2lkdGggKSB7XG5cblx0XHRcdHZhciBhc3BlY3QgPSB0aGlzLmZ1bGxXaWR0aCAvIHRoaXMuZnVsbEhlaWdodDtcblx0XHRcdHZhciB0b3AgPSBNYXRoLnRhbiggVEhSRUUuTWF0aC5kZWdUb1JhZCggZm92ICogMC41ICkgKSAqIHRoaXMubmVhcjtcblx0XHRcdHZhciBib3R0b20gPSAtIHRvcDtcblx0XHRcdHZhciBsZWZ0ID0gYXNwZWN0ICogYm90dG9tO1xuXHRcdFx0dmFyIHJpZ2h0ID0gYXNwZWN0ICogdG9wO1xuXHRcdFx0dmFyIHdpZHRoID0gTWF0aC5hYnMoIHJpZ2h0IC0gbGVmdCApO1xuXHRcdFx0dmFyIGhlaWdodCA9IE1hdGguYWJzKCB0b3AgLSBib3R0b20gKTtcblxuXHRcdFx0dGhpcy5wcm9qZWN0aW9uTWF0cml4Lm1ha2VGcnVzdHVtKFxuXHRcdFx0XHRsZWZ0ICsgdGhpcy54ICogd2lkdGggLyB0aGlzLmZ1bGxXaWR0aCxcblx0XHRcdFx0bGVmdCArICggdGhpcy54ICsgdGhpcy53aWR0aCApICogd2lkdGggLyB0aGlzLmZ1bGxXaWR0aCxcblx0XHRcdFx0dG9wIC0gKCB0aGlzLnkgKyB0aGlzLmhlaWdodCApICogaGVpZ2h0IC8gdGhpcy5mdWxsSGVpZ2h0LFxuXHRcdFx0XHR0b3AgLSB0aGlzLnkgKiBoZWlnaHQgLyB0aGlzLmZ1bGxIZWlnaHQsXG5cdFx0XHRcdHRoaXMubmVhcixcblx0XHRcdFx0dGhpcy5mYXJcblx0XHRcdCk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aGlzLnByb2plY3Rpb25NYXRyaXgubWFrZVBlcnNwZWN0aXZlKCBmb3YsIHRoaXMuYXNwZWN0LCB0aGlzLm5lYXIsIHRoaXMuZmFyICk7XG5cblx0XHR9XG5cblx0fTtcblxuXHRUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xuXHRcdFxuXHRcdFRIUkVFLkNhbWVyYS5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblx0XHRcblx0XHR0aGlzLmZvdiA9IHNvdXJjZS5mb3Y7XG5cdFx0dGhpcy5hc3BlY3QgPSBzb3VyY2UuYXNwZWN0O1xuXHRcdHRoaXMubmVhciA9IHNvdXJjZS5uZWFyO1xuXHRcdHRoaXMuZmFyID0gc291cmNlLmZhcjtcblx0XHRcblx0XHR0aGlzLnpvb20gPSBzb3VyY2Uuem9vbTtcblx0XHRcblx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFxuXHR9O1xuXG5cdFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoIG1ldGEgKSB7XG5cblx0XHR2YXIgZGF0YSA9IFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcywgbWV0YSApO1xuXG5cdFx0ZGF0YS5vYmplY3Quem9vbSA9IHRoaXMuem9vbTtcblx0XHRkYXRhLm9iamVjdC5mb3YgPSB0aGlzLmZvdjtcblx0XHRkYXRhLm9iamVjdC5hc3BlY3QgPSB0aGlzLmFzcGVjdDtcblx0XHRkYXRhLm9iamVjdC5uZWFyID0gdGhpcy5uZWFyO1xuXHRcdGRhdGEub2JqZWN0LmZhciA9IHRoaXMuZmFyO1xuXG5cdFx0cmV0dXJuIGRhdGE7XG5cblx0fTtcblxuXHQvLyBGaWxlOnNyYy9saWdodHMvTGlnaHQuanNcblxuXHQvKipcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cblx0ICovXG5cblx0VEhSRUUuTGlnaHQgPSBmdW5jdGlvbiAoIGNvbG9yICkge1xuXG5cdFx0VEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG5cdFx0dGhpcy50eXBlID0gJ0xpZ2h0JztcblxuXHRcdHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIGNvbG9yICk7XG5cblx0XHR0aGlzLnJlY2VpdmVTaGFkb3cgPSB1bmRlZmluZWQ7XG5cblx0fTtcblxuXHRUSFJFRS5MaWdodC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblx0VEhSRUUuTGlnaHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTGlnaHQ7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFRIUkVFLkxpZ2h0LnByb3RvdHlwZSwge1xuXHRcdG9ubHlTaGFkb3c6IHtcblx0XHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTGlnaHQ6IC5vbmx5U2hhZG93IGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2hhZG93Q2FtZXJhRm92OiB7XG5cdFx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cdFx0XHRcdHRoaXMuc2hhZG93LmNhbWVyYS5mb3YgPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHNoYWRvd0NhbWVyYUxlZnQ6IHtcblx0XHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblx0XHRcdFx0dGhpcy5zaGFkb3cuY2FtZXJhLmxlZnQgPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHNoYWRvd0NhbWVyYVJpZ2h0OiB7XG5cdFx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cdFx0XHRcdHRoaXMuc2hhZG93LmNhbWVyYS5yaWdodCA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2hhZG93Q2FtZXJhVG9wOiB7XG5cdFx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cdFx0XHRcdHRoaXMuc2hhZG93LmNhbWVyYS50b3AgPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHNoYWRvd0NhbWVyYUJvdHRvbToge1xuXHRcdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXHRcdFx0XHR0aGlzLnNoYWRvdy5jYW1lcmEuYm90dG9tID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzaGFkb3dDYW1lcmFOZWFyOiB7XG5cdFx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cdFx0XHRcdHRoaXMuc2hhZG93LmNhbWVyYS5uZWFyID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzaGFkb3dDYW1lcmFGYXI6IHtcblx0XHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblx0XHRcdFx0dGhpcy5zaGFkb3cuY2FtZXJhLmZhciA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2hhZG93Q2FtZXJhVmlzaWJsZToge1xuXHRcdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5MaWdodDogLnNoYWRvd0NhbWVyYVZpc2libGUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIG5ldyBUSFJFRS5DYW1lcmFIZWxwZXIoIGxpZ2h0LnNoYWRvdyApIGluc3RlYWQuJyApO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2hhZG93Qmlhczoge1xuXHRcdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXHRcdFx0XHR0aGlzLnNoYWRvdy5iaWFzID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzaGFkb3dEYXJrbmVzczoge1xuXHRcdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXHRcdFx0XHR0aGlzLnNoYWRvdy5kYXJrbmVzcyA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2hhZG93TWFwV2lkdGg6IHtcblx0XHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblx0XHRcdFx0dGhpcy5zaGFkb3cubWFwU2l6ZS53aWR0aCA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2hhZG93TWFwSGVpZ2h0OiB7XG5cdFx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cdFx0XHRcdHRoaXMuc2hhZG93Lm1hcFNpemUuaGVpZ2h0ID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9ICk7XG5cblx0VEhSRUUuTGlnaHQucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuXHRcdFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0VEhSRUUuTGlnaHQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICggbWV0YSApIHtcblxuXHRcdHZhciBkYXRhID0gVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzLCBtZXRhICk7XG5cblx0XHRkYXRhLm9iamVjdC5jb2xvciA9IHRoaXMuY29sb3IuZ2V0SGV4KCk7XG5cdFx0aWYgKCB0aGlzLmdyb3VuZENvbG9yICE9PSB1bmRlZmluZWQgKSBkYXRhLm9iamVjdC5ncm91bmRDb2xvciA9IHRoaXMuZ3JvdW5kQ29sb3IuZ2V0SGV4KCk7XG5cblx0XHRpZiAoIHRoaXMuaW50ZW5zaXR5ICE9PSB1bmRlZmluZWQgKSBkYXRhLm9iamVjdC5pbnRlbnNpdHkgPSB0aGlzLmludGVuc2l0eTtcblx0XHRpZiAoIHRoaXMuZGlzdGFuY2UgIT09IHVuZGVmaW5lZCApIGRhdGEub2JqZWN0LmRpc3RhbmNlID0gdGhpcy5kaXN0YW5jZTtcblx0XHRpZiAoIHRoaXMuYW5nbGUgIT09IHVuZGVmaW5lZCApIGRhdGEub2JqZWN0LmFuZ2xlID0gdGhpcy5hbmdsZTtcblx0XHRpZiAoIHRoaXMuZGVjYXkgIT09IHVuZGVmaW5lZCApIGRhdGEub2JqZWN0LmRlY2F5ID0gdGhpcy5kZWNheTtcblx0XHRpZiAoIHRoaXMuZXhwb25lbnQgIT09IHVuZGVmaW5lZCApIGRhdGEub2JqZWN0LmV4cG9uZW50ID0gdGhpcy5leHBvbmVudDtcblxuXHRcdHJldHVybiBkYXRhO1xuXG5cdH07XG5cblx0Ly8gRmlsZTpzcmMvbGlnaHRzL0xpZ2h0U2hhZG93LmpzXG5cblx0LyoqXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqL1xuXG5cdFRIUkVFLkxpZ2h0U2hhZG93ID0gZnVuY3Rpb24gKCBjYW1lcmEgKSB7XG5cblx0XHR0aGlzLmNhbWVyYSA9IGNhbWVyYTtcblxuXHRcdHRoaXMuYmlhcyA9IDA7XG5cdFx0dGhpcy5kYXJrbmVzcyA9IDE7XG5cblx0XHR0aGlzLm1hcFNpemUgPSBuZXcgVEhSRUUuVmVjdG9yMiggNTEyLCA1MTIgKTtcblxuXHRcdHRoaXMubWFwID0gbnVsbDtcblx0XHR0aGlzLm1hdHJpeCA9IG51bGw7XG5cblx0fTtcblxuXHRUSFJFRS5MaWdodFNoYWRvdy5wcm90b3R5cGUgPSB7XG5cblx0XHRjb25zdHJ1Y3RvcjogVEhSRUUuTGlnaHRTaGFkb3csXG5cblx0XHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuXHRcdFx0dGhpcy5jYW1lcmEgPSBzb3VyY2UuY2FtZXJhLmNsb25lKCk7XG5cblx0XHRcdHRoaXMuYmlhcyA9IHNvdXJjZS5iaWFzO1xuXHRcdFx0dGhpcy5kYXJrbmVzcyA9IHNvdXJjZS5kYXJrbmVzcztcblxuXHRcdFx0dGhpcy5tYXBTaXplLmNvcHkoIHNvdXJjZS5tYXBTaXplICk7XG5cblx0XHR9LFxuXG5cdFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0Ly8gRmlsZTpzcmMvbGlnaHRzL0FtYmllbnRMaWdodC5qc1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuXHQgKi9cblxuXHRUSFJFRS5BbWJpZW50TGlnaHQgPSBmdW5jdGlvbiAoIGNvbG9yICkge1xuXG5cdFx0VEhSRUUuTGlnaHQuY2FsbCggdGhpcywgY29sb3IgKTtcblxuXHRcdHRoaXMudHlwZSA9ICdBbWJpZW50TGlnaHQnO1xuXG5cdFx0dGhpcy5jYXN0U2hhZG93ID0gdW5kZWZpbmVkO1xuXG5cdH07XG5cblx0VEhSRUUuQW1iaWVudExpZ2h0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpZ2h0LnByb3RvdHlwZSApO1xuXHRUSFJFRS5BbWJpZW50TGlnaHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQW1iaWVudExpZ2h0O1xuXG5cdC8vIEZpbGU6c3JjL2xpZ2h0cy9EaXJlY3Rpb25hbExpZ2h0LmpzXG5cblx0LyoqXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG5cdCAqL1xuXG5cdFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQgPSBmdW5jdGlvbiAoIGNvbG9yLCBpbnRlbnNpdHkgKSB7XG5cblx0XHRUSFJFRS5MaWdodC5jYWxsKCB0aGlzLCBjb2xvciApO1xuXG5cdFx0dGhpcy50eXBlID0gJ0RpcmVjdGlvbmFsTGlnaHQnO1xuXG5cdFx0dGhpcy5wb3NpdGlvbi5zZXQoIDAsIDEsIDAgKTtcblx0XHR0aGlzLnVwZGF0ZU1hdHJpeCgpO1xuXG5cdFx0dGhpcy50YXJnZXQgPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcblxuXHRcdHRoaXMuaW50ZW5zaXR5ID0gKCBpbnRlbnNpdHkgIT09IHVuZGVmaW5lZCApID8gaW50ZW5zaXR5IDogMTtcblxuXHRcdHRoaXMuc2hhZG93ID0gbmV3IFRIUkVFLkxpZ2h0U2hhZG93KCBuZXcgVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhKCAtIDUwMCwgNTAwLCA1MDAsIC0gNTAwLCA1MCwgNTAwMCApICk7XG5cblx0fTtcblxuXHRUSFJFRS5EaXJlY3Rpb25hbExpZ2h0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpZ2h0LnByb3RvdHlwZSApO1xuXHRUSFJFRS5EaXJlY3Rpb25hbExpZ2h0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQ7XG5cblx0VEhSRUUuRGlyZWN0aW9uYWxMaWdodC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xuXG5cdFx0VEhSRUUuTGlnaHQucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cblx0XHR0aGlzLmludGVuc2l0eSA9IHNvdXJjZS5pbnRlbnNpdHk7XG5cdFx0dGhpcy50YXJnZXQgPSBzb3VyY2UudGFyZ2V0LmNsb25lKCk7XG5cblx0XHR0aGlzLnNoYWRvdyA9IHNvdXJjZS5zaGFkb3cuY2xvbmUoKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0Ly8gRmlsZTpzcmMvbGlnaHRzL0hlbWlzcGhlcmVMaWdodC5qc1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuXHQgKi9cblxuXHRUSFJFRS5IZW1pc3BoZXJlTGlnaHQgPSBmdW5jdGlvbiAoIHNreUNvbG9yLCBncm91bmRDb2xvciwgaW50ZW5zaXR5ICkge1xuXG5cdFx0VEhSRUUuTGlnaHQuY2FsbCggdGhpcywgc2t5Q29sb3IgKTtcblxuXHRcdHRoaXMudHlwZSA9ICdIZW1pc3BoZXJlTGlnaHQnO1xuXG5cdFx0dGhpcy5jYXN0U2hhZG93ID0gdW5kZWZpbmVkO1xuXG5cdFx0dGhpcy5wb3NpdGlvbi5zZXQoIDAsIDEsIDAgKTtcblx0XHR0aGlzLnVwZGF0ZU1hdHJpeCgpO1xuXG5cdFx0dGhpcy5ncm91bmRDb2xvciA9IG5ldyBUSFJFRS5Db2xvciggZ3JvdW5kQ29sb3IgKTtcblx0XHR0aGlzLmludGVuc2l0eSA9ICggaW50ZW5zaXR5ICE9PSB1bmRlZmluZWQgKSA/IGludGVuc2l0eSA6IDE7XG5cblx0fTtcblxuXHRUSFJFRS5IZW1pc3BoZXJlTGlnaHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGlnaHQucHJvdG90eXBlICk7XG5cdFRIUkVFLkhlbWlzcGhlcmVMaWdodC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5IZW1pc3BoZXJlTGlnaHQ7XG5cblx0VEhSRUUuSGVtaXNwaGVyZUxpZ2h0LnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cblx0XHRUSFJFRS5MaWdodC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuXHRcdHRoaXMuZ3JvdW5kQ29sb3IuY29weSggc291cmNlLmdyb3VuZENvbG9yICk7XG5cdFx0dGhpcy5pbnRlbnNpdHkgPSBzb3VyY2UuaW50ZW5zaXR5O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHQvLyBGaWxlOnNyYy9saWdodHMvUG9pbnRMaWdodC5qc1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuXHQgKi9cblxuXG5cdFRIUkVFLlBvaW50TGlnaHQgPSBmdW5jdGlvbiAoIGNvbG9yLCBpbnRlbnNpdHksIGRpc3RhbmNlLCBkZWNheSApIHtcblxuXHRcdFRIUkVFLkxpZ2h0LmNhbGwoIHRoaXMsIGNvbG9yICk7XG5cblx0XHR0aGlzLnR5cGUgPSAnUG9pbnRMaWdodCc7XG5cblx0XHR0aGlzLmludGVuc2l0eSA9ICggaW50ZW5zaXR5ICE9PSB1bmRlZmluZWQgKSA/IGludGVuc2l0eSA6IDE7XG5cdFx0dGhpcy5kaXN0YW5jZSA9ICggZGlzdGFuY2UgIT09IHVuZGVmaW5lZCApID8gZGlzdGFuY2UgOiAwO1xuXHRcdHRoaXMuZGVjYXkgPSAoIGRlY2F5ICE9PSB1bmRlZmluZWQgKSA/IGRlY2F5IDogMTtcdC8vIGZvciBwaHlzaWNhbGx5IGNvcnJlY3QgbGlnaHRzLCBzaG91bGQgYmUgMi5cblxuXHRcdHRoaXMuc2hhZG93ID0gbmV3IFRIUkVFLkxpZ2h0U2hhZG93KCBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoIDkwLCAxLCAxLCA1MDAgKSApO1xuXG5cdH07XG5cblx0VEhSRUUuUG9pbnRMaWdodC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaWdodC5wcm90b3R5cGUgKTtcblx0VEhSRUUuUG9pbnRMaWdodC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Qb2ludExpZ2h0O1xuXG5cdFRIUkVFLlBvaW50TGlnaHQucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuXHRcdFRIUkVFLkxpZ2h0LnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5pbnRlbnNpdHkgPSBzb3VyY2UuaW50ZW5zaXR5O1xuXHRcdHRoaXMuZGlzdGFuY2UgPSBzb3VyY2UuZGlzdGFuY2U7XG5cdFx0dGhpcy5kZWNheSA9IHNvdXJjZS5kZWNheTtcblxuXHRcdHRoaXMuc2hhZG93ID0gc291cmNlLnNoYWRvdy5jbG9uZSgpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHQvLyBGaWxlOnNyYy9saWdodHMvU3BvdExpZ2h0LmpzXG5cblx0LyoqXG5cdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG5cdCAqL1xuXG5cdFRIUkVFLlNwb3RMaWdodCA9IGZ1bmN0aW9uICggY29sb3IsIGludGVuc2l0eSwgZGlzdGFuY2UsIGFuZ2xlLCBleHBvbmVudCwgZGVjYXkgKSB7XG5cblx0XHRUSFJFRS5MaWdodC5jYWxsKCB0aGlzLCBjb2xvciApO1xuXG5cdFx0dGhpcy50eXBlID0gJ1Nwb3RMaWdodCc7XG5cblx0XHR0aGlzLnBvc2l0aW9uLnNldCggMCwgMSwgMCApO1xuXHRcdHRoaXMudXBkYXRlTWF0cml4KCk7XG5cblx0XHR0aGlzLnRhcmdldCA9IG5ldyBUSFJFRS5PYmplY3QzRCgpO1xuXG5cdFx0dGhpcy5pbnRlbnNpdHkgPSAoIGludGVuc2l0eSAhPT0gdW5kZWZpbmVkICkgPyBpbnRlbnNpdHkgOiAxO1xuXHRcdHRoaXMuZGlzdGFuY2UgPSAoIGRpc3RhbmNlICE9PSB1bmRlZmluZWQgKSA/IGRpc3RhbmNlIDogMDtcblx0XHR0aGlzLmFuZ2xlID0gKCBhbmdsZSAhPT0gdW5kZWZpbmVkICkgPyBhbmdsZSA6IE1hdGguUEkgLyAzO1xuXHRcdHRoaXMuZXhwb25lbnQgPSAoIGV4cG9uZW50ICE9PSB1bmRlZmluZWQgKSA/IGV4cG9uZW50IDogMTA7XG5cdFx0dGhpcy5kZWNheSA9ICggZGVjYXkgIT09IHVuZGVmaW5lZCApID8gZGVjYXkgOiAxO1x0Ly8gZm9yIHBoeXNpY2FsbHkgY29ycmVjdCBsaWdodHMsIHNob3VsZCBiZSAyLlxuXG5cdFx0dGhpcy5zaGFkb3cgPSBuZXcgVEhSRUUuTGlnaHRTaGFkb3coIG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSggNTAsIDEsIDUwLCA1MDAwICkgKTtcblxuXHR9O1xuXG5cdFRIUkVFLlNwb3RMaWdodC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaWdodC5wcm90b3R5cGUgKTtcblx0VEhSRUUuU3BvdExpZ2h0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlNwb3RMaWdodDtcblxuXHRUSFJFRS5TcG90TGlnaHQucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuXHRcdFRIUkVFLkxpZ2h0LnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5pbnRlbnNpdHkgPSBzb3VyY2UuaW50ZW5zaXR5O1xuXHRcdHRoaXMuZGlzdGFuY2UgPSBzb3VyY2UuZGlzdGFuY2U7XG5cdFx0dGhpcy5hbmdsZSA9IHNvdXJjZS5hbmdsZTtcblx0XHR0aGlzLmV4cG9uZW50ID0gc291cmNlLmV4cG9uZW50O1xuXHRcdHRoaXMuZGVjYXkgPSBzb3VyY2UuZGVjYXk7XG5cblx0XHR0aGlzLnRhcmdldCA9IHNvdXJjZS50YXJnZXQuY2xvbmUoKTtcblxuXHRcdHRoaXMuc2hhZG93ID0gc291cmNlLnNoYWRvdy5jbG9uZSgpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHQvLyBGaWxlOnNyYy9sb2FkZXJzL0NhY2hlLmpzXG5cblx0LyoqXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqL1xuXG5cdFRIUkVFLkNhY2hlID0ge1xuXG5cdFx0ZW5hYmxlZDogZmFsc2UsXG5cblx0XHRmaWxlczoge30sXG5cblx0XHRhZGQ6IGZ1bmN0aW9uICgga2V5LCBmaWxlICkge1xuXG5cdFx0XHRpZiAoIHRoaXMuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRcdC8vIGNvbnNvbGUubG9nKCAnVEhSRUUuQ2FjaGUnLCAnQWRkaW5nIGtleTonLCBrZXkgKTtcblxuXHRcdFx0dGhpcy5maWxlc1sga2V5IF0gPSBmaWxlO1xuXG5cdFx0fSxcblxuXHRcdGdldDogZnVuY3Rpb24gKCBrZXkgKSB7XG5cblx0XHRcdGlmICggdGhpcy5lbmFibGVkID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdFx0Ly8gY29uc29sZS5sb2coICdUSFJFRS5DYWNoZScsICdDaGVja2luZyBrZXk6Jywga2V5ICk7XG5cblx0XHRcdHJldHVybiB0aGlzLmZpbGVzWyBrZXkgXTtcblxuXHRcdH0sXG5cblx0XHRyZW1vdmU6IGZ1bmN0aW9uICgga2V5ICkge1xuXG5cdFx0XHRkZWxldGUgdGhpcy5maWxlc1sga2V5IF07XG5cblx0XHR9LFxuXG5cdFx0Y2xlYXI6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dGhpcy5maWxlcyA9IHt9O1xuXG5cdFx0fVxuXG5cdH07XG5cblx0Ly8gRmlsZTpzcmMvbG9hZGVycy9Mb2FkZXIuanNcblxuXHQvKipcblx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cblx0ICovXG5cblx0VEhSRUUuTG9hZGVyID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy5vbkxvYWRTdGFydCA9IGZ1bmN0aW9uICgpIHt9O1xuXHRcdHRoaXMub25Mb2FkUHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7fTtcblx0XHR0aGlzLm9uTG9hZENvbXBsZXRlID0gZnVuY3Rpb24gKCkge307XG5cblx0fTtcblxuXHRUSFJFRS5Mb2FkZXIucHJvdG90eXBlID0ge1xuXG5cdFx0Y29uc3RydWN0b3I6IFRIUkVFLkxvYWRlcixcblxuXHRcdGNyb3NzT3JpZ2luOiB1bmRlZmluZWQsXG5cblx0XHRleHRyYWN0VXJsQmFzZTogZnVuY3Rpb24gKCB1cmwgKSB7XG5cblx0XHRcdHZhciBwYXJ0cyA9IHVybC5zcGxpdCggJy8nICk7XG5cblx0XHRcdGlmICggcGFydHMubGVuZ3RoID09PSAxICkgcmV0dXJuICcuLyc7XG5cblx0XHRcdHBhcnRzLnBvcCgpO1xuXG5cdFx0XHRyZXR1cm4gcGFydHMuam9pbiggJy8nICkgKyAnLyc7XG5cblx0XHR9LFxuXG5cdFx0aW5pdE1hdGVyaWFsczogZnVuY3Rpb24gKCBtYXRlcmlhbHMsIHRleHR1cmVQYXRoLCBjcm9zc09yaWdpbiApIHtcblxuXHRcdFx0dmFyIGFycmF5ID0gW107XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IG1hdGVyaWFscy5sZW5ndGg7ICsrIGkgKSB7XG5cblx0XHRcdFx0YXJyYXlbIGkgXSA9IHRoaXMuY3JlYXRlTWF0ZXJpYWwoIG1hdGVyaWFsc1sgaSBdLCB0ZXh0dXJlUGF0aCwgY3Jvc3NPcmlnaW4gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYXJyYXk7XG5cblx0XHR9LFxuXG5cdFx0Y3JlYXRlTWF0ZXJpYWw6ICggZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgY29sb3IsIHRleHR1cmVMb2FkZXIsIG1hdGVyaWFsTG9hZGVyO1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKCBtLCB0ZXh0dXJlUGF0aCwgY3Jvc3NPcmlnaW4gKSB7XG5cblx0XHRcdFx0aWYgKCBjb2xvciA9PT0gdW5kZWZpbmVkICkgY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoKTtcblx0XHRcdFx0aWYgKCB0ZXh0dXJlTG9hZGVyID09PSB1bmRlZmluZWQgKSB0ZXh0dXJlTG9hZGVyID0gbmV3IFRIUkVFLlRleHR1cmVMb2FkZXIoKTtcblx0XHRcdFx0aWYgKCBtYXRlcmlhbExvYWRlciA9PT0gdW5kZWZpbmVkICkgbWF0ZXJpYWxMb2FkZXIgPSBuZXcgVEhSRUUuTWF0ZXJpYWxMb2FkZXIoKTtcblxuXHRcdFx0XHQvLyBjb252ZXJ0IGZyb20gb2xkIG1hdGVyaWFsIGZvcm1hdFxuXG5cdFx0XHRcdHZhciB0ZXh0dXJlcyA9IHt9O1xuXG5cdFx0XHRcdGZ1bmN0aW9uIGxvYWRUZXh0dXJlKCBwYXRoLCByZXBlYXQsIG9mZnNldCwgd3JhcCwgYW5pc290cm9weSApIHtcblxuXHRcdFx0XHRcdHZhciBmdWxsUGF0aCA9IHRleHR1cmVQYXRoICsgcGF0aDtcblx0XHRcdFx0XHR2YXIgbG9hZGVyID0gVEhSRUUuTG9hZGVyLkhhbmRsZXJzLmdldCggZnVsbFBhdGggKTtcblxuXHRcdFx0XHRcdHZhciB0ZXh0dXJlO1xuXG5cdFx0XHRcdFx0aWYgKCBsb2FkZXIgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRcdHRleHR1cmUgPSBsb2FkZXIubG9hZCggZnVsbFBhdGggKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdHRleHR1cmVMb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIGNyb3NzT3JpZ2luICk7XG5cdFx0XHRcdFx0XHR0ZXh0dXJlID0gdGV4dHVyZUxvYWRlci5sb2FkKCBmdWxsUGF0aCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCByZXBlYXQgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0dGV4dHVyZS5yZXBlYXQuZnJvbUFycmF5KCByZXBlYXQgKTtcblxuXHRcdFx0XHRcdFx0aWYgKCByZXBlYXRbIDAgXSAhPT0gMSApIHRleHR1cmUud3JhcFMgPSBUSFJFRS5SZXBlYXRXcmFwcGluZztcblx0XHRcdFx0XHRcdGlmICggcmVwZWF0WyAxIF0gIT09IDEgKSB0ZXh0dXJlLndyYXBUID0gVEhSRUUuUmVwZWF0V3JhcHBpbmc7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIG9mZnNldCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHR0ZXh0dXJlLm9mZnNldC5mcm9tQXJyYXkoIG9mZnNldCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCB3cmFwICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggd3JhcFsgMCBdID09PSAncmVwZWF0JyApIHRleHR1cmUud3JhcFMgPSBUSFJFRS5SZXBlYXRXcmFwcGluZztcblx0XHRcdFx0XHRcdGlmICggd3JhcFsgMCBdID09PSAnbWlycm9yJyApIHRleHR1cmUud3JhcFMgPSBUSFJFRS5NaXJyb3JlZFJlcGVhdFdyYXBwaW5nO1xuXG5cdFx0XHRcdFx0XHRpZiAoIHdyYXBbIDEgXSA9PT0gJ3JlcGVhdCcgKSB0ZXh0dXJlLndyYXBUID0gVEhSRUUuUmVwZWF0V3JhcHBpbmc7XG5cdFx0XHRcdFx0XHRpZiAoIHdyYXBbIDEgXSA9PT0gJ21pcnJvcicgKSB0ZXh0dXJlLndyYXBUID0gVEhSRUUuTWlycm9yZWRSZXBlYXRXcmFwcGluZztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggYW5pc290cm9weSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHR0ZXh0dXJlLmFuaXNvdHJvcHkgPSBhbmlzb3Ryb3B5O1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dmFyIHV1aWQgPSBUSFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpO1xuXG5cdFx0XHRcdFx0dGV4dHVyZXNbIHV1aWQgXSA9IHRleHR1cmU7XG5cblx0XHRcdFx0XHRyZXR1cm4gdXVpZDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly9cblxuXHRcdFx0XHR2YXIganNvbiA9IHtcblx0XHRcdFx0XHR1dWlkOiBUSFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpLFxuXHRcdFx0XHRcdHR5cGU6ICdNZXNoTGFtYmVydE1hdGVyaWFsJ1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdGZvciAoIHZhciBuYW1lIGluIG0gKSB7XG5cblx0XHRcdFx0XHR2YXIgdmFsdWUgPSBtWyBuYW1lIF07XG5cblx0XHRcdFx0XHRzd2l0Y2ggKCBuYW1lICkge1xuXHRcdFx0XHRcdFx0Y2FzZSAnRGJnQ29sb3InOlxuXHRcdFx0XHRcdFx0XHRqc29uLmNvbG9yID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnRGJnSW5kZXgnOlxuXHRcdFx0XHRcdFx0Y2FzZSAnb3B0aWNhbERlbnNpdHknOlxuXHRcdFx0XHRcdFx0Y2FzZSAnaWxsdW1pbmF0aW9uJzpcblx0XHRcdFx0XHRcdFx0Ly8gVGhlc2Ugd2VyZSBuZXZlciBzdXBwb3J0ZWRcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICdEYmdOYW1lJzpcblx0XHRcdFx0XHRcdFx0anNvbi5uYW1lID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnYmxlbmRpbmcnOlxuXHRcdFx0XHRcdFx0XHRqc29uLmJsZW5kaW5nID0gVEhSRUVbIHZhbHVlIF07XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnY29sb3JEaWZmdXNlJzpcblx0XHRcdFx0XHRcdFx0anNvbi5jb2xvciA9IGNvbG9yLmZyb21BcnJheSggdmFsdWUgKS5nZXRIZXgoKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICdjb2xvclNwZWN1bGFyJzpcblx0XHRcdFx0XHRcdFx0anNvbi5zcGVjdWxhciA9IGNvbG9yLmZyb21BcnJheSggdmFsdWUgKS5nZXRIZXgoKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICdjb2xvckVtaXNzaXZlJzpcblx0XHRcdFx0XHRcdFx0anNvbi5lbWlzc2l2ZSA9IGNvbG9yLmZyb21BcnJheSggdmFsdWUgKS5nZXRIZXgoKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICdzcGVjdWxhckNvZWYnOlxuXHRcdFx0XHRcdFx0XHRqc29uLnNoaW5pbmVzcyA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ3NoYWRpbmcnOlxuXHRcdFx0XHRcdFx0XHRpZiAoIHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09ICdiYXNpYycgKSBqc29uLnR5cGUgPSAnTWVzaEJhc2ljTWF0ZXJpYWwnO1xuXHRcdFx0XHRcdFx0XHRpZiAoIHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09ICdwaG9uZycgKSBqc29uLnR5cGUgPSAnTWVzaFBob25nTWF0ZXJpYWwnO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ21hcERpZmZ1c2UnOlxuXHRcdFx0XHRcdFx0XHRqc29uLm1hcCA9IGxvYWRUZXh0dXJlKCB2YWx1ZSwgbS5tYXBEaWZmdXNlUmVwZWF0LCBtLm1hcERpZmZ1c2VPZmZzZXQsIG0ubWFwRGlmZnVzZVdyYXAsIG0ubWFwRGlmZnVzZUFuaXNvdHJvcHkgKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICdtYXBEaWZmdXNlUmVwZWF0Jzpcblx0XHRcdFx0XHRcdGNhc2UgJ21hcERpZmZ1c2VPZmZzZXQnOlxuXHRcdFx0XHRcdFx0Y2FzZSAnbWFwRGlmZnVzZVdyYXAnOlxuXHRcdFx0XHRcdFx0Y2FzZSAnbWFwRGlmZnVzZUFuaXNvdHJvcHknOlxuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ21hcExpZ2h0Jzpcblx0XHRcdFx0XHRcdFx0anNvbi5saWdodE1hcCA9IGxvYWRUZXh0dXJlKCB2YWx1ZSwgbS5tYXBMaWdodFJlcGVhdCwgbS5tYXBMaWdodE9mZnNldCwgbS5tYXBMaWdodFdyYXAsIG0ubWFwTGlnaHRBbmlzb3Ryb3B5ICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnbWFwTGlnaHRSZXBlYXQnOlxuXHRcdFx0XHRcdFx0Y2FzZSAnbWFwTGlnaHRPZmZzZXQnOlxuXHRcdFx0XHRcdFx0Y2FzZSAnbWFwTGlnaHRXcmFwJzpcblx0XHRcdFx0XHRcdGNhc2UgJ21hcExpZ2h0QW5pc290cm9weSc6XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnbWFwQU8nOlxuXHRcdFx0XHRcdFx0XHRqc29uLmFvTWFwID0gbG9hZFRleHR1cmUoIHZhbHVlLCBtLm1hcEFPUmVwZWF0LCBtLm1hcEFPT2Zmc2V0LCBtLm1hcEFPV3JhcCwgbS5tYXBBT0FuaXNvdHJvcHkgKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICdtYXBBT1JlcGVhdCc6XG5cdFx0XHRcdFx0XHRjYXNlICdtYXBBT09mZnNldCc6XG5cdFx0XHRcdFx0XHRjYXNlICdtYXBBT1dyYXAnOlxuXHRcdFx0XHRcdFx0Y2FzZSAnbWFwQU9Bbmlzb3Ryb3B5Jzpcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICdtYXBCdW1wJzpcblx0XHRcdFx0XHRcdFx0anNvbi5idW1wTWFwID0gbG9hZFRleHR1cmUoIHZhbHVlLCBtLm1hcEJ1bXBSZXBlYXQsIG0ubWFwQnVtcE9mZnNldCwgbS5tYXBCdW1wV3JhcCwgbS5tYXBCdW1wQW5pc290cm9weSApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ21hcEJ1bXBTY2FsZSc6XG5cdFx0XHRcdFx0XHRcdGpzb24uYnVtcFNjYWxlID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnbWFwQnVtcFJlcGVhdCc6XG5cdFx0XHRcdFx0XHRjYXNlICdtYXBCdW1wT2Zmc2V0Jzpcblx0XHRcdFx0XHRcdGNhc2UgJ21hcEJ1bXBXcmFwJzpcblx0XHRcdFx0XHRcdGNhc2UgJ21hcEJ1bXBBbmlzb3Ryb3B5Jzpcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICdtYXBOb3JtYWwnOlxuXHRcdFx0XHRcdFx0XHRqc29uLm5vcm1hbE1hcCA9IGxvYWRUZXh0dXJlKCB2YWx1ZSwgbS5tYXBOb3JtYWxSZXBlYXQsIG0ubWFwTm9ybWFsT2Zmc2V0LCBtLm1hcE5vcm1hbFdyYXAsIG0ubWFwTm9ybWFsQW5pc290cm9weSApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ21hcE5vcm1hbEZhY3Rvcic6XG5cdFx0XHRcdFx0XHRcdGpzb24ubm9ybWFsU2NhbGUgPSBbIHZhbHVlLCB2YWx1ZSBdO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ21hcE5vcm1hbFJlcGVhdCc6XG5cdFx0XHRcdFx0XHRjYXNlICdtYXBOb3JtYWxPZmZzZXQnOlxuXHRcdFx0XHRcdFx0Y2FzZSAnbWFwTm9ybWFsV3JhcCc6XG5cdFx0XHRcdFx0XHRjYXNlICdtYXBOb3JtYWxBbmlzb3Ryb3B5Jzpcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICdtYXBTcGVjdWxhcic6XG5cdFx0XHRcdFx0XHRcdGpzb24uc3BlY3VsYXJNYXAgPSBsb2FkVGV4dHVyZSggdmFsdWUsIG0ubWFwU3BlY3VsYXJSZXBlYXQsIG0ubWFwU3BlY3VsYXJPZmZzZXQsIG0ubWFwU3BlY3VsYXJXcmFwLCBtLm1hcFNwZWN1bGFyQW5pc290cm9weSApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ21hcFNwZWN1bGFyUmVwZWF0Jzpcblx0XHRcdFx0XHRcdGNhc2UgJ21hcFNwZWN1bGFyT2Zmc2V0Jzpcblx0XHRcdFx0XHRcdGNhc2UgJ21hcFNwZWN1bGFyV3JhcCc6XG5cdFx0XHRcdFx0XHRjYXNlICdtYXBTcGVjdWxhckFuaXNvdHJvcHknOlxuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ21hcEFscGhhJzpcblx0XHRcdFx0XHRcdFx0anNvbi5hbHBoYU1hcCA9IGxvYWRUZXh0dXJlKCB2YWx1ZSwgbS5tYXBBbHBoYVJlcGVhdCwgbS5tYXBBbHBoYU9mZnNldCwgbS5tYXBBbHBoYVdyYXAsIG0ubWFwQWxwaGFBbmlzb3Ryb3B5ICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnbWFwQWxwaGFSZXBlYXQnOlxuXHRcdFx0XHRcdFx0Y2FzZSAnbWFwQWxwaGFPZmZzZXQnOlxuXHRcdFx0XHRcdFx0Y2FzZSAnbWFwQWxwaGFXcmFwJzpcblx0XHRcdFx0XHRcdGNhc2UgJ21hcEFscGhhQW5pc290cm9weSc6XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnZmxpcFNpZGVkJzpcblx0XHRcdFx0XHRcdFx0anNvbi5zaWRlID0gVEhSRUUuQmFja1NpZGU7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnZG91YmxlU2lkZWQnOlxuXHRcdFx0XHRcdFx0XHRqc29uLnNpZGUgPSBUSFJFRS5Eb3VibGVTaWRlO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ3RyYW5zcGFyZW5jeSc6XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkxvYWRlcjogdHJhbnNwYXJlbmN5IGhhcyBiZWVuIHJlbmFtZWQgdG8gb3BhY2l0eScgKTtcblx0XHRcdFx0XHRcdFx0anNvbi5vcGFjaXR5ID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnb3BhY2l0eSc6XG5cdFx0XHRcdFx0XHRjYXNlICd0cmFuc3BhcmVudCc6XG5cdFx0XHRcdFx0XHRjYXNlICdkZXB0aFRlc3QnOlxuXHRcdFx0XHRcdFx0Y2FzZSAnZGVwdGhXcml0ZSc6XG5cdFx0XHRcdFx0XHRjYXNlICd0cmFuc3BhcmVudCc6XG5cdFx0XHRcdFx0XHRjYXNlICd2aXNpYmxlJzpcblx0XHRcdFx0XHRcdGNhc2UgJ3dpcmVmcmFtZSc6XG5cdFx0XHRcdFx0XHRcdGpzb25bIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ3ZlcnRleENvbG9ycyc6XG5cdFx0XHRcdFx0XHRcdGlmICggdmFsdWUgPT09IHRydWUgKSBqc29uLnZlcnRleENvbG9ycyA9IFRIUkVFLlZlcnRleENvbG9ycztcblx0XHRcdFx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gJ2ZhY2UnICkganNvbi52ZXJ0ZXhDb2xvcnMgPSBUSFJFRS5GYWNlQ29sb3JzO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdMb2FkZXIuY3JlYXRlTWF0ZXJpYWw6IFVuc3VwcG9ydGVkJywgbmFtZSwgdmFsdWUgKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGpzb24udHlwZSAhPT0gJ01lc2hQaG9uZ01hdGVyaWFsJyApIGRlbGV0ZSBqc29uLnNwZWN1bGFyO1xuXHRcdFx0XHRpZiAoIGpzb24ub3BhY2l0eSA8IDEgKSBqc29uLnRyYW5zcGFyZW50ID0gdHJ1ZTtcblxuXHRcdFx0XHRtYXRlcmlhbExvYWRlci5zZXRUZXh0dXJlcyggdGV4dHVyZXMgKTtcblxuXHRcdFx0XHRyZXR1cm4gbWF0ZXJpYWxMb2FkZXIucGFyc2UoIGpzb24gKTtcblxuXHRcdFx0fTtcblxuXHRcdH0gKSgpXG5cblx0fTtcblxuXHRUSFJFRS5Mb2FkZXIuSGFuZGxlcnMgPSB7XG5cblx0XHRoYW5kbGVyczogW10sXG5cblx0XHRhZGQ6IGZ1bmN0aW9uICggcmVnZXgsIGxvYWRlciApIHtcblxuXHRcdFx0dGhpcy5oYW5kbGVycy5wdXNoKCByZWdleCwgbG9hZGVyICk7XG5cblx0XHR9LFxuXG5cdFx0Z2V0OiBmdW5jdGlvbiAoIGZpbGUgKSB7XG5cblx0XHRcdHZhciBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcnM7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGw7IGkgKz0gMiApIHtcblxuXHRcdFx0XHR2YXIgcmVnZXggPSBoYW5kbGVyc1sgaSBdO1xuXHRcdFx0XHR2YXIgbG9hZGVyICA9IGhhbmRsZXJzWyBpICsgMSBdO1xuXG5cdFx0XHRcdGlmICggcmVnZXgudGVzdCggZmlsZSApICkge1xuXG5cdFx0XHRcdFx0cmV0dXJuIGxvYWRlcjtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR9XG5cblx0fTtcblxuXHQvLyBGaWxlOnNyYy9sb2FkZXJzL1hIUkxvYWRlci5qc1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuXHQgKi9cblxuXHRUSFJFRS5YSFJMb2FkZXIgPSBmdW5jdGlvbiAoIG1hbmFnZXIgKSB7XG5cblx0XHR0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IFRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcblxuXHR9O1xuXG5cdFRIUkVFLlhIUkxvYWRlci5wcm90b3R5cGUgPSB7XG5cblx0XHRjb25zdHJ1Y3RvcjogVEhSRUUuWEhSTG9hZGVyLFxuXG5cdFx0bG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuXHRcdFx0dmFyIHNjb3BlID0gdGhpcztcblxuXHRcdFx0dmFyIGNhY2hlZCA9IFRIUkVFLkNhY2hlLmdldCggdXJsICk7XG5cblx0XHRcdGlmICggY2FjaGVkICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0aWYgKCBvbkxvYWQgKSB7XG5cblx0XHRcdFx0XHRzZXRUaW1lb3V0KCBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0XHRcdG9uTG9hZCggY2FjaGVkICk7XG5cblx0XHRcdFx0XHR9LCAwICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBjYWNoZWQ7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblx0XHRcdHJlcXVlc3Qub3BlbiggJ0dFVCcsIHVybCwgdHJ1ZSApO1xuXG5cdFx0XHRyZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoICdsb2FkJywgZnVuY3Rpb24gKCBldmVudCApIHtcblxuXHRcdFx0XHR2YXIgcmVzcG9uc2UgPSBldmVudC50YXJnZXQucmVzcG9uc2U7XG5cblx0XHRcdFx0VEhSRUUuQ2FjaGUuYWRkKCB1cmwsIHJlc3BvbnNlICk7XG5cblx0XHRcdFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIHJlc3BvbnNlICk7XG5cblx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcblxuXHRcdFx0fSwgZmFsc2UgKTtcblxuXHRcdFx0aWYgKCBvblByb2dyZXNzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCAncHJvZ3Jlc3MnLCBmdW5jdGlvbiAoIGV2ZW50ICkge1xuXG5cdFx0XHRcdFx0b25Qcm9ncmVzcyggZXZlbnQgKTtcblxuXHRcdFx0XHR9LCBmYWxzZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lciggJ2Vycm9yJywgZnVuY3Rpb24gKCBldmVudCApIHtcblxuXHRcdFx0XHRpZiAoIG9uRXJyb3IgKSBvbkVycm9yKCBldmVudCApO1xuXG5cdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVycm9yKCB1cmwgKTtcblxuXHRcdFx0fSwgZmFsc2UgKTtcblxuXHRcdFx0aWYgKCB0aGlzLmNyb3NzT3JpZ2luICE9PSB1bmRlZmluZWQgKSByZXF1ZXN0LmNyb3NzT3JpZ2luID0gdGhpcy5jcm9zc09yaWdpbjtcblx0XHRcdGlmICggdGhpcy5yZXNwb25zZVR5cGUgIT09IHVuZGVmaW5lZCApIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gdGhpcy5yZXNwb25zZVR5cGU7XG5cdFx0XHRpZiAoIHRoaXMud2l0aENyZWRlbnRpYWxzICE9PSB1bmRlZmluZWQgKSByZXF1ZXN0LndpdGhDcmVkZW50aWFscyA9IHRoaXMud2l0aENyZWRlbnRpYWxzO1xuXG5cdFx0XHRyZXF1ZXN0LnNlbmQoIG51bGwgKTtcblxuXHRcdFx0c2NvcGUubWFuYWdlci5pdGVtU3RhcnQoIHVybCApO1xuXG5cdFx0XHRyZXR1cm4gcmVxdWVzdDtcblxuXHRcdH0sXG5cblx0XHRzZXRSZXNwb25zZVR5cGU6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdHRoaXMucmVzcG9uc2VUeXBlID0gdmFsdWU7XG5cblx0XHR9LFxuXG5cdFx0c2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdHRoaXMuY3Jvc3NPcmlnaW4gPSB2YWx1ZTtcblxuXHRcdH0sXG5cblx0XHRzZXRXaXRoQ3JlZGVudGlhbHM6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdHRoaXMud2l0aENyZWRlbnRpYWxzID0gdmFsdWU7XG5cblx0XHR9XG5cblx0fTtcblxuXHQvLyBGaWxlOnNyYy9sb2FkZXJzL0ltYWdlTG9hZGVyLmpzXG5cblx0LyoqXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqL1xuXG5cdFRIUkVFLkltYWdlTG9hZGVyID0gZnVuY3Rpb24gKCBtYW5hZ2VyICkge1xuXG5cdFx0dGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBUSFJFRS5EZWZhdWx0TG9hZGluZ01hbmFnZXI7XG5cblx0fTtcblxuXHRUSFJFRS5JbWFnZUxvYWRlci5wcm90b3R5cGUgPSB7XG5cblx0XHRjb25zdHJ1Y3RvcjogVEhSRUUuSW1hZ2VMb2FkZXIsXG5cblx0XHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG5cdFx0XHR2YXIgc2NvcGUgPSB0aGlzO1xuXG5cdFx0XHR2YXIgY2FjaGVkID0gVEhSRUUuQ2FjaGUuZ2V0KCB1cmwgKTtcblxuXHRcdFx0aWYgKCBjYWNoZWQgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1TdGFydCggdXJsICk7XG5cblx0XHRcdFx0aWYgKCBvbkxvYWQgKSB7XG5cblx0XHRcdFx0XHRzZXRUaW1lb3V0KCBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0XHRcdG9uTG9hZCggY2FjaGVkICk7XG5cblx0XHRcdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XG5cblx0XHRcdFx0XHR9LCAwICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBjYWNoZWQ7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIGltYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2ltZycgKTtcblxuXHRcdFx0aW1hZ2UuYWRkRXZlbnRMaXN0ZW5lciggJ2xvYWQnLCBmdW5jdGlvbiAoIGV2ZW50ICkge1xuXG5cdFx0XHRcdFRIUkVFLkNhY2hlLmFkZCggdXJsLCB0aGlzICk7XG5cblx0XHRcdFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIHRoaXMgKTtcblxuXHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xuXG5cdFx0XHR9LCBmYWxzZSApO1xuXG5cdFx0XHRpZiAoIG9uUHJvZ3Jlc3MgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRpbWFnZS5hZGRFdmVudExpc3RlbmVyKCAncHJvZ3Jlc3MnLCBmdW5jdGlvbiAoIGV2ZW50ICkge1xuXG5cdFx0XHRcdFx0b25Qcm9ncmVzcyggZXZlbnQgKTtcblxuXHRcdFx0XHR9LCBmYWxzZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoICdlcnJvcicsIGZ1bmN0aW9uICggZXZlbnQgKSB7XG5cblx0XHRcdFx0aWYgKCBvbkVycm9yICkgb25FcnJvciggZXZlbnQgKTtcblxuXHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FcnJvciggdXJsICk7XG5cblx0XHRcdH0sIGZhbHNlICk7XG5cblx0XHRcdGlmICggdGhpcy5jcm9zc09yaWdpbiAhPT0gdW5kZWZpbmVkICkgaW1hZ2UuY3Jvc3NPcmlnaW4gPSB0aGlzLmNyb3NzT3JpZ2luO1xuXG5cdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1TdGFydCggdXJsICk7XG5cblx0XHRcdGltYWdlLnNyYyA9IHVybDtcblxuXHRcdFx0cmV0dXJuIGltYWdlO1xuXG5cdFx0fSxcblxuXHRcdHNldENyb3NzT3JpZ2luOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHR0aGlzLmNyb3NzT3JpZ2luID0gdmFsdWU7XG5cblx0XHR9XG5cblx0fTtcblxuXHQvLyBGaWxlOnNyYy9sb2FkZXJzL0pTT05Mb2FkZXIuanNcblxuXHQvKipcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cblx0ICovXG5cblx0VEhSRUUuSlNPTkxvYWRlciA9IGZ1bmN0aW9uICggbWFuYWdlciApIHtcblxuXHRcdGlmICggdHlwZW9mIG1hbmFnZXIgPT09ICdib29sZWFuJyApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuSlNPTkxvYWRlcjogc2hvd1N0YXR1cyBwYXJhbWV0ZXIgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIGNvbnN0cnVjdG9yLicgKTtcblx0XHRcdG1hbmFnZXIgPSB1bmRlZmluZWQ7XG5cblx0XHR9XG5cblx0XHR0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IFRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcblxuXHRcdHRoaXMud2l0aENyZWRlbnRpYWxzID0gZmFsc2U7XG5cblx0fTtcblxuXHRUSFJFRS5KU09OTG9hZGVyLnByb3RvdHlwZSA9IHtcblxuXHRcdGNvbnN0cnVjdG9yOiBUSFJFRS5KU09OTG9hZGVyLFxuXG5cdFx0Ly8gRGVwcmVjYXRlZFxuXG5cdFx0Z2V0IHN0YXR1c0RvbUVsZW1lbnQgKCkge1xuXG5cdFx0XHRpZiAoIHRoaXMuX3N0YXR1c0RvbUVsZW1lbnQgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHR0aGlzLl9zdGF0dXNEb21FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2RpdicgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5KU09OTG9hZGVyOiAuc3RhdHVzRG9tRWxlbWVudCBoYXMgYmVlbiByZW1vdmVkLicgKTtcblx0XHRcdHJldHVybiB0aGlzLl9zdGF0dXNEb21FbGVtZW50O1xuXG5cdFx0fSxcblxuXHRcdGxvYWQ6IGZ1bmN0aW9uKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuXHRcdFx0dmFyIHNjb3BlID0gdGhpcztcblxuXHRcdFx0dmFyIHRleHR1cmVQYXRoID0gdGhpcy50ZXh0dXJlUGF0aCAmJiAoIHR5cGVvZiB0aGlzLnRleHR1cmVQYXRoID09PSBcInN0cmluZ1wiICkgPyB0aGlzLnRleHR1cmVQYXRoIDogVEhSRUUuTG9hZGVyLnByb3RvdHlwZS5leHRyYWN0VXJsQmFzZSggdXJsICk7XG5cblx0XHRcdHZhciBsb2FkZXIgPSBuZXcgVEhSRUUuWEhSTG9hZGVyKCB0aGlzLm1hbmFnZXIgKTtcblx0XHRcdGxvYWRlci5zZXRDcm9zc09yaWdpbiggdGhpcy5jcm9zc09yaWdpbiApO1xuXHRcdFx0bG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyggdGhpcy53aXRoQ3JlZGVudGlhbHMgKTtcblx0XHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggdGV4dCApIHtcblxuXHRcdFx0XHR2YXIganNvbiA9IEpTT04ucGFyc2UoIHRleHQgKTtcblx0XHRcdFx0dmFyIG1ldGFkYXRhID0ganNvbi5tZXRhZGF0YTtcblxuXHRcdFx0XHRpZiAoIG1ldGFkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRpZiAoIG1ldGFkYXRhLnR5cGUgPT09ICdvYmplY3QnICkge1xuXG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuSlNPTkxvYWRlcjogJyArIHVybCArICcgc2hvdWxkIGJlIGxvYWRlZCB3aXRoIFRIUkVFLk9iamVjdExvYWRlciBpbnN0ZWFkLicgKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggbWV0YWRhdGEudHlwZSA9PT0gJ3NjZW5lJyApIHtcblxuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkpTT05Mb2FkZXI6ICcgKyB1cmwgKyAnIHNob3VsZCBiZSBsb2FkZWQgd2l0aCBUSFJFRS5TY2VuZUxvYWRlciBpbnN0ZWFkLicgKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIG9iamVjdCA9IHNjb3BlLnBhcnNlKCBqc29uLCB0ZXh0dXJlUGF0aCApO1xuXHRcdFx0XHRvbkxvYWQoIG9iamVjdC5nZW9tZXRyeSwgb2JqZWN0Lm1hdGVyaWFscyApO1xuXG5cdFx0XHR9ICk7XG5cblx0XHR9LFxuXG5cdFx0c2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdHRoaXMuY3Jvc3NPcmlnaW4gPSB2YWx1ZTtcblxuXHRcdH0sXG5cblx0XHRzZXRUZXh0dXJlUGF0aDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdFx0dGhpcy50ZXh0dXJlUGF0aCA9IHZhbHVlO1xuXG5cdFx0fSxcblxuXHRcdHBhcnNlOiBmdW5jdGlvbiAoIGpzb24sIHRleHR1cmVQYXRoICkge1xuXG5cdFx0XHR2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKSxcblx0XHRcdHNjYWxlID0gKCBqc29uLnNjYWxlICE9PSB1bmRlZmluZWQgKSA/IDEuMCAvIGpzb24uc2NhbGUgOiAxLjA7XG5cblx0XHRcdHBhcnNlTW9kZWwoIHNjYWxlICk7XG5cblx0XHRcdHBhcnNlU2tpbigpO1xuXHRcdFx0cGFyc2VNb3JwaGluZyggc2NhbGUgKTtcblx0XHRcdHBhcnNlQW5pbWF0aW9ucygpO1xuXG5cdFx0XHRnZW9tZXRyeS5jb21wdXRlRmFjZU5vcm1hbHMoKTtcblx0XHRcdGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXG5cdFx0XHRmdW5jdGlvbiBwYXJzZU1vZGVsKCBzY2FsZSApIHtcblxuXHRcdFx0XHRmdW5jdGlvbiBpc0JpdFNldCggdmFsdWUsIHBvc2l0aW9uICkge1xuXG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlICYgKCAxIDw8IHBvc2l0aW9uICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBpLCBqLCBmaSxcblxuXHRcdFx0XHRvZmZzZXQsIHpMZW5ndGgsXG5cblx0XHRcdGNvbG9ySW5kZXgsIG5vcm1hbEluZGV4LCB1dkluZGV4LCBtYXRlcmlhbEluZGV4LFxuXG5cdFx0XHRcdHR5cGUsXG5cdFx0XHRcdGlzUXVhZCxcblx0XHRcdFx0aGFzTWF0ZXJpYWwsXG5cdFx0XHRcdGhhc0ZhY2VWZXJ0ZXhVdixcblx0XHRcdFx0aGFzRmFjZU5vcm1hbCwgaGFzRmFjZVZlcnRleE5vcm1hbCxcblx0XHRcdFx0aGFzRmFjZUNvbG9yLCBoYXNGYWNlVmVydGV4Q29sb3IsXG5cblx0XHRcdHZlcnRleCwgZmFjZSwgZmFjZUEsIGZhY2VCLCBoZXgsIG5vcm1hbCxcblxuXHRcdFx0XHR1dkxheWVyLCB1diwgdSwgdixcblxuXHRcdFx0XHRmYWNlcyA9IGpzb24uZmFjZXMsXG5cdFx0XHRcdHZlcnRpY2VzID0ganNvbi52ZXJ0aWNlcyxcblx0XHRcdFx0bm9ybWFscyA9IGpzb24ubm9ybWFscyxcblx0XHRcdFx0Y29sb3JzID0ganNvbi5jb2xvcnMsXG5cblx0XHRcdFx0blV2TGF5ZXJzID0gMDtcblxuXHRcdFx0XHRpZiAoIGpzb24udXZzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHQvLyBkaXNyZWdhcmQgZW1wdHkgYXJyYXlzXG5cblx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGpzb24udXZzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBqc29uLnV2c1sgaSBdLmxlbmd0aCApIG5VdkxheWVycyArKztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgblV2TGF5ZXJzOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF0gPSBbXTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0b2Zmc2V0ID0gMDtcblx0XHRcdFx0ekxlbmd0aCA9IHZlcnRpY2VzLmxlbmd0aDtcblxuXHRcdFx0XHR3aGlsZSAoIG9mZnNldCA8IHpMZW5ndGggKSB7XG5cblx0XHRcdFx0XHR2ZXJ0ZXggPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0XHRcdFx0dmVydGV4LnggPSB2ZXJ0aWNlc1sgb2Zmc2V0ICsrIF0gKiBzY2FsZTtcblx0XHRcdFx0XHR2ZXJ0ZXgueSA9IHZlcnRpY2VzWyBvZmZzZXQgKysgXSAqIHNjYWxlO1xuXHRcdFx0XHRcdHZlcnRleC56ID0gdmVydGljZXNbIG9mZnNldCArKyBdICogc2NhbGU7XG5cblx0XHRcdFx0XHRnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXggKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0b2Zmc2V0ID0gMDtcblx0XHRcdFx0ekxlbmd0aCA9IGZhY2VzLmxlbmd0aDtcblxuXHRcdFx0XHR3aGlsZSAoIG9mZnNldCA8IHpMZW5ndGggKSB7XG5cblx0XHRcdFx0XHR0eXBlID0gZmFjZXNbIG9mZnNldCArKyBdO1xuXG5cblx0XHRcdFx0XHRpc1F1YWQgICAgICAgICAgICAgID0gaXNCaXRTZXQoIHR5cGUsIDAgKTtcblx0XHRcdFx0XHRoYXNNYXRlcmlhbCAgICAgICAgID0gaXNCaXRTZXQoIHR5cGUsIDEgKTtcblx0XHRcdFx0XHRoYXNGYWNlVmVydGV4VXYgICAgID0gaXNCaXRTZXQoIHR5cGUsIDMgKTtcblx0XHRcdFx0XHRoYXNGYWNlTm9ybWFsICAgICAgID0gaXNCaXRTZXQoIHR5cGUsIDQgKTtcblx0XHRcdFx0XHRoYXNGYWNlVmVydGV4Tm9ybWFsID0gaXNCaXRTZXQoIHR5cGUsIDUgKTtcblx0XHRcdFx0XHRoYXNGYWNlQ29sb3JcdCAgICAgPSBpc0JpdFNldCggdHlwZSwgNiApO1xuXHRcdFx0XHRcdGhhc0ZhY2VWZXJ0ZXhDb2xvciAgPSBpc0JpdFNldCggdHlwZSwgNyApO1xuXG5cdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coXCJ0eXBlXCIsIHR5cGUsIFwiYml0c1wiLCBpc1F1YWQsIGhhc01hdGVyaWFsLCBoYXNGYWNlVmVydGV4VXYsIGhhc0ZhY2VOb3JtYWwsIGhhc0ZhY2VWZXJ0ZXhOb3JtYWwsIGhhc0ZhY2VDb2xvciwgaGFzRmFjZVZlcnRleENvbG9yKTtcblxuXHRcdFx0XHRcdGlmICggaXNRdWFkICkge1xuXG5cdFx0XHRcdFx0XHRmYWNlQSA9IG5ldyBUSFJFRS5GYWNlMygpO1xuXHRcdFx0XHRcdFx0ZmFjZUEuYSA9IGZhY2VzWyBvZmZzZXQgXTtcblx0XHRcdFx0XHRcdGZhY2VBLmIgPSBmYWNlc1sgb2Zmc2V0ICsgMSBdO1xuXHRcdFx0XHRcdFx0ZmFjZUEuYyA9IGZhY2VzWyBvZmZzZXQgKyAzIF07XG5cblx0XHRcdFx0XHRcdGZhY2VCID0gbmV3IFRIUkVFLkZhY2UzKCk7XG5cdFx0XHRcdFx0XHRmYWNlQi5hID0gZmFjZXNbIG9mZnNldCArIDEgXTtcblx0XHRcdFx0XHRcdGZhY2VCLmIgPSBmYWNlc1sgb2Zmc2V0ICsgMiBdO1xuXHRcdFx0XHRcdFx0ZmFjZUIuYyA9IGZhY2VzWyBvZmZzZXQgKyAzIF07XG5cblx0XHRcdFx0XHRcdG9mZnNldCArPSA0O1xuXG5cdFx0XHRcdFx0XHRpZiAoIGhhc01hdGVyaWFsICkge1xuXG5cdFx0XHRcdFx0XHRcdG1hdGVyaWFsSW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF07XG5cdFx0XHRcdFx0XHRcdGZhY2VBLm1hdGVyaWFsSW5kZXggPSBtYXRlcmlhbEluZGV4O1xuXHRcdFx0XHRcdFx0XHRmYWNlQi5tYXRlcmlhbEluZGV4ID0gbWF0ZXJpYWxJbmRleDtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyB0byBnZXQgZmFjZSA8PT4gdXYgaW5kZXggY29ycmVzcG9uZGVuY2VcblxuXHRcdFx0XHRcdFx0ZmkgPSBnZW9tZXRyeS5mYWNlcy5sZW5ndGg7XG5cblx0XHRcdFx0XHRcdGlmICggaGFzRmFjZVZlcnRleFV2ICkge1xuXG5cdFx0XHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgblV2TGF5ZXJzOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0dXZMYXllciA9IGpzb24udXZzWyBpIF07XG5cblx0XHRcdFx0XHRcdFx0XHRnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF1bIGZpIF0gPSBbXTtcblx0XHRcdFx0XHRcdFx0XHRnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF1bIGZpICsgMSBdID0gW107XG5cblx0XHRcdFx0XHRcdFx0XHRmb3IgKCBqID0gMDsgaiA8IDQ7IGogKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdHV2SW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF07XG5cblx0XHRcdFx0XHRcdFx0XHRcdHUgPSB1dkxheWVyWyB1dkluZGV4ICogMiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0diA9IHV2TGF5ZXJbIHV2SW5kZXggKiAyICsgMSBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR1diA9IG5ldyBUSFJFRS5WZWN0b3IyKCB1LCB2ICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmICggaiAhPT0gMiApIGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIGkgXVsgZmkgXS5wdXNoKCB1diApO1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBqICE9PSAwICkgZ2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgaSBdWyBmaSArIDEgXS5wdXNoKCB1diApO1xuXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAoIGhhc0ZhY2VOb3JtYWwgKSB7XG5cblx0XHRcdFx0XHRcdFx0bm9ybWFsSW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF0gKiAzO1xuXG5cdFx0XHRcdFx0XHRcdGZhY2VBLm5vcm1hbC5zZXQoXG5cdFx0XHRcdFx0XHRcdFx0bm9ybWFsc1sgbm9ybWFsSW5kZXggKysgXSxcblx0XHRcdFx0XHRcdFx0XHRub3JtYWxzWyBub3JtYWxJbmRleCArKyBdLFxuXHRcdFx0XHRcdFx0XHRcdG5vcm1hbHNbIG5vcm1hbEluZGV4IF1cblx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0XHRmYWNlQi5ub3JtYWwuY29weSggZmFjZUEubm9ybWFsICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKCBoYXNGYWNlVmVydGV4Tm9ybWFsICkge1xuXG5cdFx0XHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgNDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRcdG5vcm1hbEluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdICogMztcblxuXHRcdFx0XHRcdFx0XHRcdG5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKFxuXHRcdFx0XHRcdFx0XHRcdFx0bm9ybWFsc1sgbm9ybWFsSW5kZXggKysgXSxcblx0XHRcdFx0XHRcdFx0XHRcdG5vcm1hbHNbIG5vcm1hbEluZGV4ICsrIF0sXG5cdFx0XHRcdFx0XHRcdFx0XHRub3JtYWxzWyBub3JtYWxJbmRleCBdXG5cdFx0XHRcdFx0XHRcdFx0KTtcblxuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBpICE9PSAyICkgZmFjZUEudmVydGV4Tm9ybWFscy5wdXNoKCBub3JtYWwgKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGkgIT09IDAgKSBmYWNlQi52ZXJ0ZXhOb3JtYWxzLnB1c2goIG5vcm1hbCApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cblx0XHRcdFx0XHRcdGlmICggaGFzRmFjZUNvbG9yICkge1xuXG5cdFx0XHRcdFx0XHRcdGNvbG9ySW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF07XG5cdFx0XHRcdFx0XHRcdGhleCA9IGNvbG9yc1sgY29sb3JJbmRleCBdO1xuXG5cdFx0XHRcdFx0XHRcdGZhY2VBLmNvbG9yLnNldEhleCggaGV4ICk7XG5cdFx0XHRcdFx0XHRcdGZhY2VCLmNvbG9yLnNldEhleCggaGV4ICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXG5cdFx0XHRcdFx0XHRpZiAoIGhhc0ZhY2VWZXJ0ZXhDb2xvciApIHtcblxuXHRcdFx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IDQ7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRjb2xvckluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdO1xuXHRcdFx0XHRcdFx0XHRcdGhleCA9IGNvbG9yc1sgY29sb3JJbmRleCBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBpICE9PSAyICkgZmFjZUEudmVydGV4Q29sb3JzLnB1c2goIG5ldyBUSFJFRS5Db2xvciggaGV4ICkgKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGkgIT09IDAgKSBmYWNlQi52ZXJ0ZXhDb2xvcnMucHVzaCggbmV3IFRIUkVFLkNvbG9yKCBoZXggKSApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRnZW9tZXRyeS5mYWNlcy5wdXNoKCBmYWNlQSApO1xuXHRcdFx0XHRcdFx0Z2VvbWV0cnkuZmFjZXMucHVzaCggZmFjZUIgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdGZhY2UgPSBuZXcgVEhSRUUuRmFjZTMoKTtcblx0XHRcdFx0XHRcdGZhY2UuYSA9IGZhY2VzWyBvZmZzZXQgKysgXTtcblx0XHRcdFx0XHRcdGZhY2UuYiA9IGZhY2VzWyBvZmZzZXQgKysgXTtcblx0XHRcdFx0XHRcdGZhY2UuYyA9IGZhY2VzWyBvZmZzZXQgKysgXTtcblxuXHRcdFx0XHRcdFx0aWYgKCBoYXNNYXRlcmlhbCApIHtcblxuXHRcdFx0XHRcdFx0XHRtYXRlcmlhbEluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdO1xuXHRcdFx0XHRcdFx0XHRmYWNlLm1hdGVyaWFsSW5kZXggPSBtYXRlcmlhbEluZGV4O1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIHRvIGdldCBmYWNlIDw9PiB1diBpbmRleCBjb3JyZXNwb25kZW5jZVxuXG5cdFx0XHRcdFx0XHRmaSA9IGdlb21ldHJ5LmZhY2VzLmxlbmd0aDtcblxuXHRcdFx0XHRcdFx0aWYgKCBoYXNGYWNlVmVydGV4VXYgKSB7XG5cblx0XHRcdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBuVXZMYXllcnM7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHR1dkxheWVyID0ganNvbi51dnNbIGkgXTtcblxuXHRcdFx0XHRcdFx0XHRcdGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIGkgXVsgZmkgXSA9IFtdO1xuXG5cdFx0XHRcdFx0XHRcdFx0Zm9yICggaiA9IDA7IGogPCAzOyBqICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR1dkluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR1ID0gdXZMYXllclsgdXZJbmRleCAqIDIgXTtcblx0XHRcdFx0XHRcdFx0XHRcdHYgPSB1dkxheWVyWyB1dkluZGV4ICogMiArIDEgXTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0dXYgPSBuZXcgVEhSRUUuVmVjdG9yMiggdSwgdiApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF1bIGZpIF0ucHVzaCggdXYgKTtcblxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKCBoYXNGYWNlTm9ybWFsICkge1xuXG5cdFx0XHRcdFx0XHRcdG5vcm1hbEluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdICogMztcblxuXHRcdFx0XHRcdFx0XHRmYWNlLm5vcm1hbC5zZXQoXG5cdFx0XHRcdFx0XHRcdFx0bm9ybWFsc1sgbm9ybWFsSW5kZXggKysgXSxcblx0XHRcdFx0XHRcdFx0XHRub3JtYWxzWyBub3JtYWxJbmRleCArKyBdLFxuXHRcdFx0XHRcdFx0XHRcdG5vcm1hbHNbIG5vcm1hbEluZGV4IF1cblx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAoIGhhc0ZhY2VWZXJ0ZXhOb3JtYWwgKSB7XG5cblx0XHRcdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCAzOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0bm9ybWFsSW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF0gKiAzO1xuXG5cdFx0XHRcdFx0XHRcdFx0bm9ybWFsID0gbmV3IFRIUkVFLlZlY3RvcjMoXG5cdFx0XHRcdFx0XHRcdFx0XHRub3JtYWxzWyBub3JtYWxJbmRleCArKyBdLFxuXHRcdFx0XHRcdFx0XHRcdFx0bm9ybWFsc1sgbm9ybWFsSW5kZXggKysgXSxcblx0XHRcdFx0XHRcdFx0XHRcdG5vcm1hbHNbIG5vcm1hbEluZGV4IF1cblx0XHRcdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRcdFx0ZmFjZS52ZXJ0ZXhOb3JtYWxzLnB1c2goIG5vcm1hbCApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cblx0XHRcdFx0XHRcdGlmICggaGFzRmFjZUNvbG9yICkge1xuXG5cdFx0XHRcdFx0XHRcdGNvbG9ySW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF07XG5cdFx0XHRcdFx0XHRcdGZhY2UuY29sb3Iuc2V0SGV4KCBjb2xvcnNbIGNvbG9ySW5kZXggXSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblxuXHRcdFx0XHRcdFx0aWYgKCBoYXNGYWNlVmVydGV4Q29sb3IgKSB7XG5cblx0XHRcdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCAzOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Y29sb3JJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXTtcblx0XHRcdFx0XHRcdFx0XHRmYWNlLnZlcnRleENvbG9ycy5wdXNoKCBuZXcgVEhSRUUuQ29sb3IoIGNvbG9yc1sgY29sb3JJbmRleCBdICkgKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Z2VvbWV0cnkuZmFjZXMucHVzaCggZmFjZSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fTtcblxuXHRcdFx0ZnVuY3Rpb24gcGFyc2VTa2luKCkge1xuXG5cdFx0XHRcdHZhciBpbmZsdWVuY2VzUGVyVmVydGV4ID0gKCBqc29uLmluZmx1ZW5jZXNQZXJWZXJ0ZXggIT09IHVuZGVmaW5lZCApID8ganNvbi5pbmZsdWVuY2VzUGVyVmVydGV4IDogMjtcblxuXHRcdFx0XHRpZiAoIGpzb24uc2tpbldlaWdodHMgKSB7XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLnNraW5XZWlnaHRzLmxlbmd0aDsgaSA8IGw7IGkgKz0gaW5mbHVlbmNlc1BlclZlcnRleCApIHtcblxuXHRcdFx0XHRcdFx0dmFyIHggPSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uLnNraW5XZWlnaHRzWyBpIF07XG5cdFx0XHRcdFx0XHR2YXIgeSA9ICggaW5mbHVlbmNlc1BlclZlcnRleCA+IDEgKSA/IGpzb24uc2tpbldlaWdodHNbIGkgKyAxIF0gOiAwO1xuXHRcdFx0XHRcdFx0dmFyIHogPSAoIGluZmx1ZW5jZXNQZXJWZXJ0ZXggPiAyICkgPyBqc29uLnNraW5XZWlnaHRzWyBpICsgMiBdIDogMDtcblx0XHRcdFx0XHRcdHZhciB3ID0gKCBpbmZsdWVuY2VzUGVyVmVydGV4ID4gMyApID8ganNvbi5za2luV2VpZ2h0c1sgaSArIDMgXSA6IDA7XG5cblx0XHRcdFx0XHRcdGdlb21ldHJ5LnNraW5XZWlnaHRzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3I0KCB4LCB5LCB6LCB3ICkgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBqc29uLnNraW5JbmRpY2VzICkge1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0ganNvbi5za2luSW5kaWNlcy5sZW5ndGg7IGkgPCBsOyBpICs9IGluZmx1ZW5jZXNQZXJWZXJ0ZXggKSB7XG5cblx0XHRcdFx0XHRcdHZhciBhID0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbi5za2luSW5kaWNlc1sgaSBdO1xuXHRcdFx0XHRcdFx0dmFyIGIgPSAoIGluZmx1ZW5jZXNQZXJWZXJ0ZXggPiAxICkgPyBqc29uLnNraW5JbmRpY2VzWyBpICsgMSBdIDogMDtcblx0XHRcdFx0XHRcdHZhciBjID0gKCBpbmZsdWVuY2VzUGVyVmVydGV4ID4gMiApID8ganNvbi5za2luSW5kaWNlc1sgaSArIDIgXSA6IDA7XG5cdFx0XHRcdFx0XHR2YXIgZCA9ICggaW5mbHVlbmNlc1BlclZlcnRleCA+IDMgKSA/IGpzb24uc2tpbkluZGljZXNbIGkgKyAzIF0gOiAwO1xuXG5cdFx0XHRcdFx0XHRnZW9tZXRyeS5za2luSW5kaWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yNCggYSwgYiwgYywgZCApICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGdlb21ldHJ5LmJvbmVzID0ganNvbi5ib25lcztcblxuXHRcdFx0XHRpZiAoIGdlb21ldHJ5LmJvbmVzICYmIGdlb21ldHJ5LmJvbmVzLmxlbmd0aCA+IDAgJiYgKCBnZW9tZXRyeS5za2luV2VpZ2h0cy5sZW5ndGggIT09IGdlb21ldHJ5LnNraW5JbmRpY2VzLmxlbmd0aCB8fCBnZW9tZXRyeS5za2luSW5kaWNlcy5sZW5ndGggIT09IGdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aCApICkge1xuXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnV2hlbiBza2lubmluZywgbnVtYmVyIG9mIHZlcnRpY2VzICgnICsgZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoICsgJyksIHNraW5JbmRpY2VzICgnICtcblx0XHRcdFx0XHRcdGdlb21ldHJ5LnNraW5JbmRpY2VzLmxlbmd0aCArICcpLCBhbmQgc2tpbldlaWdodHMgKCcgKyBnZW9tZXRyeS5za2luV2VpZ2h0cy5sZW5ndGggKyAnKSBzaG91bGQgbWF0Y2guJyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fTtcblxuXHRcdFx0ZnVuY3Rpb24gcGFyc2VNb3JwaGluZyggc2NhbGUgKSB7XG5cblx0XHRcdFx0aWYgKCBqc29uLm1vcnBoVGFyZ2V0cyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0ganNvbi5tb3JwaFRhcmdldHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0Z2VvbWV0cnkubW9ycGhUYXJnZXRzWyBpIF0gPSB7fTtcblx0XHRcdFx0XHRcdGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1sgaSBdLm5hbWUgPSBqc29uLm1vcnBoVGFyZ2V0c1sgaSBdLm5hbWU7XG5cdFx0XHRcdFx0XHRnZW9tZXRyeS5tb3JwaFRhcmdldHNbIGkgXS52ZXJ0aWNlcyA9IFtdO1xuXG5cdFx0XHRcdFx0XHR2YXIgZHN0VmVydGljZXMgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHNbIGkgXS52ZXJ0aWNlcztcblx0XHRcdFx0XHRcdHZhciBzcmNWZXJ0aWNlcyA9IGpzb24ubW9ycGhUYXJnZXRzWyBpIF0udmVydGljZXM7XG5cblx0XHRcdFx0XHRcdGZvciAoIHZhciB2ID0gMCwgdmwgPSBzcmNWZXJ0aWNlcy5sZW5ndGg7IHYgPCB2bDsgdiArPSAzICkge1xuXG5cdFx0XHRcdFx0XHRcdHZhciB2ZXJ0ZXggPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdFx0XHRcdFx0XHR2ZXJ0ZXgueCA9IHNyY1ZlcnRpY2VzWyB2IF0gKiBzY2FsZTtcblx0XHRcdFx0XHRcdFx0dmVydGV4LnkgPSBzcmNWZXJ0aWNlc1sgdiArIDEgXSAqIHNjYWxlO1xuXHRcdFx0XHRcdFx0XHR2ZXJ0ZXgueiA9IHNyY1ZlcnRpY2VzWyB2ICsgMiBdICogc2NhbGU7XG5cblx0XHRcdFx0XHRcdFx0ZHN0VmVydGljZXMucHVzaCggdmVydGV4ICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBqc29uLm1vcnBoQ29sb3JzICE9PSB1bmRlZmluZWQgJiYganNvbi5tb3JwaENvbG9ycy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuSlNPTkxvYWRlcjogXCJtb3JwaENvbG9yc1wiIG5vIGxvbmdlciBzdXBwb3J0ZWQuIFVzaW5nIHRoZW0gYXMgZmFjZSBjb2xvcnMuJyApO1xuXG5cdFx0XHRcdFx0dmFyIGZhY2VzID0gZ2VvbWV0cnkuZmFjZXM7XG5cdFx0XHRcdFx0dmFyIG1vcnBoQ29sb3JzID0ganNvbi5tb3JwaENvbG9yc1sgMCBdLmNvbG9ycztcblxuXHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGZhY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdGZhY2VzWyBpIF0uY29sb3IuZnJvbUFycmF5KCBtb3JwaENvbG9ycywgaSAqIDMgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gcGFyc2VBbmltYXRpb25zKCkge1xuXG5cdFx0XHRcdHZhciBvdXRwdXRBbmltYXRpb25zID0gW107XG5cblx0XHRcdFx0Ly8gcGFyc2Ugb2xkIHN0eWxlIEJvbmUvSGllcmFyY2h5IGFuaW1hdGlvbnNcblx0XHRcdFx0dmFyIGFuaW1hdGlvbnMgPSBbXTtcblx0XHRcdFx0aWYgKCBqc29uLmFuaW1hdGlvbiAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdGFuaW1hdGlvbnMucHVzaCgganNvbi5hbmltYXRpb24gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGpzb24uYW5pbWF0aW9ucyAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdGlmICgganNvbi5hbmltYXRpb25zLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdGFuaW1hdGlvbnMgPSBhbmltYXRpb25zLmNvbmNhdCgganNvbi5hbmltYXRpb25zICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGFuaW1hdGlvbnMucHVzaCgganNvbi5hbmltYXRpb25zICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgYW5pbWF0aW9ucy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgY2xpcCA9IFRIUkVFLkFuaW1hdGlvbkNsaXAucGFyc2VBbmltYXRpb24oIGFuaW1hdGlvbnNbaV0sIGdlb21ldHJ5LmJvbmVzICk7XG5cdFx0XHRcdFx0aWYgKCBjbGlwICkgb3V0cHV0QW5pbWF0aW9ucy5wdXNoKCBjbGlwICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHBhcnNlIGltcGxpY2l0IG1vcnBoIGFuaW1hdGlvbnNcblx0XHRcdFx0aWYgKCBnZW9tZXRyeS5tb3JwaFRhcmdldHMgKSB7XG5cblx0XHRcdFx0XHQvLyBUT0RPOiBGaWd1cmUgb3V0IHdoYXQgYW4gYXBwcm9wcmFpdGUgRlBTIGlzIGZvciBtb3JwaCB0YXJnZXQgYW5pbWF0aW9ucyAtLSBkZWZhdWx0aW5nIHRvIDEwLCBidXQgcmVhbGx5IGl0IGlzIGNvbXBsZXRlbHkgYXJiaXRyYXJ5LlxuXHRcdFx0XHRcdHZhciBtb3JwaEFuaW1hdGlvbkNsaXBzID0gVEhSRUUuQW5pbWF0aW9uQ2xpcC5DcmVhdGVDbGlwc0Zyb21Nb3JwaFRhcmdldFNlcXVlbmNlcyggZ2VvbWV0cnkubW9ycGhUYXJnZXRzLCAxMCApO1xuXHRcdFx0XHRcdG91dHB1dEFuaW1hdGlvbnMgPSBvdXRwdXRBbmltYXRpb25zLmNvbmNhdCggbW9ycGhBbmltYXRpb25DbGlwcyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIG91dHB1dEFuaW1hdGlvbnMubGVuZ3RoID4gMCApIGdlb21ldHJ5LmFuaW1hdGlvbnMgPSBvdXRwdXRBbmltYXRpb25zO1xuXG5cdFx0XHR9O1xuXG5cdFx0XHRpZiAoIGpzb24ubWF0ZXJpYWxzID09PSB1bmRlZmluZWQgfHwganNvbi5tYXRlcmlhbHMubGVuZ3RoID09PSAwICkge1xuXG5cdFx0XHRcdHJldHVybiB7IGdlb21ldHJ5OiBnZW9tZXRyeSB9O1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHZhciBtYXRlcmlhbHMgPSBUSFJFRS5Mb2FkZXIucHJvdG90eXBlLmluaXRNYXRlcmlhbHMoIGpzb24ubWF0ZXJpYWxzLCB0ZXh0dXJlUGF0aCwgdGhpcy5jcm9zc09yaWdpbiApO1xuXG5cdFx0XHRcdHJldHVybiB7IGdlb21ldHJ5OiBnZW9tZXRyeSwgbWF0ZXJpYWxzOiBtYXRlcmlhbHMgfTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH07XG5cblx0Ly8gRmlsZTpzcmMvbG9hZGVycy9Mb2FkaW5nTWFuYWdlci5qc1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuXHQgKi9cblxuXHRUSFJFRS5Mb2FkaW5nTWFuYWdlciA9IGZ1bmN0aW9uICggb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG5cdFx0dmFyIHNjb3BlID0gdGhpcztcblxuXHRcdHZhciBpc0xvYWRpbmcgPSBmYWxzZSwgaXRlbXNMb2FkZWQgPSAwLCBpdGVtc1RvdGFsID0gMDtcblxuXHRcdHRoaXMub25TdGFydCA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLm9uTG9hZCA9IG9uTG9hZDtcblx0XHR0aGlzLm9uUHJvZ3Jlc3MgPSBvblByb2dyZXNzO1xuXHRcdHRoaXMub25FcnJvciA9IG9uRXJyb3I7XG5cblx0XHR0aGlzLml0ZW1TdGFydCA9IGZ1bmN0aW9uICggdXJsICkge1xuXG5cdFx0XHRpdGVtc1RvdGFsICsrO1xuXG5cdFx0XHRpZiAoIGlzTG9hZGluZyA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0aWYgKCBzY29wZS5vblN0YXJ0ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRzY29wZS5vblN0YXJ0KCB1cmwsIGl0ZW1zTG9hZGVkLCBpdGVtc1RvdGFsICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlzTG9hZGluZyA9IHRydWU7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5pdGVtRW5kID0gZnVuY3Rpb24gKCB1cmwgKSB7XG5cblx0XHRcdGl0ZW1zTG9hZGVkICsrO1xuXG5cdFx0XHRpZiAoIHNjb3BlLm9uUHJvZ3Jlc3MgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRzY29wZS5vblByb2dyZXNzKCB1cmwsIGl0ZW1zTG9hZGVkLCBpdGVtc1RvdGFsICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBpdGVtc0xvYWRlZCA9PT0gaXRlbXNUb3RhbCApIHtcblxuXHRcdFx0XHRpc0xvYWRpbmcgPSBmYWxzZTtcblxuXHRcdFx0XHRpZiAoIHNjb3BlLm9uTG9hZCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0c2NvcGUub25Mb2FkKCk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5pdGVtRXJyb3IgPSBmdW5jdGlvbiAoIHVybCApIHtcblxuXHRcdFx0aWYgKCBzY29wZS5vbkVycm9yICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0c2NvcGUub25FcnJvciggdXJsICk7XG5cblx0XHRcdH1cblxuXHRcdH07XG5cblx0fTtcblxuXHRUSFJFRS5EZWZhdWx0TG9hZGluZ01hbmFnZXIgPSBuZXcgVEhSRUUuTG9hZGluZ01hbmFnZXIoKTtcblxuXHQvLyBGaWxlOnNyYy9sb2FkZXJzL0J1ZmZlckdlb21ldHJ5TG9hZGVyLmpzXG5cblx0LyoqXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqL1xuXG5cdFRIUkVFLkJ1ZmZlckdlb21ldHJ5TG9hZGVyID0gZnVuY3Rpb24gKCBtYW5hZ2VyICkge1xuXG5cdFx0dGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBUSFJFRS5EZWZhdWx0TG9hZGluZ01hbmFnZXI7XG5cblx0fTtcblxuXHRUSFJFRS5CdWZmZXJHZW9tZXRyeUxvYWRlci5wcm90b3R5cGUgPSB7XG5cblx0XHRjb25zdHJ1Y3RvcjogVEhSRUUuQnVmZmVyR2VvbWV0cnlMb2FkZXIsXG5cblx0XHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG5cdFx0XHR2YXIgc2NvcGUgPSB0aGlzO1xuXG5cdFx0XHR2YXIgbG9hZGVyID0gbmV3IFRIUkVFLlhIUkxvYWRlciggc2NvcGUubWFuYWdlciApO1xuXHRcdFx0bG9hZGVyLnNldENyb3NzT3JpZ2luKCB0aGlzLmNyb3NzT3JpZ2luICk7XG5cdFx0XHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIHRleHQgKSB7XG5cblx0XHRcdFx0b25Mb2FkKCBzY29wZS5wYXJzZSggSlNPTi5wYXJzZSggdGV4dCApICkgKTtcblxuXHRcdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG5cdFx0fSxcblxuXHRcdHNldENyb3NzT3JpZ2luOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHR0aGlzLmNyb3NzT3JpZ2luID0gdmFsdWU7XG5cblx0XHR9LFxuXG5cdFx0cGFyc2U6IGZ1bmN0aW9uICgganNvbiApIHtcblxuXHRcdFx0dmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCk7XG5cblx0XHRcdHZhciBpbmRleCA9IGpzb24uZGF0YS5pbmRleDtcblxuXHRcdFx0aWYgKCBpbmRleCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHZhciB0eXBlZEFycmF5ID0gbmV3IHNlbGZbIGluZGV4LnR5cGUgXSggaW5kZXguYXJyYXkgKTtcblx0XHRcdFx0Z2VvbWV0cnkuc2V0SW5kZXgoIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIHR5cGVkQXJyYXksIDEgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBhdHRyaWJ1dGVzID0ganNvbi5kYXRhLmF0dHJpYnV0ZXM7XG5cblx0XHRcdGZvciAoIHZhciBrZXkgaW4gYXR0cmlidXRlcyApIHtcblxuXHRcdFx0XHR2YXIgYXR0cmlidXRlID0gYXR0cmlidXRlc1sga2V5IF07XG5cdFx0XHRcdHZhciB0eXBlZEFycmF5ID0gbmV3IHNlbGZbIGF0dHJpYnV0ZS50eXBlIF0oIGF0dHJpYnV0ZS5hcnJheSApO1xuXG5cdFx0XHRcdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSgga2V5LCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCB0eXBlZEFycmF5LCBhdHRyaWJ1dGUuaXRlbVNpemUgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBncm91cHMgPSBqc29uLmRhdGEuZ3JvdXBzIHx8IGpzb24uZGF0YS5kcmF3Y2FsbHMgfHwganNvbi5kYXRhLm9mZnNldHM7XG5cblx0XHRcdGlmICggZ3JvdXBzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBuID0gZ3JvdXBzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcblxuXHRcdFx0XHRcdHZhciBncm91cCA9IGdyb3Vwc1sgaSBdO1xuXG5cdFx0XHRcdFx0Z2VvbWV0cnkuYWRkR3JvdXAoIGdyb3VwLnN0YXJ0LCBncm91cC5jb3VudCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgYm91bmRpbmdTcGhlcmUgPSBqc29uLmRhdGEuYm91bmRpbmdTcGhlcmU7XG5cblx0XHRcdGlmICggYm91bmRpbmdTcGhlcmUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHR2YXIgY2VudGVyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdFx0XHRpZiAoIGJvdW5kaW5nU3BoZXJlLmNlbnRlciAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0Y2VudGVyLmZyb21BcnJheSggYm91bmRpbmdTcGhlcmUuY2VudGVyICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID0gbmV3IFRIUkVFLlNwaGVyZSggY2VudGVyLCBib3VuZGluZ1NwaGVyZS5yYWRpdXMgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZ2VvbWV0cnk7XG5cblx0XHR9XG5cblx0fTtcblxuXHQvLyBGaWxlOnNyYy9sb2FkZXJzL01hdGVyaWFsTG9hZGVyLmpzXG5cblx0LyoqXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqL1xuXG5cdFRIUkVFLk1hdGVyaWFsTG9hZGVyID0gZnVuY3Rpb24gKCBtYW5hZ2VyICkge1xuXG5cdFx0dGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBUSFJFRS5EZWZhdWx0TG9hZGluZ01hbmFnZXI7XG5cdFx0dGhpcy50ZXh0dXJlcyA9IHt9O1xuXG5cdH07XG5cblx0VEhSRUUuTWF0ZXJpYWxMb2FkZXIucHJvdG90eXBlID0ge1xuXG5cdFx0Y29uc3RydWN0b3I6IFRIUkVFLk1hdGVyaWFsTG9hZGVyLFxuXG5cdFx0bG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuXHRcdFx0dmFyIHNjb3BlID0gdGhpcztcblxuXHRcdFx0dmFyIGxvYWRlciA9IG5ldyBUSFJFRS5YSFJMb2FkZXIoIHNjb3BlLm1hbmFnZXIgKTtcblx0XHRcdGxvYWRlci5zZXRDcm9zc09yaWdpbiggdGhpcy5jcm9zc09yaWdpbiApO1xuXHRcdFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCB0ZXh0ICkge1xuXG5cdFx0XHRcdG9uTG9hZCggc2NvcGUucGFyc2UoIEpTT04ucGFyc2UoIHRleHQgKSApICk7XG5cblx0XHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcblxuXHRcdH0sXG5cblx0XHRzZXRDcm9zc09yaWdpbjogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdFx0dGhpcy5jcm9zc09yaWdpbiA9IHZhbHVlO1xuXG5cdFx0fSxcblxuXHRcdHNldFRleHR1cmVzOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHR0aGlzLnRleHR1cmVzID0gdmFsdWU7XG5cblx0XHR9LFxuXG5cdFx0Z2V0VGV4dHVyZTogZnVuY3Rpb24gKCBuYW1lICkge1xuXG5cdFx0XHR2YXIgdGV4dHVyZXMgPSB0aGlzLnRleHR1cmVzO1xuXG5cdFx0XHRpZiAoIHRleHR1cmVzWyBuYW1lIF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRlcmlhbExvYWRlcjogVW5kZWZpbmVkIHRleHR1cmUnLCBuYW1lICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRleHR1cmVzWyBuYW1lIF07XG5cblx0XHR9LFxuXG5cdFx0cGFyc2U6IGZ1bmN0aW9uICgganNvbiApIHtcblxuXHRcdFx0dmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFWyBqc29uLnR5cGUgXTtcblx0XHRcdG1hdGVyaWFsLnV1aWQgPSBqc29uLnV1aWQ7XG5cblx0XHRcdGlmICgganNvbi5uYW1lICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5uYW1lID0ganNvbi5uYW1lO1xuXHRcdFx0aWYgKCBqc29uLmNvbG9yICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5jb2xvci5zZXRIZXgoIGpzb24uY29sb3IgKTtcblx0XHRcdGlmICgganNvbi5lbWlzc2l2ZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZW1pc3NpdmUuc2V0SGV4KCBqc29uLmVtaXNzaXZlICk7XG5cdFx0XHRpZiAoIGpzb24uc3BlY3VsYXIgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNwZWN1bGFyLnNldEhleCgganNvbi5zcGVjdWxhciApO1xuXHRcdFx0aWYgKCBqc29uLnNoaW5pbmVzcyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc2hpbmluZXNzID0ganNvbi5zaGluaW5lc3M7XG5cdFx0XHRpZiAoIGpzb24udW5pZm9ybXMgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnVuaWZvcm1zID0ganNvbi51bmlmb3Jtcztcblx0XHRcdGlmICgganNvbi52ZXJ0ZXhTaGFkZXIgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnZlcnRleFNoYWRlciA9IGpzb24udmVydGV4U2hhZGVyO1xuXHRcdFx0aWYgKCBqc29uLmZyYWdtZW50U2hhZGVyICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5mcmFnbWVudFNoYWRlciA9IGpzb24uZnJhZ21lbnRTaGFkZXI7XG5cdFx0XHRpZiAoIGpzb24udmVydGV4Q29sb3JzICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPSBqc29uLnZlcnRleENvbG9ycztcblx0XHRcdGlmICgganNvbi5zaGFkaW5nICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zaGFkaW5nID0ganNvbi5zaGFkaW5nO1xuXHRcdFx0aWYgKCBqc29uLmJsZW5kaW5nICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5ibGVuZGluZyA9IGpzb24uYmxlbmRpbmc7XG5cdFx0XHRpZiAoIGpzb24uc2lkZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc2lkZSA9IGpzb24uc2lkZTtcblx0XHRcdGlmICgganNvbi5vcGFjaXR5ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5vcGFjaXR5ID0ganNvbi5vcGFjaXR5O1xuXHRcdFx0aWYgKCBqc29uLnRyYW5zcGFyZW50ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC50cmFuc3BhcmVudCA9IGpzb24udHJhbnNwYXJlbnQ7XG5cdFx0XHRpZiAoIGpzb24uYWxwaGFUZXN0ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5hbHBoYVRlc3QgPSBqc29uLmFscGhhVGVzdDtcblx0XHRcdGlmICgganNvbi5kZXB0aFRlc3QgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmRlcHRoVGVzdCA9IGpzb24uZGVwdGhUZXN0O1xuXHRcdFx0aWYgKCBqc29uLmRlcHRoV3JpdGUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmRlcHRoV3JpdGUgPSBqc29uLmRlcHRoV3JpdGU7XG5cdFx0XHRpZiAoIGpzb24ud2lyZWZyYW1lICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC53aXJlZnJhbWUgPSBqc29uLndpcmVmcmFtZTtcblx0XHRcdGlmICgganNvbi53aXJlZnJhbWVMaW5ld2lkdGggIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLndpcmVmcmFtZUxpbmV3aWR0aCA9IGpzb24ud2lyZWZyYW1lTGluZXdpZHRoO1xuXG5cdFx0XHQvLyBmb3IgUG9pbnRzTWF0ZXJpYWxcblx0XHRcdGlmICgganNvbi5zaXplICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zaXplID0ganNvbi5zaXplO1xuXHRcdFx0aWYgKCBqc29uLnNpemVBdHRlbnVhdGlvbiAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc2l6ZUF0dGVudWF0aW9uID0ganNvbi5zaXplQXR0ZW51YXRpb247XG5cblx0XHRcdC8vIG1hcHNcblxuXHRcdFx0aWYgKCBqc29uLm1hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwubWFwID0gdGhpcy5nZXRUZXh0dXJlKCBqc29uLm1hcCApO1xuXG5cdFx0XHRpZiAoIGpzb24uYWxwaGFNYXAgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRtYXRlcmlhbC5hbHBoYU1hcCA9IHRoaXMuZ2V0VGV4dHVyZSgganNvbi5hbHBoYU1hcCApO1xuXHRcdFx0XHRtYXRlcmlhbC50cmFuc3BhcmVudCA9IHRydWU7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBqc29uLmJ1bXBNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmJ1bXBNYXAgPSB0aGlzLmdldFRleHR1cmUoIGpzb24uYnVtcE1hcCApO1xuXHRcdFx0aWYgKCBqc29uLmJ1bXBTY2FsZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYnVtcFNjYWxlID0ganNvbi5idW1wU2NhbGU7XG5cblx0XHRcdGlmICgganNvbi5ub3JtYWxNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLm5vcm1hbE1hcCA9IHRoaXMuZ2V0VGV4dHVyZSgganNvbi5ub3JtYWxNYXAgKTtcblx0XHRcdGlmICgganNvbi5ub3JtYWxTY2FsZSApXHRtYXRlcmlhbC5ub3JtYWxTY2FsZSA9IG5ldyBUSFJFRS5WZWN0b3IyKCBqc29uLm5vcm1hbFNjYWxlLCBqc29uLm5vcm1hbFNjYWxlICk7XG5cblx0XHRcdGlmICgganNvbi5kaXNwbGFjZW1lbnRNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcCA9IHRoaXMuZ2V0VGV4dHVyZSgganNvbi5kaXNwbGFjZW1lbnRNYXAgKTtcblx0XHRcdGlmICgganNvbi5kaXNwbGFjZW1lbnRTY2FsZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZGlzcGxhY2VtZW50U2NhbGUgPSBqc29uLmRpc3BsYWNlbWVudFNjYWxlO1xuXHRcdFx0aWYgKCBqc29uLmRpc3BsYWNlbWVudEJpYXMgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmRpc3BsYWNlbWVudEJpYXMgPSBqc29uLmRpc3BsYWNlbWVudEJpYXM7XG5cblx0XHRcdGlmICgganNvbi5zcGVjdWxhck1hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc3BlY3VsYXJNYXAgPSB0aGlzLmdldFRleHR1cmUoIGpzb24uc3BlY3VsYXJNYXAgKTtcblxuXHRcdFx0aWYgKCBqc29uLmVudk1hcCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdG1hdGVyaWFsLmVudk1hcCA9IHRoaXMuZ2V0VGV4dHVyZSgganNvbi5lbnZNYXAgKTtcblx0XHRcdFx0bWF0ZXJpYWwuY29tYmluZSA9IFRIUkVFLk11bHRpcGx5T3BlcmF0aW9uO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICgganNvbi5yZWZsZWN0aXZpdHkgKSBtYXRlcmlhbC5yZWZsZWN0aXZpdHkgPSBqc29uLnJlZmxlY3Rpdml0eTtcblxuXHRcdFx0aWYgKCBqc29uLmxpZ2h0TWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5saWdodE1hcCA9IHRoaXMuZ2V0VGV4dHVyZSgganNvbi5saWdodE1hcCApO1xuXHRcdFx0aWYgKCBqc29uLmxpZ2h0TWFwSW50ZW5zaXR5ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5saWdodE1hcEludGVuc2l0eSA9IGpzb24ubGlnaHRNYXBJbnRlbnNpdHk7XG5cblx0XHRcdGlmICgganNvbi5hb01hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYW9NYXAgPSB0aGlzLmdldFRleHR1cmUoIGpzb24uYW9NYXAgKTtcblx0XHRcdGlmICgganNvbi5hb01hcEludGVuc2l0eSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYW9NYXBJbnRlbnNpdHkgPSBqc29uLmFvTWFwSW50ZW5zaXR5O1xuXG5cdFx0XHQvLyBNZXNoRmFjZU1hdGVyaWFsXG5cblx0XHRcdGlmICgganNvbi5tYXRlcmlhbHMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLm1hdGVyaWFscy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0bWF0ZXJpYWwubWF0ZXJpYWxzLnB1c2goIHRoaXMucGFyc2UoIGpzb24ubWF0ZXJpYWxzWyBpIF0gKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0ZXJpYWw7XG5cblx0XHR9XG5cblx0fTtcblxuXHQvLyBGaWxlOnNyYy9sb2FkZXJzL09iamVjdExvYWRlci5qc1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuXHQgKi9cblxuXHRUSFJFRS5PYmplY3RMb2FkZXIgPSBmdW5jdGlvbiAoIG1hbmFnZXIgKSB7XG5cblx0XHR0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IFRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcblx0XHR0aGlzLnRleHR1cmVQYXRoID0gJyc7XG5cblx0fTtcblxuXHRUSFJFRS5PYmplY3RMb2FkZXIucHJvdG90eXBlID0ge1xuXG5cdFx0Y29uc3RydWN0b3I6IFRIUkVFLk9iamVjdExvYWRlcixcblxuXHRcdGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cblx0XHRcdGlmICggdGhpcy50ZXh0dXJlUGF0aCA9PT0gJycgKSB7XG5cblx0XHRcdFx0dGhpcy50ZXh0dXJlUGF0aCA9IHVybC5zdWJzdHJpbmcoIDAsIHVybC5sYXN0SW5kZXhPZiggJy8nICkgKyAxICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIHNjb3BlID0gdGhpcztcblxuXHRcdFx0dmFyIGxvYWRlciA9IG5ldyBUSFJFRS5YSFJMb2FkZXIoIHNjb3BlLm1hbmFnZXIgKTtcblx0XHRcdGxvYWRlci5zZXRDcm9zc09yaWdpbiggdGhpcy5jcm9zc09yaWdpbiApO1xuXHRcdFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCB0ZXh0ICkge1xuXG5cdFx0XHRcdHNjb3BlLnBhcnNlKCBKU09OLnBhcnNlKCB0ZXh0ICksIG9uTG9hZCApO1xuXG5cdFx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XG5cblx0XHR9LFxuXG5cdFx0c2V0VGV4dHVyZVBhdGg6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdHRoaXMudGV4dHVyZVBhdGggPSB2YWx1ZTtcblxuXHRcdH0sXG5cblx0XHRzZXRDcm9zc09yaWdpbjogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdFx0dGhpcy5jcm9zc09yaWdpbiA9IHZhbHVlO1xuXG5cdFx0fSxcblxuXHRcdHBhcnNlOiBmdW5jdGlvbiAoIGpzb24sIG9uTG9hZCApIHtcblxuXHRcdFx0dmFyIGdlb21ldHJpZXMgPSB0aGlzLnBhcnNlR2VvbWV0cmllcygganNvbi5nZW9tZXRyaWVzICk7XG5cblx0XHRcdHZhciBpbWFnZXMgPSB0aGlzLnBhcnNlSW1hZ2VzKCBqc29uLmltYWdlcywgZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdGlmICggb25Mb2FkICE9PSB1bmRlZmluZWQgKSBvbkxvYWQoIG9iamVjdCApO1xuXG5cdFx0XHR9ICk7XG5cblx0XHRcdHZhciB0ZXh0dXJlcyAgPSB0aGlzLnBhcnNlVGV4dHVyZXMoIGpzb24udGV4dHVyZXMsIGltYWdlcyApO1xuXHRcdFx0dmFyIG1hdGVyaWFscyA9IHRoaXMucGFyc2VNYXRlcmlhbHMoIGpzb24ubWF0ZXJpYWxzLCB0ZXh0dXJlcyApO1xuXG5cdFx0XHR2YXIgb2JqZWN0ID0gdGhpcy5wYXJzZU9iamVjdCgganNvbi5vYmplY3QsIGdlb21ldHJpZXMsIG1hdGVyaWFscyApO1xuXG5cdFx0XHRpZiAoIGpzb24uYW5pbWF0aW9ucyApIHtcblxuXHRcdFx0XHRvYmplY3QuYW5pbWF0aW9ucyA9IHRoaXMucGFyc2VBbmltYXRpb25zKCBqc29uLmFuaW1hdGlvbnMgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGpzb24uaW1hZ2VzID09PSB1bmRlZmluZWQgfHwganNvbi5pbWFnZXMubGVuZ3RoID09PSAwICkge1xuXG5cdFx0XHRcdGlmICggb25Mb2FkICE9PSB1bmRlZmluZWQgKSBvbkxvYWQoIG9iamVjdCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBvYmplY3Q7XG5cblx0XHR9LFxuXG5cdFx0cGFyc2VHZW9tZXRyaWVzOiBmdW5jdGlvbiAoIGpzb24gKSB7XG5cblx0XHRcdHZhciBnZW9tZXRyaWVzID0ge307XG5cblx0XHRcdGlmICgganNvbiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHZhciBnZW9tZXRyeUxvYWRlciA9IG5ldyBUSFJFRS5KU09OTG9hZGVyKCk7XG5cdFx0XHRcdHZhciBidWZmZXJHZW9tZXRyeUxvYWRlciA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeUxvYWRlcigpO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGpzb24ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHZhciBnZW9tZXRyeTtcblx0XHRcdFx0XHR2YXIgZGF0YSA9IGpzb25bIGkgXTtcblxuXHRcdFx0XHRcdHN3aXRjaCAoIGRhdGEudHlwZSApIHtcblxuXHRcdFx0XHRcdFx0Y2FzZSAnUGxhbmVHZW9tZXRyeSc6XG5cdFx0XHRcdFx0XHRjYXNlICdQbGFuZUJ1ZmZlckdlb21ldHJ5JzpcblxuXHRcdFx0XHRcdFx0XHRnZW9tZXRyeSA9IG5ldyBUSFJFRVsgZGF0YS50eXBlIF0oXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS53aWR0aCxcblx0XHRcdFx0XHRcdFx0XHRkYXRhLmhlaWdodCxcblx0XHRcdFx0XHRcdFx0XHRkYXRhLndpZHRoU2VnbWVudHMsXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS5oZWlnaHRTZWdtZW50c1xuXHRcdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdCb3hHZW9tZXRyeSc6XG5cdFx0XHRcdFx0XHRjYXNlICdDdWJlR2VvbWV0cnknOiAvLyBiYWNrd2FyZHMgY29tcGF0aWJsZVxuXG5cdFx0XHRcdFx0XHRcdGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJveEdlb21ldHJ5KFxuXHRcdFx0XHRcdFx0XHRcdGRhdGEud2lkdGgsXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS5oZWlnaHQsXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS5kZXB0aCxcblx0XHRcdFx0XHRcdFx0XHRkYXRhLndpZHRoU2VnbWVudHMsXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS5oZWlnaHRTZWdtZW50cyxcblx0XHRcdFx0XHRcdFx0XHRkYXRhLmRlcHRoU2VnbWVudHNcblx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnQ2lyY2xlQnVmZmVyR2VvbWV0cnknOlxuXG5cdFx0XHRcdFx0XHRcdGdlb21ldHJ5ID0gbmV3IFRIUkVFLkNpcmNsZUJ1ZmZlckdlb21ldHJ5KFxuXHRcdFx0XHRcdFx0XHRcdGRhdGEucmFkaXVzLFxuXHRcdFx0XHRcdFx0XHRcdGRhdGEuc2VnbWVudHMsXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS50aGV0YVN0YXJ0LFxuXHRcdFx0XHRcdFx0XHRcdGRhdGEudGhldGFMZW5ndGhcblx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnQ2lyY2xlR2VvbWV0cnknOlxuXG5cdFx0XHRcdFx0XHRcdGdlb21ldHJ5ID0gbmV3IFRIUkVFLkNpcmNsZUdlb21ldHJ5KFxuXHRcdFx0XHRcdFx0XHRcdGRhdGEucmFkaXVzLFxuXHRcdFx0XHRcdFx0XHRcdGRhdGEuc2VnbWVudHMsXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS50aGV0YVN0YXJ0LFxuXHRcdFx0XHRcdFx0XHRcdGRhdGEudGhldGFMZW5ndGhcblx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnQ3lsaW5kZXJHZW9tZXRyeSc6XG5cblx0XHRcdFx0XHRcdFx0Z2VvbWV0cnkgPSBuZXcgVEhSRUUuQ3lsaW5kZXJHZW9tZXRyeShcblx0XHRcdFx0XHRcdFx0XHRkYXRhLnJhZGl1c1RvcCxcblx0XHRcdFx0XHRcdFx0XHRkYXRhLnJhZGl1c0JvdHRvbSxcblx0XHRcdFx0XHRcdFx0XHRkYXRhLmhlaWdodCxcblx0XHRcdFx0XHRcdFx0XHRkYXRhLnJhZGlhbFNlZ21lbnRzLFxuXHRcdFx0XHRcdFx0XHRcdGRhdGEuaGVpZ2h0U2VnbWVudHMsXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS5vcGVuRW5kZWQsXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS50aGV0YVN0YXJ0LFxuXHRcdFx0XHRcdFx0XHRcdGRhdGEudGhldGFMZW5ndGhcblx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnU3BoZXJlR2VvbWV0cnknOlxuXG5cdFx0XHRcdFx0XHRcdGdlb21ldHJ5ID0gbmV3IFRIUkVFLlNwaGVyZUdlb21ldHJ5KFxuXHRcdFx0XHRcdFx0XHRcdGRhdGEucmFkaXVzLFxuXHRcdFx0XHRcdFx0XHRcdGRhdGEud2lkdGhTZWdtZW50cyxcblx0XHRcdFx0XHRcdFx0XHRkYXRhLmhlaWdodFNlZ21lbnRzLFxuXHRcdFx0XHRcdFx0XHRcdGRhdGEucGhpU3RhcnQsXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS5waGlMZW5ndGgsXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS50aGV0YVN0YXJ0LFxuXHRcdFx0XHRcdFx0XHRcdGRhdGEudGhldGFMZW5ndGhcblx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnU3BoZXJlQnVmZmVyR2VvbWV0cnknOlxuXG5cdFx0XHRcdFx0XHRcdGdlb21ldHJ5ID0gbmV3IFRIUkVFLlNwaGVyZUJ1ZmZlckdlb21ldHJ5KFxuXHRcdFx0XHRcdFx0XHRcdGRhdGEucmFkaXVzLFxuXHRcdFx0XHRcdFx0XHRcdGRhdGEud2lkdGhTZWdtZW50cyxcblx0XHRcdFx0XHRcdFx0XHRkYXRhLmhlaWdodFNlZ21lbnRzLFxuXHRcdFx0XHRcdFx0XHRcdGRhdGEucGhpU3RhcnQsXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS5waGlMZW5ndGgsXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS50aGV0YVN0YXJ0LFxuXHRcdFx0XHRcdFx0XHRcdGRhdGEudGhldGFMZW5ndGhcblx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnRG9kZWNhaGVkcm9uR2VvbWV0cnknOlxuXG5cdFx0XHRcdFx0XHRcdGdlb21ldHJ5ID0gbmV3IFRIUkVFLkRvZGVjYWhlZHJvbkdlb21ldHJ5KFxuXHRcdFx0XHRcdFx0XHRcdGRhdGEucmFkaXVzLFxuXHRcdFx0XHRcdFx0XHRcdGRhdGEuZGV0YWlsXG5cdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ0ljb3NhaGVkcm9uR2VvbWV0cnknOlxuXG5cdFx0XHRcdFx0XHRcdGdlb21ldHJ5ID0gbmV3IFRIUkVFLkljb3NhaGVkcm9uR2VvbWV0cnkoXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS5yYWRpdXMsXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS5kZXRhaWxcblx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnT2N0YWhlZHJvbkdlb21ldHJ5JzpcblxuXHRcdFx0XHRcdFx0XHRnZW9tZXRyeSA9IG5ldyBUSFJFRS5PY3RhaGVkcm9uR2VvbWV0cnkoXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS5yYWRpdXMsXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS5kZXRhaWxcblx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnVGV0cmFoZWRyb25HZW9tZXRyeSc6XG5cblx0XHRcdFx0XHRcdFx0Z2VvbWV0cnkgPSBuZXcgVEhSRUUuVGV0cmFoZWRyb25HZW9tZXRyeShcblx0XHRcdFx0XHRcdFx0XHRkYXRhLnJhZGl1cyxcblx0XHRcdFx0XHRcdFx0XHRkYXRhLmRldGFpbFxuXHRcdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdSaW5nR2VvbWV0cnknOlxuXG5cdFx0XHRcdFx0XHRcdGdlb21ldHJ5ID0gbmV3IFRIUkVFLlJpbmdHZW9tZXRyeShcblx0XHRcdFx0XHRcdFx0XHRkYXRhLmlubmVyUmFkaXVzLFxuXHRcdFx0XHRcdFx0XHRcdGRhdGEub3V0ZXJSYWRpdXMsXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS50aGV0YVNlZ21lbnRzLFxuXHRcdFx0XHRcdFx0XHRcdGRhdGEucGhpU2VnbWVudHMsXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS50aGV0YVN0YXJ0LFxuXHRcdFx0XHRcdFx0XHRcdGRhdGEudGhldGFMZW5ndGhcblx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnVG9ydXNHZW9tZXRyeSc6XG5cblx0XHRcdFx0XHRcdFx0Z2VvbWV0cnkgPSBuZXcgVEhSRUUuVG9ydXNHZW9tZXRyeShcblx0XHRcdFx0XHRcdFx0XHRkYXRhLnJhZGl1cyxcblx0XHRcdFx0XHRcdFx0XHRkYXRhLnR1YmUsXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS5yYWRpYWxTZWdtZW50cyxcblx0XHRcdFx0XHRcdFx0XHRkYXRhLnR1YnVsYXJTZWdtZW50cyxcblx0XHRcdFx0XHRcdFx0XHRkYXRhLmFyY1xuXHRcdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdUb3J1c0tub3RHZW9tZXRyeSc6XG5cblx0XHRcdFx0XHRcdFx0Z2VvbWV0cnkgPSBuZXcgVEhSRUUuVG9ydXNLbm90R2VvbWV0cnkoXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS5yYWRpdXMsXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS50dWJlLFxuXHRcdFx0XHRcdFx0XHRcdGRhdGEucmFkaWFsU2VnbWVudHMsXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS50dWJ1bGFyU2VnbWVudHMsXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS5wLFxuXHRcdFx0XHRcdFx0XHRcdGRhdGEucSxcblx0XHRcdFx0XHRcdFx0XHRkYXRhLmhlaWdodFNjYWxlXG5cdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ0J1ZmZlckdlb21ldHJ5JzpcblxuXHRcdFx0XHRcdFx0XHRnZW9tZXRyeSA9IGJ1ZmZlckdlb21ldHJ5TG9hZGVyLnBhcnNlKCBkYXRhICk7XG5cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ0dlb21ldHJ5JzpcblxuXHRcdFx0XHRcdFx0XHRnZW9tZXRyeSA9IGdlb21ldHJ5TG9hZGVyLnBhcnNlKCBkYXRhLmRhdGEsIHRoaXMudGV4dHVyZVBhdGggKS5nZW9tZXRyeTtcblxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblxuXHRcdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3RMb2FkZXI6IFVuc3VwcG9ydGVkIGdlb21ldHJ5IHR5cGUgXCInICsgZGF0YS50eXBlICsgJ1wiJyApO1xuXG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Z2VvbWV0cnkudXVpZCA9IGRhdGEudXVpZDtcblxuXHRcdFx0XHRcdGlmICggZGF0YS5uYW1lICE9PSB1bmRlZmluZWQgKSBnZW9tZXRyeS5uYW1lID0gZGF0YS5uYW1lO1xuXG5cdFx0XHRcdFx0Z2VvbWV0cmllc1sgZGF0YS51dWlkIF0gPSBnZW9tZXRyeTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGdlb21ldHJpZXM7XG5cblx0XHR9LFxuXG5cdFx0cGFyc2VNYXRlcmlhbHM6IGZ1bmN0aW9uICgganNvbiwgdGV4dHVyZXMgKSB7XG5cblx0XHRcdHZhciBtYXRlcmlhbHMgPSB7fTtcblxuXHRcdFx0aWYgKCBqc29uICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0dmFyIGxvYWRlciA9IG5ldyBUSFJFRS5NYXRlcmlhbExvYWRlcigpO1xuXHRcdFx0XHRsb2FkZXIuc2V0VGV4dHVyZXMoIHRleHR1cmVzICk7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0ganNvbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIG1hdGVyaWFsID0gbG9hZGVyLnBhcnNlKCBqc29uWyBpIF0gKTtcblx0XHRcdFx0XHRtYXRlcmlhbHNbIG1hdGVyaWFsLnV1aWQgXSA9IG1hdGVyaWFsO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0ZXJpYWxzO1xuXG5cdFx0fSxcblxuXHRcdHBhcnNlQW5pbWF0aW9uczogZnVuY3Rpb24gKCBqc29uICkge1xuXG5cdFx0XHR2YXIgYW5pbWF0aW9ucyA9IFtdO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBqc29uLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgY2xpcCA9IFRIUkVFLkFuaW1hdGlvbkNsaXAucGFyc2UoIGpzb25baV0gKTtcblxuXHRcdFx0XHRhbmltYXRpb25zLnB1c2goIGNsaXAgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYW5pbWF0aW9ucztcblxuXHRcdH0sXG5cblx0XHRwYXJzZUltYWdlczogZnVuY3Rpb24gKCBqc29uLCBvbkxvYWQgKSB7XG5cblx0XHRcdHZhciBzY29wZSA9IHRoaXM7XG5cdFx0XHR2YXIgaW1hZ2VzID0ge307XG5cblx0XHRcdGZ1bmN0aW9uIGxvYWRJbWFnZSggdXJsICkge1xuXG5cdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbVN0YXJ0KCB1cmwgKTtcblxuXHRcdFx0XHRyZXR1cm4gbG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcblxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBqc29uICE9PSB1bmRlZmluZWQgJiYganNvbi5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdHZhciBtYW5hZ2VyID0gbmV3IFRIUkVFLkxvYWRpbmdNYW5hZ2VyKCBvbkxvYWQgKTtcblxuXHRcdFx0XHR2YXIgbG9hZGVyID0gbmV3IFRIUkVFLkltYWdlTG9hZGVyKCBtYW5hZ2VyICk7XG5cdFx0XHRcdGxvYWRlci5zZXRDcm9zc09yaWdpbiggdGhpcy5jcm9zc09yaWdpbiApO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGpzb24ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHZhciBpbWFnZSA9IGpzb25bIGkgXTtcblx0XHRcdFx0XHR2YXIgcGF0aCA9IC9eKFxcL1xcLyl8KFthLXpdKzooXFwvXFwvKT8pL2kudGVzdCggaW1hZ2UudXJsICkgPyBpbWFnZS51cmwgOiBzY29wZS50ZXh0dXJlUGF0aCArIGltYWdlLnVybDtcblxuXHRcdFx0XHRcdGltYWdlc1sgaW1hZ2UudXVpZCBdID0gbG9hZEltYWdlKCBwYXRoICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBpbWFnZXM7XG5cblx0XHR9LFxuXG5cdFx0cGFyc2VUZXh0dXJlczogZnVuY3Rpb24gKCBqc29uLCBpbWFnZXMgKSB7XG5cblx0XHRcdGZ1bmN0aW9uIHBhcnNlQ29uc3RhbnQoIHZhbHVlICkge1xuXG5cdFx0XHRcdGlmICggdHlwZW9mKCB2YWx1ZSApID09PSAnbnVtYmVyJyApIHJldHVybiB2YWx1ZTtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3RMb2FkZXIucGFyc2VUZXh0dXJlOiBDb25zdGFudCBzaG91bGQgYmUgaW4gbnVtZXJpYyBmb3JtLicsIHZhbHVlICk7XG5cblx0XHRcdFx0cmV0dXJuIFRIUkVFWyB2YWx1ZSBdO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciB0ZXh0dXJlcyA9IHt9O1xuXG5cdFx0XHRpZiAoIGpzb24gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgZGF0YSA9IGpzb25bIGkgXTtcblxuXHRcdFx0XHRcdGlmICggZGF0YS5pbWFnZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3RMb2FkZXI6IE5vIFwiaW1hZ2VcIiBzcGVjaWZpZWQgZm9yJywgZGF0YS51dWlkICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIGltYWdlc1sgZGF0YS5pbWFnZSBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdExvYWRlcjogVW5kZWZpbmVkIGltYWdlJywgZGF0YS5pbWFnZSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dmFyIHRleHR1cmUgPSBuZXcgVEhSRUUuVGV4dHVyZSggaW1hZ2VzWyBkYXRhLmltYWdlIF0gKTtcblx0XHRcdFx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHRcdHRleHR1cmUudXVpZCA9IGRhdGEudXVpZDtcblxuXHRcdFx0XHRcdGlmICggZGF0YS5uYW1lICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLm5hbWUgPSBkYXRhLm5hbWU7XG5cdFx0XHRcdFx0aWYgKCBkYXRhLm1hcHBpbmcgIT09IHVuZGVmaW5lZCApIHRleHR1cmUubWFwcGluZyA9IHBhcnNlQ29uc3RhbnQoIGRhdGEubWFwcGluZyApO1xuXHRcdFx0XHRcdGlmICggZGF0YS5vZmZzZXQgIT09IHVuZGVmaW5lZCApIHRleHR1cmUub2Zmc2V0ID0gbmV3IFRIUkVFLlZlY3RvcjIoIGRhdGEub2Zmc2V0WyAwIF0sIGRhdGEub2Zmc2V0WyAxIF0gKTtcblx0XHRcdFx0XHRpZiAoIGRhdGEucmVwZWF0ICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLnJlcGVhdCA9IG5ldyBUSFJFRS5WZWN0b3IyKCBkYXRhLnJlcGVhdFsgMCBdLCBkYXRhLnJlcGVhdFsgMSBdICk7XG5cdFx0XHRcdFx0aWYgKCBkYXRhLm1pbkZpbHRlciAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5taW5GaWx0ZXIgPSBwYXJzZUNvbnN0YW50KCBkYXRhLm1pbkZpbHRlciApO1xuXHRcdFx0XHRcdGlmICggZGF0YS5tYWdGaWx0ZXIgIT09IHVuZGVmaW5lZCApIHRleHR1cmUubWFnRmlsdGVyID0gcGFyc2VDb25zdGFudCggZGF0YS5tYWdGaWx0ZXIgKTtcblx0XHRcdFx0XHRpZiAoIGRhdGEuYW5pc290cm9weSAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5hbmlzb3Ryb3B5ID0gZGF0YS5hbmlzb3Ryb3B5O1xuXHRcdFx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggZGF0YS53cmFwICkgKSB7XG5cblx0XHRcdFx0XHRcdHRleHR1cmUud3JhcFMgPSBwYXJzZUNvbnN0YW50KCBkYXRhLndyYXBbIDAgXSApO1xuXHRcdFx0XHRcdFx0dGV4dHVyZS53cmFwVCA9IHBhcnNlQ29uc3RhbnQoIGRhdGEud3JhcFsgMSBdICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0ZXh0dXJlc1sgZGF0YS51dWlkIF0gPSB0ZXh0dXJlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGV4dHVyZXM7XG5cblx0XHR9LFxuXG5cdFx0cGFyc2VPYmplY3Q6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIG1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiAoIGRhdGEsIGdlb21ldHJpZXMsIG1hdGVyaWFscyApIHtcblxuXHRcdFx0XHR2YXIgb2JqZWN0O1xuXG5cdFx0XHRcdGZ1bmN0aW9uIGdldEdlb21ldHJ5KCBuYW1lICkge1xuXG5cdFx0XHRcdFx0aWYgKCBnZW9tZXRyaWVzWyBuYW1lIF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBVbmRlZmluZWQgZ2VvbWV0cnknLCBuYW1lICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gZ2VvbWV0cmllc1sgbmFtZSBdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmdW5jdGlvbiBnZXRNYXRlcmlhbCggbmFtZSApIHtcblxuXHRcdFx0XHRcdGlmICggbmFtZSA9PT0gdW5kZWZpbmVkICkgcmV0dXJuIHVuZGVmaW5lZDtcblxuXHRcdFx0XHRcdGlmICggbWF0ZXJpYWxzWyBuYW1lIF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBVbmRlZmluZWQgbWF0ZXJpYWwnLCBuYW1lICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gbWF0ZXJpYWxzWyBuYW1lIF07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHN3aXRjaCAoIGRhdGEudHlwZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ1NjZW5lJzpcblxuXHRcdFx0XHRcdFx0b2JqZWN0ID0gbmV3IFRIUkVFLlNjZW5lKCk7XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnUGVyc3BlY3RpdmVDYW1lcmEnOlxuXG5cdFx0XHRcdFx0XHRvYmplY3QgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoIGRhdGEuZm92LCBkYXRhLmFzcGVjdCwgZGF0YS5uZWFyLCBkYXRhLmZhciApO1xuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ09ydGhvZ3JhcGhpY0NhbWVyYSc6XG5cblx0XHRcdFx0XHRcdG9iamVjdCA9IG5ldyBUSFJFRS5PcnRob2dyYXBoaWNDYW1lcmEoIGRhdGEubGVmdCwgZGF0YS5yaWdodCwgZGF0YS50b3AsIGRhdGEuYm90dG9tLCBkYXRhLm5lYXIsIGRhdGEuZmFyICk7XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnQW1iaWVudExpZ2h0JzpcblxuXHRcdFx0XHRcdFx0b2JqZWN0ID0gbmV3IFRIUkVFLkFtYmllbnRMaWdodCggZGF0YS5jb2xvciApO1xuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ0RpcmVjdGlvbmFsTGlnaHQnOlxuXG5cdFx0XHRcdFx0XHRvYmplY3QgPSBuZXcgVEhSRUUuRGlyZWN0aW9uYWxMaWdodCggZGF0YS5jb2xvciwgZGF0YS5pbnRlbnNpdHkgKTtcblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdQb2ludExpZ2h0JzpcblxuXHRcdFx0XHRcdFx0b2JqZWN0ID0gbmV3IFRIUkVFLlBvaW50TGlnaHQoIGRhdGEuY29sb3IsIGRhdGEuaW50ZW5zaXR5LCBkYXRhLmRpc3RhbmNlLCBkYXRhLmRlY2F5ICk7XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnU3BvdExpZ2h0JzpcblxuXHRcdFx0XHRcdFx0b2JqZWN0ID0gbmV3IFRIUkVFLlNwb3RMaWdodCggZGF0YS5jb2xvciwgZGF0YS5pbnRlbnNpdHksIGRhdGEuZGlzdGFuY2UsIGRhdGEuYW5nbGUsIGRhdGEuZXhwb25lbnQsIGRhdGEuZGVjYXkgKTtcblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdIZW1pc3BoZXJlTGlnaHQnOlxuXG5cdFx0XHRcdFx0XHRvYmplY3QgPSBuZXcgVEhSRUUuSGVtaXNwaGVyZUxpZ2h0KCBkYXRhLmNvbG9yLCBkYXRhLmdyb3VuZENvbG9yLCBkYXRhLmludGVuc2l0eSApO1xuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ01lc2gnOlxuXG5cdFx0XHRcdFx0XHRvYmplY3QgPSBuZXcgVEhSRUUuTWVzaCggZ2V0R2VvbWV0cnkoIGRhdGEuZ2VvbWV0cnkgKSwgZ2V0TWF0ZXJpYWwoIGRhdGEubWF0ZXJpYWwgKSApO1xuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ0xPRCc6XG5cblx0XHRcdFx0XHRcdG9iamVjdCA9IG5ldyBUSFJFRS5MT0QoKTtcblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdMaW5lJzpcblxuXHRcdFx0XHRcdFx0b2JqZWN0ID0gbmV3IFRIUkVFLkxpbmUoIGdldEdlb21ldHJ5KCBkYXRhLmdlb21ldHJ5ICksIGdldE1hdGVyaWFsKCBkYXRhLm1hdGVyaWFsICksIGRhdGEubW9kZSApO1xuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ1BvaW50Q2xvdWQnOlxuXHRcdFx0XHRcdGNhc2UgJ1BvaW50cyc6XG5cblx0XHRcdFx0XHRcdG9iamVjdCA9IG5ldyBUSFJFRS5Qb2ludHMoIGdldEdlb21ldHJ5KCBkYXRhLmdlb21ldHJ5ICksIGdldE1hdGVyaWFsKCBkYXRhLm1hdGVyaWFsICkgKTtcblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdTcHJpdGUnOlxuXG5cdFx0XHRcdFx0XHRvYmplY3QgPSBuZXcgVEhSRUUuU3ByaXRlKCBnZXRNYXRlcmlhbCggZGF0YS5tYXRlcmlhbCApICk7XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnR3JvdXAnOlxuXG5cdFx0XHRcdFx0XHRvYmplY3QgPSBuZXcgVEhSRUUuR3JvdXAoKTtcblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRkZWZhdWx0OlxuXG5cdFx0XHRcdFx0XHRvYmplY3QgPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0b2JqZWN0LnV1aWQgPSBkYXRhLnV1aWQ7XG5cblx0XHRcdFx0aWYgKCBkYXRhLm5hbWUgIT09IHVuZGVmaW5lZCApIG9iamVjdC5uYW1lID0gZGF0YS5uYW1lO1xuXHRcdFx0XHRpZiAoIGRhdGEubWF0cml4ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRtYXRyaXguZnJvbUFycmF5KCBkYXRhLm1hdHJpeCApO1xuXHRcdFx0XHRcdG1hdHJpeC5kZWNvbXBvc2UoIG9iamVjdC5wb3NpdGlvbiwgb2JqZWN0LnF1YXRlcm5pb24sIG9iamVjdC5zY2FsZSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRpZiAoIGRhdGEucG9zaXRpb24gIT09IHVuZGVmaW5lZCApIG9iamVjdC5wb3NpdGlvbi5mcm9tQXJyYXkoIGRhdGEucG9zaXRpb24gKTtcblx0XHRcdFx0XHRpZiAoIGRhdGEucm90YXRpb24gIT09IHVuZGVmaW5lZCApIG9iamVjdC5yb3RhdGlvbi5mcm9tQXJyYXkoIGRhdGEucm90YXRpb24gKTtcblx0XHRcdFx0XHRpZiAoIGRhdGEuc2NhbGUgIT09IHVuZGVmaW5lZCApIG9iamVjdC5zY2FsZS5mcm9tQXJyYXkoIGRhdGEuc2NhbGUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBkYXRhLmNhc3RTaGFkb3cgIT09IHVuZGVmaW5lZCApIG9iamVjdC5jYXN0U2hhZG93ID0gZGF0YS5jYXN0U2hhZG93O1xuXHRcdFx0XHRpZiAoIGRhdGEucmVjZWl2ZVNoYWRvdyAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnJlY2VpdmVTaGFkb3cgPSBkYXRhLnJlY2VpdmVTaGFkb3c7XG5cblx0XHRcdFx0aWYgKCBkYXRhLnZpc2libGUgIT09IHVuZGVmaW5lZCApIG9iamVjdC52aXNpYmxlID0gZGF0YS52aXNpYmxlO1xuXHRcdFx0XHRpZiAoIGRhdGEudXNlckRhdGEgIT09IHVuZGVmaW5lZCApIG9iamVjdC51c2VyRGF0YSA9IGRhdGEudXNlckRhdGE7XG5cblx0XHRcdFx0aWYgKCBkYXRhLmNoaWxkcmVuICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgY2hpbGQgaW4gZGF0YS5jaGlsZHJlbiApIHtcblxuXHRcdFx0XHRcdFx0b2JqZWN0LmFkZCggdGhpcy5wYXJzZU9iamVjdCggZGF0YS5jaGlsZHJlblsgY2hpbGQgXSwgZ2VvbWV0cmllcywgbWF0ZXJpYWxzICkgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBkYXRhLnR5cGUgPT09ICdMT0QnICkge1xuXG5cdFx0XHRcdFx0dmFyIGxldmVscyA9IGRhdGEubGV2ZWxzO1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGwgPSAwOyBsIDwgbGV2ZWxzLmxlbmd0aDsgbCArKyApIHtcblxuXHRcdFx0XHRcdFx0dmFyIGxldmVsID0gbGV2ZWxzWyBsIF07XG5cdFx0XHRcdFx0XHR2YXIgY2hpbGQgPSBvYmplY3QuZ2V0T2JqZWN0QnlQcm9wZXJ0eSggJ3V1aWQnLCBsZXZlbC5vYmplY3QgKTtcblxuXHRcdFx0XHRcdFx0aWYgKCBjaGlsZCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRcdG9iamVjdC5hZGRMZXZlbCggY2hpbGQsIGxldmVsLmRpc3RhbmNlICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG9iamVjdDtcblxuXHRcdFx0fVxuXG5cdFx0fSgpXG5cblx0fTtcblxuXHQvLyBGaWxlOnNyYy9sb2FkZXJzL1RleHR1cmVMb2FkZXIuanNcblxuXHQvKipcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICovXG5cblx0VEhSRUUuVGV4dHVyZUxvYWRlciA9IGZ1bmN0aW9uICggbWFuYWdlciApIHtcblxuXHRcdHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogVEhSRUUuRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xuXG5cdH07XG5cblx0VEhSRUUuVGV4dHVyZUxvYWRlci5wcm90b3R5cGUgPSB7XG5cblx0XHRjb25zdHJ1Y3RvcjogVEhSRUUuVGV4dHVyZUxvYWRlcixcblxuXHRcdGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cblx0XHRcdHZhciB0ZXh0dXJlID0gbmV3IFRIUkVFLlRleHR1cmUoKTtcblxuXHRcdFx0dmFyIGxvYWRlciA9IG5ldyBUSFJFRS5JbWFnZUxvYWRlciggdGhpcy5tYW5hZ2VyICk7XG5cdFx0XHRsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIHRoaXMuY3Jvc3NPcmlnaW4gKTtcblx0XHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggaW1hZ2UgKSB7XG5cblx0XHRcdFx0dGV4dHVyZS5pbWFnZSA9IGltYWdlO1xuXHRcdFx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHRpZiAoIG9uTG9hZCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0b25Mb2FkKCB0ZXh0dXJlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XG5cblx0XHRcdHJldHVybiB0ZXh0dXJlO1xuXG5cdFx0fSxcblxuXHRcdHNldENyb3NzT3JpZ2luOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHR0aGlzLmNyb3NzT3JpZ2luID0gdmFsdWU7XG5cblx0XHR9XG5cblx0fTtcblxuXHQvLyBGaWxlOnNyYy9sb2FkZXJzL0N1YmVUZXh0dXJlTG9hZGVyLmpzXG5cblx0LyoqXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqL1xuXG5cdFRIUkVFLkN1YmVUZXh0dXJlTG9hZGVyID0gZnVuY3Rpb24gKCBtYW5hZ2VyICkge1xuXG5cdFx0dGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBUSFJFRS5EZWZhdWx0TG9hZGluZ01hbmFnZXI7XG5cblx0fTtcblxuXHRUSFJFRS5DdWJlVGV4dHVyZUxvYWRlci5wcm90b3R5cGUgPSB7XG5cblx0XHRjb25zdHJ1Y3RvcjogVEhSRUUuQ3ViZVRleHR1cmVMb2FkZXIsXG5cblx0XHRsb2FkOiBmdW5jdGlvbiAoIHVybHMsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuXHRcdFx0dmFyIHRleHR1cmUgPSBuZXcgVEhSRUUuQ3ViZVRleHR1cmUoIFtdICk7XG5cblx0XHRcdHZhciBsb2FkZXIgPSBuZXcgVEhSRUUuSW1hZ2VMb2FkZXIoKTtcblx0XHRcdGxvYWRlci5zZXRDcm9zc09yaWdpbiggdGhpcy5jcm9zc09yaWdpbiApO1xuXG5cdFx0XHR2YXIgbG9hZGVkID0gMDtcblxuXHRcdFx0ZnVuY3Rpb24gbG9hZFRleHR1cmUoIGkgKSB7XG5cblx0XHRcdFx0bG9hZGVyLmxvYWQoIHVybHNbIGkgXSwgZnVuY3Rpb24gKCBpbWFnZSApIHtcblxuXHRcdFx0XHRcdHRleHR1cmUuaW1hZ2VzWyBpIF0gPSBpbWFnZTtcblxuXHRcdFx0XHRcdGxvYWRlZCArKztcblxuXHRcdFx0XHRcdGlmICggbG9hZGVkID09PSA2ICkge1xuXG5cdFx0XHRcdFx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIHRleHR1cmUgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9LCB1bmRlZmluZWQsIG9uRXJyb3IgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB1cmxzLmxlbmd0aDsgKysgaSApIHtcblxuXHRcdFx0XHRsb2FkVGV4dHVyZSggaSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0ZXh0dXJlO1xuXG5cdFx0fSxcblxuXHRcdHNldENyb3NzT3JpZ2luOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHR0aGlzLmNyb3NzT3JpZ2luID0gdmFsdWU7XG5cblx0XHR9XG5cblx0fTtcblxuXHQvLyBGaWxlOnNyYy9sb2FkZXJzL0JpbmFyeVRleHR1cmVMb2FkZXIuanNcblxuXHQvKipcblx0ICogQGF1dGhvciBOaWtvcyBNLiAvIGh0dHBzOi8vZ2l0aHViLmNvbS9mb28xMjMvXG5cdCAqXG5cdCAqIEFic3RyYWN0IEJhc2UgY2xhc3MgdG8gbG9hZCBnZW5lcmljIGJpbmFyeSB0ZXh0dXJlcyBmb3JtYXRzIChyZ2JlLCBoZHIsIC4uLilcblx0ICovXG5cblx0VEhSRUUuRGF0YVRleHR1cmVMb2FkZXIgPSBUSFJFRS5CaW5hcnlUZXh0dXJlTG9hZGVyID0gZnVuY3Rpb24gKCBtYW5hZ2VyICkge1xuXG5cdFx0dGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBUSFJFRS5EZWZhdWx0TG9hZGluZ01hbmFnZXI7XG5cblx0XHQvLyBvdmVycmlkZSBpbiBzdWIgY2xhc3Nlc1xuXHRcdHRoaXMuX3BhcnNlciA9IG51bGw7XG5cblx0fTtcblxuXHRUSFJFRS5CaW5hcnlUZXh0dXJlTG9hZGVyLnByb3RvdHlwZSA9IHtcblxuXHRcdGNvbnN0cnVjdG9yOiBUSFJFRS5CaW5hcnlUZXh0dXJlTG9hZGVyLFxuXG5cdFx0bG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuXHRcdFx0dmFyIHNjb3BlID0gdGhpcztcblxuXHRcdFx0dmFyIHRleHR1cmUgPSBuZXcgVEhSRUUuRGF0YVRleHR1cmUoKTtcblxuXHRcdFx0dmFyIGxvYWRlciA9IG5ldyBUSFJFRS5YSFJMb2FkZXIoIHRoaXMubWFuYWdlciApO1xuXHRcdFx0bG9hZGVyLnNldENyb3NzT3JpZ2luKCB0aGlzLmNyb3NzT3JpZ2luICk7XG5cdFx0XHRsb2FkZXIuc2V0UmVzcG9uc2VUeXBlKCAnYXJyYXlidWZmZXInICk7XG5cblx0XHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggYnVmZmVyICkge1xuXG5cdFx0XHRcdHZhciB0ZXhEYXRhID0gc2NvcGUuX3BhcnNlciggYnVmZmVyICk7XG5cblx0XHRcdFx0aWYgKCAhIHRleERhdGEgKSByZXR1cm47XG5cblx0XHRcdFx0aWYgKCB1bmRlZmluZWQgIT09IHRleERhdGEuaW1hZ2UgKSB7XG5cblx0XHRcdFx0XHR0ZXh0dXJlLmltYWdlID0gdGV4RGF0YS5pbWFnZTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCB1bmRlZmluZWQgIT09IHRleERhdGEuZGF0YSApIHtcblxuXHRcdFx0XHRcdHRleHR1cmUuaW1hZ2Uud2lkdGggPSB0ZXhEYXRhLndpZHRoO1xuXHRcdFx0XHRcdHRleHR1cmUuaW1hZ2UuaGVpZ2h0ID0gdGV4RGF0YS5oZWlnaHQ7XG5cdFx0XHRcdFx0dGV4dHVyZS5pbWFnZS5kYXRhID0gdGV4RGF0YS5kYXRhO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0ZXh0dXJlLndyYXBTID0gdW5kZWZpbmVkICE9PSB0ZXhEYXRhLndyYXBTID8gdGV4RGF0YS53cmFwUyA6IFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmc7XG5cdFx0XHRcdHRleHR1cmUud3JhcFQgPSB1bmRlZmluZWQgIT09IHRleERhdGEud3JhcFQgPyB0ZXhEYXRhLndyYXBUIDogVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZztcblxuXHRcdFx0XHR0ZXh0dXJlLm1hZ0ZpbHRlciA9IHVuZGVmaW5lZCAhPT0gdGV4RGF0YS5tYWdGaWx0ZXIgPyB0ZXhEYXRhLm1hZ0ZpbHRlciA6IFRIUkVFLkxpbmVhckZpbHRlcjtcblx0XHRcdFx0dGV4dHVyZS5taW5GaWx0ZXIgPSB1bmRlZmluZWQgIT09IHRleERhdGEubWluRmlsdGVyID8gdGV4RGF0YS5taW5GaWx0ZXIgOiBUSFJFRS5MaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXI7XG5cblx0XHRcdFx0dGV4dHVyZS5hbmlzb3Ryb3B5ID0gdW5kZWZpbmVkICE9PSB0ZXhEYXRhLmFuaXNvdHJvcHkgPyB0ZXhEYXRhLmFuaXNvdHJvcHkgOiAxO1xuXG5cdFx0XHRcdGlmICggdW5kZWZpbmVkICE9PSB0ZXhEYXRhLmZvcm1hdCApIHtcblxuXHRcdFx0XHRcdHRleHR1cmUuZm9ybWF0ID0gdGV4RGF0YS5mb3JtYXQ7XG5cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIHVuZGVmaW5lZCAhPT0gdGV4RGF0YS50eXBlICkge1xuXG5cdFx0XHRcdFx0dGV4dHVyZS50eXBlID0gdGV4RGF0YS50eXBlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHVuZGVmaW5lZCAhPT0gdGV4RGF0YS5taXBtYXBzICkge1xuXG5cdFx0XHRcdFx0dGV4dHVyZS5taXBtYXBzID0gdGV4RGF0YS5taXBtYXBzO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIDEgPT09IHRleERhdGEubWlwbWFwQ291bnQgKSB7XG5cblx0XHRcdFx0XHR0ZXh0dXJlLm1pbkZpbHRlciA9IFRIUkVFLkxpbmVhckZpbHRlcjtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIHRleHR1cmUsIHRleERhdGEgKTtcblxuXHRcdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG5cblx0XHRcdHJldHVybiB0ZXh0dXJlO1xuXG5cdFx0fSxcblxuXHRcdHNldENyb3NzT3JpZ2luOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHR0aGlzLmNyb3NzT3JpZ2luID0gdmFsdWU7XG5cblx0XHR9XG5cblx0fTtcblxuXHQvLyBGaWxlOnNyYy9sb2FkZXJzL0NvbXByZXNzZWRUZXh0dXJlTG9hZGVyLmpzXG5cblx0LyoqXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqXG5cdCAqIEFic3RyYWN0IEJhc2UgY2xhc3MgdG8gYmxvY2sgYmFzZWQgdGV4dHVyZXMgbG9hZGVyIChkZHMsIHB2ciwgLi4uKVxuXHQgKi9cblxuXHRUSFJFRS5Db21wcmVzc2VkVGV4dHVyZUxvYWRlciA9IGZ1bmN0aW9uICggbWFuYWdlciApIHtcblxuXHRcdHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogVEhSRUUuRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xuXG5cdFx0Ly8gb3ZlcnJpZGUgaW4gc3ViIGNsYXNzZXNcblx0XHR0aGlzLl9wYXJzZXIgPSBudWxsO1xuXG5cdH07XG5cblxuXHRUSFJFRS5Db21wcmVzc2VkVGV4dHVyZUxvYWRlci5wcm90b3R5cGUgPSB7XG5cblx0XHRjb25zdHJ1Y3RvcjogVEhSRUUuQ29tcHJlc3NlZFRleHR1cmVMb2FkZXIsXG5cblx0XHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG5cdFx0XHR2YXIgc2NvcGUgPSB0aGlzO1xuXG5cdFx0XHR2YXIgaW1hZ2VzID0gW107XG5cblx0XHRcdHZhciB0ZXh0dXJlID0gbmV3IFRIUkVFLkNvbXByZXNzZWRUZXh0dXJlKCk7XG5cdFx0XHR0ZXh0dXJlLmltYWdlID0gaW1hZ2VzO1xuXG5cdFx0XHR2YXIgbG9hZGVyID0gbmV3IFRIUkVFLlhIUkxvYWRlciggdGhpcy5tYW5hZ2VyICk7XG5cdFx0XHRsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIHRoaXMuY3Jvc3NPcmlnaW4gKTtcblx0XHRcdGxvYWRlci5zZXRSZXNwb25zZVR5cGUoICdhcnJheWJ1ZmZlcicgKTtcblxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCB1cmwgKSApIHtcblxuXHRcdFx0XHR2YXIgbG9hZGVkID0gMDtcblxuXHRcdFx0XHR2YXIgbG9hZFRleHR1cmUgPSBmdW5jdGlvbiAoIGkgKSB7XG5cblx0XHRcdFx0XHRsb2FkZXIubG9hZCggdXJsWyBpIF0sIGZ1bmN0aW9uICggYnVmZmVyICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgdGV4RGF0YXMgPSBzY29wZS5fcGFyc2VyKCBidWZmZXIsIHRydWUgKTtcblxuXHRcdFx0XHRcdFx0aW1hZ2VzWyBpIF0gPSB7XG5cdFx0XHRcdFx0XHRcdHdpZHRoOiB0ZXhEYXRhcy53aWR0aCxcblx0XHRcdFx0XHRcdFx0aGVpZ2h0OiB0ZXhEYXRhcy5oZWlnaHQsXG5cdFx0XHRcdFx0XHRcdGZvcm1hdDogdGV4RGF0YXMuZm9ybWF0LFxuXHRcdFx0XHRcdFx0XHRtaXBtYXBzOiB0ZXhEYXRhcy5taXBtYXBzXG5cdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0XHRsb2FkZWQgKz0gMTtcblxuXHRcdFx0XHRcdFx0aWYgKCBsb2FkZWQgPT09IDYgKSB7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCB0ZXhEYXRhcy5taXBtYXBDb3VudCA9PT0gMSApXG5cdCBcdFx0XHRcdFx0XHRcdHRleHR1cmUubWluRmlsdGVyID0gVEhSRUUuTGluZWFyRmlsdGVyO1xuXG5cdFx0XHRcdFx0XHRcdHRleHR1cmUuZm9ybWF0ID0gdGV4RGF0YXMuZm9ybWF0O1xuXHRcdFx0XHRcdFx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIG9uTG9hZCApIG9uTG9hZCggdGV4dHVyZSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XG5cblx0XHRcdFx0fTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdXJsLmxlbmd0aDsgaSA8IGlsOyArKyBpICkge1xuXG5cdFx0XHRcdFx0bG9hZFRleHR1cmUoIGkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gY29tcHJlc3NlZCBjdWJlbWFwIHRleHR1cmUgc3RvcmVkIGluIGEgc2luZ2xlIEREUyBmaWxlXG5cblx0XHRcdFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCBidWZmZXIgKSB7XG5cblx0XHRcdFx0XHR2YXIgdGV4RGF0YXMgPSBzY29wZS5fcGFyc2VyKCBidWZmZXIsIHRydWUgKTtcblxuXHRcdFx0XHRcdGlmICggdGV4RGF0YXMuaXNDdWJlbWFwICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgZmFjZXMgPSB0ZXhEYXRhcy5taXBtYXBzLmxlbmd0aCAvIHRleERhdGFzLm1pcG1hcENvdW50O1xuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgZiA9IDA7IGYgPCBmYWNlczsgZiArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRpbWFnZXNbIGYgXSA9IHsgbWlwbWFwcyA6IFtdIH07XG5cblx0XHRcdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGV4RGF0YXMubWlwbWFwQ291bnQ7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRpbWFnZXNbIGYgXS5taXBtYXBzLnB1c2goIHRleERhdGFzLm1pcG1hcHNbIGYgKiB0ZXhEYXRhcy5taXBtYXBDb3VudCArIGkgXSApO1xuXHRcdFx0XHRcdFx0XHRcdGltYWdlc1sgZiBdLmZvcm1hdCA9IHRleERhdGFzLmZvcm1hdDtcblx0XHRcdFx0XHRcdFx0XHRpbWFnZXNbIGYgXS53aWR0aCA9IHRleERhdGFzLndpZHRoO1xuXHRcdFx0XHRcdFx0XHRcdGltYWdlc1sgZiBdLmhlaWdodCA9IHRleERhdGFzLmhlaWdodDtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdHRleHR1cmUuaW1hZ2Uud2lkdGggPSB0ZXhEYXRhcy53aWR0aDtcblx0XHRcdFx0XHRcdHRleHR1cmUuaW1hZ2UuaGVpZ2h0ID0gdGV4RGF0YXMuaGVpZ2h0O1xuXHRcdFx0XHRcdFx0dGV4dHVyZS5taXBtYXBzID0gdGV4RGF0YXMubWlwbWFwcztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggdGV4RGF0YXMubWlwbWFwQ291bnQgPT09IDEgKSB7XG5cblx0XHRcdFx0XHRcdHRleHR1cmUubWluRmlsdGVyID0gVEhSRUUuTGluZWFyRmlsdGVyO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dGV4dHVyZS5mb3JtYXQgPSB0ZXhEYXRhcy5mb3JtYXQ7XG5cdFx0XHRcdFx0dGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0XHRpZiAoIG9uTG9hZCApIG9uTG9hZCggdGV4dHVyZSApO1xuXG5cdFx0XHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGV4dHVyZTtcblxuXHRcdH0sXG5cblx0XHRzZXRDcm9zc09yaWdpbjogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdFx0dGhpcy5jcm9zc09yaWdpbiA9IHZhbHVlO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0Ly8gRmlsZTpzcmMvbWF0ZXJpYWxzL01hdGVyaWFsLmpzXG5cblx0LyoqXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG5cdCAqL1xuXG5cdFRIUkVFLk1hdGVyaWFsID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnaWQnLCB7IHZhbHVlOiBUSFJFRS5NYXRlcmlhbElkQ291bnQgKysgfSApO1xuXG5cdFx0dGhpcy51dWlkID0gVEhSRUUuTWF0aC5nZW5lcmF0ZVVVSUQoKTtcblxuXHRcdHRoaXMubmFtZSA9ICcnO1xuXHRcdHRoaXMudHlwZSA9ICdNYXRlcmlhbCc7XG5cblx0XHR0aGlzLnNpZGUgPSBUSFJFRS5Gcm9udFNpZGU7XG5cblx0XHR0aGlzLm9wYWNpdHkgPSAxO1xuXHRcdHRoaXMudHJhbnNwYXJlbnQgPSBmYWxzZTtcblxuXHRcdHRoaXMuYmxlbmRpbmcgPSBUSFJFRS5Ob3JtYWxCbGVuZGluZztcblxuXHRcdHRoaXMuYmxlbmRTcmMgPSBUSFJFRS5TcmNBbHBoYUZhY3Rvcjtcblx0XHR0aGlzLmJsZW5kRHN0ID0gVEhSRUUuT25lTWludXNTcmNBbHBoYUZhY3Rvcjtcblx0XHR0aGlzLmJsZW5kRXF1YXRpb24gPSBUSFJFRS5BZGRFcXVhdGlvbjtcblx0XHR0aGlzLmJsZW5kU3JjQWxwaGEgPSBudWxsO1xuXHRcdHRoaXMuYmxlbmREc3RBbHBoYSA9IG51bGw7XG5cdFx0dGhpcy5ibGVuZEVxdWF0aW9uQWxwaGEgPSBudWxsO1xuXG5cdFx0dGhpcy5kZXB0aEZ1bmMgPSBUSFJFRS5MZXNzRXF1YWxEZXB0aDtcblx0XHR0aGlzLmRlcHRoVGVzdCA9IHRydWU7XG5cdFx0dGhpcy5kZXB0aFdyaXRlID0gdHJ1ZTtcblxuXHRcdHRoaXMuY29sb3JXcml0ZSA9IHRydWU7XG5cblx0XHR0aGlzLnByZWNpc2lvbiA9IG51bGw7IC8vIG92ZXJyaWRlIHRoZSByZW5kZXJlcidzIGRlZmF1bHQgcHJlY2lzaW9uIGZvciB0aGlzIG1hdGVyaWFsXG5cblx0XHR0aGlzLnBvbHlnb25PZmZzZXQgPSBmYWxzZTtcblx0XHR0aGlzLnBvbHlnb25PZmZzZXRGYWN0b3IgPSAwO1xuXHRcdHRoaXMucG9seWdvbk9mZnNldFVuaXRzID0gMDtcblxuXHRcdHRoaXMuYWxwaGFUZXN0ID0gMDtcblxuXHRcdHRoaXMub3ZlcmRyYXcgPSAwOyAvLyBPdmVyZHJhd24gcGl4ZWxzICh0eXBpY2FsbHkgYmV0d2VlbiAwIGFuZCAxKSBmb3IgZml4aW5nIGFudGlhbGlhc2luZyBnYXBzIGluIENhbnZhc1JlbmRlcmVyXG5cblx0XHR0aGlzLnZpc2libGUgPSB0cnVlO1xuXG5cdFx0dGhpcy5fbmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdH07XG5cblx0VEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlID0ge1xuXG5cdFx0Y29uc3RydWN0b3I6IFRIUkVFLk1hdGVyaWFsLFxuXG5cdFx0Z2V0IG5lZWRzVXBkYXRlICgpIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuX25lZWRzVXBkYXRlO1xuXG5cdFx0fSxcblxuXHRcdHNldCBuZWVkc1VwZGF0ZSAoIHZhbHVlICkge1xuXG5cdFx0XHRpZiAoIHZhbHVlID09PSB0cnVlICkgdGhpcy51cGRhdGUoKTtcblxuXHRcdFx0dGhpcy5fbmVlZHNVcGRhdGUgPSB2YWx1ZTtcblxuXHRcdH0sXG5cblx0XHRzZXRWYWx1ZXM6IGZ1bmN0aW9uICggdmFsdWVzICkge1xuXG5cdFx0XHRpZiAoIHZhbHVlcyA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuXG5cdFx0XHRmb3IgKCB2YXIga2V5IGluIHZhbHVlcyApIHtcblxuXHRcdFx0XHR2YXIgbmV3VmFsdWUgPSB2YWx1ZXNbIGtleSBdO1xuXG5cdFx0XHRcdGlmICggbmV3VmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggXCJUSFJFRS5NYXRlcmlhbDogJ1wiICsga2V5ICsgXCInIHBhcmFtZXRlciBpcyB1bmRlZmluZWQuXCIgKTtcblx0XHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGN1cnJlbnRWYWx1ZSA9IHRoaXNbIGtleSBdO1xuXG5cdFx0XHRcdGlmICggY3VycmVudFZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLndhcm4oIFwiVEhSRUUuXCIgKyB0aGlzLnR5cGUgKyBcIjogJ1wiICsga2V5ICsgXCInIGlzIG5vdCBhIHByb3BlcnR5IG9mIHRoaXMgbWF0ZXJpYWwuXCIgKTtcblx0XHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBjdXJyZW50VmFsdWUgaW5zdGFuY2VvZiBUSFJFRS5Db2xvciApIHtcblxuXHRcdFx0XHRcdGN1cnJlbnRWYWx1ZS5zZXQoIG5ld1ZhbHVlICk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggY3VycmVudFZhbHVlIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yMyAmJiBuZXdWYWx1ZSBpbnN0YW5jZW9mIFRIUkVFLlZlY3RvcjMgKSB7XG5cblx0XHRcdFx0XHRjdXJyZW50VmFsdWUuY29weSggbmV3VmFsdWUgKTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBrZXkgPT09ICdvdmVyZHJhdycgKSB7XG5cblx0XHRcdFx0XHQvLyBlbnN1cmUgb3ZlcmRyYXcgaXMgYmFja3dhcmRzLWNvbXBhdGlibGUgd2l0aCBsZWdhY3kgYm9vbGVhbiB0eXBlXG5cdFx0XHRcdFx0dGhpc1sga2V5IF0gPSBOdW1iZXIoIG5ld1ZhbHVlICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHRoaXNbIGtleSBdID0gbmV3VmFsdWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9LFxuXG5cdFx0dG9KU09OOiBmdW5jdGlvbiAoIG1ldGEgKSB7XG5cblx0XHRcdHZhciBkYXRhID0ge1xuXHRcdFx0XHRtZXRhZGF0YToge1xuXHRcdFx0XHRcdHZlcnNpb246IDQuNCxcblx0XHRcdFx0XHR0eXBlOiAnTWF0ZXJpYWwnLFxuXHRcdFx0XHRcdGdlbmVyYXRvcjogJ01hdGVyaWFsLnRvSlNPTidcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0Ly8gc3RhbmRhcmQgTWF0ZXJpYWwgc2VyaWFsaXphdGlvblxuXHRcdFx0ZGF0YS51dWlkID0gdGhpcy51dWlkO1xuXHRcdFx0ZGF0YS50eXBlID0gdGhpcy50eXBlO1xuXHRcdFx0aWYgKCB0aGlzLm5hbWUgIT09ICcnICkgZGF0YS5uYW1lID0gdGhpcy5uYW1lO1xuXG5cdFx0XHRpZiAoIHRoaXMuY29sb3IgaW5zdGFuY2VvZiBUSFJFRS5Db2xvciApIGRhdGEuY29sb3IgPSB0aGlzLmNvbG9yLmdldEhleCgpO1xuXHRcdFx0aWYgKCB0aGlzLmVtaXNzaXZlIGluc3RhbmNlb2YgVEhSRUUuQ29sb3IgKSBkYXRhLmVtaXNzaXZlID0gdGhpcy5lbWlzc2l2ZS5nZXRIZXgoKTtcblx0XHRcdGlmICggdGhpcy5zcGVjdWxhciBpbnN0YW5jZW9mIFRIUkVFLkNvbG9yICkgZGF0YS5zcGVjdWxhciA9IHRoaXMuc3BlY3VsYXIuZ2V0SGV4KCk7XG5cdFx0XHRpZiAoIHRoaXMuc2hpbmluZXNzICE9PSB1bmRlZmluZWQgKSBkYXRhLnNoaW5pbmVzcyA9IHRoaXMuc2hpbmluZXNzO1xuXG5cdFx0XHRpZiAoIHRoaXMubWFwIGluc3RhbmNlb2YgVEhSRUUuVGV4dHVyZSApIGRhdGEubWFwID0gdGhpcy5tYXAudG9KU09OKCBtZXRhICkudXVpZDtcblx0XHRcdGlmICggdGhpcy5hbHBoYU1hcCBpbnN0YW5jZW9mIFRIUkVFLlRleHR1cmUgKSBkYXRhLmFscGhhTWFwID0gdGhpcy5hbHBoYU1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xuXHRcdFx0aWYgKCB0aGlzLmxpZ2h0TWFwIGluc3RhbmNlb2YgVEhSRUUuVGV4dHVyZSApIGRhdGEubGlnaHRNYXAgPSB0aGlzLmxpZ2h0TWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XG5cdFx0XHRpZiAoIHRoaXMuYnVtcE1hcCBpbnN0YW5jZW9mIFRIUkVFLlRleHR1cmUgKSB7XG5cblx0XHRcdFx0ZGF0YS5idW1wTWFwID0gdGhpcy5idW1wTWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XG5cdFx0XHRcdGRhdGEuYnVtcFNjYWxlID0gdGhpcy5idW1wU2NhbGU7XG5cblx0XHRcdH1cblx0XHRcdGlmICggdGhpcy5ub3JtYWxNYXAgaW5zdGFuY2VvZiBUSFJFRS5UZXh0dXJlICkge1xuXG5cdFx0XHRcdGRhdGEubm9ybWFsTWFwID0gdGhpcy5ub3JtYWxNYXAudG9KU09OKCBtZXRhICkudXVpZDtcblx0XHRcdFx0ZGF0YS5ub3JtYWxTY2FsZSA9IHRoaXMubm9ybWFsU2NhbGU7IC8vIFJlbW92ZWQgZm9yIG5vdywgY2F1c2VzIGlzc3VlIGluIGVkaXRvciB1aS5qc1xuXG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRoaXMuZGlzcGxhY2VtZW50TWFwIGluc3RhbmNlb2YgVEhSRUUuVGV4dHVyZSApIHtcblxuXHRcdFx0XHRkYXRhLmRpc3BsYWNlbWVudE1hcCA9IHRoaXMuZGlzcGxhY2VtZW50TWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XG5cdFx0XHRcdGRhdGEuZGlzcGxhY2VtZW50U2NhbGUgPSB0aGlzLmRpc3BsYWNlbWVudFNjYWxlO1xuXHRcdFx0XHRkYXRhLmRpc3BsYWNlbWVudEJpYXMgPSB0aGlzLmRpc3BsYWNlbWVudEJpYXM7XG5cblx0XHRcdH1cblx0XHRcdGlmICggdGhpcy5zcGVjdWxhck1hcCBpbnN0YW5jZW9mIFRIUkVFLlRleHR1cmUgKSBkYXRhLnNwZWN1bGFyTWFwID0gdGhpcy5zcGVjdWxhck1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xuXHRcdFx0aWYgKCB0aGlzLmVudk1hcCBpbnN0YW5jZW9mIFRIUkVFLlRleHR1cmUgKSB7XG5cblx0XHRcdFx0ZGF0YS5lbnZNYXAgPSB0aGlzLmVudk1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xuXHRcdFx0XHRkYXRhLnJlZmxlY3Rpdml0eSA9IHRoaXMucmVmbGVjdGl2aXR5OyAvLyBTY2FsZSBiZWhpbmQgZW52TWFwXG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0aGlzLnNpemUgIT09IHVuZGVmaW5lZCApIGRhdGEuc2l6ZSA9IHRoaXMuc2l6ZTtcblx0XHRcdGlmICggdGhpcy5zaXplQXR0ZW51YXRpb24gIT09IHVuZGVmaW5lZCApIGRhdGEuc2l6ZUF0dGVudWF0aW9uID0gdGhpcy5zaXplQXR0ZW51YXRpb247XG5cblx0XHRcdGlmICggdGhpcy52ZXJ0ZXhDb2xvcnMgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnZlcnRleENvbG9ycyAhPT0gVEhSRUUuTm9Db2xvcnMgKSBkYXRhLnZlcnRleENvbG9ycyA9IHRoaXMudmVydGV4Q29sb3JzO1xuXHRcdFx0aWYgKCB0aGlzLnNoYWRpbmcgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnNoYWRpbmcgIT09IFRIUkVFLlNtb290aFNoYWRpbmcgKSBkYXRhLnNoYWRpbmcgPSB0aGlzLnNoYWRpbmc7XG5cdFx0XHRpZiAoIHRoaXMuYmxlbmRpbmcgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmJsZW5kaW5nICE9PSBUSFJFRS5Ob3JtYWxCbGVuZGluZyApIGRhdGEuYmxlbmRpbmcgPSB0aGlzLmJsZW5kaW5nO1xuXHRcdFx0aWYgKCB0aGlzLnNpZGUgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnNpZGUgIT09IFRIUkVFLkZyb250U2lkZSApIGRhdGEuc2lkZSA9IHRoaXMuc2lkZTtcblxuXHRcdFx0aWYgKCB0aGlzLm9wYWNpdHkgPCAxICkgZGF0YS5vcGFjaXR5ID0gdGhpcy5vcGFjaXR5O1xuXHRcdFx0aWYgKCB0aGlzLnRyYW5zcGFyZW50ID09PSB0cnVlICkgZGF0YS50cmFuc3BhcmVudCA9IHRoaXMudHJhbnNwYXJlbnQ7XG5cdFx0XHRpZiAoIHRoaXMuYWxwaGFUZXN0ID4gMCApIGRhdGEuYWxwaGFUZXN0ID0gdGhpcy5hbHBoYVRlc3Q7XG5cdFx0XHRpZiAoIHRoaXMud2lyZWZyYW1lID09PSB0cnVlICkgZGF0YS53aXJlZnJhbWUgPSB0aGlzLndpcmVmcmFtZTtcblx0XHRcdGlmICggdGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPiAxICkgZGF0YS53aXJlZnJhbWVMaW5ld2lkdGggPSB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aDtcblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cblx0XHR9LFxuXG5cdFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG5cdFx0fSxcblxuXHRcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xuXG5cdFx0XHR0aGlzLm5hbWUgPSBzb3VyY2UubmFtZTtcblxuXHRcdFx0dGhpcy5zaWRlID0gc291cmNlLnNpZGU7XG5cblx0XHRcdHRoaXMub3BhY2l0eSA9IHNvdXJjZS5vcGFjaXR5O1xuXHRcdFx0dGhpcy50cmFuc3BhcmVudCA9IHNvdXJjZS50cmFuc3BhcmVudDtcblxuXHRcdFx0dGhpcy5ibGVuZGluZyA9IHNvdXJjZS5ibGVuZGluZztcblxuXHRcdFx0dGhpcy5ibGVuZFNyYyA9IHNvdXJjZS5ibGVuZFNyYztcblx0XHRcdHRoaXMuYmxlbmREc3QgPSBzb3VyY2UuYmxlbmREc3Q7XG5cdFx0XHR0aGlzLmJsZW5kRXF1YXRpb24gPSBzb3VyY2UuYmxlbmRFcXVhdGlvbjtcblx0XHRcdHRoaXMuYmxlbmRTcmNBbHBoYSA9IHNvdXJjZS5ibGVuZFNyY0FscGhhO1xuXHRcdFx0dGhpcy5ibGVuZERzdEFscGhhID0gc291cmNlLmJsZW5kRHN0QWxwaGE7XG5cdFx0XHR0aGlzLmJsZW5kRXF1YXRpb25BbHBoYSA9IHNvdXJjZS5ibGVuZEVxdWF0aW9uQWxwaGE7XG5cblx0XHRcdHRoaXMuZGVwdGhGdW5jID0gc291cmNlLmRlcHRoRnVuYztcblx0XHRcdHRoaXMuZGVwdGhUZXN0ID0gc291cmNlLmRlcHRoVGVzdDtcblx0XHRcdHRoaXMuZGVwdGhXcml0ZSA9IHNvdXJjZS5kZXB0aFdyaXRlO1xuXG5cdFx0XHR0aGlzLnByZWNpc2lvbiA9IHNvdXJjZS5wcmVjaXNpb247XG5cblx0XHRcdHRoaXMucG9seWdvbk9mZnNldCA9IHNvdXJjZS5wb2x5Z29uT2Zmc2V0O1xuXHRcdFx0dGhpcy5wb2x5Z29uT2Zmc2V0RmFjdG9yID0gc291cmNlLnBvbHlnb25PZmZzZXRGYWN0b3I7XG5cdFx0XHR0aGlzLnBvbHlnb25PZmZzZXRVbml0cyA9IHNvdXJjZS5wb2x5Z29uT2Zmc2V0VW5pdHM7XG5cblx0XHRcdHRoaXMuYWxwaGFUZXN0ID0gc291cmNlLmFscGhhVGVzdDtcblxuXHRcdFx0dGhpcy5vdmVyZHJhdyA9IHNvdXJjZS5vdmVyZHJhdztcblxuXHRcdFx0dGhpcy52aXNpYmxlID0gc291cmNlLnZpc2libGU7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHVwZGF0ZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ3VwZGF0ZScgfSApO1xuXG5cdFx0fSxcblxuXHRcdGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdkaXNwb3NlJyB9ICk7XG5cblx0XHR9LFxuXG5cdFx0Ly8gRGVwcmVjYXRlZFxuXG5cdFx0Z2V0IHdyYXBBcm91bmQgKCkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS4nICsgdGhpcy50eXBlICsgJzogLndyYXBBcm91bmQgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG5cblx0XHR9LFxuXG5cdFx0c2V0IHdyYXBBcm91bmQgKCBib29sZWFuICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS4nICsgdGhpcy50eXBlICsgJzogLndyYXBBcm91bmQgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG5cblx0XHR9LFxuXG5cdFx0Z2V0IHdyYXBSR0IgKCkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS4nICsgdGhpcy50eXBlICsgJzogLndyYXBSR0IgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG5cdFx0XHRyZXR1cm4gbmV3IFRIUkVFLkNvbG9yKCk7XG5cblx0XHR9XG5cblx0fTtcblxuXHRUSFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmFwcGx5KCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcblxuXHRUSFJFRS5NYXRlcmlhbElkQ291bnQgPSAwO1xuXG5cdC8vIEZpbGU6c3JjL21hdGVyaWFscy9MaW5lQmFzaWNNYXRlcmlhbC5qc1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuXHQgKlxuXHQgKiBwYXJhbWV0ZXJzID0ge1xuXHQgKiAgY29sb3I6IDxoZXg+LFxuXHQgKiAgb3BhY2l0eTogPGZsb2F0Pixcblx0ICpcblx0ICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcblx0ICogIGRlcHRoVGVzdDogPGJvb2w+LFxuXHQgKiAgZGVwdGhXcml0ZTogPGJvb2w+LFxuXHQgKlxuXHQgKiAgbGluZXdpZHRoOiA8ZmxvYXQ+LFxuXHQgKiAgbGluZWNhcDogXCJyb3VuZFwiLFxuXHQgKiAgbGluZWpvaW46IFwicm91bmRcIixcblx0ICpcblx0ICogIHZlcnRleENvbG9yczogPGJvb2w+XG5cdCAqXG5cdCAqICBmb2c6IDxib29sPlxuXHQgKiB9XG5cdCAqL1xuXG5cdFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xuXG5cdFx0VEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcyApO1xuXG5cdFx0dGhpcy50eXBlID0gJ0xpbmVCYXNpY01hdGVyaWFsJztcblxuXHRcdHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICk7XG5cblx0XHR0aGlzLmxpbmV3aWR0aCA9IDE7XG5cdFx0dGhpcy5saW5lY2FwID0gJ3JvdW5kJztcblx0XHR0aGlzLmxpbmVqb2luID0gJ3JvdW5kJztcblxuXHRcdHRoaXMudmVydGV4Q29sb3JzID0gVEhSRUUuTm9Db2xvcnM7XG5cblx0XHR0aGlzLmZvZyA9IHRydWU7XG5cblx0XHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG5cdH07XG5cblx0VEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlICk7XG5cdFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsO1xuXG5cdFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cblx0XHRUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuXHRcdHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XG5cblx0XHR0aGlzLmxpbmV3aWR0aCA9IHNvdXJjZS5saW5ld2lkdGg7XG5cdFx0dGhpcy5saW5lY2FwID0gc291cmNlLmxpbmVjYXA7XG5cdFx0dGhpcy5saW5lam9pbiA9IHNvdXJjZS5saW5lam9pbjtcblxuXHRcdHRoaXMudmVydGV4Q29sb3JzID0gc291cmNlLnZlcnRleENvbG9ycztcblxuXHRcdHRoaXMuZm9nID0gc291cmNlLmZvZztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0Ly8gRmlsZTpzcmMvbWF0ZXJpYWxzL0xpbmVEYXNoZWRNYXRlcmlhbC5qc1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuXHQgKlxuXHQgKiBwYXJhbWV0ZXJzID0ge1xuXHQgKiAgY29sb3I6IDxoZXg+LFxuXHQgKiAgb3BhY2l0eTogPGZsb2F0Pixcblx0ICpcblx0ICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcblx0ICogIGRlcHRoVGVzdDogPGJvb2w+LFxuXHQgKiAgZGVwdGhXcml0ZTogPGJvb2w+LFxuXHQgKlxuXHQgKiAgbGluZXdpZHRoOiA8ZmxvYXQ+LFxuXHQgKlxuXHQgKiAgc2NhbGU6IDxmbG9hdD4sXG5cdCAqICBkYXNoU2l6ZTogPGZsb2F0Pixcblx0ICogIGdhcFNpemU6IDxmbG9hdD4sXG5cdCAqXG5cdCAqICB2ZXJ0ZXhDb2xvcnM6IDxib29sPlxuXHQgKlxuXHQgKiAgZm9nOiA8Ym9vbD5cblx0ICogfVxuXHQgKi9cblxuXHRUSFJFRS5MaW5lRGFzaGVkTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XG5cblx0XHRUSFJFRS5NYXRlcmlhbC5jYWxsKCB0aGlzICk7XG5cblx0XHR0aGlzLnR5cGUgPSAnTGluZURhc2hlZE1hdGVyaWFsJztcblxuXHRcdHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICk7XG5cblx0XHR0aGlzLmxpbmV3aWR0aCA9IDE7XG5cblx0XHR0aGlzLnNjYWxlID0gMTtcblx0XHR0aGlzLmRhc2hTaXplID0gMztcblx0XHR0aGlzLmdhcFNpemUgPSAxO1xuXG5cdFx0dGhpcy52ZXJ0ZXhDb2xvcnMgPSBmYWxzZTtcblxuXHRcdHRoaXMuZm9nID0gdHJ1ZTtcblxuXHRcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cblx0fTtcblxuXHRUSFJFRS5MaW5lRGFzaGVkTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlICk7XG5cdFRIUkVFLkxpbmVEYXNoZWRNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5MaW5lRGFzaGVkTWF0ZXJpYWw7XG5cblx0VEhSRUUuTGluZURhc2hlZE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cblx0XHRUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuXHRcdHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XG5cdFx0XG5cdFx0dGhpcy5saW5ld2lkdGggPSBzb3VyY2UubGluZXdpZHRoO1xuXG5cdFx0dGhpcy5zY2FsZSA9IHNvdXJjZS5zY2FsZTtcblx0XHR0aGlzLmRhc2hTaXplID0gc291cmNlLmRhc2hTaXplO1xuXHRcdHRoaXMuZ2FwU2l6ZSA9IHNvdXJjZS5nYXBTaXplO1xuXG5cdFx0dGhpcy52ZXJ0ZXhDb2xvcnMgPSBzb3VyY2UudmVydGV4Q29sb3JzO1xuXG5cdFx0dGhpcy5mb2cgPSBzb3VyY2UuZm9nO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHQvLyBGaWxlOnNyYy9tYXRlcmlhbHMvTWVzaEJhc2ljTWF0ZXJpYWwuanNcblxuXHQvKipcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cblx0ICpcblx0ICogcGFyYW1ldGVycyA9IHtcblx0ICogIGNvbG9yOiA8aGV4Pixcblx0ICogIG9wYWNpdHk6IDxmbG9hdD4sXG5cdCAqICBtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG5cdCAqXG5cdCAqICBhb01hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcblx0ICogIGFvTWFwSW50ZW5zaXR5OiA8ZmxvYXQ+XG5cdCAqXG5cdCAqICBzcGVjdWxhck1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcblx0ICpcblx0ICogIGFscGhhTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuXHQgKlxuXHQgKiAgZW52TWFwOiBuZXcgVEhSRUUuVGV4dHVyZUN1YmUoIFtwb3N4LCBuZWd4LCBwb3N5LCBuZWd5LCBwb3N6LCBuZWd6XSApLFxuXHQgKiAgY29tYmluZTogVEhSRUUuTXVsdGlwbHksXG5cdCAqICByZWZsZWN0aXZpdHk6IDxmbG9hdD4sXG5cdCAqICByZWZyYWN0aW9uUmF0aW86IDxmbG9hdD4sXG5cdCAqXG5cdCAqICBzaGFkaW5nOiBUSFJFRS5TbW9vdGhTaGFkaW5nLFxuXHQgKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxuXHQgKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXG5cdCAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXG5cdCAqXG5cdCAqICB3aXJlZnJhbWU6IDxib29sZWFuPixcblx0ICogIHdpcmVmcmFtZUxpbmV3aWR0aDogPGZsb2F0Pixcblx0ICpcblx0ICogIHZlcnRleENvbG9yczogVEhSRUUuTm9Db2xvcnMgLyBUSFJFRS5WZXJ0ZXhDb2xvcnMgLyBUSFJFRS5GYWNlQ29sb3JzLFxuXHQgKlxuXHQgKiAgc2tpbm5pbmc6IDxib29sPixcblx0ICogIG1vcnBoVGFyZ2V0czogPGJvb2w+LFxuXHQgKlxuXHQgKiAgZm9nOiA8Ym9vbD5cblx0ICogfVxuXHQgKi9cblxuXHRUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcblxuXHRcdFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcblxuXHRcdHRoaXMudHlwZSA9ICdNZXNoQmFzaWNNYXRlcmlhbCc7XG5cblx0XHR0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApOyAvLyBlbWlzc2l2ZVxuXG5cdFx0dGhpcy5tYXAgPSBudWxsO1xuXG5cdFx0dGhpcy5hb01hcCA9IG51bGw7XG5cdFx0dGhpcy5hb01hcEludGVuc2l0eSA9IDEuMDtcblxuXHRcdHRoaXMuc3BlY3VsYXJNYXAgPSBudWxsO1xuXG5cdFx0dGhpcy5hbHBoYU1hcCA9IG51bGw7XG5cblx0XHR0aGlzLmVudk1hcCA9IG51bGw7XG5cdFx0dGhpcy5jb21iaW5lID0gVEhSRUUuTXVsdGlwbHlPcGVyYXRpb247XG5cdFx0dGhpcy5yZWZsZWN0aXZpdHkgPSAxO1xuXHRcdHRoaXMucmVmcmFjdGlvblJhdGlvID0gMC45ODtcblxuXHRcdHRoaXMuZm9nID0gdHJ1ZTtcblxuXHRcdHRoaXMuc2hhZGluZyA9IFRIUkVFLlNtb290aFNoYWRpbmc7XG5cblx0XHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcblx0XHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSAncm91bmQnO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSAncm91bmQnO1xuXG5cdFx0dGhpcy52ZXJ0ZXhDb2xvcnMgPSBUSFJFRS5Ob0NvbG9ycztcblxuXHRcdHRoaXMuc2tpbm5pbmcgPSBmYWxzZTtcblx0XHR0aGlzLm1vcnBoVGFyZ2V0cyA9IGZhbHNlO1xuXG5cdFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxuXHR9O1xuXG5cdFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xuXHRUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbDtcblxuXHRUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xuXHRcdFxuXHRcdFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcblxuXHRcdHRoaXMubWFwID0gc291cmNlLm1hcDtcblxuXHRcdHRoaXMuYW9NYXAgPSBzb3VyY2UuYW9NYXA7XG5cdFx0dGhpcy5hb01hcEludGVuc2l0eSA9IHNvdXJjZS5hb01hcEludGVuc2l0eTtcblxuXHRcdHRoaXMuc3BlY3VsYXJNYXAgPSBzb3VyY2Uuc3BlY3VsYXJNYXA7XG5cblx0XHR0aGlzLmFscGhhTWFwID0gc291cmNlLmFscGhhTWFwO1xuXG5cdFx0dGhpcy5lbnZNYXAgPSBzb3VyY2UuZW52TWFwO1xuXHRcdHRoaXMuY29tYmluZSA9IHNvdXJjZS5jb21iaW5lO1xuXHRcdHRoaXMucmVmbGVjdGl2aXR5ID0gc291cmNlLnJlZmxlY3Rpdml0eTtcblx0XHR0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IHNvdXJjZS5yZWZyYWN0aW9uUmF0aW87XG5cblx0XHR0aGlzLmZvZyA9IHNvdXJjZS5mb2c7XG5cblx0XHR0aGlzLnNoYWRpbmcgPSBzb3VyY2Uuc2hhZGluZztcblxuXHRcdHRoaXMud2lyZWZyYW1lID0gc291cmNlLndpcmVmcmFtZTtcblx0XHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IHNvdXJjZS53aXJlZnJhbWVMaW5ld2lkdGg7XG5cdFx0dGhpcy53aXJlZnJhbWVMaW5lY2FwID0gc291cmNlLndpcmVmcmFtZUxpbmVjYXA7XG5cdFx0dGhpcy53aXJlZnJhbWVMaW5lam9pbiA9IHNvdXJjZS53aXJlZnJhbWVMaW5lam9pbjtcblxuXHRcdHRoaXMudmVydGV4Q29sb3JzID0gc291cmNlLnZlcnRleENvbG9ycztcblxuXHRcdHRoaXMuc2tpbm5pbmcgPSBzb3VyY2Uuc2tpbm5pbmc7XG5cdFx0dGhpcy5tb3JwaFRhcmdldHMgPSBzb3VyY2UubW9ycGhUYXJnZXRzO1xuXHRcdFxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0Ly8gRmlsZTpzcmMvbWF0ZXJpYWxzL01lc2hMYW1iZXJ0TWF0ZXJpYWwuanNcblxuXHQvKipcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cblx0ICpcblx0ICogcGFyYW1ldGVycyA9IHtcblx0ICogIGNvbG9yOiA8aGV4Pixcblx0ICogIGVtaXNzaXZlOiA8aGV4Pixcblx0ICogIG9wYWNpdHk6IDxmbG9hdD4sXG5cdCAqXG5cdCAqICBtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG5cdCAqXG5cdCAqICBzcGVjdWxhck1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcblx0ICpcblx0ICogIGFscGhhTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuXHQgKlxuXHQgKiAgZW52TWFwOiBuZXcgVEhSRUUuVGV4dHVyZUN1YmUoIFtwb3N4LCBuZWd4LCBwb3N5LCBuZWd5LCBwb3N6LCBuZWd6XSApLFxuXHQgKiAgY29tYmluZTogVEhSRUUuTXVsdGlwbHksXG5cdCAqICByZWZsZWN0aXZpdHk6IDxmbG9hdD4sXG5cdCAqICByZWZyYWN0aW9uUmF0aW86IDxmbG9hdD4sXG5cdCAqXG5cdCAqICBibGVuZGluZzogVEhSRUUuTm9ybWFsQmxlbmRpbmcsXG5cdCAqICBkZXB0aFRlc3Q6IDxib29sPixcblx0ICogIGRlcHRoV3JpdGU6IDxib29sPixcblx0ICpcblx0ICogIHdpcmVmcmFtZTogPGJvb2xlYW4+LFxuXHQgKiAgd2lyZWZyYW1lTGluZXdpZHRoOiA8ZmxvYXQ+LFxuXHQgKlxuXHQgKiAgdmVydGV4Q29sb3JzOiBUSFJFRS5Ob0NvbG9ycyAvIFRIUkVFLlZlcnRleENvbG9ycyAvIFRIUkVFLkZhY2VDb2xvcnMsXG5cdCAqXG5cdCAqICBza2lubmluZzogPGJvb2w+LFxuXHQgKiAgbW9ycGhUYXJnZXRzOiA8Ym9vbD4sXG5cdCAqICBtb3JwaE5vcm1hbHM6IDxib29sPixcblx0ICpcblx0ICpcdGZvZzogPGJvb2w+XG5cdCAqIH1cblx0ICovXG5cblx0VEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcblxuXHRcdFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcblxuXHRcdHRoaXMudHlwZSA9ICdNZXNoTGFtYmVydE1hdGVyaWFsJztcblxuXHRcdHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICk7IC8vIGRpZmZ1c2Vcblx0XHR0aGlzLmVtaXNzaXZlID0gbmV3IFRIUkVFLkNvbG9yKCAweDAwMDAwMCApO1xuXG5cdFx0dGhpcy5tYXAgPSBudWxsO1xuXG5cdFx0dGhpcy5zcGVjdWxhck1hcCA9IG51bGw7XG5cblx0XHR0aGlzLmFscGhhTWFwID0gbnVsbDtcblxuXHRcdHRoaXMuZW52TWFwID0gbnVsbDtcblx0XHR0aGlzLmNvbWJpbmUgPSBUSFJFRS5NdWx0aXBseU9wZXJhdGlvbjtcblx0XHR0aGlzLnJlZmxlY3Rpdml0eSA9IDE7XG5cdFx0dGhpcy5yZWZyYWN0aW9uUmF0aW8gPSAwLjk4O1xuXG5cdFx0dGhpcy5mb2cgPSB0cnVlO1xuXG5cdFx0dGhpcy53aXJlZnJhbWUgPSBmYWxzZTtcblx0XHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XG5cdFx0dGhpcy53aXJlZnJhbWVMaW5lY2FwID0gJ3JvdW5kJztcblx0XHR0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gJ3JvdW5kJztcblxuXHRcdHRoaXMudmVydGV4Q29sb3JzID0gVEhSRUUuTm9Db2xvcnM7XG5cblx0XHR0aGlzLnNraW5uaW5nID0gZmFsc2U7XG5cdFx0dGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTtcblx0XHR0aGlzLm1vcnBoTm9ybWFscyA9IGZhbHNlO1xuXG5cdFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxuXHR9O1xuXG5cdFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlICk7XG5cdFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbDtcblxuXHRUSFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cblx0XHRUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuXHRcdHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XG5cdFx0dGhpcy5lbWlzc2l2ZS5jb3B5KCBzb3VyY2UuZW1pc3NpdmUgKTtcblxuXHRcdHRoaXMubWFwID0gc291cmNlLm1hcDtcblxuXHRcdHRoaXMuc3BlY3VsYXJNYXAgPSBzb3VyY2Uuc3BlY3VsYXJNYXA7XG5cblx0XHR0aGlzLmFscGhhTWFwID0gc291cmNlLmFscGhhTWFwO1xuXG5cdFx0dGhpcy5lbnZNYXAgPSBzb3VyY2UuZW52TWFwO1xuXHRcdHRoaXMuY29tYmluZSA9IHNvdXJjZS5jb21iaW5lO1xuXHRcdHRoaXMucmVmbGVjdGl2aXR5ID0gc291cmNlLnJlZmxlY3Rpdml0eTtcblx0XHR0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IHNvdXJjZS5yZWZyYWN0aW9uUmF0aW87XG5cblx0XHR0aGlzLmZvZyA9IHNvdXJjZS5mb2c7XG5cblx0XHR0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XG5cdFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSBzb3VyY2Uud2lyZWZyYW1lTGluZXdpZHRoO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZWNhcCA9IHNvdXJjZS53aXJlZnJhbWVMaW5lY2FwO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSBzb3VyY2Uud2lyZWZyYW1lTGluZWpvaW47XG5cblx0XHR0aGlzLnZlcnRleENvbG9ycyA9IHNvdXJjZS52ZXJ0ZXhDb2xvcnM7XG5cblx0XHR0aGlzLnNraW5uaW5nID0gc291cmNlLnNraW5uaW5nO1xuXHRcdHRoaXMubW9ycGhUYXJnZXRzID0gc291cmNlLm1vcnBoVGFyZ2V0cztcblx0XHR0aGlzLm1vcnBoTm9ybWFscyA9IHNvdXJjZS5tb3JwaE5vcm1hbHM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdC8vIEZpbGU6c3JjL21hdGVyaWFscy9NZXNoUGhvbmdNYXRlcmlhbC5qc1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuXHQgKlxuXHQgKiBwYXJhbWV0ZXJzID0ge1xuXHQgKiAgY29sb3I6IDxoZXg+LFxuXHQgKiAgZW1pc3NpdmU6IDxoZXg+LFxuXHQgKiAgc3BlY3VsYXI6IDxoZXg+LFxuXHQgKiAgc2hpbmluZXNzOiA8ZmxvYXQ+LFxuXHQgKiAgb3BhY2l0eTogPGZsb2F0Pixcblx0ICpcblx0ICogIG1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcblx0ICpcblx0ICogIGxpZ2h0TWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuXHQgKiAgbGlnaHRNYXBJbnRlbnNpdHk6IDxmbG9hdD5cblx0ICpcblx0ICogIGFvTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuXHQgKiAgYW9NYXBJbnRlbnNpdHk6IDxmbG9hdD5cblx0ICpcblx0ICogIGVtaXNzaXZlTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuXHQgKlxuXHQgKiAgYnVtcE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcblx0ICogIGJ1bXBTY2FsZTogPGZsb2F0Pixcblx0ICpcblx0ICogIG5vcm1hbE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcblx0ICogIG5vcm1hbFNjYWxlOiA8VmVjdG9yMj4sXG5cdCAqXG5cdCAqICBkaXNwbGFjZW1lbnRNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG5cdCAqICBkaXNwbGFjZW1lbnRTY2FsZTogPGZsb2F0Pixcblx0ICogIGRpc3BsYWNlbWVudEJpYXM6IDxmbG9hdD4sXG5cdCAqXG5cdCAqICBzcGVjdWxhck1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcblx0ICpcblx0ICogIGFscGhhTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuXHQgKlxuXHQgKiAgZW52TWFwOiBuZXcgVEhSRUUuVGV4dHVyZUN1YmUoIFtwb3N4LCBuZWd4LCBwb3N5LCBuZWd5LCBwb3N6LCBuZWd6XSApLFxuXHQgKiAgY29tYmluZTogVEhSRUUuTXVsdGlwbHksXG5cdCAqICByZWZsZWN0aXZpdHk6IDxmbG9hdD4sXG5cdCAqICByZWZyYWN0aW9uUmF0aW86IDxmbG9hdD4sXG5cdCAqXG5cdCAqICBzaGFkaW5nOiBUSFJFRS5TbW9vdGhTaGFkaW5nLFxuXHQgKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxuXHQgKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXG5cdCAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXG5cdCAqXG5cdCAqICB3aXJlZnJhbWU6IDxib29sZWFuPixcblx0ICogIHdpcmVmcmFtZUxpbmV3aWR0aDogPGZsb2F0Pixcblx0ICpcblx0ICogIHZlcnRleENvbG9yczogVEhSRUUuTm9Db2xvcnMgLyBUSFJFRS5WZXJ0ZXhDb2xvcnMgLyBUSFJFRS5GYWNlQ29sb3JzLFxuXHQgKlxuXHQgKiAgc2tpbm5pbmc6IDxib29sPixcblx0ICogIG1vcnBoVGFyZ2V0czogPGJvb2w+LFxuXHQgKiAgbW9ycGhOb3JtYWxzOiA8Ym9vbD4sXG5cdCAqXG5cdCAqXHRmb2c6IDxib29sPlxuXHQgKiB9XG5cdCAqL1xuXG5cdFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xuXG5cdFx0VEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcyApO1xuXG5cdFx0dGhpcy50eXBlID0gJ01lc2hQaG9uZ01hdGVyaWFsJztcblxuXHRcdHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICk7IC8vIGRpZmZ1c2Vcblx0XHR0aGlzLmVtaXNzaXZlID0gbmV3IFRIUkVFLkNvbG9yKCAweDAwMDAwMCApO1xuXHRcdHRoaXMuc3BlY3VsYXIgPSBuZXcgVEhSRUUuQ29sb3IoIDB4MTExMTExICk7XG5cdFx0dGhpcy5zaGluaW5lc3MgPSAzMDtcblxuXHRcdHRoaXMubWV0YWwgPSBmYWxzZTtcblxuXHRcdHRoaXMubWFwID0gbnVsbDtcblxuXHRcdHRoaXMubGlnaHRNYXAgPSBudWxsO1xuXHRcdHRoaXMubGlnaHRNYXBJbnRlbnNpdHkgPSAxLjA7XG5cblx0XHR0aGlzLmFvTWFwID0gbnVsbDtcblx0XHR0aGlzLmFvTWFwSW50ZW5zaXR5ID0gMS4wO1xuXG5cdFx0dGhpcy5lbWlzc2l2ZU1hcCA9IG51bGw7XG5cblx0XHR0aGlzLmJ1bXBNYXAgPSBudWxsO1xuXHRcdHRoaXMuYnVtcFNjYWxlID0gMTtcblxuXHRcdHRoaXMubm9ybWFsTWFwID0gbnVsbDtcblx0XHR0aGlzLm5vcm1hbFNjYWxlID0gbmV3IFRIUkVFLlZlY3RvcjIoIDEsIDEgKTtcblxuXHRcdHRoaXMuZGlzcGxhY2VtZW50TWFwID0gbnVsbDtcblx0XHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gMTtcblx0XHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSAwO1xuXG5cdFx0dGhpcy5zcGVjdWxhck1hcCA9IG51bGw7XG5cblx0XHR0aGlzLmFscGhhTWFwID0gbnVsbDtcblxuXHRcdHRoaXMuZW52TWFwID0gbnVsbDtcblx0XHR0aGlzLmNvbWJpbmUgPSBUSFJFRS5NdWx0aXBseU9wZXJhdGlvbjtcblx0XHR0aGlzLnJlZmxlY3Rpdml0eSA9IDE7XG5cdFx0dGhpcy5yZWZyYWN0aW9uUmF0aW8gPSAwLjk4O1xuXG5cdFx0dGhpcy5mb2cgPSB0cnVlO1xuXG5cdFx0dGhpcy5zaGFkaW5nID0gVEhSRUUuU21vb3RoU2hhZGluZztcblxuXHRcdHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XG5cdFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZWNhcCA9ICdyb3VuZCc7XG5cdFx0dGhpcy53aXJlZnJhbWVMaW5lam9pbiA9ICdyb3VuZCc7XG5cblx0XHR0aGlzLnZlcnRleENvbG9ycyA9IFRIUkVFLk5vQ29sb3JzO1xuXG5cdFx0dGhpcy5za2lubmluZyA9IGZhbHNlO1xuXHRcdHRoaXMubW9ycGhUYXJnZXRzID0gZmFsc2U7XG5cdFx0dGhpcy5tb3JwaE5vcm1hbHMgPSBmYWxzZTtcblxuXHRcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cblx0fTtcblxuXHRUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcblx0VEhSRUUuTWVzaFBob25nTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTWVzaFBob25nTWF0ZXJpYWw7XG5cblx0VEhSRUUuTWVzaFBob25nTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuXHRcdFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcblx0XHR0aGlzLmVtaXNzaXZlLmNvcHkoIHNvdXJjZS5lbWlzc2l2ZSApO1xuXHRcdHRoaXMuc3BlY3VsYXIuY29weSggc291cmNlLnNwZWN1bGFyICk7XG5cdFx0dGhpcy5zaGluaW5lc3MgPSBzb3VyY2Uuc2hpbmluZXNzO1xuXG5cdFx0dGhpcy5tZXRhbCA9IHNvdXJjZS5tZXRhbDtcblxuXHRcdHRoaXMubWFwID0gc291cmNlLm1hcDtcblxuXHRcdHRoaXMubGlnaHRNYXAgPSBzb3VyY2UubGlnaHRNYXA7XG5cdFx0dGhpcy5saWdodE1hcEludGVuc2l0eSA9IHNvdXJjZS5saWdodE1hcEludGVuc2l0eTtcblxuXHRcdHRoaXMuYW9NYXAgPSBzb3VyY2UuYW9NYXA7XG5cdFx0dGhpcy5hb01hcEludGVuc2l0eSA9IHNvdXJjZS5hb01hcEludGVuc2l0eTtcblxuXHRcdHRoaXMuZW1pc3NpdmVNYXAgPSBzb3VyY2UuZW1pc3NpdmVNYXA7XG5cblx0XHR0aGlzLmJ1bXBNYXAgPSBzb3VyY2UuYnVtcE1hcDtcblx0XHR0aGlzLmJ1bXBTY2FsZSA9IHNvdXJjZS5idW1wU2NhbGU7XG5cblx0XHR0aGlzLm5vcm1hbE1hcCA9IHNvdXJjZS5ub3JtYWxNYXA7XG5cdFx0dGhpcy5ub3JtYWxTY2FsZS5jb3B5KCBzb3VyY2Uubm9ybWFsU2NhbGUgKTtcblxuXHRcdHRoaXMuZGlzcGxhY2VtZW50TWFwID0gc291cmNlLmRpc3BsYWNlbWVudE1hcDtcblx0XHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gc291cmNlLmRpc3BsYWNlbWVudFNjYWxlO1xuXHRcdHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IHNvdXJjZS5kaXNwbGFjZW1lbnRCaWFzO1xuXG5cdFx0dGhpcy5zcGVjdWxhck1hcCA9IHNvdXJjZS5zcGVjdWxhck1hcDtcblxuXHRcdHRoaXMuYWxwaGFNYXAgPSBzb3VyY2UuYWxwaGFNYXA7XG5cblx0XHR0aGlzLmVudk1hcCA9IHNvdXJjZS5lbnZNYXA7XG5cdFx0dGhpcy5jb21iaW5lID0gc291cmNlLmNvbWJpbmU7XG5cdFx0dGhpcy5yZWZsZWN0aXZpdHkgPSBzb3VyY2UucmVmbGVjdGl2aXR5O1xuXHRcdHRoaXMucmVmcmFjdGlvblJhdGlvID0gc291cmNlLnJlZnJhY3Rpb25SYXRpbztcblxuXHRcdHRoaXMuZm9nID0gc291cmNlLmZvZztcblxuXHRcdHRoaXMuc2hhZGluZyA9IHNvdXJjZS5zaGFkaW5nO1xuXG5cdFx0dGhpcy53aXJlZnJhbWUgPSBzb3VyY2Uud2lyZWZyYW1lO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcblx0XHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSBzb3VyY2Uud2lyZWZyYW1lTGluZWNhcDtcblx0XHR0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gc291cmNlLndpcmVmcmFtZUxpbmVqb2luO1xuXG5cdFx0dGhpcy52ZXJ0ZXhDb2xvcnMgPSBzb3VyY2UudmVydGV4Q29sb3JzO1xuXG5cdFx0dGhpcy5za2lubmluZyA9IHNvdXJjZS5za2lubmluZztcblx0XHR0aGlzLm1vcnBoVGFyZ2V0cyA9IHNvdXJjZS5tb3JwaFRhcmdldHM7XG5cdFx0dGhpcy5tb3JwaE5vcm1hbHMgPSBzb3VyY2UubW9ycGhOb3JtYWxzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHQvLyBGaWxlOnNyYy9tYXRlcmlhbHMvTWVzaERlcHRoTWF0ZXJpYWwuanNcblxuXHQvKipcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cblx0ICpcblx0ICogcGFyYW1ldGVycyA9IHtcblx0ICogIG9wYWNpdHk6IDxmbG9hdD4sXG5cdCAqXG5cdCAqICBibGVuZGluZzogVEhSRUUuTm9ybWFsQmxlbmRpbmcsXG5cdCAqICBkZXB0aFRlc3Q6IDxib29sPixcblx0ICogIGRlcHRoV3JpdGU6IDxib29sPixcblx0ICpcblx0ICogIHdpcmVmcmFtZTogPGJvb2xlYW4+LFxuXHQgKiAgd2lyZWZyYW1lTGluZXdpZHRoOiA8ZmxvYXQ+XG5cdCAqIH1cblx0ICovXG5cblx0VEhSRUUuTWVzaERlcHRoTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XG5cblx0XHRUSFJFRS5NYXRlcmlhbC5jYWxsKCB0aGlzICk7XG5cblx0XHR0aGlzLnR5cGUgPSAnTWVzaERlcHRoTWF0ZXJpYWwnO1xuXG5cdFx0dGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTtcblx0XHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcblxuXHRcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cblx0fTtcblxuXHRUSFJFRS5NZXNoRGVwdGhNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcblx0VEhSRUUuTWVzaERlcHRoTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTWVzaERlcHRoTWF0ZXJpYWw7XG5cblx0VEhSRUUuTWVzaERlcHRoTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuXHRcdFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG5cdFx0dGhpcy53aXJlZnJhbWUgPSBzb3VyY2Uud2lyZWZyYW1lO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0Ly8gRmlsZTpzcmMvbWF0ZXJpYWxzL01lc2hOb3JtYWxNYXRlcmlhbC5qc1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuXHQgKlxuXHQgKiBwYXJhbWV0ZXJzID0ge1xuXHQgKiAgb3BhY2l0eTogPGZsb2F0Pixcblx0ICpcblx0ICogIHNoYWRpbmc6IFRIUkVFLkZsYXRTaGFkaW5nLFxuXHQgKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxuXHQgKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXG5cdCAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXG5cdCAqXG5cdCAqICB3aXJlZnJhbWU6IDxib29sZWFuPixcblx0ICogIHdpcmVmcmFtZUxpbmV3aWR0aDogPGZsb2F0PlxuXHQgKiB9XG5cdCAqL1xuXG5cdFRIUkVFLk1lc2hOb3JtYWxNYXRlcmlhbCA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcblxuXHRcdFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMsIHBhcmFtZXRlcnMgKTtcblxuXHRcdHRoaXMudHlwZSA9ICdNZXNoTm9ybWFsTWF0ZXJpYWwnO1xuXG5cdFx0dGhpcy53aXJlZnJhbWUgPSBmYWxzZTtcblx0XHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XG5cblx0XHR0aGlzLm1vcnBoVGFyZ2V0cyA9IGZhbHNlO1xuXG5cdFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxuXHR9O1xuXG5cdFRIUkVFLk1lc2hOb3JtYWxNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcblx0VEhSRUUuTWVzaE5vcm1hbE1hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLk1lc2hOb3JtYWxNYXRlcmlhbDtcblxuXHRUSFJFRS5NZXNoTm9ybWFsTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuXHRcdFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG5cdFx0dGhpcy53aXJlZnJhbWUgPSBzb3VyY2Uud2lyZWZyYW1lO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0Ly8gRmlsZTpzcmMvbWF0ZXJpYWxzL011bHRpTWF0ZXJpYWwuanNcblxuXHQvKipcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICovXG5cblx0VEhSRUUuTXVsdGlNYXRlcmlhbCA9IGZ1bmN0aW9uICggbWF0ZXJpYWxzICkge1xuXG5cdFx0dGhpcy51dWlkID0gVEhSRUUuTWF0aC5nZW5lcmF0ZVVVSUQoKTtcblxuXHRcdHRoaXMudHlwZSA9ICdNdWx0aU1hdGVyaWFsJztcblxuXHRcdHRoaXMubWF0ZXJpYWxzID0gbWF0ZXJpYWxzIGluc3RhbmNlb2YgQXJyYXkgPyBtYXRlcmlhbHMgOiBbXTtcblxuXHRcdHRoaXMudmlzaWJsZSA9IHRydWU7XG5cblx0fTtcblxuXHRUSFJFRS5NdWx0aU1hdGVyaWFsLnByb3RvdHlwZSA9IHtcblxuXHRcdGNvbnN0cnVjdG9yOiBUSFJFRS5NdWx0aU1hdGVyaWFsLFxuXG5cdFx0dG9KU09OOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciBvdXRwdXQgPSB7XG5cdFx0XHRcdG1ldGFkYXRhOiB7XG5cdFx0XHRcdFx0dmVyc2lvbjogNC4yLFxuXHRcdFx0XHRcdHR5cGU6ICdtYXRlcmlhbCcsXG5cdFx0XHRcdFx0Z2VuZXJhdG9yOiAnTWF0ZXJpYWxFeHBvcnRlcidcblx0XHRcdFx0fSxcblx0XHRcdFx0dXVpZDogdGhpcy51dWlkLFxuXHRcdFx0XHR0eXBlOiB0aGlzLnR5cGUsXG5cdFx0XHRcdG1hdGVyaWFsczogW11cblx0XHRcdH07XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMubWF0ZXJpYWxzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0b3V0cHV0Lm1hdGVyaWFscy5wdXNoKCB0aGlzLm1hdGVyaWFsc1sgaSBdLnRvSlNPTigpICk7XG5cblx0XHRcdH1cblxuXHRcdFx0b3V0cHV0LnZpc2libGUgPSB0aGlzLnZpc2libGU7XG5cblx0XHRcdHJldHVybiBvdXRwdXQ7XG5cblx0XHR9LFxuXG5cdFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIG1hdGVyaWFsID0gbmV3IHRoaXMuY29uc3RydWN0b3IoKTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5tYXRlcmlhbHMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdG1hdGVyaWFsLm1hdGVyaWFscy5wdXNoKCB0aGlzLm1hdGVyaWFsc1sgaSBdLmNsb25lKCkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRtYXRlcmlhbC52aXNpYmxlID0gdGhpcy52aXNpYmxlO1xuXG5cdFx0XHRyZXR1cm4gbWF0ZXJpYWw7XG5cblx0XHR9XG5cblx0fTtcblxuXHQvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXG5cdFRIUkVFLk1lc2hGYWNlTWF0ZXJpYWwgPSBUSFJFRS5NdWx0aU1hdGVyaWFsO1xuXG5cdC8vIEZpbGU6c3JjL21hdGVyaWFscy9Qb2ludHNNYXRlcmlhbC5qc1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuXHQgKlxuXHQgKiBwYXJhbWV0ZXJzID0ge1xuXHQgKiAgY29sb3I6IDxoZXg+LFxuXHQgKiAgb3BhY2l0eTogPGZsb2F0Pixcblx0ICogIG1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcblx0ICpcblx0ICogIHNpemU6IDxmbG9hdD4sXG5cdCAqICBzaXplQXR0ZW51YXRpb246IDxib29sPixcblx0ICpcblx0ICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcblx0ICogIGRlcHRoVGVzdDogPGJvb2w+LFxuXHQgKiAgZGVwdGhXcml0ZTogPGJvb2w+LFxuXHQgKlxuXHQgKiAgdmVydGV4Q29sb3JzOiA8Ym9vbD4sXG5cdCAqXG5cdCAqICBmb2c6IDxib29sPlxuXHQgKiB9XG5cdCAqL1xuXG5cdFRIUkVFLlBvaW50c01hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xuXG5cdFx0VEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcyApO1xuXG5cdFx0dGhpcy50eXBlID0gJ1BvaW50c01hdGVyaWFsJztcblxuXHRcdHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICk7XG5cblx0XHR0aGlzLm1hcCA9IG51bGw7XG5cblx0XHR0aGlzLnNpemUgPSAxO1xuXHRcdHRoaXMuc2l6ZUF0dGVudWF0aW9uID0gdHJ1ZTtcblxuXHRcdHRoaXMudmVydGV4Q29sb3JzID0gVEhSRUUuTm9Db2xvcnM7XG5cblx0XHR0aGlzLmZvZyA9IHRydWU7XG5cblx0XHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG5cdH07XG5cblx0VEhSRUUuUG9pbnRzTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlICk7XG5cdFRIUkVFLlBvaW50c01hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlBvaW50c01hdGVyaWFsO1xuXG5cdFRIUkVFLlBvaW50c01hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cblx0XHRUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuXHRcdHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XG5cblx0XHR0aGlzLm1hcCA9IHNvdXJjZS5tYXA7XG5cblx0XHR0aGlzLnNpemUgPSBzb3VyY2Uuc2l6ZTtcblx0XHR0aGlzLnNpemVBdHRlbnVhdGlvbiA9IHNvdXJjZS5zaXplQXR0ZW51YXRpb247XG5cblx0XHR0aGlzLnZlcnRleENvbG9ycyA9IHNvdXJjZS52ZXJ0ZXhDb2xvcnM7XG5cblx0XHR0aGlzLmZvZyA9IHNvdXJjZS5mb2c7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cblx0VEhSRUUuUG9pbnRDbG91ZE1hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUG9pbnRDbG91ZE1hdGVyaWFsIGhhcyBiZWVuIHJlbmFtZWQgdG8gVEhSRUUuUG9pbnRzTWF0ZXJpYWwuJyApO1xuXHRcdHJldHVybiBuZXcgVEhSRUUuUG9pbnRzTWF0ZXJpYWwoIHBhcmFtZXRlcnMgKTtcblxuXHR9O1xuXG5cdFRIUkVFLlBhcnRpY2xlQmFzaWNNYXRlcmlhbCA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlBhcnRpY2xlQmFzaWNNYXRlcmlhbCBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLlBvaW50c01hdGVyaWFsLicgKTtcblx0XHRyZXR1cm4gbmV3IFRIUkVFLlBvaW50c01hdGVyaWFsKCBwYXJhbWV0ZXJzICk7XG5cblx0fTtcblxuXHRUSFJFRS5QYXJ0aWNsZVN5c3RlbU1hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUGFydGljbGVTeXN0ZW1NYXRlcmlhbCBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLlBvaW50c01hdGVyaWFsLicgKTtcblx0XHRyZXR1cm4gbmV3IFRIUkVFLlBvaW50c01hdGVyaWFsKCBwYXJhbWV0ZXJzICk7XG5cblx0fTtcblxuXHQvLyBGaWxlOnNyYy9tYXRlcmlhbHMvU2hhZGVyTWF0ZXJpYWwuanNcblxuXHQvKipcblx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cblx0ICpcblx0ICogcGFyYW1ldGVycyA9IHtcblx0ICogIGRlZmluZXM6IHsgXCJsYWJlbFwiIDogXCJ2YWx1ZVwiIH0sXG5cdCAqICB1bmlmb3JtczogeyBcInBhcmFtZXRlcjFcIjogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEuMCB9LCBcInBhcmFtZXRlcjJcIjogeyB0eXBlOiBcImlcIiB2YWx1ZTI6IDIgfSB9LFxuXHQgKlxuXHQgKiAgZnJhZ21lbnRTaGFkZXI6IDxzdHJpbmc+LFxuXHQgKiAgdmVydGV4U2hhZGVyOiA8c3RyaW5nPixcblx0ICpcblx0ICogIHNoYWRpbmc6IFRIUkVFLlNtb290aFNoYWRpbmcsXG5cdCAqICBibGVuZGluZzogVEhSRUUuTm9ybWFsQmxlbmRpbmcsXG5cdCAqICBkZXB0aFRlc3Q6IDxib29sPixcblx0ICogIGRlcHRoV3JpdGU6IDxib29sPixcblx0ICpcblx0ICogIHdpcmVmcmFtZTogPGJvb2xlYW4+LFxuXHQgKiAgd2lyZWZyYW1lTGluZXdpZHRoOiA8ZmxvYXQ+LFxuXHQgKlxuXHQgKiAgbGlnaHRzOiA8Ym9vbD4sXG5cdCAqXG5cdCAqICB2ZXJ0ZXhDb2xvcnM6IFRIUkVFLk5vQ29sb3JzIC8gVEhSRUUuVmVydGV4Q29sb3JzIC8gVEhSRUUuRmFjZUNvbG9ycyxcblx0ICpcblx0ICogIHNraW5uaW5nOiA8Ym9vbD4sXG5cdCAqICBtb3JwaFRhcmdldHM6IDxib29sPixcblx0ICogIG1vcnBoTm9ybWFsczogPGJvb2w+LFxuXHQgKlxuXHQgKlx0Zm9nOiA8Ym9vbD5cblx0ICogfVxuXHQgKi9cblxuXHRUSFJFRS5TaGFkZXJNYXRlcmlhbCA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcblxuXHRcdFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcblxuXHRcdHRoaXMudHlwZSA9ICdTaGFkZXJNYXRlcmlhbCc7XG5cblx0XHR0aGlzLmRlZmluZXMgPSB7fTtcblx0XHR0aGlzLnVuaWZvcm1zID0ge307XG5cblx0XHR0aGlzLnZlcnRleFNoYWRlciA9ICd2b2lkIG1haW4oKSB7XFxuXFx0Z2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1xcbn0nO1xuXHRcdHRoaXMuZnJhZ21lbnRTaGFkZXIgPSAndm9pZCBtYWluKCkge1xcblxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIDEuMCwgMC4wLCAwLjAsIDEuMCApO1xcbn0nO1xuXG5cdFx0dGhpcy5zaGFkaW5nID0gVEhSRUUuU21vb3RoU2hhZGluZztcblxuXHRcdHRoaXMubGluZXdpZHRoID0gMTtcblxuXHRcdHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XG5cdFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xuXG5cdFx0dGhpcy5mb2cgPSBmYWxzZTsgLy8gc2V0IHRvIHVzZSBzY2VuZSBmb2dcblxuXHRcdHRoaXMubGlnaHRzID0gZmFsc2U7IC8vIHNldCB0byB1c2Ugc2NlbmUgbGlnaHRzXG5cblx0XHR0aGlzLnZlcnRleENvbG9ycyA9IFRIUkVFLk5vQ29sb3JzOyAvLyBzZXQgdG8gdXNlIFwiY29sb3JcIiBhdHRyaWJ1dGUgc3RyZWFtXG5cblx0XHR0aGlzLnNraW5uaW5nID0gZmFsc2U7IC8vIHNldCB0byB1c2Ugc2tpbm5pbmcgYXR0cmlidXRlIHN0cmVhbXNcblxuXHRcdHRoaXMubW9ycGhUYXJnZXRzID0gZmFsc2U7IC8vIHNldCB0byB1c2UgbW9ycGggdGFyZ2V0c1xuXHRcdHRoaXMubW9ycGhOb3JtYWxzID0gZmFsc2U7IC8vIHNldCB0byB1c2UgbW9ycGggbm9ybWFsc1xuXG5cdFx0dGhpcy5kZXJpdmF0aXZlcyA9IGZhbHNlOyAvLyBzZXQgdG8gdXNlIGRlcml2YXRpdmVzXG5cblx0XHQvLyBXaGVuIHJlbmRlcmVkIGdlb21ldHJ5IGRvZXNuJ3QgaW5jbHVkZSB0aGVzZSBhdHRyaWJ1dGVzIGJ1dCB0aGUgbWF0ZXJpYWwgZG9lcyxcblx0XHQvLyB1c2UgdGhlc2UgZGVmYXVsdCB2YWx1ZXMgaW4gV2ViR0wuIFRoaXMgYXZvaWRzIGVycm9ycyB3aGVuIGJ1ZmZlciBkYXRhIGlzIG1pc3NpbmcuXG5cdFx0dGhpcy5kZWZhdWx0QXR0cmlidXRlVmFsdWVzID0ge1xuXHRcdFx0J2NvbG9yJzogWyAxLCAxLCAxIF0sXG5cdFx0XHQndXYnOiBbIDAsIDAgXSxcblx0XHRcdCd1djInOiBbIDAsIDAgXVxuXHRcdH07XG5cblx0XHR0aGlzLmluZGV4MEF0dHJpYnV0ZU5hbWUgPSB1bmRlZmluZWQ7XG5cblx0XHRpZiAoIHBhcmFtZXRlcnMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0aWYgKCBwYXJhbWV0ZXJzLmF0dHJpYnV0ZXMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuU2hhZGVyTWF0ZXJpYWw6IGF0dHJpYnV0ZXMgc2hvdWxkIG5vdyBiZSBkZWZpbmVkIGluIFRIUkVFLkJ1ZmZlckdlb21ldHJ5IGluc3RlYWQuJyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cblx0XHR9XG5cblx0fTtcblxuXHRUSFJFRS5TaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcblx0VEhSRUUuU2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuU2hhZGVyTWF0ZXJpYWw7XG5cblx0VEhSRUUuU2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuXHRcdFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5mcmFnbWVudFNoYWRlciA9IHNvdXJjZS5mcmFnbWVudFNoYWRlcjtcblx0XHR0aGlzLnZlcnRleFNoYWRlciA9IHNvdXJjZS52ZXJ0ZXhTaGFkZXI7XG5cblx0XHR0aGlzLnVuaWZvcm1zID0gVEhSRUUuVW5pZm9ybXNVdGlscy5jbG9uZSggc291cmNlLnVuaWZvcm1zICk7XG5cblx0XHR0aGlzLmF0dHJpYnV0ZXMgPSBzb3VyY2UuYXR0cmlidXRlcztcblx0XHR0aGlzLmRlZmluZXMgPSBzb3VyY2UuZGVmaW5lcztcblxuXHRcdHRoaXMuc2hhZGluZyA9IHNvdXJjZS5zaGFkaW5nO1xuXG5cdFx0dGhpcy53aXJlZnJhbWUgPSBzb3VyY2Uud2lyZWZyYW1lO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcblxuXHRcdHRoaXMuZm9nID0gc291cmNlLmZvZztcblxuXHRcdHRoaXMubGlnaHRzID0gc291cmNlLmxpZ2h0cztcblxuXHRcdHRoaXMudmVydGV4Q29sb3JzID0gc291cmNlLnZlcnRleENvbG9ycztcblxuXHRcdHRoaXMuc2tpbm5pbmcgPSBzb3VyY2Uuc2tpbm5pbmc7XG5cblx0XHR0aGlzLm1vcnBoVGFyZ2V0cyA9IHNvdXJjZS5tb3JwaFRhcmdldHM7XG5cdFx0dGhpcy5tb3JwaE5vcm1hbHMgPSBzb3VyY2UubW9ycGhOb3JtYWxzO1xuXG5cdFx0dGhpcy5kZXJpdmF0aXZlcyA9IHNvdXJjZS5kZXJpdmF0aXZlcztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0VEhSRUUuU2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICggbWV0YSApIHtcblxuXHRcdHZhciBkYXRhID0gVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzLCBtZXRhICk7XG5cblx0XHRkYXRhLnVuaWZvcm1zID0gdGhpcy51bmlmb3Jtcztcblx0XHRkYXRhLmF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XG5cdFx0ZGF0YS52ZXJ0ZXhTaGFkZXIgPSB0aGlzLnZlcnRleFNoYWRlcjtcblx0XHRkYXRhLmZyYWdtZW50U2hhZGVyID0gdGhpcy5mcmFnbWVudFNoYWRlcjtcblxuXHRcdHJldHVybiBkYXRhO1xuXG5cdH07XG5cblx0Ly8gRmlsZTpzcmMvbWF0ZXJpYWxzL1Jhd1NoYWRlck1hdGVyaWFsLmpzXG5cblx0LyoqXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqL1xuXG5cdFRIUkVFLlJhd1NoYWRlck1hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xuXG5cdFx0VEhSRUUuU2hhZGVyTWF0ZXJpYWwuY2FsbCggdGhpcywgcGFyYW1ldGVycyApO1xuXG5cdFx0dGhpcy50eXBlID0gJ1Jhd1NoYWRlck1hdGVyaWFsJztcblxuXHR9O1xuXG5cdFRIUkVFLlJhd1NoYWRlck1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLlNoYWRlck1hdGVyaWFsLnByb3RvdHlwZSApO1xuXHRUSFJFRS5SYXdTaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5SYXdTaGFkZXJNYXRlcmlhbDtcblx0Ly8gRmlsZTpzcmMvbWF0ZXJpYWxzL1Nwcml0ZU1hdGVyaWFsLmpzXG5cblx0LyoqXG5cdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG5cdCAqXG5cdCAqIHBhcmFtZXRlcnMgPSB7XG5cdCAqICBjb2xvcjogPGhleD4sXG5cdCAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxuXHQgKiAgbWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuXHQgKlxuXHQgKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxuXHQgKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXG5cdCAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXG5cdCAqXG5cdCAqXHR1dk9mZnNldDogbmV3IFRIUkVFLlZlY3RvcjIoKSxcblx0ICpcdHV2U2NhbGU6IG5ldyBUSFJFRS5WZWN0b3IyKCksXG5cdCAqXG5cdCAqICBmb2c6IDxib29sPlxuXHQgKiB9XG5cdCAqL1xuXG5cdFRIUkVFLlNwcml0ZU1hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xuXG5cdFx0VEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcyApO1xuXG5cdFx0dGhpcy50eXBlID0gJ1Nwcml0ZU1hdGVyaWFsJztcblxuXHRcdHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICk7XG5cdFx0dGhpcy5tYXAgPSBudWxsO1xuXG5cdFx0dGhpcy5yb3RhdGlvbiA9IDA7XG5cblx0XHR0aGlzLmZvZyA9IGZhbHNlO1xuXG5cdFx0Ly8gc2V0IHBhcmFtZXRlcnNcblxuXHRcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cblx0fTtcblxuXHRUSFJFRS5TcHJpdGVNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcblx0VEhSRUUuU3ByaXRlTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuU3ByaXRlTWF0ZXJpYWw7XG5cblx0VEhSRUUuU3ByaXRlTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuXHRcdFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcblx0XHR0aGlzLm1hcCA9IHNvdXJjZS5tYXA7XG5cblx0XHR0aGlzLnJvdGF0aW9uID0gc291cmNlLnJvdGF0aW9uO1xuXG5cdFx0dGhpcy5mb2cgPSBzb3VyY2UuZm9nO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHQvLyBGaWxlOnNyYy90ZXh0dXJlcy9UZXh0dXJlLmpzXG5cblx0LyoqXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG5cdCAqIEBhdXRob3Igc3ppbWVrIC8gaHR0cHM6Ly9naXRodWIuY29tL3N6aW1lay9cblx0ICovXG5cblx0VEhSRUUuVGV4dHVyZSA9IGZ1bmN0aW9uICggaW1hZ2UsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSApIHtcblxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ2lkJywgeyB2YWx1ZTogVEhSRUUuVGV4dHVyZUlkQ291bnQgKysgfSApO1xuXG5cdFx0dGhpcy51dWlkID0gVEhSRUUuTWF0aC5nZW5lcmF0ZVVVSUQoKTtcblxuXHRcdHRoaXMubmFtZSA9ICcnO1xuXHRcdHRoaXMuc291cmNlRmlsZSA9ICcnO1xuXG5cdFx0dGhpcy5pbWFnZSA9IGltYWdlICE9PSB1bmRlZmluZWQgPyBpbWFnZSA6IFRIUkVFLlRleHR1cmUuREVGQVVMVF9JTUFHRTtcblx0XHR0aGlzLm1pcG1hcHMgPSBbXTtcblxuXHRcdHRoaXMubWFwcGluZyA9IG1hcHBpbmcgIT09IHVuZGVmaW5lZCA/IG1hcHBpbmcgOiBUSFJFRS5UZXh0dXJlLkRFRkFVTFRfTUFQUElORztcblxuXHRcdHRoaXMud3JhcFMgPSB3cmFwUyAhPT0gdW5kZWZpbmVkID8gd3JhcFMgOiBUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nO1xuXHRcdHRoaXMud3JhcFQgPSB3cmFwVCAhPT0gdW5kZWZpbmVkID8gd3JhcFQgOiBUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nO1xuXG5cdFx0dGhpcy5tYWdGaWx0ZXIgPSBtYWdGaWx0ZXIgIT09IHVuZGVmaW5lZCA/IG1hZ0ZpbHRlciA6IFRIUkVFLkxpbmVhckZpbHRlcjtcblx0XHR0aGlzLm1pbkZpbHRlciA9IG1pbkZpbHRlciAhPT0gdW5kZWZpbmVkID8gbWluRmlsdGVyIDogVEhSRUUuTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyO1xuXG5cdFx0dGhpcy5hbmlzb3Ryb3B5ID0gYW5pc290cm9weSAhPT0gdW5kZWZpbmVkID8gYW5pc290cm9weSA6IDE7XG5cblx0XHR0aGlzLmZvcm1hdCA9IGZvcm1hdCAhPT0gdW5kZWZpbmVkID8gZm9ybWF0IDogVEhSRUUuUkdCQUZvcm1hdDtcblx0XHR0aGlzLnR5cGUgPSB0eXBlICE9PSB1bmRlZmluZWQgPyB0eXBlIDogVEhSRUUuVW5zaWduZWRCeXRlVHlwZTtcblxuXHRcdHRoaXMub2Zmc2V0ID0gbmV3IFRIUkVFLlZlY3RvcjIoIDAsIDAgKTtcblx0XHR0aGlzLnJlcGVhdCA9IG5ldyBUSFJFRS5WZWN0b3IyKCAxLCAxICk7XG5cblx0XHR0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IHRydWU7XG5cdFx0dGhpcy5wcmVtdWx0aXBseUFscGhhID0gZmFsc2U7XG5cdFx0dGhpcy5mbGlwWSA9IHRydWU7XG5cdFx0dGhpcy51bnBhY2tBbGlnbm1lbnQgPSA0OyAvLyB2YWxpZCB2YWx1ZXM6IDEsIDIsIDQsIDggKHNlZSBodHRwOi8vd3d3Lmtocm9ub3Mub3JnL29wZW5nbGVzL3Nkay9kb2NzL21hbi94aHRtbC9nbFBpeGVsU3RvcmVpLnhtbClcblxuXHRcdHRoaXMudmVyc2lvbiA9IDA7XG5cdFx0dGhpcy5vblVwZGF0ZSA9IG51bGw7XG5cblx0fTtcblxuXHRUSFJFRS5UZXh0dXJlLkRFRkFVTFRfSU1BR0UgPSB1bmRlZmluZWQ7XG5cdFRIUkVFLlRleHR1cmUuREVGQVVMVF9NQVBQSU5HID0gVEhSRUUuVVZNYXBwaW5nO1xuXG5cdFRIUkVFLlRleHR1cmUucHJvdG90eXBlID0ge1xuXG5cdFx0Y29uc3RydWN0b3I6IFRIUkVFLlRleHR1cmUsXG5cblx0XHRzZXQgbmVlZHNVcGRhdGUgKCB2YWx1ZSApIHtcblxuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gdHJ1ZSApIHRoaXMudmVyc2lvbiArKztcblxuXHRcdH0sXG5cblx0XHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cblx0XHR9LFxuXG5cdFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cblx0XHRcdHRoaXMuaW1hZ2UgPSBzb3VyY2UuaW1hZ2U7XG5cdFx0XHR0aGlzLm1pcG1hcHMgPSBzb3VyY2UubWlwbWFwcy5zbGljZSggMCApO1xuXG5cdFx0XHR0aGlzLm1hcHBpbmcgPSBzb3VyY2UubWFwcGluZztcblxuXHRcdFx0dGhpcy53cmFwUyA9IHNvdXJjZS53cmFwUztcblx0XHRcdHRoaXMud3JhcFQgPSBzb3VyY2Uud3JhcFQ7XG5cblx0XHRcdHRoaXMubWFnRmlsdGVyID0gc291cmNlLm1hZ0ZpbHRlcjtcblx0XHRcdHRoaXMubWluRmlsdGVyID0gc291cmNlLm1pbkZpbHRlcjtcblxuXHRcdFx0dGhpcy5hbmlzb3Ryb3B5ID0gc291cmNlLmFuaXNvdHJvcHk7XG5cblx0XHRcdHRoaXMuZm9ybWF0ID0gc291cmNlLmZvcm1hdDtcblx0XHRcdHRoaXMudHlwZSA9IHNvdXJjZS50eXBlO1xuXG5cdFx0XHR0aGlzLm9mZnNldC5jb3B5KCBzb3VyY2Uub2Zmc2V0ICk7XG5cdFx0XHR0aGlzLnJlcGVhdC5jb3B5KCBzb3VyY2UucmVwZWF0ICk7XG5cblx0XHRcdHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gc291cmNlLmdlbmVyYXRlTWlwbWFwcztcblx0XHRcdHRoaXMucHJlbXVsdGlwbHlBbHBoYSA9IHNvdXJjZS5wcmVtdWx0aXBseUFscGhhO1xuXHRcdFx0dGhpcy5mbGlwWSA9IHNvdXJjZS5mbGlwWTtcblx0XHRcdHRoaXMudW5wYWNrQWxpZ25tZW50ID0gc291cmNlLnVucGFja0FsaWdubWVudDtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0dG9KU09OOiBmdW5jdGlvbiAoIG1ldGEgKSB7XG5cblx0XHRcdGlmICggbWV0YS50ZXh0dXJlc1sgdGhpcy51dWlkIF0gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRyZXR1cm4gbWV0YS50ZXh0dXJlc1sgdGhpcy51dWlkIF07XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gZ2V0RGF0YVVSTCggaW1hZ2UgKSB7XG5cblx0XHRcdFx0dmFyIGNhbnZhcztcblxuXHRcdFx0XHRpZiAoIGltYWdlLnRvRGF0YVVSTCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0Y2FudmFzID0gaW1hZ2U7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdjYW52YXMnICk7XG5cdFx0XHRcdFx0Y2FudmFzLndpZHRoID0gaW1hZ2Uud2lkdGg7XG5cdFx0XHRcdFx0Y2FudmFzLmhlaWdodCA9IGltYWdlLmhlaWdodDtcblxuXHRcdFx0XHRcdGNhbnZhcy5nZXRDb250ZXh0KCAnMmQnICkuZHJhd0ltYWdlKCBpbWFnZSwgMCwgMCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGNhbnZhcy53aWR0aCA+IDIwNDggfHwgY2FudmFzLmhlaWdodCA+IDIwNDggKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gY2FudmFzLnRvRGF0YVVSTCggJ2ltYWdlL2pwZWcnLCAwLjYgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0cmV0dXJuIGNhbnZhcy50b0RhdGFVUkwoICdpbWFnZS9wbmcnICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBvdXRwdXQgPSB7XG5cdFx0XHRcdG1ldGFkYXRhOiB7XG5cdFx0XHRcdFx0dmVyc2lvbjogNC40LFxuXHRcdFx0XHRcdHR5cGU6ICdUZXh0dXJlJyxcblx0XHRcdFx0XHRnZW5lcmF0b3I6ICdUZXh0dXJlLnRvSlNPTidcblx0XHRcdFx0fSxcblxuXHRcdFx0XHR1dWlkOiB0aGlzLnV1aWQsXG5cdFx0XHRcdG5hbWU6IHRoaXMubmFtZSxcblxuXHRcdFx0XHRtYXBwaW5nOiB0aGlzLm1hcHBpbmcsXG5cblx0XHRcdFx0cmVwZWF0OiBbIHRoaXMucmVwZWF0LngsIHRoaXMucmVwZWF0LnkgXSxcblx0XHRcdFx0b2Zmc2V0OiBbIHRoaXMub2Zmc2V0LngsIHRoaXMub2Zmc2V0LnkgXSxcblx0XHRcdFx0d3JhcDogWyB0aGlzLndyYXBTLCB0aGlzLndyYXBUIF0sXG5cblx0XHRcdFx0bWluRmlsdGVyOiB0aGlzLm1pbkZpbHRlcixcblx0XHRcdFx0bWFnRmlsdGVyOiB0aGlzLm1hZ0ZpbHRlcixcblx0XHRcdFx0YW5pc290cm9weTogdGhpcy5hbmlzb3Ryb3B5XG5cdFx0XHR9O1xuXG5cdFx0XHRpZiAoIHRoaXMuaW1hZ2UgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHQvLyBUT0RPOiBNb3ZlIHRvIFRIUkVFLkltYWdlXG5cblx0XHRcdFx0dmFyIGltYWdlID0gdGhpcy5pbWFnZTtcblxuXHRcdFx0XHRpZiAoIGltYWdlLnV1aWQgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGltYWdlLnV1aWQgPSBUSFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpOyAvLyBVR0hcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBtZXRhLmltYWdlc1sgaW1hZ2UudXVpZCBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRtZXRhLmltYWdlc1sgaW1hZ2UudXVpZCBdID0ge1xuXHRcdFx0XHRcdFx0dXVpZDogaW1hZ2UudXVpZCxcblx0XHRcdFx0XHRcdHVybDogZ2V0RGF0YVVSTCggaW1hZ2UgKVxuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdG91dHB1dC5pbWFnZSA9IGltYWdlLnV1aWQ7XG5cblx0XHRcdH1cblxuXHRcdFx0bWV0YS50ZXh0dXJlc1sgdGhpcy51dWlkIF0gPSBvdXRwdXQ7XG5cblx0XHRcdHJldHVybiBvdXRwdXQ7XG5cblx0XHR9LFxuXG5cdFx0ZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc3Bvc2UnIH0gKTtcblxuXHRcdH0sXG5cblx0XHR0cmFuc2Zvcm1VdjogZnVuY3Rpb24gKCB1diApIHtcblxuXHRcdFx0aWYgKCB0aGlzLm1hcHBpbmcgIT09IFRIUkVFLlVWTWFwcGluZyApICByZXR1cm47XG5cblx0XHRcdHV2Lm11bHRpcGx5KCB0aGlzLnJlcGVhdCApO1xuXHRcdFx0dXYuYWRkKCB0aGlzLm9mZnNldCApO1xuXG5cdFx0XHRpZiAoIHV2LnggPCAwIHx8IHV2LnggPiAxICkge1xuXG5cdFx0XHRcdHN3aXRjaCAoIHRoaXMud3JhcFMgKSB7XG5cblx0XHRcdFx0XHRjYXNlIFRIUkVFLlJlcGVhdFdyYXBwaW5nOlxuXG5cdFx0XHRcdFx0XHR1di54ID0gdXYueCAtIE1hdGguZmxvb3IoIHV2LnggKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSBUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nOlxuXG5cdFx0XHRcdFx0XHR1di54ID0gdXYueCA8IDAgPyAwIDogMTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSBUSFJFRS5NaXJyb3JlZFJlcGVhdFdyYXBwaW5nOlxuXG5cdFx0XHRcdFx0XHRpZiAoIE1hdGguYWJzKCBNYXRoLmZsb29yKCB1di54ICkgJSAyICkgPT09IDEgKSB7XG5cblx0XHRcdFx0XHRcdFx0dXYueCA9IE1hdGguY2VpbCggdXYueCApIC0gdXYueDtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHR1di54ID0gdXYueCAtIE1hdGguZmxvb3IoIHV2LnggKTtcblxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggdXYueSA8IDAgfHwgdXYueSA+IDEgKSB7XG5cblx0XHRcdFx0c3dpdGNoICggdGhpcy53cmFwVCApIHtcblxuXHRcdFx0XHRcdGNhc2UgVEhSRUUuUmVwZWF0V3JhcHBpbmc6XG5cblx0XHRcdFx0XHRcdHV2LnkgPSB1di55IC0gTWF0aC5mbG9vciggdXYueSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlIFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmc6XG5cblx0XHRcdFx0XHRcdHV2LnkgPSB1di55IDwgMCA/IDAgOiAxO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlIFRIUkVFLk1pcnJvcmVkUmVwZWF0V3JhcHBpbmc6XG5cblx0XHRcdFx0XHRcdGlmICggTWF0aC5hYnMoIE1hdGguZmxvb3IoIHV2LnkgKSAlIDIgKSA9PT0gMSApIHtcblxuXHRcdFx0XHRcdFx0XHR1di55ID0gTWF0aC5jZWlsKCB1di55ICkgLSB1di55O1xuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdHV2LnkgPSB1di55IC0gTWF0aC5mbG9vciggdXYueSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0aGlzLmZsaXBZICkge1xuXG5cdFx0XHRcdHV2LnkgPSAxIC0gdXYueTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH07XG5cblx0VEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5hcHBseSggVEhSRUUuVGV4dHVyZS5wcm90b3R5cGUgKTtcblxuXHRUSFJFRS5UZXh0dXJlSWRDb3VudCA9IDA7XG5cblx0Ly8gRmlsZTpzcmMvdGV4dHVyZXMvQ2FudmFzVGV4dHVyZS5qc1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuXHQgKi9cblxuXHRUSFJFRS5DYW52YXNUZXh0dXJlID0gZnVuY3Rpb24gKCBjYW52YXMsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSApIHtcblxuXHRcdFRIUkVFLlRleHR1cmUuY2FsbCggdGhpcywgY2FudmFzLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkgKTtcblxuXHRcdHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdH07XG5cblx0VEhSRUUuQ2FudmFzVGV4dHVyZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5UZXh0dXJlLnByb3RvdHlwZSApO1xuXHRUSFJFRS5DYW52YXNUZXh0dXJlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkNhbnZhc1RleHR1cmU7XG5cblx0Ly8gRmlsZTpzcmMvdGV4dHVyZXMvQ3ViZVRleHR1cmUuanNcblxuXHQvKipcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICovXG5cblx0VEhSRUUuQ3ViZVRleHR1cmUgPSBmdW5jdGlvbiAoIGltYWdlcywgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICkge1xuXG5cdFx0bWFwcGluZyA9IG1hcHBpbmcgIT09IHVuZGVmaW5lZCA/IG1hcHBpbmcgOiBUSFJFRS5DdWJlUmVmbGVjdGlvbk1hcHBpbmc7XG5cblx0XHRUSFJFRS5UZXh0dXJlLmNhbGwoIHRoaXMsIGltYWdlcywgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICk7XG5cblx0XHR0aGlzLmltYWdlcyA9IGltYWdlcztcblx0XHR0aGlzLmZsaXBZID0gZmFsc2U7XG5cblx0fTtcblxuXHRUSFJFRS5DdWJlVGV4dHVyZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5UZXh0dXJlLnByb3RvdHlwZSApO1xuXHRUSFJFRS5DdWJlVGV4dHVyZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5DdWJlVGV4dHVyZTtcblxuXHRUSFJFRS5DdWJlVGV4dHVyZS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xuXG5cdFx0VEhSRUUuVGV4dHVyZS5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblx0XHRcblx0XHR0aGlzLmltYWdlcyA9IHNvdXJjZS5pbWFnZXM7XG5cdFx0XG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblx0Ly8gRmlsZTpzcmMvdGV4dHVyZXMvQ29tcHJlc3NlZFRleHR1cmUuanNcblxuXHQvKipcblx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cblx0ICovXG5cblx0VEhSRUUuQ29tcHJlc3NlZFRleHR1cmUgPSBmdW5jdGlvbiAoIG1pcG1hcHMsIHdpZHRoLCBoZWlnaHQsIGZvcm1hdCwgdHlwZSwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgYW5pc290cm9weSApIHtcblxuXHRcdFRIUkVFLlRleHR1cmUuY2FsbCggdGhpcywgbnVsbCwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICk7XG5cblx0XHR0aGlzLmltYWdlID0geyB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH07XG5cdFx0dGhpcy5taXBtYXBzID0gbWlwbWFwcztcblxuXHRcdC8vIG5vIGZsaXBwaW5nIGZvciBjdWJlIHRleHR1cmVzXG5cdFx0Ly8gKGFsc28gZmxpcHBpbmcgZG9lc24ndCB3b3JrIGZvciBjb21wcmVzc2VkIHRleHR1cmVzIClcblxuXHRcdHRoaXMuZmxpcFkgPSBmYWxzZTtcblxuXHRcdC8vIGNhbid0IGdlbmVyYXRlIG1pcG1hcHMgZm9yIGNvbXByZXNzZWQgdGV4dHVyZXNcblx0XHQvLyBtaXBzIG11c3QgYmUgZW1iZWRkZWQgaW4gRERTIGZpbGVzXG5cblx0XHR0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuXG5cdH07XG5cblx0VEhSRUUuQ29tcHJlc3NlZFRleHR1cmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuVGV4dHVyZS5wcm90b3R5cGUgKTtcblx0VEhSRUUuQ29tcHJlc3NlZFRleHR1cmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQ29tcHJlc3NlZFRleHR1cmU7XG5cblx0Ly8gRmlsZTpzcmMvdGV4dHVyZXMvRGF0YVRleHR1cmUuanNcblxuXHQvKipcblx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cblx0ICovXG5cblx0VEhSRUUuRGF0YVRleHR1cmUgPSBmdW5jdGlvbiAoIGRhdGEsIHdpZHRoLCBoZWlnaHQsIGZvcm1hdCwgdHlwZSwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgYW5pc290cm9weSApIHtcblxuXHRcdFRIUkVFLlRleHR1cmUuY2FsbCggdGhpcywgbnVsbCwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICk7XG5cblx0XHR0aGlzLmltYWdlID0geyBkYXRhOiBkYXRhLCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH07XG5cblx0XHR0aGlzLm1hZ0ZpbHRlciA9IG1hZ0ZpbHRlciAhPT0gdW5kZWZpbmVkID8gbWFnRmlsdGVyIDogVEhSRUUuTmVhcmVzdEZpbHRlcjtcblx0XHR0aGlzLm1pbkZpbHRlciA9IG1pbkZpbHRlciAhPT0gdW5kZWZpbmVkID8gbWluRmlsdGVyIDogVEhSRUUuTmVhcmVzdEZpbHRlcjtcblx0XHRcblx0XHR0aGlzLmZsaXBZID0gZmFsc2U7XG5cdFx0dGhpcy5nZW5lcmF0ZU1pcG1hcHMgID0gZmFsc2U7XG5cblx0fTtcblxuXHRUSFJFRS5EYXRhVGV4dHVyZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5UZXh0dXJlLnByb3RvdHlwZSApO1xuXHRUSFJFRS5EYXRhVGV4dHVyZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5EYXRhVGV4dHVyZTtcblxuXHQvLyBGaWxlOnNyYy90ZXh0dXJlcy9WaWRlb1RleHR1cmUuanNcblxuXHQvKipcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICovXG5cblx0VEhSRUUuVmlkZW9UZXh0dXJlID0gZnVuY3Rpb24gKCB2aWRlbywgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICkge1xuXG5cdFx0VEhSRUUuVGV4dHVyZS5jYWxsKCB0aGlzLCB2aWRlbywgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICk7XG5cblx0XHR0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuXG5cdFx0dmFyIHNjb3BlID0gdGhpcztcblxuXHRcdGZ1bmN0aW9uIHVwZGF0ZSgpIHtcblxuXHRcdFx0cmVxdWVzdEFuaW1hdGlvbkZyYW1lKCB1cGRhdGUgKTtcblxuXHRcdFx0aWYgKCB2aWRlby5yZWFkeVN0YXRlID09PSB2aWRlby5IQVZFX0VOT1VHSF9EQVRBICkge1xuXG5cdFx0XHRcdHNjb3BlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0dXBkYXRlKCk7XG5cblx0fTtcblxuXHRUSFJFRS5WaWRlb1RleHR1cmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuVGV4dHVyZS5wcm90b3R5cGUgKTtcblx0VEhSRUUuVmlkZW9UZXh0dXJlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlZpZGVvVGV4dHVyZTtcblxuXHQvLyBGaWxlOnNyYy9vYmplY3RzL0dyb3VwLmpzXG5cblx0LyoqXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqL1xuXG5cdFRIUkVFLkdyb3VwID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0VEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG5cdFx0dGhpcy50eXBlID0gJ0dyb3VwJztcblxuXHR9O1xuXG5cdFRIUkVFLkdyb3VwLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xuXHRUSFJFRS5Hcm91cC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Hcm91cDtcblx0Ly8gRmlsZTpzcmMvb2JqZWN0cy9Qb2ludHMuanNcblxuXHQvKipcblx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cblx0ICovXG5cblx0VEhSRUUuUG9pbnRzID0gZnVuY3Rpb24gKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKSB7XG5cblx0XHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cblx0XHR0aGlzLnR5cGUgPSAnUG9pbnRzJztcblxuXHRcdHRoaXMuZ2VvbWV0cnkgPSBnZW9tZXRyeSAhPT0gdW5kZWZpbmVkID8gZ2VvbWV0cnkgOiBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcblx0XHR0aGlzLm1hdGVyaWFsID0gbWF0ZXJpYWwgIT09IHVuZGVmaW5lZCA/IG1hdGVyaWFsIDogbmV3IFRIUkVFLlBvaW50c01hdGVyaWFsKCB7IGNvbG9yOiBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmYgfSApO1xuXG5cdH07XG5cblx0VEhSRUUuUG9pbnRzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xuXHRUSFJFRS5Qb2ludHMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuUG9pbnRzO1xuXG5cdFRIUkVFLlBvaW50cy5wcm90b3R5cGUucmF5Y2FzdCA9ICggZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIGludmVyc2VNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXHRcdHZhciByYXkgPSBuZXcgVEhSRUUuUmF5KCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gcmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICkge1xuXG5cdFx0XHR2YXIgb2JqZWN0ID0gdGhpcztcblx0XHRcdHZhciBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcblx0XHRcdHZhciB0aHJlc2hvbGQgPSByYXljYXN0ZXIucGFyYW1zLlBvaW50cy50aHJlc2hvbGQ7XG5cblx0XHRcdGludmVyc2VNYXRyaXguZ2V0SW52ZXJzZSggdGhpcy5tYXRyaXhXb3JsZCApO1xuXHRcdFx0cmF5LmNvcHkoIHJheWNhc3Rlci5yYXkgKS5hcHBseU1hdHJpeDQoIGludmVyc2VNYXRyaXggKTtcblxuXHRcdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRpZiAoIHJheS5pc0ludGVyc2VjdGlvbkJveCggZ2VvbWV0cnkuYm91bmRpbmdCb3ggKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBsb2NhbFRocmVzaG9sZCA9IHRocmVzaG9sZCAvICggKCB0aGlzLnNjYWxlLnggKyB0aGlzLnNjYWxlLnkgKyB0aGlzLnNjYWxlLnogKSAvIDMgKTtcblx0XHRcdHZhciBsb2NhbFRocmVzaG9sZFNxID0gbG9jYWxUaHJlc2hvbGQgKiBsb2NhbFRocmVzaG9sZDtcblx0XHRcdHZhciBwb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRcdGZ1bmN0aW9uIHRlc3RQb2ludCggcG9pbnQsIGluZGV4ICkge1xuXG5cdFx0XHRcdHZhciByYXlQb2ludERpc3RhbmNlU3EgPSByYXkuZGlzdGFuY2VTcVRvUG9pbnQoIHBvaW50ICk7XG5cblx0XHRcdFx0aWYgKCByYXlQb2ludERpc3RhbmNlU3EgPCBsb2NhbFRocmVzaG9sZFNxICkge1xuXG5cdFx0XHRcdFx0dmFyIGludGVyc2VjdFBvaW50ID0gcmF5LmNsb3Nlc3RQb2ludFRvUG9pbnQoIHBvaW50ICk7XG5cdFx0XHRcdFx0aW50ZXJzZWN0UG9pbnQuYXBwbHlNYXRyaXg0KCBvYmplY3QubWF0cml4V29ybGQgKTtcblxuXHRcdFx0XHRcdHZhciBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkub3JpZ2luLmRpc3RhbmNlVG8oIGludGVyc2VjdFBvaW50ICk7XG5cblx0XHRcdFx0XHRpZiAoIGRpc3RhbmNlIDwgcmF5Y2FzdGVyLm5lYXIgfHwgZGlzdGFuY2UgPiByYXljYXN0ZXIuZmFyICkgcmV0dXJuO1xuXG5cdFx0XHRcdFx0aW50ZXJzZWN0cy5wdXNoKCB7XG5cblx0XHRcdFx0XHRcdGRpc3RhbmNlOiBkaXN0YW5jZSxcblx0XHRcdFx0XHRcdGRpc3RhbmNlVG9SYXk6IE1hdGguc3FydCggcmF5UG9pbnREaXN0YW5jZVNxICksXG5cdFx0XHRcdFx0XHRwb2ludDogaW50ZXJzZWN0UG9pbnQuY2xvbmUoKSxcblx0XHRcdFx0XHRcdGluZGV4OiBpbmRleCxcblx0XHRcdFx0XHRcdGZhY2U6IG51bGwsXG5cdFx0XHRcdFx0XHRvYmplY3Q6IG9iamVjdFxuXG5cdFx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkgKSB7XG5cblx0XHRcdFx0dmFyIGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XG5cdFx0XHRcdHZhciBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcblx0XHRcdFx0dmFyIHBvc2l0aW9ucyA9IGF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XG5cblx0XHRcdFx0aWYgKCBpbmRleCAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdHZhciBpbmRpY2VzID0gaW5kZXguYXJyYXk7XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gaW5kaWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0dmFyIGEgPSBpbmRpY2VzWyBpIF07XG5cblx0XHRcdFx0XHRcdHBvc2l0aW9uLmZyb21BcnJheSggcG9zaXRpb25zLCBhICogMyApO1xuXG5cdFx0XHRcdFx0XHR0ZXN0UG9pbnQoIHBvc2l0aW9uLCBhICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHBvc2l0aW9ucy5sZW5ndGggLyAzOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0cG9zaXRpb24uZnJvbUFycmF5KCBwb3NpdGlvbnMsIGkgKiAzICk7XG5cblx0XHRcdFx0XHRcdHRlc3RQb2ludCggcG9zaXRpb24sIGkgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXM7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdmVydGljZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHRlc3RQb2ludCggdmVydGljZXNbIGkgXSwgaSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fTtcblxuXHR9KCkgKTtcblxuXHRUSFJFRS5Qb2ludHMucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLmdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsICkuY29weSggdGhpcyApO1xuXG5cdH07XG5cblx0Ly8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblxuXHRUSFJFRS5Qb2ludENsb3VkID0gZnVuY3Rpb24gKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Qb2ludENsb3VkIGhhcyBiZWVuIHJlbmFtZWQgdG8gVEhSRUUuUG9pbnRzLicgKTtcblx0XHRyZXR1cm4gbmV3IFRIUkVFLlBvaW50cyggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cblx0fTtcblxuXHRUSFJFRS5QYXJ0aWNsZVN5c3RlbSA9IGZ1bmN0aW9uICggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUGFydGljbGVTeXN0ZW0gaGFzIGJlZW4gcmVuYW1lZCB0byBUSFJFRS5Qb2ludHMuJyApO1xuXHRcdHJldHVybiBuZXcgVEhSRUUuUG9pbnRzKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxuXHR9O1xuXG5cdC8vIEZpbGU6c3JjL29iamVjdHMvTGluZS5qc1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuXHQgKi9cblxuXHRUSFJFRS5MaW5lID0gZnVuY3Rpb24gKCBnZW9tZXRyeSwgbWF0ZXJpYWwsIG1vZGUgKSB7XG5cblx0XHRpZiAoIG1vZGUgPT09IDEgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkxpbmU6IHBhcmFtZXRlciBUSFJFRS5MaW5lUGllY2VzIG5vIGxvbmdlciBzdXBwb3J0ZWQuIENyZWF0ZWQgVEhSRUUuTGluZVNlZ21lbnRzIGluc3RlYWQuJyApO1xuXHRcdFx0cmV0dXJuIG5ldyBUSFJFRS5MaW5lU2VnbWVudHMoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG5cdFx0fVxuXG5cdFx0VEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG5cdFx0dGhpcy50eXBlID0gJ0xpbmUnO1xuXG5cdFx0dGhpcy5nZW9tZXRyeSA9IGdlb21ldHJ5ICE9PSB1bmRlZmluZWQgPyBnZW9tZXRyeSA6IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuXHRcdHRoaXMubWF0ZXJpYWwgPSBtYXRlcmlhbCAhPT0gdW5kZWZpbmVkID8gbWF0ZXJpYWwgOiBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZiB9ICk7XG5cblx0fTtcblxuXHRUSFJFRS5MaW5lLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xuXHRUSFJFRS5MaW5lLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkxpbmU7XG5cblx0VEhSRUUuTGluZS5wcm90b3R5cGUucmF5Y2FzdCA9ICggZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIGludmVyc2VNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXHRcdHZhciByYXkgPSBuZXcgVEhSRUUuUmF5KCk7XG5cdFx0dmFyIHNwaGVyZSA9IG5ldyBUSFJFRS5TcGhlcmUoKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiByYXljYXN0KCByYXljYXN0ZXIsIGludGVyc2VjdHMgKSB7XG5cblx0XHRcdHZhciBwcmVjaXNpb24gPSByYXljYXN0ZXIubGluZVByZWNpc2lvbjtcblx0XHRcdHZhciBwcmVjaXNpb25TcSA9IHByZWNpc2lvbiAqIHByZWNpc2lvbjtcblxuXHRcdFx0dmFyIGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblxuXHRcdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXG5cdFx0XHQvLyBDaGVja2luZyBib3VuZGluZ1NwaGVyZSBkaXN0YW5jZSB0byByYXlcblxuXHRcdFx0c3BoZXJlLmNvcHkoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICk7XG5cdFx0XHRzcGhlcmUuYXBwbHlNYXRyaXg0KCB0aGlzLm1hdHJpeFdvcmxkICk7XG5cblx0XHRcdGlmICggcmF5Y2FzdGVyLnJheS5pc0ludGVyc2VjdGlvblNwaGVyZSggc3BoZXJlICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0fVxuXG5cdFx0XHRpbnZlcnNlTWF0cml4LmdldEludmVyc2UoIHRoaXMubWF0cml4V29ybGQgKTtcblx0XHRcdHJheS5jb3B5KCByYXljYXN0ZXIucmF5ICkuYXBwbHlNYXRyaXg0KCBpbnZlcnNlTWF0cml4ICk7XG5cblx0XHRcdHZhciB2U3RhcnQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdFx0dmFyIHZFbmQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdFx0dmFyIGludGVyU2VnbWVudCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0XHR2YXIgaW50ZXJSYXkgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdFx0dmFyIHN0ZXAgPSB0aGlzIGluc3RhbmNlb2YgVEhSRUUuTGluZVNlZ21lbnRzID8gMiA6IDE7XG5cblx0XHRcdGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSApIHtcblxuXHRcdFx0XHR2YXIgaW5kZXggPSBnZW9tZXRyeS5pbmRleDtcblx0XHRcdFx0dmFyIGF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xuXG5cdFx0XHRcdGlmICggaW5kZXggIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHR2YXIgaW5kaWNlcyA9IGluZGV4LmFycmF5O1xuXHRcdFx0XHRcdHZhciBwb3NpdGlvbnMgPSBhdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gaW5kaWNlcy5sZW5ndGggLSAxOyBpIDwgbDsgaSArPSBzdGVwICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgYSA9IGluZGljZXNbIGkgXTtcblx0XHRcdFx0XHRcdHZhciBiID0gaW5kaWNlc1sgaSArIDEgXTtcblxuXHRcdFx0XHRcdFx0dlN0YXJ0LmZyb21BcnJheSggcG9zaXRpb25zLCBhICogMyApO1xuXHRcdFx0XHRcdFx0dkVuZC5mcm9tQXJyYXkoIHBvc2l0aW9ucywgYiAqIDMgKTtcblxuXHRcdFx0XHRcdFx0dmFyIGRpc3RTcSA9IHJheS5kaXN0YW5jZVNxVG9TZWdtZW50KCB2U3RhcnQsIHZFbmQsIGludGVyUmF5LCBpbnRlclNlZ21lbnQgKTtcblxuXHRcdFx0XHRcdFx0aWYgKCBkaXN0U3EgPiBwcmVjaXNpb25TcSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdFx0XHRpbnRlclJheS5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4V29ybGQgKTsgLy9Nb3ZlIGJhY2sgdG8gd29ybGQgc3BhY2UgZm9yIGRpc3RhbmNlIGNhbGN1bGF0aW9uXG5cblx0XHRcdFx0XHRcdHZhciBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkub3JpZ2luLmRpc3RhbmNlVG8oIGludGVyUmF5ICk7XG5cblx0XHRcdFx0XHRcdGlmICggZGlzdGFuY2UgPCByYXljYXN0ZXIubmVhciB8fCBkaXN0YW5jZSA+IHJheWNhc3Rlci5mYXIgKSBjb250aW51ZTtcblxuXHRcdFx0XHRcdFx0aW50ZXJzZWN0cy5wdXNoKCB7XG5cblx0XHRcdFx0XHRcdFx0ZGlzdGFuY2U6IGRpc3RhbmNlLFxuXHRcdFx0XHRcdFx0XHQvLyBXaGF0IGRvIHdlIHdhbnQ/IGludGVyc2VjdGlvbiBwb2ludCBvbiB0aGUgcmF5IG9yIG9uIHRoZSBzZWdtZW50Pz9cblx0XHRcdFx0XHRcdFx0Ly8gcG9pbnQ6IHJheWNhc3Rlci5yYXkuYXQoIGRpc3RhbmNlICksXG5cdFx0XHRcdFx0XHRcdHBvaW50OiBpbnRlclNlZ21lbnQuY2xvbmUoKS5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4V29ybGQgKSxcblx0XHRcdFx0XHRcdFx0aW5kZXg6IGksXG5cdFx0XHRcdFx0XHRcdGZhY2U6IG51bGwsXG5cdFx0XHRcdFx0XHRcdGZhY2VJbmRleDogbnVsbCxcblx0XHRcdFx0XHRcdFx0b2JqZWN0OiB0aGlzXG5cblx0XHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dmFyIHBvc2l0aW9ucyA9IGF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBwb3NpdGlvbnMubGVuZ3RoIC8gMyAtIDE7IGkgPCBsOyBpICs9IHN0ZXAgKSB7XG5cblx0XHRcdFx0XHRcdHZTdGFydC5mcm9tQXJyYXkoIHBvc2l0aW9ucywgMyAqIGkgKTtcblx0XHRcdFx0XHRcdHZFbmQuZnJvbUFycmF5KCBwb3NpdGlvbnMsIDMgKiBpICsgMyApO1xuXG5cdFx0XHRcdFx0XHR2YXIgZGlzdFNxID0gcmF5LmRpc3RhbmNlU3FUb1NlZ21lbnQoIHZTdGFydCwgdkVuZCwgaW50ZXJSYXksIGludGVyU2VnbWVudCApO1xuXG5cdFx0XHRcdFx0XHRpZiAoIGRpc3RTcSA+IHByZWNpc2lvblNxICkgY29udGludWU7XG5cblx0XHRcdFx0XHRcdGludGVyUmF5LmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApOyAvL01vdmUgYmFjayB0byB3b3JsZCBzcGFjZSBmb3IgZGlzdGFuY2UgY2FsY3VsYXRpb25cblxuXHRcdFx0XHRcdFx0dmFyIGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyggaW50ZXJSYXkgKTtcblxuXHRcdFx0XHRcdFx0aWYgKCBkaXN0YW5jZSA8IHJheWNhc3Rlci5uZWFyIHx8IGRpc3RhbmNlID4gcmF5Y2FzdGVyLmZhciApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdFx0XHRpbnRlcnNlY3RzLnB1c2goIHtcblxuXHRcdFx0XHRcdFx0XHRkaXN0YW5jZTogZGlzdGFuY2UsXG5cdFx0XHRcdFx0XHRcdC8vIFdoYXQgZG8gd2Ugd2FudD8gaW50ZXJzZWN0aW9uIHBvaW50IG9uIHRoZSByYXkgb3Igb24gdGhlIHNlZ21lbnQ/P1xuXHRcdFx0XHRcdFx0XHQvLyBwb2ludDogcmF5Y2FzdGVyLnJheS5hdCggZGlzdGFuY2UgKSxcblx0XHRcdFx0XHRcdFx0cG9pbnQ6IGludGVyU2VnbWVudC5jbG9uZSgpLmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApLFxuXHRcdFx0XHRcdFx0XHRpbmRleDogaSxcblx0XHRcdFx0XHRcdFx0ZmFjZTogbnVsbCxcblx0XHRcdFx0XHRcdFx0ZmFjZUluZGV4OiBudWxsLFxuXHRcdFx0XHRcdFx0XHRvYmplY3Q6IHRoaXNcblxuXHRcdFx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5HZW9tZXRyeSApIHtcblxuXHRcdFx0XHR2YXIgdmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcblx0XHRcdFx0dmFyIG5iVmVydGljZXMgPSB2ZXJ0aWNlcy5sZW5ndGg7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbmJWZXJ0aWNlcyAtIDE7IGkgKz0gc3RlcCApIHtcblxuXHRcdFx0XHRcdHZhciBkaXN0U3EgPSByYXkuZGlzdGFuY2VTcVRvU2VnbWVudCggdmVydGljZXNbIGkgXSwgdmVydGljZXNbIGkgKyAxIF0sIGludGVyUmF5LCBpbnRlclNlZ21lbnQgKTtcblxuXHRcdFx0XHRcdGlmICggZGlzdFNxID4gcHJlY2lzaW9uU3EgKSBjb250aW51ZTtcblxuXHRcdFx0XHRcdGludGVyUmF5LmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApOyAvL01vdmUgYmFjayB0byB3b3JsZCBzcGFjZSBmb3IgZGlzdGFuY2UgY2FsY3VsYXRpb25cblxuXHRcdFx0XHRcdHZhciBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkub3JpZ2luLmRpc3RhbmNlVG8oIGludGVyUmF5ICk7XG5cblx0XHRcdFx0XHRpZiAoIGRpc3RhbmNlIDwgcmF5Y2FzdGVyLm5lYXIgfHwgZGlzdGFuY2UgPiByYXljYXN0ZXIuZmFyICkgY29udGludWU7XG5cblx0XHRcdFx0XHRpbnRlcnNlY3RzLnB1c2goIHtcblxuXHRcdFx0XHRcdFx0ZGlzdGFuY2U6IGRpc3RhbmNlLFxuXHRcdFx0XHRcdFx0Ly8gV2hhdCBkbyB3ZSB3YW50PyBpbnRlcnNlY3Rpb24gcG9pbnQgb24gdGhlIHJheSBvciBvbiB0aGUgc2VnbWVudD8/XG5cdFx0XHRcdFx0XHQvLyBwb2ludDogcmF5Y2FzdGVyLnJheS5hdCggZGlzdGFuY2UgKSxcblx0XHRcdFx0XHRcdHBvaW50OiBpbnRlclNlZ21lbnQuY2xvbmUoKS5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4V29ybGQgKSxcblx0XHRcdFx0XHRcdGluZGV4OiBpLFxuXHRcdFx0XHRcdFx0ZmFjZTogbnVsbCxcblx0XHRcdFx0XHRcdGZhY2VJbmRleDogbnVsbCxcblx0XHRcdFx0XHRcdG9iamVjdDogdGhpc1xuXG5cdFx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fTtcblxuXHR9KCkgKTtcblxuXHRUSFJFRS5MaW5lLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5nZW9tZXRyeSwgdGhpcy5tYXRlcmlhbCApLmNvcHkoIHRoaXMgKTtcblxuXHR9O1xuXG5cdC8vIERFUFJFQ0FURURcblxuXHRUSFJFRS5MaW5lU3RyaXAgPSAwO1xuXHRUSFJFRS5MaW5lUGllY2VzID0gMTtcblxuXHQvLyBGaWxlOnNyYy9vYmplY3RzL0xpbmVTZWdtZW50cy5qc1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuXHQgKi9cblxuXHRUSFJFRS5MaW5lU2VnbWVudHMgPSBmdW5jdGlvbiAoIGdlb21ldHJ5LCBtYXRlcmlhbCApIHtcblxuXHRcdFRIUkVFLkxpbmUuY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cblx0XHR0aGlzLnR5cGUgPSAnTGluZVNlZ21lbnRzJztcblxuXHR9O1xuXG5cdFRIUkVFLkxpbmVTZWdtZW50cy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaW5lLnByb3RvdHlwZSApO1xuXHRUSFJFRS5MaW5lU2VnbWVudHMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTGluZVNlZ21lbnRzO1xuXG5cdC8vIEZpbGU6c3JjL29iamVjdHMvTWVzaC5qc1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuXHQgKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuXHQgKiBAYXV0aG9yIGpvbm9icjEgLyBodHRwOi8vam9ub2JyMS5jb20vXG5cdCAqL1xuXG5cdFRIUkVFLk1lc2ggPSBmdW5jdGlvbiAoIGdlb21ldHJ5LCBtYXRlcmlhbCApIHtcblxuXHRcdFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuXHRcdHRoaXMudHlwZSA9ICdNZXNoJztcblxuXHRcdHRoaXMuZ2VvbWV0cnkgPSBnZW9tZXRyeSAhPT0gdW5kZWZpbmVkID8gZ2VvbWV0cnkgOiBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcblx0XHR0aGlzLm1hdGVyaWFsID0gbWF0ZXJpYWwgIT09IHVuZGVmaW5lZCA/IG1hdGVyaWFsIDogbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmYgfSApO1xuXG5cdFx0dGhpcy51cGRhdGVNb3JwaFRhcmdldHMoKTtcblxuXHR9O1xuXG5cdFRIUkVFLk1lc2gucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XG5cdFRIUkVFLk1lc2gucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTWVzaDtcblxuXHRUSFJFRS5NZXNoLnByb3RvdHlwZS51cGRhdGVNb3JwaFRhcmdldHMgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRpZiAoIHRoaXMuZ2VvbWV0cnkubW9ycGhUYXJnZXRzICE9PSB1bmRlZmluZWQgJiYgdGhpcy5nZW9tZXRyeS5tb3JwaFRhcmdldHMubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0dGhpcy5tb3JwaFRhcmdldEJhc2UgPSAtIDE7XG5cdFx0XHR0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcyA9IFtdO1xuXHRcdFx0dGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnkgPSB7fTtcblxuXHRcdFx0Zm9yICggdmFyIG0gPSAwLCBtbCA9IHRoaXMuZ2VvbWV0cnkubW9ycGhUYXJnZXRzLmxlbmd0aDsgbSA8IG1sOyBtICsrICkge1xuXG5cdFx0XHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzLnB1c2goIDAgKTtcblx0XHRcdFx0dGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnlbIHRoaXMuZ2VvbWV0cnkubW9ycGhUYXJnZXRzWyBtIF0ubmFtZSBdID0gbTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH07XG5cblx0VEhSRUUuTWVzaC5wcm90b3R5cGUuZ2V0TW9ycGhUYXJnZXRJbmRleEJ5TmFtZSA9IGZ1bmN0aW9uICggbmFtZSApIHtcblxuXHRcdGlmICggdGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnlbIG5hbWUgXSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnlbIG5hbWUgXTtcblxuXHRcdH1cblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1lc2guZ2V0TW9ycGhUYXJnZXRJbmRleEJ5TmFtZTogbW9ycGggdGFyZ2V0ICcgKyBuYW1lICsgJyBkb2VzIG5vdCBleGlzdC4gUmV0dXJuaW5nIDAuJyApO1xuXG5cdFx0cmV0dXJuIDA7XG5cblx0fTtcblxuXG5cdFRIUkVFLk1lc2gucHJvdG90eXBlLnJheWNhc3QgPSAoIGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBpbnZlcnNlTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblx0XHR2YXIgcmF5ID0gbmV3IFRIUkVFLlJheSgpO1xuXHRcdHZhciBzcGhlcmUgPSBuZXcgVEhSRUUuU3BoZXJlKCk7XG5cblx0XHR2YXIgdkEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdHZhciB2QiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0dmFyIHZDID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdHZhciB0ZW1wQSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0dmFyIHRlbXBCID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHR2YXIgdGVtcEMgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0dmFyIHV2QSA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cdFx0dmFyIHV2QiA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cdFx0dmFyIHV2QyA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cblx0XHR2YXIgYmFyeWNvb3JkID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdHZhciBpbnRlcnNlY3Rpb25Qb2ludCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0dmFyIGludGVyc2VjdGlvblBvaW50V29ybGQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0ZnVuY3Rpb24gdXZJbnRlcnNlY3Rpb24oIHBvaW50LCBwMSwgcDIsIHAzLCB1djEsIHV2MiwgdXYzICkge1xuXG5cdFx0XHRUSFJFRS5UcmlhbmdsZS5iYXJ5Y29vcmRGcm9tUG9pbnQoIHBvaW50LCBwMSwgcDIsIHAzLCBiYXJ5Y29vcmQgKTtcblxuXHRcdFx0dXYxLm11bHRpcGx5U2NhbGFyKCBiYXJ5Y29vcmQueCApO1xuXHRcdFx0dXYyLm11bHRpcGx5U2NhbGFyKCBiYXJ5Y29vcmQueSApO1xuXHRcdFx0dXYzLm11bHRpcGx5U2NhbGFyKCBiYXJ5Y29vcmQueiApO1xuXG5cdFx0XHR1djEuYWRkKCB1djIgKS5hZGQoIHV2MyApO1xuXG5cdFx0XHRyZXR1cm4gdXYxLmNsb25lKCk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjaGVja0ludGVyc2VjdGlvbiggb2JqZWN0LCByYXljYXN0ZXIsIHJheSwgcEEsIHBCLCBwQywgcG9pbnQgKXtcblxuXHRcdFx0dmFyIGludGVyc2VjdDtcblx0XHRcdHZhciBtYXRlcmlhbCA9IG9iamVjdC5tYXRlcmlhbDtcblxuXHRcdFx0aWYgKCBtYXRlcmlhbC5zaWRlID09PSBUSFJFRS5CYWNrU2lkZSApIHtcblxuXHRcdFx0XHRpbnRlcnNlY3QgPSByYXkuaW50ZXJzZWN0VHJpYW5nbGUoIHBDLCBwQiwgcEEsIHRydWUsIHBvaW50ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0aW50ZXJzZWN0ID0gcmF5LmludGVyc2VjdFRyaWFuZ2xlKCBwQSwgcEIsIHBDLCBtYXRlcmlhbC5zaWRlICE9PSBUSFJFRS5Eb3VibGVTaWRlLCBwb2ludCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggaW50ZXJzZWN0ID09PSBudWxsICkgcmV0dXJuIG51bGw7XG5cblx0XHRcdGludGVyc2VjdGlvblBvaW50V29ybGQuY29weSggcG9pbnQgKTtcblx0XHRcdGludGVyc2VjdGlvblBvaW50V29ybGQuYXBwbHlNYXRyaXg0KCBvYmplY3QubWF0cml4V29ybGQgKTtcblxuXHRcdFx0dmFyIGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyggaW50ZXJzZWN0aW9uUG9pbnRXb3JsZCApO1xuXG5cdFx0XHRpZiAoIGRpc3RhbmNlIDwgcmF5Y2FzdGVyLm5lYXIgfHwgZGlzdGFuY2UgPiByYXljYXN0ZXIuZmFyICkgcmV0dXJuIG51bGw7XG5cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRpc3RhbmNlOiBkaXN0YW5jZSxcblx0XHRcdFx0cG9pbnQ6IGludGVyc2VjdGlvblBvaW50V29ybGQuY2xvbmUoKSxcblx0XHRcdFx0b2JqZWN0OiBvYmplY3Rcblx0XHRcdH07XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjaGVja0J1ZmZlckdlb21ldHJ5SW50ZXJzZWN0aW9uKCBvYmplY3QsIHJheWNhc3RlciwgcmF5LCBwb3NpdGlvbnMsIHV2cywgYSwgYiwgYyApIHtcblxuXHRcdFx0dkEuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGEgKiAzICk7XG5cdFx0XHR2Qi5mcm9tQXJyYXkoIHBvc2l0aW9ucywgYiAqIDMgKTtcblx0XHRcdHZDLmZyb21BcnJheSggcG9zaXRpb25zLCBjICogMyApO1xuXG5cdFx0XHR2YXIgaW50ZXJzZWN0aW9uID0gY2hlY2tJbnRlcnNlY3Rpb24oIG9iamVjdCwgcmF5Y2FzdGVyLCByYXksIHZBLCB2QiwgdkMsIGludGVyc2VjdGlvblBvaW50ICk7XG5cblx0XHRcdGlmICggaW50ZXJzZWN0aW9uICkge1xuXG5cdFx0XHRcdGlmICggdXZzICkge1xuXG5cdFx0XHRcdFx0dXZBLmZyb21BcnJheSggdXZzLCBhICogMiApO1xuXHRcdFx0XHRcdHV2Qi5mcm9tQXJyYXkoIHV2cywgYiAqIDIgKTtcblx0XHRcdFx0XHR1dkMuZnJvbUFycmF5KCB1dnMsIGMgKiAyICk7XG5cblx0XHRcdFx0XHRpbnRlcnNlY3Rpb24udXYgPSB1dkludGVyc2VjdGlvbiggaW50ZXJzZWN0aW9uUG9pbnQsICB2QSwgdkIsIHZDLCAgdXZBLCB1dkIsIHV2QyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpbnRlcnNlY3Rpb24uZmFjZSA9IG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgYywgVEhSRUUuVHJpYW5nbGUubm9ybWFsKCB2QSwgdkIsIHZDICkgKTtcblx0XHRcdFx0aW50ZXJzZWN0aW9uLmZhY2VJbmRleCA9IGE7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGludGVyc2VjdGlvbjtcblxuXHRcdH1cblxuXHRcdHJldHVybiBmdW5jdGlvbiByYXljYXN0KCByYXljYXN0ZXIsIGludGVyc2VjdHMgKSB7XG5cblx0XHRcdHZhciBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cdFx0XHR2YXIgbWF0ZXJpYWwgPSB0aGlzLm1hdGVyaWFsO1xuXG5cdFx0XHRpZiAoIG1hdGVyaWFsID09PSB1bmRlZmluZWQgKSByZXR1cm47XG5cblx0XHRcdC8vIENoZWNraW5nIGJvdW5kaW5nU3BoZXJlIGRpc3RhbmNlIHRvIHJheVxuXG5cdFx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID09PSBudWxsICkgZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cblx0XHRcdHZhciBtYXRyaXhXb3JsZCA9IHRoaXMubWF0cml4V29ybGQ7XG5cblx0XHRcdHNwaGVyZS5jb3B5KCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSApO1xuXHRcdFx0c3BoZXJlLmFwcGx5TWF0cml4NCggbWF0cml4V29ybGQgKTtcblxuXHRcdFx0aWYgKCByYXljYXN0ZXIucmF5LmlzSW50ZXJzZWN0aW9uU3BoZXJlKCBzcGhlcmUgKSA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRcdC8vIENoZWNrIGJvdW5kaW5nQm94IGJlZm9yZSBjb250aW51aW5nXG5cblx0XHRcdGludmVyc2VNYXRyaXguZ2V0SW52ZXJzZSggbWF0cml4V29ybGQgKTtcblx0XHRcdHJheS5jb3B5KCByYXljYXN0ZXIucmF5ICkuYXBwbHlNYXRyaXg0KCBpbnZlcnNlTWF0cml4ICk7XG5cblx0XHRcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XG5cblx0XHRcdFx0aWYgKCByYXkuaXNJbnRlcnNlY3Rpb25Cb3goIGdlb21ldHJ5LmJvdW5kaW5nQm94ICkgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciB1dnMsIGludGVyc2VjdGlvbjtcblxuXHRcdFx0aWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5ICkge1xuXG5cdFx0XHRcdHZhciBhLCBiLCBjO1xuXHRcdFx0XHR2YXIgaW5kZXggPSBnZW9tZXRyeS5pbmRleDtcblx0XHRcdFx0dmFyIGF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xuXHRcdFx0XHR2YXIgcG9zaXRpb25zID0gYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcblxuXHRcdFx0XHRpZiAoIGF0dHJpYnV0ZXMudXYgIT09IHVuZGVmaW5lZCApe1xuXG5cdFx0XHRcdFx0dXZzID0gYXR0cmlidXRlcy51di5hcnJheTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBpbmRleCAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdHZhciBpbmRpY2VzID0gaW5kZXguYXJyYXk7XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBpbmRpY2VzLmxlbmd0aDsgaSA8IGw7IGkgKz0gMyApIHtcblxuXHRcdFx0XHRcdFx0YSA9IGluZGljZXNbIGkgXTtcblx0XHRcdFx0XHRcdGIgPSBpbmRpY2VzWyBpICsgMSBdO1xuXHRcdFx0XHRcdFx0YyA9IGluZGljZXNbIGkgKyAyIF07XG5cblx0XHRcdFx0XHRcdGludGVyc2VjdGlvbiA9IGNoZWNrQnVmZmVyR2VvbWV0cnlJbnRlcnNlY3Rpb24oIHRoaXMsIHJheWNhc3RlciwgcmF5LCBwb3NpdGlvbnMsIHV2cywgYSwgYiwgYyApO1xuXG5cdFx0XHRcdFx0XHRpZiAoIGludGVyc2VjdGlvbiApIHtcblxuXHRcdFx0XHRcdFx0XHRpbnRlcnNlY3Rpb24uZmFjZUluZGV4ID0gTWF0aC5mbG9vciggaSAvIDMgKTsgLy8gdHJpYW5nbGUgbnVtYmVyIGluIGluZGljZXMgYnVmZmVyIHNlbWFudGljc1xuXHRcdFx0XHRcdFx0XHRpbnRlcnNlY3RzLnB1c2goIGludGVyc2VjdGlvbiApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGw7IGkgKz0gOSApIHtcblxuXHRcdFx0XHRcdFx0YSA9IGkgLyAzO1xuXHRcdFx0XHRcdFx0YiA9IGEgKyAxO1xuXHRcdFx0XHRcdFx0YyA9IGEgKyAyO1xuXG5cdFx0XHRcdFx0XHRpbnRlcnNlY3Rpb24gPSBjaGVja0J1ZmZlckdlb21ldHJ5SW50ZXJzZWN0aW9uKCB0aGlzLCByYXljYXN0ZXIsIHJheSwgcG9zaXRpb25zLCB1dnMsIGEsIGIsIGMgKTtcblxuXHRcdFx0XHRcdFx0aWYgKCBpbnRlcnNlY3Rpb24gKSB7XG5cblx0XHRcdFx0XHRcdFx0aW50ZXJzZWN0aW9uLmluZGV4ID0gYTsgLy8gdHJpYW5nbGUgbnVtYmVyIGluIHBvc2l0aW9ucyBidWZmZXIgc2VtYW50aWNzXG5cdFx0XHRcdFx0XHRcdGludGVyc2VjdHMucHVzaCggaW50ZXJzZWN0aW9uICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuR2VvbWV0cnkgKSB7XG5cblx0XHRcdFx0dmFyIGZ2QSwgZnZCLCBmdkM7XG5cdFx0XHRcdHZhciBpc0ZhY2VNYXRlcmlhbCA9IG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaEZhY2VNYXRlcmlhbDtcblx0XHRcdFx0dmFyIG1hdGVyaWFscyA9IGlzRmFjZU1hdGVyaWFsID09PSB0cnVlID8gbWF0ZXJpYWwubWF0ZXJpYWxzIDogbnVsbDtcblxuXHRcdFx0XHR2YXIgdmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcblx0XHRcdFx0dmFyIGZhY2VzID0gZ2VvbWV0cnkuZmFjZXM7XG5cdFx0XHRcdHZhciBmYWNlVmVydGV4VXZzID0gZ2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgMCBdO1xuXHRcdFx0XHRpZiAoIGZhY2VWZXJ0ZXhVdnMubGVuZ3RoID4gMCApIHV2cyA9IGZhY2VWZXJ0ZXhVdnM7XG5cblx0XHRcdFx0Zm9yICggdmFyIGYgPSAwLCBmbCA9IGZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIGZhY2UgPSBmYWNlc1sgZiBdO1xuXHRcdFx0XHRcdHZhciBmYWNlTWF0ZXJpYWwgPSBpc0ZhY2VNYXRlcmlhbCA9PT0gdHJ1ZSA/IG1hdGVyaWFsc1sgZmFjZS5tYXRlcmlhbEluZGV4IF0gOiBtYXRlcmlhbDtcblxuXHRcdFx0XHRcdGlmICggZmFjZU1hdGVyaWFsID09PSB1bmRlZmluZWQgKSBjb250aW51ZTtcblxuXHRcdFx0XHRcdGZ2QSA9IHZlcnRpY2VzWyBmYWNlLmEgXTtcblx0XHRcdFx0XHRmdkIgPSB2ZXJ0aWNlc1sgZmFjZS5iIF07XG5cdFx0XHRcdFx0ZnZDID0gdmVydGljZXNbIGZhY2UuYyBdO1xuXG5cdFx0XHRcdFx0aWYgKCBmYWNlTWF0ZXJpYWwubW9ycGhUYXJnZXRzID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgbW9ycGhUYXJnZXRzID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzO1xuXHRcdFx0XHRcdFx0dmFyIG1vcnBoSW5mbHVlbmNlcyA9IHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzO1xuXG5cdFx0XHRcdFx0XHR2QS5zZXQoIDAsIDAsIDAgKTtcblx0XHRcdFx0XHRcdHZCLnNldCggMCwgMCwgMCApO1xuXHRcdFx0XHRcdFx0dkMuc2V0KCAwLCAwLCAwICk7XG5cblx0XHRcdFx0XHRcdGZvciAoIHZhciB0ID0gMCwgdGwgPSBtb3JwaFRhcmdldHMubGVuZ3RoOyB0IDwgdGw7IHQgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0dmFyIGluZmx1ZW5jZSA9IG1vcnBoSW5mbHVlbmNlc1sgdCBdO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggaW5mbHVlbmNlID09PSAwICkgY29udGludWU7XG5cblx0XHRcdFx0XHRcdFx0dmFyIHRhcmdldHMgPSBtb3JwaFRhcmdldHNbIHQgXS52ZXJ0aWNlcztcblxuXHRcdFx0XHRcdFx0XHR2QS5hZGRTY2FsZWRWZWN0b3IoIHRlbXBBLnN1YlZlY3RvcnMoIHRhcmdldHNbIGZhY2UuYSBdLCBmdkEgKSwgaW5mbHVlbmNlICk7XG5cdFx0XHRcdFx0XHRcdHZCLmFkZFNjYWxlZFZlY3RvciggdGVtcEIuc3ViVmVjdG9ycyggdGFyZ2V0c1sgZmFjZS5iIF0sIGZ2QiApLCBpbmZsdWVuY2UgKTtcblx0XHRcdFx0XHRcdFx0dkMuYWRkU2NhbGVkVmVjdG9yKCB0ZW1wQy5zdWJWZWN0b3JzKCB0YXJnZXRzWyBmYWNlLmMgXSwgZnZDICksIGluZmx1ZW5jZSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHZBLmFkZCggZnZBICk7XG5cdFx0XHRcdFx0XHR2Qi5hZGQoIGZ2QiApO1xuXHRcdFx0XHRcdFx0dkMuYWRkKCBmdkMgKTtcblxuXHRcdFx0XHRcdFx0ZnZBID0gdkE7XG5cdFx0XHRcdFx0XHRmdkIgPSB2Qjtcblx0XHRcdFx0XHRcdGZ2QyA9IHZDO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aW50ZXJzZWN0aW9uID0gY2hlY2tJbnRlcnNlY3Rpb24oIHRoaXMsIHJheWNhc3RlciwgcmF5LCBmdkEsIGZ2QiwgZnZDLCBpbnRlcnNlY3Rpb25Qb2ludCApO1xuXG5cdFx0XHRcdFx0aWYgKCBpbnRlcnNlY3Rpb24gKSB7XG5cblx0XHRcdFx0XHRcdGlmICggdXZzICkge1xuXG5cdFx0XHRcdFx0XHRcdHZhciB1dnNfZiA9IHV2c1sgZiBdO1xuXHRcdFx0XHRcdFx0XHR1dkEuY29weSggdXZzX2ZbIDAgXSApO1xuXHRcdFx0XHRcdFx0XHR1dkIuY29weSggdXZzX2ZbIDEgXSApO1xuXHRcdFx0XHRcdFx0XHR1dkMuY29weSggdXZzX2ZbIDIgXSApO1xuXG5cdFx0XHRcdFx0XHRcdGludGVyc2VjdGlvbi51diA9IHV2SW50ZXJzZWN0aW9uKCBpbnRlcnNlY3Rpb25Qb2ludCwgZnZBLCBmdkIsIGZ2QywgdXZBLCB1dkIsIHV2QyApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGludGVyc2VjdGlvbi5mYWNlID0gZmFjZTtcblx0XHRcdFx0XHRcdGludGVyc2VjdGlvbi5mYWNlSW5kZXggPSBmO1xuXHRcdFx0XHRcdFx0aW50ZXJzZWN0cy5wdXNoKCBpbnRlcnNlY3Rpb24gKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH07XG5cblx0fSgpICk7XG5cblx0VEhSRUUuTWVzaC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMuZ2VvbWV0cnksIHRoaXMubWF0ZXJpYWwgKS5jb3B5KCB0aGlzICk7XG5cblx0fTtcblxuXHQvLyBGaWxlOnNyYy9vYmplY3RzL0JvbmUuanNcblxuXHQvKipcblx0ICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cblx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cblx0ICogQGF1dGhvciBpa2VyciAvIGh0dHA6Ly92ZXJvbGQuY29tXG5cdCAqL1xuXG5cdFRIUkVFLkJvbmUgPSBmdW5jdGlvbiAoIHNraW4gKSB7XG5cblx0XHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cblx0XHR0aGlzLnR5cGUgPSAnQm9uZSc7XG5cblx0XHR0aGlzLnNraW4gPSBza2luO1xuXG5cdH07XG5cblx0VEhSRUUuQm9uZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblx0VEhSRUUuQm9uZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Cb25lO1xuXG5cdFRIUkVFLkJvbmUucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblx0XHRcblx0XHRUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblx0XHRcblx0XHR0aGlzLnNraW4gPSBzb3VyY2Uuc2tpbjtcblx0XHRcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdC8vIEZpbGU6c3JjL29iamVjdHMvU2tlbGV0b24uanNcblxuXHQvKipcblx0ICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cblx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cblx0ICogQGF1dGhvciBtaWNoYWVsIGd1ZXJyZXJvIC8gaHR0cDovL3JlYWxpdHltZWx0ZG93bi5jb21cblx0ICogQGF1dGhvciBpa2VyciAvIGh0dHA6Ly92ZXJvbGQuY29tXG5cdCAqL1xuXG5cdFRIUkVFLlNrZWxldG9uID0gZnVuY3Rpb24gKCBib25lcywgYm9uZUludmVyc2VzLCB1c2VWZXJ0ZXhUZXh0dXJlICkge1xuXG5cdFx0dGhpcy51c2VWZXJ0ZXhUZXh0dXJlID0gdXNlVmVydGV4VGV4dHVyZSAhPT0gdW5kZWZpbmVkID8gdXNlVmVydGV4VGV4dHVyZSA6IHRydWU7XG5cblx0XHR0aGlzLmlkZW50aXR5TWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuXHRcdC8vIGNvcHkgdGhlIGJvbmUgYXJyYXlcblxuXHRcdGJvbmVzID0gYm9uZXMgfHwgW107XG5cblx0XHR0aGlzLmJvbmVzID0gYm9uZXMuc2xpY2UoIDAgKTtcblxuXHRcdC8vIGNyZWF0ZSBhIGJvbmUgdGV4dHVyZSBvciBhbiBhcnJheSBvZiBmbG9hdHNcblxuXHRcdGlmICggdGhpcy51c2VWZXJ0ZXhUZXh0dXJlICkge1xuXG5cdFx0XHQvLyBsYXlvdXQgKDEgbWF0cml4ID0gNCBwaXhlbHMpXG5cdFx0XHQvLyAgICAgIFJHQkEgUkdCQSBSR0JBIFJHQkEgKD0+IGNvbHVtbjEsIGNvbHVtbjIsIGNvbHVtbjMsIGNvbHVtbjQpXG5cdFx0XHQvLyAgd2l0aCAgOHg4ICBwaXhlbCB0ZXh0dXJlIG1heCAgIDE2IGJvbmVzICogNCBwaXhlbHMgPSAgKDggKiA4KVxuXHRcdFx0Ly8gICAgICAgMTZ4MTYgcGl4ZWwgdGV4dHVyZSBtYXggICA2NCBib25lcyAqIDQgcGl4ZWxzID0gKDE2ICogMTYpXG5cdFx0XHQvLyAgICAgICAzMngzMiBwaXhlbCB0ZXh0dXJlIG1heCAgMjU2IGJvbmVzICogNCBwaXhlbHMgPSAoMzIgKiAzMilcblx0XHRcdC8vICAgICAgIDY0eDY0IHBpeGVsIHRleHR1cmUgbWF4IDEwMjQgYm9uZXMgKiA0IHBpeGVscyA9ICg2NCAqIDY0KVxuXG5cdFx0XHRcblx0XHRcdHZhciBzaXplID0gTWF0aC5zcXJ0KCB0aGlzLmJvbmVzLmxlbmd0aCAqIDQgKTsgLy8gNCBwaXhlbHMgbmVlZGVkIGZvciAxIG1hdHJpeFxuXHRcdFx0c2l6ZSA9IFRIUkVFLk1hdGgubmV4dFBvd2VyT2ZUd28oIE1hdGguY2VpbCggc2l6ZSApICk7XG5cdFx0XHRzaXplID0gTWF0aC5tYXgoIHNpemUsIDQgKTtcblxuXHRcdFx0dGhpcy5ib25lVGV4dHVyZVdpZHRoID0gc2l6ZTtcblx0XHRcdHRoaXMuYm9uZVRleHR1cmVIZWlnaHQgPSBzaXplO1xuXG5cdFx0XHR0aGlzLmJvbmVNYXRyaWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIHRoaXMuYm9uZVRleHR1cmVXaWR0aCAqIHRoaXMuYm9uZVRleHR1cmVIZWlnaHQgKiA0ICk7IC8vIDQgZmxvYXRzIHBlciBSR0JBIHBpeGVsXG5cdFx0XHR0aGlzLmJvbmVUZXh0dXJlID0gbmV3IFRIUkVFLkRhdGFUZXh0dXJlKCB0aGlzLmJvbmVNYXRyaWNlcywgdGhpcy5ib25lVGV4dHVyZVdpZHRoLCB0aGlzLmJvbmVUZXh0dXJlSGVpZ2h0LCBUSFJFRS5SR0JBRm9ybWF0LCBUSFJFRS5GbG9hdFR5cGUgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMuYm9uZU1hdHJpY2VzID0gbmV3IEZsb2F0MzJBcnJheSggMTYgKiB0aGlzLmJvbmVzLmxlbmd0aCApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gdXNlIHRoZSBzdXBwbGllZCBib25lIGludmVyc2VzIG9yIGNhbGN1bGF0ZSB0aGUgaW52ZXJzZXNcblxuXHRcdGlmICggYm9uZUludmVyc2VzID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHRoaXMuY2FsY3VsYXRlSW52ZXJzZXMoKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGlmICggdGhpcy5ib25lcy5sZW5ndGggPT09IGJvbmVJbnZlcnNlcy5sZW5ndGggKSB7XG5cblx0XHRcdFx0dGhpcy5ib25lSW52ZXJzZXMgPSBib25lSW52ZXJzZXMuc2xpY2UoIDAgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Ta2VsZXRvbiBib25JbnZlcnNlcyBpcyB0aGUgd3JvbmcgbGVuZ3RoLicgKTtcblxuXHRcdFx0XHR0aGlzLmJvbmVJbnZlcnNlcyA9IFtdO1xuXG5cdFx0XHRcdGZvciAoIHZhciBiID0gMCwgYmwgPSB0aGlzLmJvbmVzLmxlbmd0aDsgYiA8IGJsOyBiICsrICkge1xuXG5cdFx0XHRcdFx0dGhpcy5ib25lSW52ZXJzZXMucHVzaCggbmV3IFRIUkVFLk1hdHJpeDQoKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH07XG5cblx0VEhSRUUuU2tlbGV0b24ucHJvdG90eXBlLmNhbGN1bGF0ZUludmVyc2VzID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy5ib25lSW52ZXJzZXMgPSBbXTtcblxuXHRcdGZvciAoIHZhciBiID0gMCwgYmwgPSB0aGlzLmJvbmVzLmxlbmd0aDsgYiA8IGJsOyBiICsrICkge1xuXG5cdFx0XHR2YXIgaW52ZXJzZSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cblx0XHRcdGlmICggdGhpcy5ib25lc1sgYiBdICkge1xuXG5cdFx0XHRcdGludmVyc2UuZ2V0SW52ZXJzZSggdGhpcy5ib25lc1sgYiBdLm1hdHJpeFdvcmxkICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5ib25lSW52ZXJzZXMucHVzaCggaW52ZXJzZSApO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0VEhSRUUuU2tlbGV0b24ucHJvdG90eXBlLnBvc2UgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgYm9uZTtcblxuXHRcdC8vIHJlY292ZXIgdGhlIGJpbmQtdGltZSB3b3JsZCBtYXRyaWNlc1xuXG5cdFx0Zm9yICggdmFyIGIgPSAwLCBibCA9IHRoaXMuYm9uZXMubGVuZ3RoOyBiIDwgYmw7IGIgKysgKSB7XG5cblx0XHRcdGJvbmUgPSB0aGlzLmJvbmVzWyBiIF07XG5cblx0XHRcdGlmICggYm9uZSApIHtcblxuXHRcdFx0XHRib25lLm1hdHJpeFdvcmxkLmdldEludmVyc2UoIHRoaXMuYm9uZUludmVyc2VzWyBiIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gY29tcHV0ZSB0aGUgbG9jYWwgbWF0cmljZXMsIHBvc2l0aW9ucywgcm90YXRpb25zIGFuZCBzY2FsZXNcblxuXHRcdGZvciAoIHZhciBiID0gMCwgYmwgPSB0aGlzLmJvbmVzLmxlbmd0aDsgYiA8IGJsOyBiICsrICkge1xuXG5cdFx0XHRib25lID0gdGhpcy5ib25lc1sgYiBdO1xuXG5cdFx0XHRpZiAoIGJvbmUgKSB7XG5cblx0XHRcdFx0aWYgKCBib25lLnBhcmVudCApIHtcblxuXHRcdFx0XHRcdGJvbmUubWF0cml4LmdldEludmVyc2UoIGJvbmUucGFyZW50Lm1hdHJpeFdvcmxkICk7XG5cdFx0XHRcdFx0Ym9uZS5tYXRyaXgubXVsdGlwbHkoIGJvbmUubWF0cml4V29ybGQgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ym9uZS5tYXRyaXguY29weSggYm9uZS5tYXRyaXhXb3JsZCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRib25lLm1hdHJpeC5kZWNvbXBvc2UoIGJvbmUucG9zaXRpb24sIGJvbmUucXVhdGVybmlvbiwgYm9uZS5zY2FsZSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fTtcblxuXHRUSFJFRS5Ta2VsZXRvbi5wcm90b3R5cGUudXBkYXRlID0gKCBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgb2Zmc2V0TWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiB1cGRhdGUoKSB7XG5cblx0XHRcdC8vIGZsYXR0ZW4gYm9uZSBtYXRyaWNlcyB0byBhcnJheVxuXG5cdFx0XHRmb3IgKCB2YXIgYiA9IDAsIGJsID0gdGhpcy5ib25lcy5sZW5ndGg7IGIgPCBibDsgYiArKyApIHtcblxuXHRcdFx0XHQvLyBjb21wdXRlIHRoZSBvZmZzZXQgYmV0d2VlbiB0aGUgY3VycmVudCBhbmQgdGhlIG9yaWdpbmFsIHRyYW5zZm9ybVxuXG5cdFx0XHRcdHZhciBtYXRyaXggPSB0aGlzLmJvbmVzWyBiIF0gPyB0aGlzLmJvbmVzWyBiIF0ubWF0cml4V29ybGQgOiB0aGlzLmlkZW50aXR5TWF0cml4O1xuXG5cdFx0XHRcdG9mZnNldE1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBtYXRyaXgsIHRoaXMuYm9uZUludmVyc2VzWyBiIF0gKTtcblx0XHRcdFx0b2Zmc2V0TWF0cml4LmZsYXR0ZW5Ub0FycmF5T2Zmc2V0KCB0aGlzLmJvbmVNYXRyaWNlcywgYiAqIDE2ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0aGlzLnVzZVZlcnRleFRleHR1cmUgKSB7XG5cblx0XHRcdFx0dGhpcy5ib25lVGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdH1cblxuXHRcdH07XG5cblx0fSApKCk7XG5cblx0VEhSRUUuU2tlbGV0b24ucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5Ta2VsZXRvbiggdGhpcy5ib25lcywgdGhpcy5ib25lSW52ZXJzZXMsIHRoaXMudXNlVmVydGV4VGV4dHVyZSApO1xuXG5cdH07XG5cblx0Ly8gRmlsZTpzcmMvb2JqZWN0cy9Ta2lubmVkTWVzaC5qc1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuXHQgKiBAYXV0aG9yIGlrZXJyIC8gaHR0cDovL3Zlcm9sZC5jb21cblx0ICovXG5cblx0VEhSRUUuU2tpbm5lZE1lc2ggPSBmdW5jdGlvbiAoIGdlb21ldHJ5LCBtYXRlcmlhbCwgdXNlVmVydGV4VGV4dHVyZSApIHtcblxuXHRcdFRIUkVFLk1lc2guY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cblx0XHR0aGlzLnR5cGUgPSAnU2tpbm5lZE1lc2gnO1xuXG5cdFx0dGhpcy5iaW5kTW9kZSA9IFwiYXR0YWNoZWRcIjtcblx0XHR0aGlzLmJpbmRNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXHRcdHRoaXMuYmluZE1hdHJpeEludmVyc2UgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG5cdFx0Ly8gaW5pdCBib25lc1xuXG5cdFx0Ly8gVE9ETzogcmVtb3ZlIGJvbmUgY3JlYXRpb24gYXMgdGhlcmUgaXMgbm8gcmVhc29uIChvdGhlciB0aGFuXG5cdFx0Ly8gY29udmVuaWVuY2UpIGZvciBUSFJFRS5Ta2lubmVkTWVzaCB0byBkbyB0aGlzLlxuXG5cdFx0dmFyIGJvbmVzID0gW107XG5cblx0XHRpZiAoIHRoaXMuZ2VvbWV0cnkgJiYgdGhpcy5nZW9tZXRyeS5ib25lcyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR2YXIgYm9uZSwgZ2JvbmU7XG5cblx0XHRcdGZvciAoIHZhciBiID0gMCwgYmwgPSB0aGlzLmdlb21ldHJ5LmJvbmVzLmxlbmd0aDsgYiA8IGJsOyArKyBiICkge1xuXG5cdFx0XHRcdGdib25lID0gdGhpcy5nZW9tZXRyeS5ib25lc1sgYiBdO1xuXG5cdFx0XHRcdGJvbmUgPSBuZXcgVEhSRUUuQm9uZSggdGhpcyApO1xuXHRcdFx0XHRib25lcy5wdXNoKCBib25lICk7XG5cblx0XHRcdFx0Ym9uZS5uYW1lID0gZ2JvbmUubmFtZTtcblx0XHRcdFx0Ym9uZS5wb3NpdGlvbi5mcm9tQXJyYXkoIGdib25lLnBvcyApO1xuXHRcdFx0XHRib25lLnF1YXRlcm5pb24uZnJvbUFycmF5KCBnYm9uZS5yb3RxICk7XG5cdFx0XHRcdGlmICggZ2JvbmUuc2NsICE9PSB1bmRlZmluZWQgKSBib25lLnNjYWxlLmZyb21BcnJheSggZ2JvbmUuc2NsICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggdmFyIGIgPSAwLCBibCA9IHRoaXMuZ2VvbWV0cnkuYm9uZXMubGVuZ3RoOyBiIDwgYmw7ICsrIGIgKSB7XG5cblx0XHRcdFx0Z2JvbmUgPSB0aGlzLmdlb21ldHJ5LmJvbmVzWyBiIF07XG5cblx0XHRcdFx0aWYgKCBnYm9uZS5wYXJlbnQgIT09IC0gMSAmJiBnYm9uZS5wYXJlbnQgIT09IG51bGwpIHtcblxuXHRcdFx0XHRcdGJvbmVzWyBnYm9uZS5wYXJlbnQgXS5hZGQoIGJvbmVzWyBiIF0gKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dGhpcy5hZGQoIGJvbmVzWyBiIF0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHRoaXMubm9ybWFsaXplU2tpbldlaWdodHMoKTtcblxuXHRcdHRoaXMudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcblx0XHR0aGlzLmJpbmQoIG5ldyBUSFJFRS5Ta2VsZXRvbiggYm9uZXMsIHVuZGVmaW5lZCwgdXNlVmVydGV4VGV4dHVyZSApLCB0aGlzLm1hdHJpeFdvcmxkICk7XG5cblx0fTtcblxuXG5cdFRIUkVFLlNraW5uZWRNZXNoLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1lc2gucHJvdG90eXBlICk7XG5cdFRIUkVFLlNraW5uZWRNZXNoLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlNraW5uZWRNZXNoO1xuXG5cdFRIUkVFLlNraW5uZWRNZXNoLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24oIHNrZWxldG9uLCBiaW5kTWF0cml4ICkge1xuXG5cdFx0dGhpcy5za2VsZXRvbiA9IHNrZWxldG9uO1xuXG5cdFx0aWYgKCBiaW5kTWF0cml4ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHRoaXMudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcblx0XHRcdFxuXHRcdFx0dGhpcy5za2VsZXRvbi5jYWxjdWxhdGVJbnZlcnNlcygpO1xuXG5cdFx0XHRiaW5kTWF0cml4ID0gdGhpcy5tYXRyaXhXb3JsZDtcblxuXHRcdH1cblxuXHRcdHRoaXMuYmluZE1hdHJpeC5jb3B5KCBiaW5kTWF0cml4ICk7XG5cdFx0dGhpcy5iaW5kTWF0cml4SW52ZXJzZS5nZXRJbnZlcnNlKCBiaW5kTWF0cml4ICk7XG5cblx0fTtcblxuXHRUSFJFRS5Ta2lubmVkTWVzaC5wcm90b3R5cGUucG9zZSA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHRoaXMuc2tlbGV0b24ucG9zZSgpO1xuXG5cdH07XG5cblx0VEhSRUUuU2tpbm5lZE1lc2gucHJvdG90eXBlLm5vcm1hbGl6ZVNraW5XZWlnaHRzID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0aWYgKCB0aGlzLmdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuR2VvbWV0cnkgKSB7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuZ2VvbWV0cnkuc2tpbkluZGljZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBzdyA9IHRoaXMuZ2VvbWV0cnkuc2tpbldlaWdodHNbIGkgXTtcblxuXHRcdFx0XHR2YXIgc2NhbGUgPSAxLjAgLyBzdy5sZW5ndGhNYW5oYXR0YW4oKTtcblxuXHRcdFx0XHRpZiAoIHNjYWxlICE9PSBJbmZpbml0eSApIHtcblxuXHRcdFx0XHRcdHN3Lm11bHRpcGx5U2NhbGFyKCBzY2FsZSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRzdy5zZXQoIDEgKTsgLy8gdGhpcyB3aWxsIGJlIG5vcm1hbGl6ZWQgYnkgdGhlIHNoYWRlciBhbnl3YXlcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIHNraW5uaW5nIHdlaWdodHMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkIGZvciBUSFJFRS5CdWZmZXJHZW9tZXRyeVxuXG5cdFx0fVxuXG5cdH07XG5cblx0VEhSRUUuU2tpbm5lZE1lc2gucHJvdG90eXBlLnVwZGF0ZU1hdHJpeFdvcmxkID0gZnVuY3Rpb24oIGZvcmNlICkge1xuXG5cdFx0VEhSRUUuTWVzaC5wcm90b3R5cGUudXBkYXRlTWF0cml4V29ybGQuY2FsbCggdGhpcywgdHJ1ZSApO1xuXG5cdFx0aWYgKCB0aGlzLmJpbmRNb2RlID09PSBcImF0dGFjaGVkXCIgKSB7XG5cblx0XHRcdHRoaXMuYmluZE1hdHJpeEludmVyc2UuZ2V0SW52ZXJzZSggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG5cdFx0fSBlbHNlIGlmICggdGhpcy5iaW5kTW9kZSA9PT0gXCJkZXRhY2hlZFwiICkge1xuXG5cdFx0XHR0aGlzLmJpbmRNYXRyaXhJbnZlcnNlLmdldEludmVyc2UoIHRoaXMuYmluZE1hdHJpeCApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuU2tpbm5lZE1lc2ggdW5yZWNvZ25pemVkIGJpbmRNb2RlOiAnICsgdGhpcy5iaW5kTW9kZSApO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0VEhSRUUuU2tpbm5lZE1lc2gucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMuZ2VvbWV0cnksIHRoaXMubWF0ZXJpYWwsIHRoaXMudXNlVmVydGV4VGV4dHVyZSApLmNvcHkoIHRoaXMgKTtcblxuXHR9O1xuXG5cdC8vIEZpbGU6c3JjL29iamVjdHMvTE9ELmpzXG5cblx0LyoqXG5cdCAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG5cdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqL1xuXG5cdFRIUkVFLkxPRCA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuXHRcdHRoaXMudHlwZSA9ICdMT0QnO1xuXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIHRoaXMsIHtcblx0XHRcdGxldmVsczoge1xuXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHR2YWx1ZTogW11cblx0XHRcdH0sXG5cdFx0XHRvYmplY3RzOiB7XG5cdFx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTE9EOiAub2JqZWN0cyBoYXMgYmVlbiByZW5hbWVkIHRvIC5sZXZlbHMuJyApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLmxldmVscztcblxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cdH07XG5cblxuXHRUSFJFRS5MT0QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XG5cdFRIUkVFLkxPRC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5MT0Q7XG5cblx0VEhSRUUuTE9ELnByb3RvdHlwZS5hZGRMZXZlbCA9IGZ1bmN0aW9uICggb2JqZWN0LCBkaXN0YW5jZSApIHtcblxuXHRcdGlmICggZGlzdGFuY2UgPT09IHVuZGVmaW5lZCApIGRpc3RhbmNlID0gMDtcblxuXHRcdGRpc3RhbmNlID0gTWF0aC5hYnMoIGRpc3RhbmNlICk7XG5cblx0XHR2YXIgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG5cblx0XHRmb3IgKCB2YXIgbCA9IDA7IGwgPCBsZXZlbHMubGVuZ3RoOyBsICsrICkge1xuXG5cdFx0XHRpZiAoIGRpc3RhbmNlIDwgbGV2ZWxzWyBsIF0uZGlzdGFuY2UgKSB7XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGxldmVscy5zcGxpY2UoIGwsIDAsIHsgZGlzdGFuY2U6IGRpc3RhbmNlLCBvYmplY3Q6IG9iamVjdCB9ICk7XG5cblx0XHR0aGlzLmFkZCggb2JqZWN0ICk7XG5cblx0fTtcblxuXHRUSFJFRS5MT0QucHJvdG90eXBlLmdldE9iamVjdEZvckRpc3RhbmNlID0gZnVuY3Rpb24gKCBkaXN0YW5jZSApIHtcblxuXHRcdHZhciBsZXZlbHMgPSB0aGlzLmxldmVscztcblxuXHRcdGZvciAoIHZhciBpID0gMSwgbCA9IGxldmVscy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRpZiAoIGRpc3RhbmNlIDwgbGV2ZWxzWyBpIF0uZGlzdGFuY2UgKSB7XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBsZXZlbHNbIGkgLSAxIF0ub2JqZWN0O1xuXG5cdH07XG5cblx0VEhSRUUuTE9ELnByb3RvdHlwZS5yYXljYXN0ID0gKCBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgbWF0cml4UG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHJheWNhc3QoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApIHtcblxuXHRcdFx0bWF0cml4UG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLm1hdHJpeFdvcmxkICk7XG5cblx0XHRcdHZhciBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkub3JpZ2luLmRpc3RhbmNlVG8oIG1hdHJpeFBvc2l0aW9uICk7XG5cblx0XHRcdHRoaXMuZ2V0T2JqZWN0Rm9yRGlzdGFuY2UoIGRpc3RhbmNlICkucmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICk7XG5cblx0XHR9O1xuXG5cdH0oKSApO1xuXG5cdFRIUkVFLkxPRC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHR2YXIgdjIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSggY2FtZXJhICkge1xuXG5cdFx0XHR2YXIgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG5cblx0XHRcdGlmICggbGV2ZWxzLmxlbmd0aCA+IDEgKSB7XG5cblx0XHRcdFx0djEuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBjYW1lcmEubWF0cml4V29ybGQgKTtcblx0XHRcdFx0djIuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLm1hdHJpeFdvcmxkICk7XG5cblx0XHRcdFx0dmFyIGRpc3RhbmNlID0gdjEuZGlzdGFuY2VUbyggdjIgKTtcblxuXHRcdFx0XHRsZXZlbHNbIDAgXS5vYmplY3QudmlzaWJsZSA9IHRydWU7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAxLCBsID0gbGV2ZWxzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGRpc3RhbmNlID49IGxldmVsc1sgaSBdLmRpc3RhbmNlICkge1xuXG5cdFx0XHRcdFx0XHRsZXZlbHNbIGkgLSAxIF0ub2JqZWN0LnZpc2libGUgPSBmYWxzZTtcblx0XHRcdFx0XHRcdGxldmVsc1sgaSBdLm9iamVjdC52aXNpYmxlID0gdHJ1ZTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKCA7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0bGV2ZWxzWyBpIF0ub2JqZWN0LnZpc2libGUgPSBmYWxzZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH07XG5cblx0fSgpO1xuXG5cdFRIUkVFLkxPRC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xuXG5cdFx0VEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlLCBmYWxzZSApO1xuXG5cdFx0dmFyIGxldmVscyA9IHNvdXJjZS5sZXZlbHM7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBsZXZlbHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0dmFyIGxldmVsID0gbGV2ZWxzWyBpIF07XG5cblx0XHRcdHRoaXMuYWRkTGV2ZWwoIGxldmVsLm9iamVjdC5jbG9uZSgpLCBsZXZlbC5kaXN0YW5jZSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHRUSFJFRS5MT0QucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICggbWV0YSApIHtcblxuXHRcdHZhciBkYXRhID0gVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzLCBtZXRhICk7XG5cblx0XHRkYXRhLm9iamVjdC5sZXZlbHMgPSBbXTtcblxuXHRcdHZhciBsZXZlbHMgPSB0aGlzLmxldmVscztcblxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGxldmVscy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHR2YXIgbGV2ZWwgPSBsZXZlbHNbIGkgXTtcblxuXHRcdFx0ZGF0YS5vYmplY3QubGV2ZWxzLnB1c2goIHtcblx0XHRcdFx0b2JqZWN0OiBsZXZlbC5vYmplY3QudXVpZCxcblx0XHRcdFx0ZGlzdGFuY2U6IGxldmVsLmRpc3RhbmNlXG5cdFx0XHR9ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YTtcblxuXHR9O1xuXG5cdC8vIEZpbGU6c3JjL29iamVjdHMvU3ByaXRlLmpzXG5cblx0LyoqXG5cdCAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG5cdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG5cdCAqL1xuXG5cdFRIUkVFLlNwcml0ZSA9ICggZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIGluZGljZXMgPSBuZXcgVWludDE2QXJyYXkoIFsgMCwgMSwgMiwgIDAsIDIsIDMgXSApO1xuXHRcdHZhciB2ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIFsgLSAwLjUsIC0gMC41LCAwLCAgIDAuNSwgLSAwLjUsIDAsICAgMC41LCAwLjUsIDAsICAgLSAwLjUsIDAuNSwgMCBdICk7XG5cdFx0dmFyIHV2cyA9IG5ldyBGbG9hdDMyQXJyYXkoIFsgMCwgMCwgICAxLCAwLCAgIDEsIDEsICAgMCwgMSBdICk7XG5cblx0XHR2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKTtcblx0XHRnZW9tZXRyeS5zZXRJbmRleCggbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggaW5kaWNlcywgMSApICk7XG5cdFx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG5cdFx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAndXYnLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKSApO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFNwcml0ZSggbWF0ZXJpYWwgKSB7XG5cblx0XHRcdFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuXHRcdFx0dGhpcy50eXBlID0gJ1Nwcml0ZSc7XG5cblx0XHRcdHRoaXMuZ2VvbWV0cnkgPSBnZW9tZXRyeTtcblx0XHRcdHRoaXMubWF0ZXJpYWwgPSAoIG1hdGVyaWFsICE9PSB1bmRlZmluZWQgKSA/IG1hdGVyaWFsIDogbmV3IFRIUkVFLlNwcml0ZU1hdGVyaWFsKCk7XG5cblx0XHR9O1xuXG5cdH0gKSgpO1xuXG5cdFRIUkVFLlNwcml0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblx0VEhSRUUuU3ByaXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlNwcml0ZTtcblxuXHRUSFJFRS5TcHJpdGUucHJvdG90eXBlLnJheWNhc3QgPSAoIGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBtYXRyaXhQb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gcmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICkge1xuXG5cdFx0XHRtYXRyaXhQb3NpdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubWF0cml4V29ybGQgKTtcblxuXHRcdFx0dmFyIGRpc3RhbmNlU3EgPSByYXljYXN0ZXIucmF5LmRpc3RhbmNlU3FUb1BvaW50KCBtYXRyaXhQb3NpdGlvbiApO1xuXHRcdFx0dmFyIGd1ZXNzU2l6ZVNxID0gdGhpcy5zY2FsZS54ICogdGhpcy5zY2FsZS55O1xuXG5cdFx0XHRpZiAoIGRpc3RhbmNlU3EgPiBndWVzc1NpemVTcSApIHtcblxuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdH1cblxuXHRcdFx0aW50ZXJzZWN0cy5wdXNoKCB7XG5cblx0XHRcdFx0ZGlzdGFuY2U6IE1hdGguc3FydCggZGlzdGFuY2VTcSApLFxuXHRcdFx0XHRwb2ludDogdGhpcy5wb3NpdGlvbixcblx0XHRcdFx0ZmFjZTogbnVsbCxcblx0XHRcdFx0b2JqZWN0OiB0aGlzXG5cblx0XHRcdH0gKTtcblxuXHRcdH07XG5cblx0fSgpICk7XG5cblx0VEhSRUUuU3ByaXRlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5tYXRlcmlhbCApLmNvcHkoIHRoaXMgKTtcblxuXHR9O1xuXG5cdC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cblx0VEhSRUUuUGFydGljbGUgPSBUSFJFRS5TcHJpdGU7XG5cblx0Ly8gRmlsZTpzcmMvb2JqZWN0cy9MZW5zRmxhcmUuanNcblxuXHQvKipcblx0ICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cblx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cblx0ICovXG5cblx0VEhSRUUuTGVuc0ZsYXJlID0gZnVuY3Rpb24gKCB0ZXh0dXJlLCBzaXplLCBkaXN0YW5jZSwgYmxlbmRpbmcsIGNvbG9yICkge1xuXG5cdFx0VEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG5cdFx0dGhpcy5sZW5zRmxhcmVzID0gW107XG5cblx0XHR0aGlzLnBvc2l0aW9uU2NyZWVuID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHR0aGlzLmN1c3RvbVVwZGF0ZUNhbGxiYWNrID0gdW5kZWZpbmVkO1xuXG5cdFx0aWYgKCB0ZXh0dXJlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHRoaXMuYWRkKCB0ZXh0dXJlLCBzaXplLCBkaXN0YW5jZSwgYmxlbmRpbmcsIGNvbG9yICk7XG5cblx0XHR9XG5cblx0fTtcblxuXHRUSFJFRS5MZW5zRmxhcmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XG5cdFRIUkVFLkxlbnNGbGFyZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5MZW5zRmxhcmU7XG5cblxuXHQvKlxuXHQgKiBBZGQ6IGFkZHMgYW5vdGhlciBmbGFyZVxuXHQgKi9cblxuXHRUSFJFRS5MZW5zRmxhcmUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICggdGV4dHVyZSwgc2l6ZSwgZGlzdGFuY2UsIGJsZW5kaW5nLCBjb2xvciwgb3BhY2l0eSApIHtcblxuXHRcdGlmICggc2l6ZSA9PT0gdW5kZWZpbmVkICkgc2l6ZSA9IC0gMTtcblx0XHRpZiAoIGRpc3RhbmNlID09PSB1bmRlZmluZWQgKSBkaXN0YW5jZSA9IDA7XG5cdFx0aWYgKCBvcGFjaXR5ID09PSB1bmRlZmluZWQgKSBvcGFjaXR5ID0gMTtcblx0XHRpZiAoIGNvbG9yID09PSB1bmRlZmluZWQgKSBjb2xvciA9IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKTtcblx0XHRpZiAoIGJsZW5kaW5nID09PSB1bmRlZmluZWQgKSBibGVuZGluZyA9IFRIUkVFLk5vcm1hbEJsZW5kaW5nO1xuXG5cdFx0ZGlzdGFuY2UgPSBNYXRoLm1pbiggZGlzdGFuY2UsIE1hdGgubWF4KCAwLCBkaXN0YW5jZSApICk7XG5cblx0XHR0aGlzLmxlbnNGbGFyZXMucHVzaCgge1xuXHRcdFx0dGV4dHVyZTogdGV4dHVyZSxcdC8vIFRIUkVFLlRleHR1cmVcblx0XHRcdHNpemU6IHNpemUsIFx0XHQvLyBzaXplIGluIHBpeGVscyAoLTEgPSB1c2UgdGV4dHVyZS53aWR0aClcblx0XHRcdGRpc3RhbmNlOiBkaXN0YW5jZSwgXHQvLyBkaXN0YW5jZSAoMC0xKSBmcm9tIGxpZ2h0IHNvdXJjZSAoMD1hdCBsaWdodCBzb3VyY2UpXG5cdFx0XHR4OiAwLCB5OiAwLCB6OiAwLFx0Ly8gc2NyZWVuIHBvc2l0aW9uICgtMSA9PiAxKSB6ID0gMCBpcyBpbiBmcm9udCB6ID0gMSBpcyBiYWNrXG5cdFx0XHRzY2FsZTogMSwgXHRcdC8vIHNjYWxlXG5cdFx0XHRyb3RhdGlvbjogMCwgXHRcdC8vIHJvdGF0aW9uXG5cdFx0XHRvcGFjaXR5OiBvcGFjaXR5LFx0Ly8gb3BhY2l0eVxuXHRcdFx0Y29sb3I6IGNvbG9yLFx0XHQvLyBjb2xvclxuXHRcdFx0YmxlbmRpbmc6IGJsZW5kaW5nXHQvLyBibGVuZGluZ1xuXHRcdH0gKTtcblxuXHR9O1xuXG5cdC8qXG5cdCAqIFVwZGF0ZSBsZW5zIGZsYXJlcyB1cGRhdGUgcG9zaXRpb25zIG9uIGFsbCBmbGFyZXMgYmFzZWQgb24gdGhlIHNjcmVlbiBwb3NpdGlvblxuXHQgKiBTZXQgbXlMZW5zRmxhcmUuY3VzdG9tVXBkYXRlQ2FsbGJhY2sgdG8gYWx0ZXIgdGhlIGZsYXJlcyBpbiB5b3VyIHByb2plY3Qgc3BlY2lmaWMgd2F5LlxuXHQgKi9cblxuXHRUSFJFRS5MZW5zRmxhcmUucHJvdG90eXBlLnVwZGF0ZUxlbnNGbGFyZXMgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgZiwgZmwgPSB0aGlzLmxlbnNGbGFyZXMubGVuZ3RoO1xuXHRcdHZhciBmbGFyZTtcblx0XHR2YXIgdmVjWCA9IC0gdGhpcy5wb3NpdGlvblNjcmVlbi54ICogMjtcblx0XHR2YXIgdmVjWSA9IC0gdGhpcy5wb3NpdGlvblNjcmVlbi55ICogMjtcblxuXHRcdGZvciAoIGYgPSAwOyBmIDwgZmw7IGYgKysgKSB7XG5cblx0XHRcdGZsYXJlID0gdGhpcy5sZW5zRmxhcmVzWyBmIF07XG5cblx0XHRcdGZsYXJlLnggPSB0aGlzLnBvc2l0aW9uU2NyZWVuLnggKyB2ZWNYICogZmxhcmUuZGlzdGFuY2U7XG5cdFx0XHRmbGFyZS55ID0gdGhpcy5wb3NpdGlvblNjcmVlbi55ICsgdmVjWSAqIGZsYXJlLmRpc3RhbmNlO1xuXG5cdFx0XHRmbGFyZS53YW50ZWRSb3RhdGlvbiA9IGZsYXJlLnggKiBNYXRoLlBJICogMC4yNTtcblx0XHRcdGZsYXJlLnJvdGF0aW9uICs9ICggZmxhcmUud2FudGVkUm90YXRpb24gLSBmbGFyZS5yb3RhdGlvbiApICogMC4yNTtcblxuXHRcdH1cblxuXHR9O1xuXG5cdFRIUkVFLkxlbnNGbGFyZS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xuXG5cdFx0VEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cblx0XHR0aGlzLnBvc2l0aW9uU2NyZWVuLmNvcHkoIHNvdXJjZS5wb3NpdGlvblNjcmVlbiApO1xuXHRcdHRoaXMuY3VzdG9tVXBkYXRlQ2FsbGJhY2sgPSBzb3VyY2UuY3VzdG9tVXBkYXRlQ2FsbGJhY2s7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBzb3VyY2UubGVuc0ZsYXJlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHR0aGlzLmxlbnNGbGFyZXMucHVzaCggc291cmNlLmxlbnNGbGFyZXNbIGkgXSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHQvLyBGaWxlOnNyYy9zY2VuZXMvU2NlbmUuanNcblxuXHQvKipcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICovXG5cblx0VEhSRUUuU2NlbmUgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cblx0XHR0aGlzLnR5cGUgPSAnU2NlbmUnO1xuXG5cdFx0dGhpcy5mb2cgPSBudWxsO1xuXHRcdHRoaXMub3ZlcnJpZGVNYXRlcmlhbCA9IG51bGw7XG5cblx0XHR0aGlzLmF1dG9VcGRhdGUgPSB0cnVlOyAvLyBjaGVja2VkIGJ5IHRoZSByZW5kZXJlclxuXG5cdH07XG5cblx0VEhSRUUuU2NlbmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XG5cdFRIUkVFLlNjZW5lLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlNjZW5lO1xuXG5cdFRIUkVFLlNjZW5lLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cblx0XHRUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuXHRcdGlmICggc291cmNlLmZvZyAhPT0gbnVsbCApIHRoaXMuZm9nID0gc291cmNlLmZvZy5jbG9uZSgpO1xuXHRcdGlmICggc291cmNlLm92ZXJyaWRlTWF0ZXJpYWwgIT09IG51bGwgKSB0aGlzLm92ZXJyaWRlTWF0ZXJpYWwgPSBzb3VyY2Uub3ZlcnJpZGVNYXRlcmlhbC5jbG9uZSgpO1xuXG5cdFx0dGhpcy5hdXRvVXBkYXRlID0gc291cmNlLmF1dG9VcGRhdGU7XG5cdFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gc291cmNlLm1hdHJpeEF1dG9VcGRhdGU7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdC8vIEZpbGU6c3JjL3NjZW5lcy9Gb2cuanNcblxuXHQvKipcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cblx0ICovXG5cblx0VEhSRUUuRm9nID0gZnVuY3Rpb24gKCBjb2xvciwgbmVhciwgZmFyICkge1xuXG5cdFx0dGhpcy5uYW1lID0gJyc7XG5cblx0XHR0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCBjb2xvciApO1xuXG5cdFx0dGhpcy5uZWFyID0gKCBuZWFyICE9PSB1bmRlZmluZWQgKSA/IG5lYXIgOiAxO1xuXHRcdHRoaXMuZmFyID0gKCBmYXIgIT09IHVuZGVmaW5lZCApID8gZmFyIDogMTAwMDtcblxuXHR9O1xuXG5cdFRIUkVFLkZvZy5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gbmV3IFRIUkVFLkZvZyggdGhpcy5jb2xvci5nZXRIZXgoKSwgdGhpcy5uZWFyLCB0aGlzLmZhciApO1xuXG5cdH07XG5cblx0Ly8gRmlsZTpzcmMvc2NlbmVzL0ZvZ0V4cDIuanNcblxuXHQvKipcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cblx0ICovXG5cblx0VEhSRUUuRm9nRXhwMiA9IGZ1bmN0aW9uICggY29sb3IsIGRlbnNpdHkgKSB7XG5cblx0XHR0aGlzLm5hbWUgPSAnJztcblxuXHRcdHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIGNvbG9yICk7XG5cdFx0dGhpcy5kZW5zaXR5ID0gKCBkZW5zaXR5ICE9PSB1bmRlZmluZWQgKSA/IGRlbnNpdHkgOiAwLjAwMDI1O1xuXG5cdH07XG5cblx0VEhSRUUuRm9nRXhwMi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gbmV3IFRIUkVFLkZvZ0V4cDIoIHRoaXMuY29sb3IuZ2V0SGV4KCksIHRoaXMuZGVuc2l0eSApO1xuXG5cdH07XG5cblx0Ly8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsuanNcblxuXHRUSFJFRS5TaGFkZXJDaHVuayA9IHt9O1xuXG5cdC8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2FscGhhbWFwX2ZyYWdtZW50Lmdsc2xcblxuXHRUSFJFRS5TaGFkZXJDaHVua1sgJ2FscGhhbWFwX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfQUxQSEFNQVBcXG5cXG5cdGRpZmZ1c2VDb2xvci5hICo9IHRleHR1cmUyRCggYWxwaGFNYXAsIHZVdiApLmc7XFxuXFxuI2VuZGlmXFxuXCI7XG5cblx0Ly8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvYWxwaGFtYXBfcGFyc19mcmFnbWVudC5nbHNsXG5cblx0VEhSRUUuU2hhZGVyQ2h1bmtbICdhbHBoYW1hcF9wYXJzX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfQUxQSEFNQVBcXG5cXG5cdHVuaWZvcm0gc2FtcGxlcjJEIGFscGhhTWFwO1xcblxcbiNlbmRpZlxcblwiO1xuXG5cdC8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2FscGhhdGVzdF9mcmFnbWVudC5nbHNsXG5cblx0VEhSRUUuU2hhZGVyQ2h1bmtbICdhbHBoYXRlc3RfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIEFMUEhBVEVTVFxcblxcblx0aWYgKCBkaWZmdXNlQ29sb3IuYSA8IEFMUEhBVEVTVCApIGRpc2NhcmQ7XFxuXFxuI2VuZGlmXFxuXCI7XG5cblx0Ly8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvYW9tYXBfZnJhZ21lbnQuZ2xzbFxuXG5cdFRIUkVFLlNoYWRlckNodW5rWyAnYW9tYXBfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIFVTRV9BT01BUFxcblxcblx0dG90YWxBbWJpZW50TGlnaHQgKj0gKCB0ZXh0dXJlMkQoIGFvTWFwLCB2VXYyICkuciAtIDEuMCApICogYW9NYXBJbnRlbnNpdHkgKyAxLjA7XFxuXFxuI2VuZGlmXFxuXCI7XG5cblx0Ly8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvYW9tYXBfcGFyc19mcmFnbWVudC5nbHNsXG5cblx0VEhSRUUuU2hhZGVyQ2h1bmtbICdhb21hcF9wYXJzX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfQU9NQVBcXG5cXG5cdHVuaWZvcm0gc2FtcGxlcjJEIGFvTWFwO1xcblx0dW5pZm9ybSBmbG9hdCBhb01hcEludGVuc2l0eTtcXG5cXG4jZW5kaWZcIjtcblxuXHQvLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9iZWdpbl92ZXJ0ZXguZ2xzbFxuXG5cdFRIUkVFLlNoYWRlckNodW5rWyAnYmVnaW5fdmVydGV4J10gPSBcIlxcbnZlYzMgdHJhbnNmb3JtZWQgPSB2ZWMzKCBwb3NpdGlvbiApO1xcblwiO1xuXG5cdC8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2JlZ2lubm9ybWFsX3ZlcnRleC5nbHNsXG5cblx0VEhSRUUuU2hhZGVyQ2h1bmtbICdiZWdpbm5vcm1hbF92ZXJ0ZXgnXSA9IFwiXFxudmVjMyBvYmplY3ROb3JtYWwgPSB2ZWMzKCBub3JtYWwgKTtcXG5cIjtcblxuXHQvLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9idW1wbWFwX3BhcnNfZnJhZ21lbnQuZ2xzbFxuXG5cdFRIUkVFLlNoYWRlckNodW5rWyAnYnVtcG1hcF9wYXJzX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfQlVNUE1BUFxcblxcblx0dW5pZm9ybSBzYW1wbGVyMkQgYnVtcE1hcDtcXG5cdHVuaWZvcm0gZmxvYXQgYnVtcFNjYWxlO1xcblxcblxcblxcblx0dmVjMiBkSGR4eV9md2QoKSB7XFxuXFxuXHRcdHZlYzIgZFNUZHggPSBkRmR4KCB2VXYgKTtcXG5cdFx0dmVjMiBkU1RkeSA9IGRGZHkoIHZVdiApO1xcblxcblx0XHRmbG9hdCBIbGwgPSBidW1wU2NhbGUgKiB0ZXh0dXJlMkQoIGJ1bXBNYXAsIHZVdiApLng7XFxuXHRcdGZsb2F0IGRCeCA9IGJ1bXBTY2FsZSAqIHRleHR1cmUyRCggYnVtcE1hcCwgdlV2ICsgZFNUZHggKS54IC0gSGxsO1xcblx0XHRmbG9hdCBkQnkgPSBidW1wU2NhbGUgKiB0ZXh0dXJlMkQoIGJ1bXBNYXAsIHZVdiArIGRTVGR5ICkueCAtIEhsbDtcXG5cXG5cdFx0cmV0dXJuIHZlYzIoIGRCeCwgZEJ5ICk7XFxuXFxuXHR9XFxuXFxuXHR2ZWMzIHBlcnR1cmJOb3JtYWxBcmIoIHZlYzMgc3VyZl9wb3MsIHZlYzMgc3VyZl9ub3JtLCB2ZWMyIGRIZHh5ICkge1xcblxcblx0XHR2ZWMzIHZTaWdtYVggPSBkRmR4KCBzdXJmX3BvcyApO1xcblx0XHR2ZWMzIHZTaWdtYVkgPSBkRmR5KCBzdXJmX3BvcyApO1xcblx0XHR2ZWMzIHZOID0gc3VyZl9ub3JtO1xcblx0XHR2ZWMzIFIxID0gY3Jvc3MoIHZTaWdtYVksIHZOICk7XFxuXHRcdHZlYzMgUjIgPSBjcm9zcyggdk4sIHZTaWdtYVggKTtcXG5cXG5cdFx0ZmxvYXQgZkRldCA9IGRvdCggdlNpZ21hWCwgUjEgKTtcXG5cXG5cdFx0dmVjMyB2R3JhZCA9IHNpZ24oIGZEZXQgKSAqICggZEhkeHkueCAqIFIxICsgZEhkeHkueSAqIFIyICk7XFxuXHRcdHJldHVybiBub3JtYWxpemUoIGFicyggZkRldCApICogc3VyZl9ub3JtIC0gdkdyYWQgKTtcXG5cXG5cdH1cXG5cXG4jZW5kaWZcXG5cIjtcblxuXHQvLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9jb2xvcl9mcmFnbWVudC5nbHNsXG5cblx0VEhSRUUuU2hhZGVyQ2h1bmtbICdjb2xvcl9mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX0NPTE9SXFxuXFxuXHRkaWZmdXNlQ29sb3IucmdiICo9IHZDb2xvcjtcXG5cXG4jZW5kaWZcIjtcblxuXHQvLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9jb2xvcl9wYXJzX2ZyYWdtZW50Lmdsc2xcblxuXHRUSFJFRS5TaGFkZXJDaHVua1sgJ2NvbG9yX3BhcnNfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIFVTRV9DT0xPUlxcblxcblx0dmFyeWluZyB2ZWMzIHZDb2xvcjtcXG5cXG4jZW5kaWZcXG5cIjtcblxuXHQvLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9jb2xvcl9wYXJzX3ZlcnRleC5nbHNsXG5cblx0VEhSRUUuU2hhZGVyQ2h1bmtbICdjb2xvcl9wYXJzX3ZlcnRleCddID0gXCIjaWZkZWYgVVNFX0NPTE9SXFxuXFxuXHR2YXJ5aW5nIHZlYzMgdkNvbG9yO1xcblxcbiNlbmRpZlwiO1xuXG5cdC8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2NvbG9yX3ZlcnRleC5nbHNsXG5cblx0VEhSRUUuU2hhZGVyQ2h1bmtbICdjb2xvcl92ZXJ0ZXgnXSA9IFwiI2lmZGVmIFVTRV9DT0xPUlxcblxcblx0dkNvbG9yLnh5eiA9IGNvbG9yLnh5ejtcXG5cXG4jZW5kaWZcIjtcblxuXHQvLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9jb21tb24uZ2xzbFxuXG5cdFRIUkVFLlNoYWRlckNodW5rWyAnY29tbW9uJ10gPSBcIiNkZWZpbmUgUEkgMy4xNDE1OVxcbiNkZWZpbmUgUEkyIDYuMjgzMThcXG4jZGVmaW5lIFJFQ0lQUk9DQUxfUEkyIDAuMTU5MTU0OTRcXG4jZGVmaW5lIExPRzIgMS40NDI2OTVcXG4jZGVmaW5lIEVQU0lMT04gMWUtNlxcblxcbiNkZWZpbmUgc2F0dXJhdGUoYSkgY2xhbXAoIGEsIDAuMCwgMS4wIClcXG4jZGVmaW5lIHdoaXRlQ29tcGxpbWVudChhKSAoIDEuMCAtIHNhdHVyYXRlKCBhICkgKVxcblxcbnZlYzMgdHJhbnNmb3JtRGlyZWN0aW9uKCBpbiB2ZWMzIG5vcm1hbCwgaW4gbWF0NCBtYXRyaXggKSB7XFxuXFxuXHRyZXR1cm4gbm9ybWFsaXplKCAoIG1hdHJpeCAqIHZlYzQoIG5vcm1hbCwgMC4wICkgKS54eXogKTtcXG5cXG59XFxuXFxudmVjMyBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCBpbiB2ZWMzIG5vcm1hbCwgaW4gbWF0NCBtYXRyaXggKSB7XFxuXFxuXHRyZXR1cm4gbm9ybWFsaXplKCAoIHZlYzQoIG5vcm1hbCwgMC4wICkgKiBtYXRyaXggKS54eXogKTtcXG5cXG59XFxuXFxudmVjMyBwcm9qZWN0T25QbGFuZShpbiB2ZWMzIHBvaW50LCBpbiB2ZWMzIHBvaW50T25QbGFuZSwgaW4gdmVjMyBwbGFuZU5vcm1hbCApIHtcXG5cXG5cdGZsb2F0IGRpc3RhbmNlID0gZG90KCBwbGFuZU5vcm1hbCwgcG9pbnQgLSBwb2ludE9uUGxhbmUgKTtcXG5cXG5cdHJldHVybiAtIGRpc3RhbmNlICogcGxhbmVOb3JtYWwgKyBwb2ludDtcXG5cXG59XFxuXFxuZmxvYXQgc2lkZU9mUGxhbmUoIGluIHZlYzMgcG9pbnQsIGluIHZlYzMgcG9pbnRPblBsYW5lLCBpbiB2ZWMzIHBsYW5lTm9ybWFsICkge1xcblxcblx0cmV0dXJuIHNpZ24oIGRvdCggcG9pbnQgLSBwb2ludE9uUGxhbmUsIHBsYW5lTm9ybWFsICkgKTtcXG5cXG59XFxuXFxudmVjMyBsaW5lUGxhbmVJbnRlcnNlY3QoIGluIHZlYzMgcG9pbnRPbkxpbmUsIGluIHZlYzMgbGluZURpcmVjdGlvbiwgaW4gdmVjMyBwb2ludE9uUGxhbmUsIGluIHZlYzMgcGxhbmVOb3JtYWwgKSB7XFxuXFxuXHRyZXR1cm4gbGluZURpcmVjdGlvbiAqICggZG90KCBwbGFuZU5vcm1hbCwgcG9pbnRPblBsYW5lIC0gcG9pbnRPbkxpbmUgKSAvIGRvdCggcGxhbmVOb3JtYWwsIGxpbmVEaXJlY3Rpb24gKSApICsgcG9pbnRPbkxpbmU7XFxuXFxufVxcblxcbmZsb2F0IGNhbGNMaWdodEF0dGVudWF0aW9uKCBmbG9hdCBsaWdodERpc3RhbmNlLCBmbG9hdCBjdXRvZmZEaXN0YW5jZSwgZmxvYXQgZGVjYXlFeHBvbmVudCApIHtcXG5cXG5cdGlmICggZGVjYXlFeHBvbmVudCA+IDAuMCApIHtcXG5cXG5cdCAgcmV0dXJuIHBvdyggc2F0dXJhdGUoIC1saWdodERpc3RhbmNlIC8gY3V0b2ZmRGlzdGFuY2UgKyAxLjAgKSwgZGVjYXlFeHBvbmVudCApO1xcblxcblx0fVxcblxcblx0cmV0dXJuIDEuMDtcXG5cXG59XFxuXFxudmVjMyBGX1NjaGxpY2soIGluIHZlYzMgc3BlY3VsYXJDb2xvciwgaW4gZmxvYXQgZG90TEggKSB7XFxuXFxuXFxuXHRmbG9hdCBmcmVzbmVsID0gZXhwMiggKCAtNS41NTQzNyAqIGRvdExIIC0gNi45ODMxNiApICogZG90TEggKTtcXG5cXG5cdHJldHVybiAoIDEuMCAtIHNwZWN1bGFyQ29sb3IgKSAqIGZyZXNuZWwgKyBzcGVjdWxhckNvbG9yO1xcblxcbn1cXG5cXG5mbG9hdCBHX0JsaW5uUGhvbmdfSW1wbGljaXQoIC8qIGluIGZsb2F0IGRvdE5MLCBpbiBmbG9hdCBkb3ROViAqLyApIHtcXG5cXG5cXG5cdHJldHVybiAwLjI1O1xcblxcbn1cXG5cXG5mbG9hdCBEX0JsaW5uUGhvbmcoIGluIGZsb2F0IHNoaW5pbmVzcywgaW4gZmxvYXQgZG90TkggKSB7XFxuXFxuXFxuXHRyZXR1cm4gKCBzaGluaW5lc3MgKiAwLjUgKyAxLjAgKSAqIHBvdyggZG90TkgsIHNoaW5pbmVzcyApO1xcblxcbn1cXG5cXG52ZWMzIEJSREZfQmxpbm5QaG9uZyggaW4gdmVjMyBzcGVjdWxhckNvbG9yLCBpbiBmbG9hdCBzaGluaW5lc3MsIGluIHZlYzMgbm9ybWFsLCBpbiB2ZWMzIGxpZ2h0RGlyLCBpbiB2ZWMzIHZpZXdEaXIgKSB7XFxuXFxuXHR2ZWMzIGhhbGZEaXIgPSBub3JtYWxpemUoIGxpZ2h0RGlyICsgdmlld0RpciApO1xcblxcblx0ZmxvYXQgZG90TkggPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIGhhbGZEaXIgKSApO1xcblx0ZmxvYXQgZG90TEggPSBzYXR1cmF0ZSggZG90KCBsaWdodERpciwgaGFsZkRpciApICk7XFxuXFxuXHR2ZWMzIEYgPSBGX1NjaGxpY2soIHNwZWN1bGFyQ29sb3IsIGRvdExIICk7XFxuXFxuXHRmbG9hdCBHID0gR19CbGlublBob25nX0ltcGxpY2l0KCAvKiBkb3ROTCwgZG90TlYgKi8gKTtcXG5cXG5cdGZsb2F0IEQgPSBEX0JsaW5uUGhvbmcoIHNoaW5pbmVzcywgZG90TkggKTtcXG5cXG5cdHJldHVybiBGICogRyAqIEQ7XFxuXFxufVxcblxcbnZlYzMgaW5wdXRUb0xpbmVhciggaW4gdmVjMyBhICkge1xcblxcblx0I2lmZGVmIEdBTU1BX0lOUFVUXFxuXFxuXHRcdHJldHVybiBwb3coIGEsIHZlYzMoIGZsb2F0KCBHQU1NQV9GQUNUT1IgKSApICk7XFxuXFxuXHQjZWxzZVxcblxcblx0XHRyZXR1cm4gYTtcXG5cXG5cdCNlbmRpZlxcblxcbn1cXG5cXG52ZWMzIGxpbmVhclRvT3V0cHV0KCBpbiB2ZWMzIGEgKSB7XFxuXFxuXHQjaWZkZWYgR0FNTUFfT1VUUFVUXFxuXFxuXHRcdHJldHVybiBwb3coIGEsIHZlYzMoIDEuMCAvIGZsb2F0KCBHQU1NQV9GQUNUT1IgKSApICk7XFxuXFxuXHQjZWxzZVxcblxcblx0XHRyZXR1cm4gYTtcXG5cXG5cdCNlbmRpZlxcblxcbn1cXG5cIjtcblxuXHQvLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9kZWZhdWx0bm9ybWFsX3ZlcnRleC5nbHNsXG5cblx0VEhSRUUuU2hhZGVyQ2h1bmtbICdkZWZhdWx0bm9ybWFsX3ZlcnRleCddID0gXCIjaWZkZWYgRkxJUF9TSURFRFxcblxcblx0b2JqZWN0Tm9ybWFsID0gLW9iamVjdE5vcm1hbDtcXG5cXG4jZW5kaWZcXG5cXG52ZWMzIHRyYW5zZm9ybWVkTm9ybWFsID0gbm9ybWFsTWF0cml4ICogb2JqZWN0Tm9ybWFsO1xcblwiO1xuXG5cdC8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2Rpc3BsYWNlbWVudG1hcF92ZXJ0ZXguZ2xzbFxuXG5cdFRIUkVFLlNoYWRlckNodW5rWyAnZGlzcGxhY2VtZW50bWFwX3ZlcnRleCddID0gXCIjaWZkZWYgVVNFX0RJU1BMQUNFTUVOVE1BUFxcblxcblx0dHJhbnNmb3JtZWQgKz0gbm9ybWFsICogKCB0ZXh0dXJlMkQoIGRpc3BsYWNlbWVudE1hcCwgdXYgKS54ICogZGlzcGxhY2VtZW50U2NhbGUgKyBkaXNwbGFjZW1lbnRCaWFzICk7XFxuXFxuI2VuZGlmXFxuXCI7XG5cblx0Ly8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4Lmdsc2xcblxuXHRUSFJFRS5TaGFkZXJDaHVua1sgJ2Rpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleCddID0gXCIjaWZkZWYgVVNFX0RJU1BMQUNFTUVOVE1BUFxcblxcblx0dW5pZm9ybSBzYW1wbGVyMkQgZGlzcGxhY2VtZW50TWFwO1xcblx0dW5pZm9ybSBmbG9hdCBkaXNwbGFjZW1lbnRTY2FsZTtcXG5cdHVuaWZvcm0gZmxvYXQgZGlzcGxhY2VtZW50QmlhcztcXG5cXG4jZW5kaWZcXG5cIjtcblxuXHQvLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9lbWlzc2l2ZW1hcF9mcmFnbWVudC5nbHNsXG5cblx0VEhSRUUuU2hhZGVyQ2h1bmtbICdlbWlzc2l2ZW1hcF9mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX0VNSVNTSVZFTUFQXFxuXFxuXHR2ZWM0IGVtaXNzaXZlQ29sb3IgPSB0ZXh0dXJlMkQoIGVtaXNzaXZlTWFwLCB2VXYgKTtcXG5cXG5cdGVtaXNzaXZlQ29sb3IucmdiID0gaW5wdXRUb0xpbmVhciggZW1pc3NpdmVDb2xvci5yZ2IgKTtcXG5cXG5cdHRvdGFsRW1pc3NpdmVMaWdodCAqPSBlbWlzc2l2ZUNvbG9yLnJnYjtcXG5cXG4jZW5kaWZcXG5cIjtcblxuXHQvLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9lbWlzc2l2ZW1hcF9wYXJzX2ZyYWdtZW50Lmdsc2xcblxuXHRUSFJFRS5TaGFkZXJDaHVua1sgJ2VtaXNzaXZlbWFwX3BhcnNfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIFVTRV9FTUlTU0lWRU1BUFxcblxcblx0dW5pZm9ybSBzYW1wbGVyMkQgZW1pc3NpdmVNYXA7XFxuXFxuI2VuZGlmXFxuXCI7XG5cblx0Ly8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvZW52bWFwX2ZyYWdtZW50Lmdsc2xcblxuXHRUSFJFRS5TaGFkZXJDaHVua1sgJ2Vudm1hcF9mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX0VOVk1BUFxcblxcblx0I2lmIGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApIHx8IGRlZmluZWQoIFBIT05HIClcXG5cXG5cdFx0dmVjMyBjYW1lcmFUb1ZlcnRleCA9IG5vcm1hbGl6ZSggdldvcmxkUG9zaXRpb24gLSBjYW1lcmFQb3NpdGlvbiApO1xcblxcblx0XHR2ZWMzIHdvcmxkTm9ybWFsID0gaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggbm9ybWFsLCB2aWV3TWF0cml4ICk7XFxuXFxuXHRcdCNpZmRlZiBFTlZNQVBfTU9ERV9SRUZMRUNUSU9OXFxuXFxuXHRcdFx0dmVjMyByZWZsZWN0VmVjID0gcmVmbGVjdCggY2FtZXJhVG9WZXJ0ZXgsIHdvcmxkTm9ybWFsICk7XFxuXFxuXHRcdCNlbHNlXFxuXFxuXHRcdFx0dmVjMyByZWZsZWN0VmVjID0gcmVmcmFjdCggY2FtZXJhVG9WZXJ0ZXgsIHdvcmxkTm9ybWFsLCByZWZyYWN0aW9uUmF0aW8gKTtcXG5cXG5cdFx0I2VuZGlmXFxuXFxuXHQjZWxzZVxcblxcblx0XHR2ZWMzIHJlZmxlY3RWZWMgPSB2UmVmbGVjdDtcXG5cXG5cdCNlbmRpZlxcblxcblx0I2lmZGVmIERPVUJMRV9TSURFRFxcblx0XHRmbG9hdCBmbGlwTm9ybWFsID0gKCBmbG9hdCggZ2xfRnJvbnRGYWNpbmcgKSAqIDIuMCAtIDEuMCApO1xcblx0I2Vsc2VcXG5cdFx0ZmxvYXQgZmxpcE5vcm1hbCA9IDEuMDtcXG5cdCNlbmRpZlxcblxcblx0I2lmZGVmIEVOVk1BUF9UWVBFX0NVQkVcXG5cdFx0dmVjNCBlbnZDb2xvciA9IHRleHR1cmVDdWJlKCBlbnZNYXAsIGZsaXBOb3JtYWwgKiB2ZWMzKCBmbGlwRW52TWFwICogcmVmbGVjdFZlYy54LCByZWZsZWN0VmVjLnl6ICkgKTtcXG5cXG5cdCNlbGlmIGRlZmluZWQoIEVOVk1BUF9UWVBFX0VRVUlSRUMgKVxcblx0XHR2ZWMyIHNhbXBsZVVWO1xcblx0XHRzYW1wbGVVVi55ID0gc2F0dXJhdGUoIGZsaXBOb3JtYWwgKiByZWZsZWN0VmVjLnkgKiAwLjUgKyAwLjUgKTtcXG5cdFx0c2FtcGxlVVYueCA9IGF0YW4oIGZsaXBOb3JtYWwgKiByZWZsZWN0VmVjLnosIGZsaXBOb3JtYWwgKiByZWZsZWN0VmVjLnggKSAqIFJFQ0lQUk9DQUxfUEkyICsgMC41O1xcblx0XHR2ZWM0IGVudkNvbG9yID0gdGV4dHVyZTJEKCBlbnZNYXAsIHNhbXBsZVVWICk7XFxuXFxuXHQjZWxpZiBkZWZpbmVkKCBFTlZNQVBfVFlQRV9TUEhFUkUgKVxcblx0XHR2ZWMzIHJlZmxlY3RWaWV3ID0gZmxpcE5vcm1hbCAqIG5vcm1hbGl6ZSgodmlld01hdHJpeCAqIHZlYzQoIHJlZmxlY3RWZWMsIDAuMCApKS54eXogKyB2ZWMzKDAuMCwwLjAsMS4wKSk7XFxuXHRcdHZlYzQgZW52Q29sb3IgPSB0ZXh0dXJlMkQoIGVudk1hcCwgcmVmbGVjdFZpZXcueHkgKiAwLjUgKyAwLjUgKTtcXG5cdCNlbmRpZlxcblxcblx0ZW52Q29sb3IueHl6ID0gaW5wdXRUb0xpbmVhciggZW52Q29sb3IueHl6ICk7XFxuXFxuXHQjaWZkZWYgRU5WTUFQX0JMRU5ESU5HX01VTFRJUExZXFxuXFxuXHRcdG91dGdvaW5nTGlnaHQgPSBtaXgoIG91dGdvaW5nTGlnaHQsIG91dGdvaW5nTGlnaHQgKiBlbnZDb2xvci54eXosIHNwZWN1bGFyU3RyZW5ndGggKiByZWZsZWN0aXZpdHkgKTtcXG5cXG5cdCNlbGlmIGRlZmluZWQoIEVOVk1BUF9CTEVORElOR19NSVggKVxcblxcblx0XHRvdXRnb2luZ0xpZ2h0ID0gbWl4KCBvdXRnb2luZ0xpZ2h0LCBlbnZDb2xvci54eXosIHNwZWN1bGFyU3RyZW5ndGggKiByZWZsZWN0aXZpdHkgKTtcXG5cXG5cdCNlbGlmIGRlZmluZWQoIEVOVk1BUF9CTEVORElOR19BREQgKVxcblxcblx0XHRvdXRnb2luZ0xpZ2h0ICs9IGVudkNvbG9yLnh5eiAqIHNwZWN1bGFyU3RyZW5ndGggKiByZWZsZWN0aXZpdHk7XFxuXFxuXHQjZW5kaWZcXG5cXG4jZW5kaWZcXG5cIjtcblxuXHQvLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9lbnZtYXBfcGFyc19mcmFnbWVudC5nbHNsXG5cblx0VEhSRUUuU2hhZGVyQ2h1bmtbICdlbnZtYXBfcGFyc19mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX0VOVk1BUFxcblxcblx0dW5pZm9ybSBmbG9hdCByZWZsZWN0aXZpdHk7XFxuXHQjaWZkZWYgRU5WTUFQX1RZUEVfQ1VCRVxcblx0XHR1bmlmb3JtIHNhbXBsZXJDdWJlIGVudk1hcDtcXG5cdCNlbHNlXFxuXHRcdHVuaWZvcm0gc2FtcGxlcjJEIGVudk1hcDtcXG5cdCNlbmRpZlxcblx0dW5pZm9ybSBmbG9hdCBmbGlwRW52TWFwO1xcblxcblx0I2lmIGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApIHx8IGRlZmluZWQoIFBIT05HIClcXG5cXG5cdFx0dW5pZm9ybSBmbG9hdCByZWZyYWN0aW9uUmF0aW87XFxuXFxuXHQjZWxzZVxcblxcblx0XHR2YXJ5aW5nIHZlYzMgdlJlZmxlY3Q7XFxuXFxuXHQjZW5kaWZcXG5cXG4jZW5kaWZcXG5cIjtcblxuXHQvLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9lbnZtYXBfcGFyc192ZXJ0ZXguZ2xzbFxuXG5cdFRIUkVFLlNoYWRlckNodW5rWyAnZW52bWFwX3BhcnNfdmVydGV4J10gPSBcIiNpZiBkZWZpbmVkKCBVU0VfRU5WTUFQICkgJiYgISBkZWZpbmVkKCBVU0VfQlVNUE1BUCApICYmICEgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApICYmICEgZGVmaW5lZCggUEhPTkcgKVxcblxcblx0dmFyeWluZyB2ZWMzIHZSZWZsZWN0O1xcblxcblx0dW5pZm9ybSBmbG9hdCByZWZyYWN0aW9uUmF0aW87XFxuXFxuI2VuZGlmXFxuXCI7XG5cblx0Ly8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvZW52bWFwX3ZlcnRleC5nbHNsXG5cblx0VEhSRUUuU2hhZGVyQ2h1bmtbICdlbnZtYXBfdmVydGV4J10gPSBcIiNpZiBkZWZpbmVkKCBVU0VfRU5WTUFQICkgJiYgISBkZWZpbmVkKCBVU0VfQlVNUE1BUCApICYmICEgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApICYmICEgZGVmaW5lZCggUEhPTkcgKVxcblxcblx0dmVjMyBjYW1lcmFUb1ZlcnRleCA9IG5vcm1hbGl6ZSggd29ybGRQb3NpdGlvbi54eXogLSBjYW1lcmFQb3NpdGlvbiApO1xcblxcblx0dmVjMyB3b3JsZE5vcm1hbCA9IGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIHRyYW5zZm9ybWVkTm9ybWFsLCB2aWV3TWF0cml4ICk7XFxuXFxuXHQjaWZkZWYgRU5WTUFQX01PREVfUkVGTEVDVElPTlxcblxcblx0XHR2UmVmbGVjdCA9IHJlZmxlY3QoIGNhbWVyYVRvVmVydGV4LCB3b3JsZE5vcm1hbCApO1xcblxcblx0I2Vsc2VcXG5cXG5cdFx0dlJlZmxlY3QgPSByZWZyYWN0KCBjYW1lcmFUb1ZlcnRleCwgd29ybGROb3JtYWwsIHJlZnJhY3Rpb25SYXRpbyApO1xcblxcblx0I2VuZGlmXFxuXFxuI2VuZGlmXFxuXCI7XG5cblx0Ly8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvZm9nX2ZyYWdtZW50Lmdsc2xcblxuXHRUSFJFRS5TaGFkZXJDaHVua1sgJ2ZvZ19mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX0ZPR1xcblxcblx0I2lmZGVmIFVTRV9MT0dERVBUSEJVRl9FWFRcXG5cXG5cdFx0ZmxvYXQgZGVwdGggPSBnbF9GcmFnRGVwdGhFWFQgLyBnbF9GcmFnQ29vcmQudztcXG5cXG5cdCNlbHNlXFxuXFxuXHRcdGZsb2F0IGRlcHRoID0gZ2xfRnJhZ0Nvb3JkLnogLyBnbF9GcmFnQ29vcmQudztcXG5cXG5cdCNlbmRpZlxcblxcblx0I2lmZGVmIEZPR19FWFAyXFxuXFxuXHRcdGZsb2F0IGZvZ0ZhY3RvciA9IHdoaXRlQ29tcGxpbWVudCggZXhwMiggLSBmb2dEZW5zaXR5ICogZm9nRGVuc2l0eSAqIGRlcHRoICogZGVwdGggKiBMT0cyICkgKTtcXG5cXG5cdCNlbHNlXFxuXFxuXHRcdGZsb2F0IGZvZ0ZhY3RvciA9IHNtb290aHN0ZXAoIGZvZ05lYXIsIGZvZ0ZhciwgZGVwdGggKTtcXG5cXG5cdCNlbmRpZlxcblx0XFxuXHRvdXRnb2luZ0xpZ2h0ID0gbWl4KCBvdXRnb2luZ0xpZ2h0LCBmb2dDb2xvciwgZm9nRmFjdG9yICk7XFxuXFxuI2VuZGlmXCI7XG5cblx0Ly8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvZm9nX3BhcnNfZnJhZ21lbnQuZ2xzbFxuXG5cdFRIUkVFLlNoYWRlckNodW5rWyAnZm9nX3BhcnNfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIFVTRV9GT0dcXG5cXG5cdHVuaWZvcm0gdmVjMyBmb2dDb2xvcjtcXG5cXG5cdCNpZmRlZiBGT0dfRVhQMlxcblxcblx0XHR1bmlmb3JtIGZsb2F0IGZvZ0RlbnNpdHk7XFxuXFxuXHQjZWxzZVxcblxcblx0XHR1bmlmb3JtIGZsb2F0IGZvZ05lYXI7XFxuXHRcdHVuaWZvcm0gZmxvYXQgZm9nRmFyO1xcblx0I2VuZGlmXFxuXFxuI2VuZGlmXCI7XG5cblx0Ly8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvaGVtaWxpZ2h0X2ZyYWdtZW50Lmdsc2xcblxuXHRUSFJFRS5TaGFkZXJDaHVua1sgJ2hlbWlsaWdodF9mcmFnbWVudCddID0gXCIjaWYgTUFYX0hFTUlfTElHSFRTID4gMFxcblxcblx0Zm9yICggaW50IGkgPSAwOyBpIDwgTUFYX0hFTUlfTElHSFRTOyBpICsrICkge1xcblxcblx0XHR2ZWMzIGxpZ2h0RGlyID0gaGVtaXNwaGVyZUxpZ2h0RGlyZWN0aW9uWyBpIF07XFxuXFxuXHRcdGZsb2F0IGRvdFByb2R1Y3QgPSBkb3QoIG5vcm1hbCwgbGlnaHREaXIgKTtcXG5cXG5cdFx0ZmxvYXQgaGVtaURpZmZ1c2VXZWlnaHQgPSAwLjUgKiBkb3RQcm9kdWN0ICsgMC41O1xcblxcblx0XHR2ZWMzIGxpZ2h0Q29sb3IgPSBtaXgoIGhlbWlzcGhlcmVMaWdodEdyb3VuZENvbG9yWyBpIF0sIGhlbWlzcGhlcmVMaWdodFNreUNvbG9yWyBpIF0sIGhlbWlEaWZmdXNlV2VpZ2h0ICk7XFxuXFxuXHRcdHRvdGFsQW1iaWVudExpZ2h0ICs9IGxpZ2h0Q29sb3I7XFxuXFxuXHR9XFxuXFxuI2VuZGlmXFxuXFxuXCI7XG5cblx0Ly8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbGlnaHRtYXBfZnJhZ21lbnQuZ2xzbFxuXG5cdFRIUkVFLlNoYWRlckNodW5rWyAnbGlnaHRtYXBfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIFVTRV9MSUdIVE1BUFxcblxcblx0dG90YWxBbWJpZW50TGlnaHQgKz0gdGV4dHVyZTJEKCBsaWdodE1hcCwgdlV2MiApLnh5eiAqIGxpZ2h0TWFwSW50ZW5zaXR5O1xcblxcbiNlbmRpZlxcblwiO1xuXG5cdC8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xpZ2h0bWFwX3BhcnNfZnJhZ21lbnQuZ2xzbFxuXG5cdFRIUkVFLlNoYWRlckNodW5rWyAnbGlnaHRtYXBfcGFyc19mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX0xJR0hUTUFQXFxuXFxuXHR1bmlmb3JtIHNhbXBsZXIyRCBsaWdodE1hcDtcXG5cdHVuaWZvcm0gZmxvYXQgbGlnaHRNYXBJbnRlbnNpdHk7XFxuXFxuI2VuZGlmXCI7XG5cblx0Ly8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbGlnaHRzX2xhbWJlcnRfcGFyc192ZXJ0ZXguZ2xzbFxuXG5cdFRIUkVFLlNoYWRlckNodW5rWyAnbGlnaHRzX2xhbWJlcnRfcGFyc192ZXJ0ZXgnXSA9IFwiI2lmIE1BWF9ESVJfTElHSFRTID4gMFxcblxcblx0dW5pZm9ybSB2ZWMzIGRpcmVjdGlvbmFsTGlnaHRDb2xvclsgTUFYX0RJUl9MSUdIVFMgXTtcXG5cdHVuaWZvcm0gdmVjMyBkaXJlY3Rpb25hbExpZ2h0RGlyZWN0aW9uWyBNQVhfRElSX0xJR0hUUyBdO1xcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfSEVNSV9MSUdIVFMgPiAwXFxuXFxuXHR1bmlmb3JtIHZlYzMgaGVtaXNwaGVyZUxpZ2h0U2t5Q29sb3JbIE1BWF9IRU1JX0xJR0hUUyBdO1xcblx0dW5pZm9ybSB2ZWMzIGhlbWlzcGhlcmVMaWdodEdyb3VuZENvbG9yWyBNQVhfSEVNSV9MSUdIVFMgXTtcXG5cdHVuaWZvcm0gdmVjMyBoZW1pc3BoZXJlTGlnaHREaXJlY3Rpb25bIE1BWF9IRU1JX0xJR0hUUyBdO1xcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfUE9JTlRfTElHSFRTID4gMFxcblxcblx0dW5pZm9ybSB2ZWMzIHBvaW50TGlnaHRDb2xvclsgTUFYX1BPSU5UX0xJR0hUUyBdO1xcblx0dW5pZm9ybSB2ZWMzIHBvaW50TGlnaHRQb3NpdGlvblsgTUFYX1BPSU5UX0xJR0hUUyBdO1xcblx0dW5pZm9ybSBmbG9hdCBwb2ludExpZ2h0RGlzdGFuY2VbIE1BWF9QT0lOVF9MSUdIVFMgXTtcXG5cdHVuaWZvcm0gZmxvYXQgcG9pbnRMaWdodERlY2F5WyBNQVhfUE9JTlRfTElHSFRTIF07XFxuXFxuI2VuZGlmXFxuXFxuI2lmIE1BWF9TUE9UX0xJR0hUUyA+IDBcXG5cXG5cdHVuaWZvcm0gdmVjMyBzcG90TGlnaHRDb2xvclsgTUFYX1NQT1RfTElHSFRTIF07XFxuXHR1bmlmb3JtIHZlYzMgc3BvdExpZ2h0UG9zaXRpb25bIE1BWF9TUE9UX0xJR0hUUyBdO1xcblx0dW5pZm9ybSB2ZWMzIHNwb3RMaWdodERpcmVjdGlvblsgTUFYX1NQT1RfTElHSFRTIF07XFxuXHR1bmlmb3JtIGZsb2F0IHNwb3RMaWdodERpc3RhbmNlWyBNQVhfU1BPVF9MSUdIVFMgXTtcXG5cdHVuaWZvcm0gZmxvYXQgc3BvdExpZ2h0QW5nbGVDb3NbIE1BWF9TUE9UX0xJR0hUUyBdO1xcblx0dW5pZm9ybSBmbG9hdCBzcG90TGlnaHRFeHBvbmVudFsgTUFYX1NQT1RfTElHSFRTIF07XFxuXHR1bmlmb3JtIGZsb2F0IHNwb3RMaWdodERlY2F5WyBNQVhfU1BPVF9MSUdIVFMgXTtcXG5cXG4jZW5kaWZcXG5cIjtcblxuXHQvLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9saWdodHNfbGFtYmVydF92ZXJ0ZXguZ2xzbFxuXG5cdFRIUkVFLlNoYWRlckNodW5rWyAnbGlnaHRzX2xhbWJlcnRfdmVydGV4J10gPSBcInZMaWdodEZyb250ID0gdmVjMyggMC4wICk7XFxuXFxuI2lmZGVmIERPVUJMRV9TSURFRFxcblxcblx0dkxpZ2h0QmFjayA9IHZlYzMoIDAuMCApO1xcblxcbiNlbmRpZlxcblxcbnZlYzMgbm9ybWFsID0gbm9ybWFsaXplKCB0cmFuc2Zvcm1lZE5vcm1hbCApO1xcblxcbiNpZiBNQVhfUE9JTlRfTElHSFRTID4gMFxcblxcblx0Zm9yICggaW50IGkgPSAwOyBpIDwgTUFYX1BPSU5UX0xJR0hUUzsgaSArKyApIHtcXG5cXG5cdFx0dmVjMyBsaWdodENvbG9yID0gcG9pbnRMaWdodENvbG9yWyBpIF07XFxuXFxuXHRcdHZlYzMgbFZlY3RvciA9IHBvaW50TGlnaHRQb3NpdGlvblsgaSBdIC0gbXZQb3NpdGlvbi54eXo7XFxuXHRcdHZlYzMgbGlnaHREaXIgPSBub3JtYWxpemUoIGxWZWN0b3IgKTtcXG5cXG5cXG5cdFx0ZmxvYXQgYXR0ZW51YXRpb24gPSBjYWxjTGlnaHRBdHRlbnVhdGlvbiggbGVuZ3RoKCBsVmVjdG9yICksIHBvaW50TGlnaHREaXN0YW5jZVsgaSBdLCBwb2ludExpZ2h0RGVjYXlbIGkgXSApO1xcblxcblxcblx0XHRmbG9hdCBkb3RQcm9kdWN0ID0gZG90KCBub3JtYWwsIGxpZ2h0RGlyICk7XFxuXFxuXHRcdHZMaWdodEZyb250ICs9IGxpZ2h0Q29sb3IgKiBhdHRlbnVhdGlvbiAqIHNhdHVyYXRlKCBkb3RQcm9kdWN0ICk7XFxuXFxuXHRcdCNpZmRlZiBET1VCTEVfU0lERURcXG5cXG5cdFx0XHR2TGlnaHRCYWNrICs9IGxpZ2h0Q29sb3IgKiBhdHRlbnVhdGlvbiAqIHNhdHVyYXRlKCAtIGRvdFByb2R1Y3QgKTtcXG5cXG5cdFx0I2VuZGlmXFxuXFxuXHR9XFxuXFxuI2VuZGlmXFxuXFxuI2lmIE1BWF9TUE9UX0xJR0hUUyA+IDBcXG5cXG5cdGZvciAoIGludCBpID0gMDsgaSA8IE1BWF9TUE9UX0xJR0hUUzsgaSArKyApIHtcXG5cXG5cdFx0dmVjMyBsaWdodENvbG9yID0gc3BvdExpZ2h0Q29sb3JbIGkgXTtcXG5cXG5cdFx0dmVjMyBsaWdodFBvc2l0aW9uID0gc3BvdExpZ2h0UG9zaXRpb25bIGkgXTtcXG5cdFx0dmVjMyBsVmVjdG9yID0gbGlnaHRQb3NpdGlvbiAtIG12UG9zaXRpb24ueHl6O1xcblx0XHR2ZWMzIGxpZ2h0RGlyID0gbm9ybWFsaXplKCBsVmVjdG9yICk7XFxuXFxuXHRcdGZsb2F0IHNwb3RFZmZlY3QgPSBkb3QoIHNwb3RMaWdodERpcmVjdGlvblsgaSBdLCBsaWdodERpciApO1xcblxcblx0XHRpZiAoIHNwb3RFZmZlY3QgPiBzcG90TGlnaHRBbmdsZUNvc1sgaSBdICkge1xcblxcblx0XHRcdHNwb3RFZmZlY3QgPSBzYXR1cmF0ZSggcG93KCBzYXR1cmF0ZSggc3BvdEVmZmVjdCApLCBzcG90TGlnaHRFeHBvbmVudFsgaSBdICkgKTtcXG5cXG5cXG5cdFx0XHRmbG9hdCBhdHRlbnVhdGlvbiA9IGNhbGNMaWdodEF0dGVudWF0aW9uKCBsZW5ndGgoIGxWZWN0b3IgKSwgc3BvdExpZ2h0RGlzdGFuY2VbIGkgXSwgc3BvdExpZ2h0RGVjYXlbIGkgXSApO1xcblxcblx0XHRcdGF0dGVudWF0aW9uICo9IHNwb3RFZmZlY3Q7XFxuXFxuXFxuXHRcdFx0ZmxvYXQgZG90UHJvZHVjdCA9IGRvdCggbm9ybWFsLCBsaWdodERpciApO1xcblxcblx0XHRcdHZMaWdodEZyb250ICs9IGxpZ2h0Q29sb3IgKiBhdHRlbnVhdGlvbiAqIHNhdHVyYXRlKCBkb3RQcm9kdWN0ICk7XFxuXFxuXHRcdFx0I2lmZGVmIERPVUJMRV9TSURFRFxcblxcblx0XHRcdFx0dkxpZ2h0QmFjayArPSBsaWdodENvbG9yICogYXR0ZW51YXRpb24gKiBzYXR1cmF0ZSggLSBkb3RQcm9kdWN0ICk7XFxuXFxuXHRcdFx0I2VuZGlmXFxuXFxuXHRcdH1cXG5cXG5cdH1cXG5cXG4jZW5kaWZcXG5cXG4jaWYgTUFYX0RJUl9MSUdIVFMgPiAwXFxuXFxuXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBNQVhfRElSX0xJR0hUUzsgaSArKyApIHtcXG5cXG5cdFx0dmVjMyBsaWdodENvbG9yID0gZGlyZWN0aW9uYWxMaWdodENvbG9yWyBpIF07XFxuXFxuXHRcdHZlYzMgbGlnaHREaXIgPSBkaXJlY3Rpb25hbExpZ2h0RGlyZWN0aW9uWyBpIF07XFxuXFxuXFxuXHRcdGZsb2F0IGRvdFByb2R1Y3QgPSBkb3QoIG5vcm1hbCwgbGlnaHREaXIgKTtcXG5cXG5cdFx0dkxpZ2h0RnJvbnQgKz0gbGlnaHRDb2xvciAqIHNhdHVyYXRlKCBkb3RQcm9kdWN0ICk7XFxuXFxuXHRcdCNpZmRlZiBET1VCTEVfU0lERURcXG5cXG5cdFx0XHR2TGlnaHRCYWNrICs9IGxpZ2h0Q29sb3IgKiBzYXR1cmF0ZSggLSBkb3RQcm9kdWN0ICk7XFxuXFxuXHRcdCNlbmRpZlxcblxcblx0fVxcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfSEVNSV9MSUdIVFMgPiAwXFxuXFxuXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBNQVhfSEVNSV9MSUdIVFM7IGkgKysgKSB7XFxuXFxuXHRcdHZlYzMgbGlnaHREaXIgPSBoZW1pc3BoZXJlTGlnaHREaXJlY3Rpb25bIGkgXTtcXG5cXG5cXG5cdFx0ZmxvYXQgZG90UHJvZHVjdCA9IGRvdCggbm9ybWFsLCBsaWdodERpciApO1xcblxcblx0XHRmbG9hdCBoZW1pRGlmZnVzZVdlaWdodCA9IDAuNSAqIGRvdFByb2R1Y3QgKyAwLjU7XFxuXFxuXHRcdHZMaWdodEZyb250ICs9IG1peCggaGVtaXNwaGVyZUxpZ2h0R3JvdW5kQ29sb3JbIGkgXSwgaGVtaXNwaGVyZUxpZ2h0U2t5Q29sb3JbIGkgXSwgaGVtaURpZmZ1c2VXZWlnaHQgKTtcXG5cXG5cdFx0I2lmZGVmIERPVUJMRV9TSURFRFxcblxcblx0XHRcdGZsb2F0IGhlbWlEaWZmdXNlV2VpZ2h0QmFjayA9IC0gMC41ICogZG90UHJvZHVjdCArIDAuNTtcXG5cXG5cdFx0XHR2TGlnaHRCYWNrICs9IG1peCggaGVtaXNwaGVyZUxpZ2h0R3JvdW5kQ29sb3JbIGkgXSwgaGVtaXNwaGVyZUxpZ2h0U2t5Q29sb3JbIGkgXSwgaGVtaURpZmZ1c2VXZWlnaHRCYWNrICk7XFxuXFxuXHRcdCNlbmRpZlxcblxcblx0fVxcblxcbiNlbmRpZlxcblwiO1xuXG5cdC8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xpZ2h0c19waG9uZ19mcmFnbWVudC5nbHNsXG5cblx0VEhSRUUuU2hhZGVyQ2h1bmtbICdsaWdodHNfcGhvbmdfZnJhZ21lbnQnXSA9IFwidmVjMyB2aWV3RGlyID0gbm9ybWFsaXplKCB2Vmlld1Bvc2l0aW9uICk7XFxuXFxudmVjMyB0b3RhbERpZmZ1c2VMaWdodCA9IHZlYzMoIDAuMCApO1xcbnZlYzMgdG90YWxTcGVjdWxhckxpZ2h0ID0gdmVjMyggMC4wICk7XFxuXFxuI2lmIE1BWF9QT0lOVF9MSUdIVFMgPiAwXFxuXFxuXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBNQVhfUE9JTlRfTElHSFRTOyBpICsrICkge1xcblxcblx0XHR2ZWMzIGxpZ2h0Q29sb3IgPSBwb2ludExpZ2h0Q29sb3JbIGkgXTtcXG5cXG5cdFx0dmVjMyBsaWdodFBvc2l0aW9uID0gcG9pbnRMaWdodFBvc2l0aW9uWyBpIF07XFxuXHRcdHZlYzMgbFZlY3RvciA9IGxpZ2h0UG9zaXRpb24gKyB2Vmlld1Bvc2l0aW9uLnh5ejtcXG5cdFx0dmVjMyBsaWdodERpciA9IG5vcm1hbGl6ZSggbFZlY3RvciApO1xcblxcblxcblx0XHRmbG9hdCBhdHRlbnVhdGlvbiA9IGNhbGNMaWdodEF0dGVudWF0aW9uKCBsZW5ndGgoIGxWZWN0b3IgKSwgcG9pbnRMaWdodERpc3RhbmNlWyBpIF0sIHBvaW50TGlnaHREZWNheVsgaSBdICk7XFxuXFxuXFxuXHRcdGZsb2F0IGNvc2luZVRlcm0gPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIGxpZ2h0RGlyICkgKTtcXG5cXG5cdFx0dG90YWxEaWZmdXNlTGlnaHQgKz0gbGlnaHRDb2xvciAqIGF0dGVudWF0aW9uICogY29zaW5lVGVybTtcXG5cXG5cXG5cdFx0dmVjMyBicmRmID0gQlJERl9CbGlublBob25nKCBzcGVjdWxhciwgc2hpbmluZXNzLCBub3JtYWwsIGxpZ2h0RGlyLCB2aWV3RGlyICk7XFxuXFxuXHRcdHRvdGFsU3BlY3VsYXJMaWdodCArPSBicmRmICogc3BlY3VsYXJTdHJlbmd0aCAqIGxpZ2h0Q29sb3IgKiBhdHRlbnVhdGlvbiAqIGNvc2luZVRlcm07XFxuXFxuXFxuXHR9XFxuXFxuI2VuZGlmXFxuXFxuI2lmIE1BWF9TUE9UX0xJR0hUUyA+IDBcXG5cXG5cdGZvciAoIGludCBpID0gMDsgaSA8IE1BWF9TUE9UX0xJR0hUUzsgaSArKyApIHtcXG5cXG5cdFx0dmVjMyBsaWdodENvbG9yID0gc3BvdExpZ2h0Q29sb3JbIGkgXTtcXG5cXG5cdFx0dmVjMyBsaWdodFBvc2l0aW9uID0gc3BvdExpZ2h0UG9zaXRpb25bIGkgXTtcXG5cdFx0dmVjMyBsVmVjdG9yID0gbGlnaHRQb3NpdGlvbiArIHZWaWV3UG9zaXRpb24ueHl6O1xcblx0XHR2ZWMzIGxpZ2h0RGlyID0gbm9ybWFsaXplKCBsVmVjdG9yICk7XFxuXFxuXHRcdGZsb2F0IHNwb3RFZmZlY3QgPSBkb3QoIHNwb3RMaWdodERpcmVjdGlvblsgaSBdLCBsaWdodERpciApO1xcblxcblx0XHRpZiAoIHNwb3RFZmZlY3QgPiBzcG90TGlnaHRBbmdsZUNvc1sgaSBdICkge1xcblxcblx0XHRcdHNwb3RFZmZlY3QgPSBzYXR1cmF0ZSggcG93KCBzYXR1cmF0ZSggc3BvdEVmZmVjdCApLCBzcG90TGlnaHRFeHBvbmVudFsgaSBdICkgKTtcXG5cXG5cXG5cdFx0XHRmbG9hdCBhdHRlbnVhdGlvbiA9IGNhbGNMaWdodEF0dGVudWF0aW9uKCBsZW5ndGgoIGxWZWN0b3IgKSwgc3BvdExpZ2h0RGlzdGFuY2VbIGkgXSwgc3BvdExpZ2h0RGVjYXlbIGkgXSApO1xcblxcblx0XHRcdGF0dGVudWF0aW9uICo9IHNwb3RFZmZlY3Q7XFxuXFxuXFxuXHRcdFx0ZmxvYXQgY29zaW5lVGVybSA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgbGlnaHREaXIgKSApO1xcblxcblx0XHRcdHRvdGFsRGlmZnVzZUxpZ2h0ICs9IGxpZ2h0Q29sb3IgKiBhdHRlbnVhdGlvbiAqIGNvc2luZVRlcm07XFxuXFxuXFxuXHRcdFx0dmVjMyBicmRmID0gQlJERl9CbGlublBob25nKCBzcGVjdWxhciwgc2hpbmluZXNzLCBub3JtYWwsIGxpZ2h0RGlyLCB2aWV3RGlyICk7XFxuXFxuXHRcdFx0dG90YWxTcGVjdWxhckxpZ2h0ICs9IGJyZGYgKiBzcGVjdWxhclN0cmVuZ3RoICogbGlnaHRDb2xvciAqIGF0dGVudWF0aW9uICogY29zaW5lVGVybTtcXG5cXG5cdFx0fVxcblxcblx0fVxcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfRElSX0xJR0hUUyA+IDBcXG5cXG5cdGZvciAoIGludCBpID0gMDsgaSA8IE1BWF9ESVJfTElHSFRTOyBpICsrICkge1xcblxcblx0XHR2ZWMzIGxpZ2h0Q29sb3IgPSBkaXJlY3Rpb25hbExpZ2h0Q29sb3JbIGkgXTtcXG5cXG5cdFx0dmVjMyBsaWdodERpciA9IGRpcmVjdGlvbmFsTGlnaHREaXJlY3Rpb25bIGkgXTtcXG5cXG5cXG5cdFx0ZmxvYXQgY29zaW5lVGVybSA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgbGlnaHREaXIgKSApO1xcblxcblx0XHR0b3RhbERpZmZ1c2VMaWdodCArPSBsaWdodENvbG9yICogY29zaW5lVGVybTtcXG5cXG5cXG5cdFx0dmVjMyBicmRmID0gQlJERl9CbGlublBob25nKCBzcGVjdWxhciwgc2hpbmluZXNzLCBub3JtYWwsIGxpZ2h0RGlyLCB2aWV3RGlyICk7XFxuXFxuXHRcdHRvdGFsU3BlY3VsYXJMaWdodCArPSBicmRmICogc3BlY3VsYXJTdHJlbmd0aCAqIGxpZ2h0Q29sb3IgKiBjb3NpbmVUZXJtO1xcblxcblx0fVxcblxcbiNlbmRpZlxcblwiO1xuXG5cdC8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xpZ2h0c19waG9uZ19wYXJzX2ZyYWdtZW50Lmdsc2xcblxuXHRUSFJFRS5TaGFkZXJDaHVua1sgJ2xpZ2h0c19waG9uZ19wYXJzX2ZyYWdtZW50J10gPSBcInVuaWZvcm0gdmVjMyBhbWJpZW50TGlnaHRDb2xvcjtcXG5cXG4jaWYgTUFYX0RJUl9MSUdIVFMgPiAwXFxuXFxuXHR1bmlmb3JtIHZlYzMgZGlyZWN0aW9uYWxMaWdodENvbG9yWyBNQVhfRElSX0xJR0hUUyBdO1xcblx0dW5pZm9ybSB2ZWMzIGRpcmVjdGlvbmFsTGlnaHREaXJlY3Rpb25bIE1BWF9ESVJfTElHSFRTIF07XFxuXFxuI2VuZGlmXFxuXFxuI2lmIE1BWF9IRU1JX0xJR0hUUyA+IDBcXG5cXG5cdHVuaWZvcm0gdmVjMyBoZW1pc3BoZXJlTGlnaHRTa3lDb2xvclsgTUFYX0hFTUlfTElHSFRTIF07XFxuXHR1bmlmb3JtIHZlYzMgaGVtaXNwaGVyZUxpZ2h0R3JvdW5kQ29sb3JbIE1BWF9IRU1JX0xJR0hUUyBdO1xcblx0dW5pZm9ybSB2ZWMzIGhlbWlzcGhlcmVMaWdodERpcmVjdGlvblsgTUFYX0hFTUlfTElHSFRTIF07XFxuXFxuI2VuZGlmXFxuXFxuI2lmIE1BWF9QT0lOVF9MSUdIVFMgPiAwXFxuXFxuXHR1bmlmb3JtIHZlYzMgcG9pbnRMaWdodENvbG9yWyBNQVhfUE9JTlRfTElHSFRTIF07XFxuXFxuXHR1bmlmb3JtIHZlYzMgcG9pbnRMaWdodFBvc2l0aW9uWyBNQVhfUE9JTlRfTElHSFRTIF07XFxuXHR1bmlmb3JtIGZsb2F0IHBvaW50TGlnaHREaXN0YW5jZVsgTUFYX1BPSU5UX0xJR0hUUyBdO1xcblx0dW5pZm9ybSBmbG9hdCBwb2ludExpZ2h0RGVjYXlbIE1BWF9QT0lOVF9MSUdIVFMgXTtcXG5cXG4jZW5kaWZcXG5cXG4jaWYgTUFYX1NQT1RfTElHSFRTID4gMFxcblxcblx0dW5pZm9ybSB2ZWMzIHNwb3RMaWdodENvbG9yWyBNQVhfU1BPVF9MSUdIVFMgXTtcXG5cdHVuaWZvcm0gdmVjMyBzcG90TGlnaHRQb3NpdGlvblsgTUFYX1NQT1RfTElHSFRTIF07XFxuXHR1bmlmb3JtIHZlYzMgc3BvdExpZ2h0RGlyZWN0aW9uWyBNQVhfU1BPVF9MSUdIVFMgXTtcXG5cdHVuaWZvcm0gZmxvYXQgc3BvdExpZ2h0QW5nbGVDb3NbIE1BWF9TUE9UX0xJR0hUUyBdO1xcblx0dW5pZm9ybSBmbG9hdCBzcG90TGlnaHRFeHBvbmVudFsgTUFYX1NQT1RfTElHSFRTIF07XFxuXHR1bmlmb3JtIGZsb2F0IHNwb3RMaWdodERpc3RhbmNlWyBNQVhfU1BPVF9MSUdIVFMgXTtcXG5cdHVuaWZvcm0gZmxvYXQgc3BvdExpZ2h0RGVjYXlbIE1BWF9TUE9UX0xJR0hUUyBdO1xcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfU1BPVF9MSUdIVFMgPiAwIHx8IGRlZmluZWQoIFVTRV9FTlZNQVAgKVxcblxcblx0dmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1xcblxcbiNlbmRpZlxcblxcbnZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1xcblxcbiNpZm5kZWYgRkxBVF9TSEFERURcXG5cXG5cdHZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xcblxcbiNlbmRpZlxcblwiO1xuXG5cdC8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xpZ2h0c19waG9uZ19wYXJzX3ZlcnRleC5nbHNsXG5cblx0VEhSRUUuU2hhZGVyQ2h1bmtbICdsaWdodHNfcGhvbmdfcGFyc192ZXJ0ZXgnXSA9IFwiI2lmIE1BWF9TUE9UX0xJR0hUUyA+IDAgfHwgZGVmaW5lZCggVVNFX0VOVk1BUCApXFxuXFxuXHR2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XFxuXFxuI2VuZGlmXFxuXFxuI2lmIE1BWF9QT0lOVF9MSUdIVFMgPiAwXFxuXFxuXHR1bmlmb3JtIHZlYzMgcG9pbnRMaWdodFBvc2l0aW9uWyBNQVhfUE9JTlRfTElHSFRTIF07XFxuXFxuI2VuZGlmXFxuXCI7XG5cblx0Ly8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbGlnaHRzX3Bob25nX3ZlcnRleC5nbHNsXG5cblx0VEhSRUUuU2hhZGVyQ2h1bmtbICdsaWdodHNfcGhvbmdfdmVydGV4J10gPSBcIiNpZiBNQVhfU1BPVF9MSUdIVFMgPiAwIHx8IGRlZmluZWQoIFVTRV9FTlZNQVAgKVxcblxcblx0dldvcmxkUG9zaXRpb24gPSB3b3JsZFBvc2l0aW9uLnh5ejtcXG5cXG4jZW5kaWZcXG5cIjtcblxuXHQvLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9saW5lYXJfdG9fZ2FtbWFfZnJhZ21lbnQuZ2xzbFxuXG5cdFRIUkVFLlNoYWRlckNodW5rWyAnbGluZWFyX3RvX2dhbW1hX2ZyYWdtZW50J10gPSBcIlxcblx0b3V0Z29pbmdMaWdodCA9IGxpbmVhclRvT3V0cHV0KCBvdXRnb2luZ0xpZ2h0ICk7XFxuXCI7XG5cblx0Ly8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbG9nZGVwdGhidWZfZnJhZ21lbnQuZ2xzbFxuXG5cdFRIUkVFLlNoYWRlckNodW5rWyAnbG9nZGVwdGhidWZfZnJhZ21lbnQnXSA9IFwiI2lmIGRlZmluZWQoVVNFX0xPR0RFUFRIQlVGKSAmJiBkZWZpbmVkKFVTRV9MT0dERVBUSEJVRl9FWFQpXFxuXFxuXHRnbF9GcmFnRGVwdGhFWFQgPSBsb2cyKHZGcmFnRGVwdGgpICogbG9nRGVwdGhCdWZGQyAqIDAuNTtcXG5cXG4jZW5kaWZcIjtcblxuXHQvLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9sb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50Lmdsc2xcblxuXHRUSFJFRS5TaGFkZXJDaHVua1sgJ2xvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIFVTRV9MT0dERVBUSEJVRlxcblxcblx0dW5pZm9ybSBmbG9hdCBsb2dEZXB0aEJ1ZkZDO1xcblxcblx0I2lmZGVmIFVTRV9MT0dERVBUSEJVRl9FWFRcXG5cXG5cdFx0dmFyeWluZyBmbG9hdCB2RnJhZ0RlcHRoO1xcblxcblx0I2VuZGlmXFxuXFxuI2VuZGlmXFxuXCI7XG5cblx0Ly8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbG9nZGVwdGhidWZfcGFyc192ZXJ0ZXguZ2xzbFxuXG5cdFRIUkVFLlNoYWRlckNodW5rWyAnbG9nZGVwdGhidWZfcGFyc192ZXJ0ZXgnXSA9IFwiI2lmZGVmIFVTRV9MT0dERVBUSEJVRlxcblxcblx0I2lmZGVmIFVTRV9MT0dERVBUSEJVRl9FWFRcXG5cXG5cdFx0dmFyeWluZyBmbG9hdCB2RnJhZ0RlcHRoO1xcblxcblx0I2VuZGlmXFxuXFxuXHR1bmlmb3JtIGZsb2F0IGxvZ0RlcHRoQnVmRkM7XFxuXFxuI2VuZGlmXCI7XG5cblx0Ly8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbG9nZGVwdGhidWZfdmVydGV4Lmdsc2xcblxuXHRUSFJFRS5TaGFkZXJDaHVua1sgJ2xvZ2RlcHRoYnVmX3ZlcnRleCddID0gXCIjaWZkZWYgVVNFX0xPR0RFUFRIQlVGXFxuXFxuXHRnbF9Qb3NpdGlvbi56ID0gbG9nMihtYXgoIEVQU0lMT04sIGdsX1Bvc2l0aW9uLncgKyAxLjAgKSkgKiBsb2dEZXB0aEJ1ZkZDO1xcblxcblx0I2lmZGVmIFVTRV9MT0dERVBUSEJVRl9FWFRcXG5cXG5cdFx0dkZyYWdEZXB0aCA9IDEuMCArIGdsX1Bvc2l0aW9uLnc7XFxuXFxuI2Vsc2VcXG5cXG5cdFx0Z2xfUG9zaXRpb24ueiA9IChnbF9Qb3NpdGlvbi56IC0gMS4wKSAqIGdsX1Bvc2l0aW9uLnc7XFxuXFxuXHQjZW5kaWZcXG5cXG4jZW5kaWZcIjtcblxuXHQvLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9tYXBfZnJhZ21lbnQuZ2xzbFxuXG5cdFRIUkVFLlNoYWRlckNodW5rWyAnbWFwX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfTUFQXFxuXFxuXHR2ZWM0IHRleGVsQ29sb3IgPSB0ZXh0dXJlMkQoIG1hcCwgdlV2ICk7XFxuXFxuXHR0ZXhlbENvbG9yLnh5eiA9IGlucHV0VG9MaW5lYXIoIHRleGVsQ29sb3IueHl6ICk7XFxuXFxuXHRkaWZmdXNlQ29sb3IgKj0gdGV4ZWxDb2xvcjtcXG5cXG4jZW5kaWZcXG5cIjtcblxuXHQvLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9tYXBfcGFyc19mcmFnbWVudC5nbHNsXG5cblx0VEhSRUUuU2hhZGVyQ2h1bmtbICdtYXBfcGFyc19mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX01BUFxcblxcblx0dW5pZm9ybSBzYW1wbGVyMkQgbWFwO1xcblxcbiNlbmRpZlwiO1xuXG5cdC8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL21hcF9wYXJ0aWNsZV9mcmFnbWVudC5nbHNsXG5cblx0VEhSRUUuU2hhZGVyQ2h1bmtbICdtYXBfcGFydGljbGVfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIFVTRV9NQVBcXG5cXG5cdGRpZmZ1c2VDb2xvciAqPSB0ZXh0dXJlMkQoIG1hcCwgdmVjMiggZ2xfUG9pbnRDb29yZC54LCAxLjAgLSBnbF9Qb2ludENvb3JkLnkgKSAqIG9mZnNldFJlcGVhdC56dyArIG9mZnNldFJlcGVhdC54eSApO1xcblxcbiNlbmRpZlxcblwiO1xuXG5cdC8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL21hcF9wYXJ0aWNsZV9wYXJzX2ZyYWdtZW50Lmdsc2xcblxuXHRUSFJFRS5TaGFkZXJDaHVua1sgJ21hcF9wYXJ0aWNsZV9wYXJzX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfTUFQXFxuXFxuXHR1bmlmb3JtIHZlYzQgb2Zmc2V0UmVwZWF0O1xcblx0dW5pZm9ybSBzYW1wbGVyMkQgbWFwO1xcblxcbiNlbmRpZlxcblwiO1xuXG5cdC8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL21vcnBobm9ybWFsX3ZlcnRleC5nbHNsXG5cblx0VEhSRUUuU2hhZGVyQ2h1bmtbICdtb3JwaG5vcm1hbF92ZXJ0ZXgnXSA9IFwiI2lmZGVmIFVTRV9NT1JQSE5PUk1BTFNcXG5cXG5cdG9iamVjdE5vcm1hbCArPSAoIG1vcnBoTm9ybWFsMCAtIG5vcm1hbCApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAwIF07XFxuXHRvYmplY3ROb3JtYWwgKz0gKCBtb3JwaE5vcm1hbDEgLSBub3JtYWwgKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMSBdO1xcblx0b2JqZWN0Tm9ybWFsICs9ICggbW9ycGhOb3JtYWwyIC0gbm9ybWFsICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDIgXTtcXG5cdG9iamVjdE5vcm1hbCArPSAoIG1vcnBoTm9ybWFsMyAtIG5vcm1hbCApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAzIF07XFxuXFxuI2VuZGlmXFxuXCI7XG5cblx0Ly8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXguZ2xzbFxuXG5cdFRIUkVFLlNoYWRlckNodW5rWyAnbW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXgnXSA9IFwiI2lmZGVmIFVTRV9NT1JQSFRBUkdFVFNcXG5cXG5cdCNpZm5kZWYgVVNFX01PUlBITk9STUFMU1xcblxcblx0dW5pZm9ybSBmbG9hdCBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDggXTtcXG5cXG5cdCNlbHNlXFxuXFxuXHR1bmlmb3JtIGZsb2F0IG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNCBdO1xcblxcblx0I2VuZGlmXFxuXFxuI2VuZGlmXCI7XG5cblx0Ly8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbW9ycGh0YXJnZXRfdmVydGV4Lmdsc2xcblxuXHRUSFJFRS5TaGFkZXJDaHVua1sgJ21vcnBodGFyZ2V0X3ZlcnRleCddID0gXCIjaWZkZWYgVVNFX01PUlBIVEFSR0VUU1xcblxcblx0dHJhbnNmb3JtZWQgKz0gKCBtb3JwaFRhcmdldDAgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAwIF07XFxuXHR0cmFuc2Zvcm1lZCArPSAoIG1vcnBoVGFyZ2V0MSAtIHBvc2l0aW9uICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDEgXTtcXG5cdHRyYW5zZm9ybWVkICs9ICggbW9ycGhUYXJnZXQyIC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMiBdO1xcblx0dHJhbnNmb3JtZWQgKz0gKCBtb3JwaFRhcmdldDMgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAzIF07XFxuXFxuXHQjaWZuZGVmIFVTRV9NT1JQSE5PUk1BTFNcXG5cXG5cdHRyYW5zZm9ybWVkICs9ICggbW9ycGhUYXJnZXQ0IC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNCBdO1xcblx0dHJhbnNmb3JtZWQgKz0gKCBtb3JwaFRhcmdldDUgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA1IF07XFxuXHR0cmFuc2Zvcm1lZCArPSAoIG1vcnBoVGFyZ2V0NiAtIHBvc2l0aW9uICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDYgXTtcXG5cdHRyYW5zZm9ybWVkICs9ICggbW9ycGhUYXJnZXQ3IC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNyBdO1xcblxcblx0I2VuZGlmXFxuXFxuI2VuZGlmXFxuXCI7XG5cblx0Ly8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbm9ybWFsX3Bob25nX2ZyYWdtZW50Lmdsc2xcblxuXHRUSFJFRS5TaGFkZXJDaHVua1sgJ25vcm1hbF9waG9uZ19mcmFnbWVudCddID0gXCIjaWZuZGVmIEZMQVRfU0hBREVEXFxuXFxuXHR2ZWMzIG5vcm1hbCA9IG5vcm1hbGl6ZSggdk5vcm1hbCApO1xcblxcblx0I2lmZGVmIERPVUJMRV9TSURFRFxcblxcblx0XHRub3JtYWwgPSBub3JtYWwgKiAoIC0xLjAgKyAyLjAgKiBmbG9hdCggZ2xfRnJvbnRGYWNpbmcgKSApO1xcblxcblx0I2VuZGlmXFxuXFxuI2Vsc2VcXG5cXG5cdHZlYzMgZmR4ID0gZEZkeCggdlZpZXdQb3NpdGlvbiApO1xcblx0dmVjMyBmZHkgPSBkRmR5KCB2Vmlld1Bvc2l0aW9uICk7XFxuXHR2ZWMzIG5vcm1hbCA9IG5vcm1hbGl6ZSggY3Jvc3MoIGZkeCwgZmR5ICkgKTtcXG5cXG4jZW5kaWZcXG5cXG4jaWZkZWYgVVNFX05PUk1BTE1BUFxcblxcblx0bm9ybWFsID0gcGVydHVyYk5vcm1hbDJBcmIoIC12Vmlld1Bvc2l0aW9uLCBub3JtYWwgKTtcXG5cXG4jZWxpZiBkZWZpbmVkKCBVU0VfQlVNUE1BUCApXFxuXFxuXHRub3JtYWwgPSBwZXJ0dXJiTm9ybWFsQXJiKCAtdlZpZXdQb3NpdGlvbiwgbm9ybWFsLCBkSGR4eV9md2QoKSApO1xcblxcbiNlbmRpZlxcblxcblwiO1xuXG5cdC8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL25vcm1hbG1hcF9wYXJzX2ZyYWdtZW50Lmdsc2xcblxuXHRUSFJFRS5TaGFkZXJDaHVua1sgJ25vcm1hbG1hcF9wYXJzX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfTk9STUFMTUFQXFxuXFxuXHR1bmlmb3JtIHNhbXBsZXIyRCBub3JtYWxNYXA7XFxuXHR1bmlmb3JtIHZlYzIgbm9ybWFsU2NhbGU7XFxuXFxuXFxuXHR2ZWMzIHBlcnR1cmJOb3JtYWwyQXJiKCB2ZWMzIGV5ZV9wb3MsIHZlYzMgc3VyZl9ub3JtICkge1xcblxcblx0XHR2ZWMzIHEwID0gZEZkeCggZXllX3Bvcy54eXogKTtcXG5cdFx0dmVjMyBxMSA9IGRGZHkoIGV5ZV9wb3MueHl6ICk7XFxuXHRcdHZlYzIgc3QwID0gZEZkeCggdlV2LnN0ICk7XFxuXHRcdHZlYzIgc3QxID0gZEZkeSggdlV2LnN0ICk7XFxuXFxuXHRcdHZlYzMgUyA9IG5vcm1hbGl6ZSggcTAgKiBzdDEudCAtIHExICogc3QwLnQgKTtcXG5cdFx0dmVjMyBUID0gbm9ybWFsaXplKCAtcTAgKiBzdDEucyArIHExICogc3QwLnMgKTtcXG5cdFx0dmVjMyBOID0gbm9ybWFsaXplKCBzdXJmX25vcm0gKTtcXG5cXG5cdFx0dmVjMyBtYXBOID0gdGV4dHVyZTJEKCBub3JtYWxNYXAsIHZVdiApLnh5eiAqIDIuMCAtIDEuMDtcXG5cdFx0bWFwTi54eSA9IG5vcm1hbFNjYWxlICogbWFwTi54eTtcXG5cdFx0bWF0MyB0c24gPSBtYXQzKCBTLCBULCBOICk7XFxuXHRcdHJldHVybiBub3JtYWxpemUoIHRzbiAqIG1hcE4gKTtcXG5cXG5cdH1cXG5cXG4jZW5kaWZcXG5cIjtcblxuXHQvLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9wcm9qZWN0X3ZlcnRleC5nbHNsXG5cblx0VEhSRUUuU2hhZGVyQ2h1bmtbICdwcm9qZWN0X3ZlcnRleCddID0gXCIjaWZkZWYgVVNFX1NLSU5OSU5HXFxuXFxuXHR2ZWM0IG12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiBza2lubmVkO1xcblxcbiNlbHNlXFxuXFxuXHR2ZWM0IG12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCB0cmFuc2Zvcm1lZCwgMS4wICk7XFxuXFxuI2VuZGlmXFxuXFxuZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbXZQb3NpdGlvbjtcXG5cIjtcblxuXHQvLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9zaGFkb3dtYXBfZnJhZ21lbnQuZ2xzbFxuXG5cdFRIUkVFLlNoYWRlckNodW5rWyAnc2hhZG93bWFwX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfU0hBRE9XTUFQXFxuXFxuXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBNQVhfU0hBRE9XUzsgaSArKyApIHtcXG5cXG5cdFx0ZmxvYXQgdGV4ZWxTaXplWSA9ICAxLjAgLyBzaGFkb3dNYXBTaXplWyBpIF0ueTtcXG5cXG5cdFx0ZmxvYXQgc2hhZG93ID0gMC4wO1xcblxcbiNpZiBkZWZpbmVkKCBQT0lOVF9MSUdIVF9TSEFET1dTIClcXG5cXG5cdFx0Ym9vbCBpc1BvaW50TGlnaHQgPSBzaGFkb3dEYXJrbmVzc1sgaSBdIDwgMC4wO1xcblxcblx0XHRpZiAoIGlzUG9pbnRMaWdodCApIHtcXG5cXG5cdFx0XHRmbG9hdCByZWFsU2hhZG93RGFya25lc3MgPSBhYnMoIHNoYWRvd0RhcmtuZXNzWyBpIF0gKTtcXG5cXG5cdFx0XHR2ZWMzIGxpZ2h0VG9Qb3NpdGlvbiA9IHZTaGFkb3dDb29yZFsgaSBdLnh5ejtcXG5cXG5cdCNpZiBkZWZpbmVkKCBTSEFET1dNQVBfVFlQRV9QQ0YgKSB8fCBkZWZpbmVkKCBTSEFET1dNQVBfVFlQRV9QQ0ZfU09GVCApXFxuXFxuXHRcdFx0dmVjMyBiZDNEID0gbm9ybWFsaXplKCBsaWdodFRvUG9zaXRpb24gKTtcXG5cdFx0XHRmbG9hdCBkcCA9IGxlbmd0aCggbGlnaHRUb1Bvc2l0aW9uICk7XFxuXFxuXHRcdFx0YWRqdXN0U2hhZG93VmFsdWUxSyggZHAsIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIGN1YmVUb1VWKCBiZDNELCB0ZXhlbFNpemVZICkgKSwgc2hhZG93Qmlhc1sgaSBdLCBzaGFkb3cgKTtcXG5cXG5cXG5cdCNpZiBkZWZpbmVkKCBTSEFET1dNQVBfVFlQRV9QQ0YgKVxcblx0XHRcdGNvbnN0IGZsb2F0IERyID0gMS4yNTtcXG5cdCNlbGlmIGRlZmluZWQoIFNIQURPV01BUF9UWVBFX1BDRl9TT0ZUIClcXG5cdFx0XHRjb25zdCBmbG9hdCBEciA9IDIuMjU7XFxuXHQjZW5kaWZcXG5cXG5cdFx0XHRmbG9hdCBvcyA9IERyICogIDIuMCAqIHRleGVsU2l6ZVk7XFxuXFxuXHRcdFx0Y29uc3QgdmVjMyBHc2QgPSB2ZWMzKCAtIDEsIDAsIDEgKTtcXG5cXG5cdFx0XHRhZGp1c3RTaGFkb3dWYWx1ZTFLKCBkcCwgdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgY3ViZVRvVVYoIGJkM0QgKyBHc2Quenp6ICogb3MsIHRleGVsU2l6ZVkgKSApLCBzaGFkb3dCaWFzWyBpIF0sIHNoYWRvdyApO1xcblx0XHRcdGFkanVzdFNoYWRvd1ZhbHVlMUsoIGRwLCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBjdWJlVG9VViggYmQzRCArIEdzZC56eHogKiBvcywgdGV4ZWxTaXplWSApICksIHNoYWRvd0JpYXNbIGkgXSwgc2hhZG93ICk7XFxuXHRcdFx0YWRqdXN0U2hhZG93VmFsdWUxSyggZHAsIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIGN1YmVUb1VWKCBiZDNEICsgR3NkLnh4eiAqIG9zLCB0ZXhlbFNpemVZICkgKSwgc2hhZG93Qmlhc1sgaSBdLCBzaGFkb3cgKTtcXG5cdFx0XHRhZGp1c3RTaGFkb3dWYWx1ZTFLKCBkcCwgdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgY3ViZVRvVVYoIGJkM0QgKyBHc2QueHp6ICogb3MsIHRleGVsU2l6ZVkgKSApLCBzaGFkb3dCaWFzWyBpIF0sIHNoYWRvdyApO1xcblx0XHRcdGFkanVzdFNoYWRvd1ZhbHVlMUsoIGRwLCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBjdWJlVG9VViggYmQzRCArIEdzZC56enggKiBvcywgdGV4ZWxTaXplWSApICksIHNoYWRvd0JpYXNbIGkgXSwgc2hhZG93ICk7XFxuXHRcdFx0YWRqdXN0U2hhZG93VmFsdWUxSyggZHAsIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIGN1YmVUb1VWKCBiZDNEICsgR3NkLnp4eCAqIG9zLCB0ZXhlbFNpemVZICkgKSwgc2hhZG93Qmlhc1sgaSBdLCBzaGFkb3cgKTtcXG5cdFx0XHRhZGp1c3RTaGFkb3dWYWx1ZTFLKCBkcCwgdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgY3ViZVRvVVYoIGJkM0QgKyBHc2QueHh4ICogb3MsIHRleGVsU2l6ZVkgKSApLCBzaGFkb3dCaWFzWyBpIF0sIHNoYWRvdyApO1xcblx0XHRcdGFkanVzdFNoYWRvd1ZhbHVlMUsoIGRwLCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBjdWJlVG9VViggYmQzRCArIEdzZC54enggKiBvcywgdGV4ZWxTaXplWSApICksIHNoYWRvd0JpYXNbIGkgXSwgc2hhZG93ICk7XFxuXHRcdFx0YWRqdXN0U2hhZG93VmFsdWUxSyggZHAsIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIGN1YmVUb1VWKCBiZDNEICsgR3NkLnp6eSAqIG9zLCB0ZXhlbFNpemVZICkgKSwgc2hhZG93Qmlhc1sgaSBdLCBzaGFkb3cgKTtcXG5cdFx0XHRhZGp1c3RTaGFkb3dWYWx1ZTFLKCBkcCwgdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgY3ViZVRvVVYoIGJkM0QgKyBHc2Quenh5ICogb3MsIHRleGVsU2l6ZVkgKSApLCBzaGFkb3dCaWFzWyBpIF0sIHNoYWRvdyApO1xcblxcblx0XHRcdGFkanVzdFNoYWRvd1ZhbHVlMUsoIGRwLCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBjdWJlVG9VViggYmQzRCArIEdzZC54eHkgKiBvcywgdGV4ZWxTaXplWSApICksIHNoYWRvd0JpYXNbIGkgXSwgc2hhZG93ICk7XFxuXHRcdFx0YWRqdXN0U2hhZG93VmFsdWUxSyggZHAsIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIGN1YmVUb1VWKCBiZDNEICsgR3NkLnh6eSAqIG9zLCB0ZXhlbFNpemVZICkgKSwgc2hhZG93Qmlhc1sgaSBdLCBzaGFkb3cgKTtcXG5cdFx0XHRhZGp1c3RTaGFkb3dWYWx1ZTFLKCBkcCwgdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgY3ViZVRvVVYoIGJkM0QgKyBHc2Quenl6ICogb3MsIHRleGVsU2l6ZVkgKSApLCBzaGFkb3dCaWFzWyBpIF0sIHNoYWRvdyApO1xcblx0XHRcdGFkanVzdFNoYWRvd1ZhbHVlMUsoIGRwLCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBjdWJlVG9VViggYmQzRCArIEdzZC54eXogKiBvcywgdGV4ZWxTaXplWSApICksIHNoYWRvd0JpYXNbIGkgXSwgc2hhZG93ICk7XFxuXHRcdFx0YWRqdXN0U2hhZG93VmFsdWUxSyggZHAsIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIGN1YmVUb1VWKCBiZDNEICsgR3NkLnp5eCAqIG9zLCB0ZXhlbFNpemVZICkgKSwgc2hhZG93Qmlhc1sgaSBdLCBzaGFkb3cgKTtcXG5cdFx0XHRhZGp1c3RTaGFkb3dWYWx1ZTFLKCBkcCwgdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgY3ViZVRvVVYoIGJkM0QgKyBHc2QueHl4ICogb3MsIHRleGVsU2l6ZVkgKSApLCBzaGFkb3dCaWFzWyBpIF0sIHNoYWRvdyApO1xcblx0XHRcdGFkanVzdFNoYWRvd1ZhbHVlMUsoIGRwLCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBjdWJlVG9VViggYmQzRCArIEdzZC55enogKiBvcywgdGV4ZWxTaXplWSApICksIHNoYWRvd0JpYXNbIGkgXSwgc2hhZG93ICk7XFxuXHRcdFx0YWRqdXN0U2hhZG93VmFsdWUxSyggZHAsIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIGN1YmVUb1VWKCBiZDNEICsgR3NkLnl4eiAqIG9zLCB0ZXhlbFNpemVZICkgKSwgc2hhZG93Qmlhc1sgaSBdLCBzaGFkb3cgKTtcXG5cdFx0XHRhZGp1c3RTaGFkb3dWYWx1ZTFLKCBkcCwgdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgY3ViZVRvVVYoIGJkM0QgKyBHc2QueXh4ICogb3MsIHRleGVsU2l6ZVkgKSApLCBzaGFkb3dCaWFzWyBpIF0sIHNoYWRvdyApO1xcblx0XHRcdGFkanVzdFNoYWRvd1ZhbHVlMUsoIGRwLCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBjdWJlVG9VViggYmQzRCArIEdzZC55enggKiBvcywgdGV4ZWxTaXplWSApICksIHNoYWRvd0JpYXNbIGkgXSwgc2hhZG93ICk7XFxuXFxuXHRcdFx0c2hhZG93ICo9IHJlYWxTaGFkb3dEYXJrbmVzcyAqICggMS4wIC8gMjEuMCApO1xcblxcblx0I2Vsc2UgXFxuXHRcdFx0dmVjMyBiZDNEID0gbm9ybWFsaXplKCBsaWdodFRvUG9zaXRpb24gKTtcXG5cdFx0XHRmbG9hdCBkcCA9IGxlbmd0aCggbGlnaHRUb1Bvc2l0aW9uICk7XFxuXFxuXHRcdFx0YWRqdXN0U2hhZG93VmFsdWUxSyggZHAsIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIGN1YmVUb1VWKCBiZDNELCB0ZXhlbFNpemVZICkgKSwgc2hhZG93Qmlhc1sgaSBdLCBzaGFkb3cgKTtcXG5cXG5cdFx0XHRzaGFkb3cgKj0gcmVhbFNoYWRvd0RhcmtuZXNzO1xcblxcblx0I2VuZGlmXFxuXFxuXHRcdH0gZWxzZSB7XFxuXFxuI2VuZGlmIFxcblx0XHRcdGZsb2F0IHRleGVsU2l6ZVggPSAgMS4wIC8gc2hhZG93TWFwU2l6ZVsgaSBdLng7XFxuXFxuXHRcdFx0dmVjMyBzaGFkb3dDb29yZCA9IHZTaGFkb3dDb29yZFsgaSBdLnh5eiAvIHZTaGFkb3dDb29yZFsgaSBdLnc7XFxuXFxuXFxuXHRcdFx0YnZlYzQgaW5GcnVzdHVtVmVjID0gYnZlYzQgKCBzaGFkb3dDb29yZC54ID49IDAuMCwgc2hhZG93Q29vcmQueCA8PSAxLjAsIHNoYWRvd0Nvb3JkLnkgPj0gMC4wLCBzaGFkb3dDb29yZC55IDw9IDEuMCApO1xcblx0XHRcdGJvb2wgaW5GcnVzdHVtID0gYWxsKCBpbkZydXN0dW1WZWMgKTtcXG5cXG5cdFx0XHRidmVjMiBmcnVzdHVtVGVzdFZlYyA9IGJ2ZWMyKCBpbkZydXN0dW0sIHNoYWRvd0Nvb3JkLnogPD0gMS4wICk7XFxuXFxuXHRcdFx0Ym9vbCBmcnVzdHVtVGVzdCA9IGFsbCggZnJ1c3R1bVRlc3RWZWMgKTtcXG5cXG5cdFx0XHRpZiAoIGZydXN0dW1UZXN0ICkge1xcblxcblx0I2lmIGRlZmluZWQoIFNIQURPV01BUF9UWVBFX1BDRiApXFxuXFxuXFxuXHRcdFx0XHQvKlxcblx0XHRcdFx0XHRmb3IgKCBmbG9hdCB5ID0gLTEuMjU7IHkgPD0gMS4yNTsgeSArPSAxLjI1IClcXG5cdFx0XHRcdFx0XHRmb3IgKCBmbG9hdCB4ID0gLTEuMjU7IHggPD0gMS4yNTsgeCArPSAxLjI1ICkge1xcblx0XHRcdFx0XHRcdFx0dmVjNCByZ2JhRGVwdGggPSB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCB2ZWMyKCB4ICogeFBpeGVsT2Zmc2V0LCB5ICogeVBpeGVsT2Zmc2V0ICkgKyBzaGFkb3dDb29yZC54eSApO1xcblx0XHRcdFx0XHRcdFx0ZmxvYXQgZkRlcHRoID0gdW5wYWNrRGVwdGgoIHJnYmFEZXB0aCApO1xcblx0XHRcdFx0XHRcdFx0aWYgKCBmRGVwdGggPCBzaGFkb3dDb29yZC56IClcXG5cdFx0XHRcdFx0XHRcdFx0c2hhZG93ICs9IDEuMDtcXG5cdFx0XHRcdFx0fVxcblx0XHRcdFx0XHRzaGFkb3cgLz0gOS4wO1xcblx0XHRcdFx0Ki9cXG5cXG5cdFx0XHRcdHNoYWRvd0Nvb3JkLnogKz0gc2hhZG93Qmlhc1sgaSBdO1xcblxcblx0XHRcdFx0Y29uc3QgZmxvYXQgU2hhZG93RGVsdGEgPSAxLjAgLyA5LjA7XFxuXFxuXHRcdFx0XHRmbG9hdCB4UGl4ZWxPZmZzZXQgPSB0ZXhlbFNpemVYO1xcblx0XHRcdFx0ZmxvYXQgeVBpeGVsT2Zmc2V0ID0gdGV4ZWxTaXplWTtcXG5cXG5cdFx0XHRcdGZsb2F0IGR4MCA9IC0gMS4yNSAqIHhQaXhlbE9mZnNldDtcXG5cdFx0XHRcdGZsb2F0IGR5MCA9IC0gMS4yNSAqIHlQaXhlbE9mZnNldDtcXG5cdFx0XHRcdGZsb2F0IGR4MSA9IDEuMjUgKiB4UGl4ZWxPZmZzZXQ7XFxuXHRcdFx0XHRmbG9hdCBkeTEgPSAxLjI1ICogeVBpeGVsT2Zmc2V0O1xcblxcblx0XHRcdFx0ZmxvYXQgZkRlcHRoID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCBkeTAgKSApICk7XFxuXHRcdFx0XHRpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKSBzaGFkb3cgKz0gU2hhZG93RGVsdGE7XFxuXFxuXHRcdFx0XHRmRGVwdGggPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCAwLjAsIGR5MCApICkgKTtcXG5cdFx0XHRcdGlmICggZkRlcHRoIDwgc2hhZG93Q29vcmQueiApIHNoYWRvdyArPSBTaGFkb3dEZWx0YTtcXG5cXG5cdFx0XHRcdGZEZXB0aCA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MSwgZHkwICkgKSApO1xcblx0XHRcdFx0aWYgKCBmRGVwdGggPCBzaGFkb3dDb29yZC56ICkgc2hhZG93ICs9IFNoYWRvd0RlbHRhO1xcblxcblx0XHRcdFx0ZkRlcHRoID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCAwLjAgKSApICk7XFxuXHRcdFx0XHRpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKSBzaGFkb3cgKz0gU2hhZG93RGVsdGE7XFxuXFxuXHRcdFx0XHRmRGVwdGggPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKSApO1xcblx0XHRcdFx0aWYgKCBmRGVwdGggPCBzaGFkb3dDb29yZC56ICkgc2hhZG93ICs9IFNoYWRvd0RlbHRhO1xcblxcblx0XHRcdFx0ZkRlcHRoID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCAwLjAgKSApICk7XFxuXHRcdFx0XHRpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKSBzaGFkb3cgKz0gU2hhZG93RGVsdGE7XFxuXFxuXHRcdFx0XHRmRGVwdGggPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIGR5MSApICkgKTtcXG5cdFx0XHRcdGlmICggZkRlcHRoIDwgc2hhZG93Q29vcmQueiApIHNoYWRvdyArPSBTaGFkb3dEZWx0YTtcXG5cXG5cdFx0XHRcdGZEZXB0aCA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIDAuMCwgZHkxICkgKSApO1xcblx0XHRcdFx0aWYgKCBmRGVwdGggPCBzaGFkb3dDb29yZC56ICkgc2hhZG93ICs9IFNoYWRvd0RlbHRhO1xcblxcblx0XHRcdFx0ZkRlcHRoID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCBkeTEgKSApICk7XFxuXHRcdFx0XHRpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKSBzaGFkb3cgKz0gU2hhZG93RGVsdGE7XFxuXFxuXHRcdFx0XHRzaGFkb3cgKj0gc2hhZG93RGFya25lc3NbIGkgXTtcXG5cXG5cdCNlbGlmIGRlZmluZWQoIFNIQURPV01BUF9UWVBFX1BDRl9TT0ZUIClcXG5cXG5cXG5cdFx0XHRcdHNoYWRvd0Nvb3JkLnogKz0gc2hhZG93Qmlhc1sgaSBdO1xcblxcblx0XHRcdFx0ZmxvYXQgeFBpeGVsT2Zmc2V0ID0gdGV4ZWxTaXplWDtcXG5cdFx0XHRcdGZsb2F0IHlQaXhlbE9mZnNldCA9IHRleGVsU2l6ZVk7XFxuXFxuXHRcdFx0XHRmbG9hdCBkeDAgPSAtIDEuMCAqIHhQaXhlbE9mZnNldDtcXG5cdFx0XHRcdGZsb2F0IGR5MCA9IC0gMS4wICogeVBpeGVsT2Zmc2V0O1xcblx0XHRcdFx0ZmxvYXQgZHgxID0gMS4wICogeFBpeGVsT2Zmc2V0O1xcblx0XHRcdFx0ZmxvYXQgZHkxID0gMS4wICogeVBpeGVsT2Zmc2V0O1xcblxcblx0XHRcdFx0bWF0MyBzaGFkb3dLZXJuZWw7XFxuXHRcdFx0XHRtYXQzIGRlcHRoS2VybmVsO1xcblxcblx0XHRcdFx0ZGVwdGhLZXJuZWxbIDAgXVsgMCBdID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCBkeTAgKSApICk7XFxuXHRcdFx0XHRkZXB0aEtlcm5lbFsgMCBdWyAxIF0gPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIDAuMCApICkgKTtcXG5cdFx0XHRcdGRlcHRoS2VybmVsWyAwIF1bIDIgXSA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgZHkxICkgKSApO1xcblx0XHRcdFx0ZGVwdGhLZXJuZWxbIDEgXVsgMCBdID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggMC4wLCBkeTAgKSApICk7XFxuXHRcdFx0XHRkZXB0aEtlcm5lbFsgMSBdWyAxIF0gPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKSApO1xcblx0XHRcdFx0ZGVwdGhLZXJuZWxbIDEgXVsgMiBdID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggMC4wLCBkeTEgKSApICk7XFxuXHRcdFx0XHRkZXB0aEtlcm5lbFsgMiBdWyAwIF0gPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIGR5MCApICkgKTtcXG5cdFx0XHRcdGRlcHRoS2VybmVsWyAyIF1bIDEgXSA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MSwgMC4wICkgKSApO1xcblx0XHRcdFx0ZGVwdGhLZXJuZWxbIDIgXVsgMiBdID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCBkeTEgKSApICk7XFxuXFxuXHRcdFx0XHR2ZWMzIHNoYWRvd1ogPSB2ZWMzKCBzaGFkb3dDb29yZC56ICk7XFxuXHRcdFx0XHRzaGFkb3dLZXJuZWxbIDAgXSA9IHZlYzMoIGxlc3NUaGFuKCBkZXB0aEtlcm5lbFsgMCBdLCBzaGFkb3daICkgKTtcXG5cdFx0XHRcdHNoYWRvd0tlcm5lbFsgMCBdICo9IHZlYzMoIDAuMjUgKTtcXG5cXG5cdFx0XHRcdHNoYWRvd0tlcm5lbFsgMSBdID0gdmVjMyggbGVzc1RoYW4oIGRlcHRoS2VybmVsWyAxIF0sIHNoYWRvd1ogKSApO1xcblx0XHRcdFx0c2hhZG93S2VybmVsWyAxIF0gKj0gdmVjMyggMC4yNSApO1xcblxcblx0XHRcdFx0c2hhZG93S2VybmVsWyAyIF0gPSB2ZWMzKCBsZXNzVGhhbiggZGVwdGhLZXJuZWxbIDIgXSwgc2hhZG93WiApICk7XFxuXHRcdFx0XHRzaGFkb3dLZXJuZWxbIDIgXSAqPSB2ZWMzKCAwLjI1ICk7XFxuXFxuXHRcdFx0XHR2ZWMyIGZyYWN0aW9uYWxDb29yZCA9IDEuMCAtIGZyYWN0KCBzaGFkb3dDb29yZC54eSAqIHNoYWRvd01hcFNpemVbIGkgXS54eSApO1xcblxcblx0XHRcdFx0c2hhZG93S2VybmVsWyAwIF0gPSBtaXgoIHNoYWRvd0tlcm5lbFsgMSBdLCBzaGFkb3dLZXJuZWxbIDAgXSwgZnJhY3Rpb25hbENvb3JkLnggKTtcXG5cdFx0XHRcdHNoYWRvd0tlcm5lbFsgMSBdID0gbWl4KCBzaGFkb3dLZXJuZWxbIDIgXSwgc2hhZG93S2VybmVsWyAxIF0sIGZyYWN0aW9uYWxDb29yZC54ICk7XFxuXFxuXHRcdFx0XHR2ZWM0IHNoYWRvd1ZhbHVlcztcXG5cdFx0XHRcdHNoYWRvd1ZhbHVlcy54ID0gbWl4KCBzaGFkb3dLZXJuZWxbIDAgXVsgMSBdLCBzaGFkb3dLZXJuZWxbIDAgXVsgMCBdLCBmcmFjdGlvbmFsQ29vcmQueSApO1xcblx0XHRcdFx0c2hhZG93VmFsdWVzLnkgPSBtaXgoIHNoYWRvd0tlcm5lbFsgMCBdWyAyIF0sIHNoYWRvd0tlcm5lbFsgMCBdWyAxIF0sIGZyYWN0aW9uYWxDb29yZC55ICk7XFxuXHRcdFx0XHRzaGFkb3dWYWx1ZXMueiA9IG1peCggc2hhZG93S2VybmVsWyAxIF1bIDEgXSwgc2hhZG93S2VybmVsWyAxIF1bIDAgXSwgZnJhY3Rpb25hbENvb3JkLnkgKTtcXG5cdFx0XHRcdHNoYWRvd1ZhbHVlcy53ID0gbWl4KCBzaGFkb3dLZXJuZWxbIDEgXVsgMiBdLCBzaGFkb3dLZXJuZWxbIDEgXVsgMSBdLCBmcmFjdGlvbmFsQ29vcmQueSApO1xcblxcblx0XHRcdFx0c2hhZG93ID0gZG90KCBzaGFkb3dWYWx1ZXMsIHZlYzQoIDEuMCApICkgKiBzaGFkb3dEYXJrbmVzc1sgaSBdO1xcblxcblx0I2Vsc2UgXFxuXHRcdFx0XHRzaGFkb3dDb29yZC56ICs9IHNoYWRvd0JpYXNbIGkgXTtcXG5cXG5cdFx0XHRcdHZlYzQgcmdiYURlcHRoID0gdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKTtcXG5cdFx0XHRcdGZsb2F0IGZEZXB0aCA9IHVucGFja0RlcHRoKCByZ2JhRGVwdGggKTtcXG5cXG5cdFx0XHRcdGlmICggZkRlcHRoIDwgc2hhZG93Q29vcmQueiApXFxuXHRcdFx0XHRcdHNoYWRvdyA9IHNoYWRvd0RhcmtuZXNzWyBpIF07XFxuXFxuXHQjZW5kaWZcXG5cXG5cdFx0XHR9XFxuXFxuI2lmZGVmIFNIQURPV01BUF9ERUJVR1xcblxcblx0XHRcdGlmICggaW5GcnVzdHVtICkge1xcblxcblx0XHRcdFx0aWYgKCBpID09IDAgKSB7XFxuXFxuXHRcdFx0XHRcdG91dGdvaW5nTGlnaHQgKj0gdmVjMyggMS4wLCAwLjUsIDAuMCApO1xcblxcblx0XHRcdFx0fSBlbHNlIGlmICggaSA9PSAxICkge1xcblxcblx0XHRcdFx0XHRvdXRnb2luZ0xpZ2h0ICo9IHZlYzMoIDAuMCwgMS4wLCAwLjggKTtcXG5cXG5cdFx0XHRcdH0gZWxzZSB7XFxuXFxuXHRcdFx0XHRcdG91dGdvaW5nTGlnaHQgKj0gdmVjMyggMC4wLCAwLjUsIDEuMCApO1xcblxcblx0XHRcdFx0fVxcblxcblx0XHRcdH1cXG5cXG4jZW5kaWZcXG5cXG4jaWYgZGVmaW5lZCggUE9JTlRfTElHSFRfU0hBRE9XUyApXFxuXFxuXHRcdH1cXG5cXG4jZW5kaWZcXG5cXG5cdFx0c2hhZG93TWFzayA9IHNoYWRvd01hc2sgKiB2ZWMzKCAxLjAgLSBzaGFkb3cgKTtcXG5cXG5cdH1cXG5cXG4jZW5kaWZcXG5cIjtcblxuXHQvLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9zaGFkb3dtYXBfcGFyc19mcmFnbWVudC5nbHNsXG5cblx0VEhSRUUuU2hhZGVyQ2h1bmtbICdzaGFkb3dtYXBfcGFyc19mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX1NIQURPV01BUFxcblxcblx0dW5pZm9ybSBzYW1wbGVyMkQgc2hhZG93TWFwWyBNQVhfU0hBRE9XUyBdO1xcblx0dW5pZm9ybSB2ZWMyIHNoYWRvd01hcFNpemVbIE1BWF9TSEFET1dTIF07XFxuXFxuXHR1bmlmb3JtIGZsb2F0IHNoYWRvd0RhcmtuZXNzWyBNQVhfU0hBRE9XUyBdO1xcblx0dW5pZm9ybSBmbG9hdCBzaGFkb3dCaWFzWyBNQVhfU0hBRE9XUyBdO1xcblxcblx0dmFyeWluZyB2ZWM0IHZTaGFkb3dDb29yZFsgTUFYX1NIQURPV1MgXTtcXG5cXG5cdGZsb2F0IHVucGFja0RlcHRoKCBjb25zdCBpbiB2ZWM0IHJnYmFfZGVwdGggKSB7XFxuXFxuXHRcdGNvbnN0IHZlYzQgYml0X3NoaWZ0ID0gdmVjNCggMS4wIC8gKCAyNTYuMCAqIDI1Ni4wICogMjU2LjAgKSwgMS4wIC8gKCAyNTYuMCAqIDI1Ni4wICksIDEuMCAvIDI1Ni4wLCAxLjAgKTtcXG5cdFx0ZmxvYXQgZGVwdGggPSBkb3QoIHJnYmFfZGVwdGgsIGJpdF9zaGlmdCApO1xcblx0XHRyZXR1cm4gZGVwdGg7XFxuXFxuXHR9XFxuXFxuXHQjaWYgZGVmaW5lZChQT0lOVF9MSUdIVF9TSEFET1dTKVxcblxcblxcblx0XHR2b2lkIGFkanVzdFNoYWRvd1ZhbHVlMUsoIGNvbnN0IGZsb2F0IHRlc3REZXB0aCwgY29uc3QgdmVjNCB0ZXh0dXJlRGF0YSwgY29uc3QgZmxvYXQgYmlhcywgaW5vdXQgZmxvYXQgc2hhZG93VmFsdWUgKSB7XFxuXFxuXHRcdFx0Y29uc3QgdmVjNCBiaXRTaCA9IHZlYzQoIDEuMCAvICggMjU2LjAgKiAyNTYuMCAqIDI1Ni4wICksIDEuMCAvICggMjU2LjAgKiAyNTYuMCApLCAxLjAgLyAyNTYuMCwgMS4wICk7XFxuXHRcdFx0aWYgKCB0ZXN0RGVwdGggPj0gZG90KCB0ZXh0dXJlRGF0YSwgYml0U2ggKSAqIDEwMDAuMCArIGJpYXMgKVxcblx0XHRcdFx0c2hhZG93VmFsdWUgKz0gMS4wO1xcblxcblx0XHR9XFxuXFxuXFxuXHRcdHZlYzIgY3ViZVRvVVYoIHZlYzMgdiwgZmxvYXQgdGV4ZWxTaXplWSApIHtcXG5cXG5cXG5cdFx0XHR2ZWMzIGFic1YgPSBhYnMoIHYgKTtcXG5cXG5cXG5cdFx0XHRmbG9hdCBzY2FsZVRvQ3ViZSA9IDEuMCAvIG1heCggYWJzVi54LCBtYXgoIGFic1YueSwgYWJzVi56ICkgKTtcXG5cdFx0XHRhYnNWICo9IHNjYWxlVG9DdWJlO1xcblxcblxcblx0XHRcdHYgKj0gc2NhbGVUb0N1YmUgKiAoIDEuMCAtIDIuMCAqIHRleGVsU2l6ZVkgKTtcXG5cXG5cXG5cXG5cdFx0XHR2ZWMyIHBsYW5hciA9IHYueHk7XFxuXFxuXHRcdFx0ZmxvYXQgYWxtb3N0QVRleGVsID0gMS41ICogdGV4ZWxTaXplWTtcXG5cdFx0XHRmbG9hdCBhbG1vc3RPbmUgPSAxLjAgLSBhbG1vc3RBVGV4ZWw7XFxuXFxuXHRcdFx0aWYgKCBhYnNWLnogPj0gYWxtb3N0T25lICkge1xcblxcblx0XHRcdFx0aWYgKCB2LnogPiAwLjAgKVxcblx0XHRcdFx0XHRwbGFuYXIueCA9IDQuMCAtIHYueDtcXG5cXG5cdFx0XHR9IGVsc2UgaWYgKCBhYnNWLnggPj0gYWxtb3N0T25lICkge1xcblxcblx0XHRcdFx0ZmxvYXQgc2lnblggPSBzaWduKCB2LnggKTtcXG5cdFx0XHRcdHBsYW5hci54ID0gdi56ICogc2lnblggKyAyLjAgKiBzaWduWDtcXG5cXG5cdFx0XHR9IGVsc2UgaWYgKCBhYnNWLnkgPj0gYWxtb3N0T25lICkge1xcblxcblx0XHRcdFx0ZmxvYXQgc2lnblkgPSBzaWduKCB2LnkgKTtcXG5cdFx0XHRcdHBsYW5hci54ID0gdi54ICsgMi4wICogc2lnblkgKyAyLjA7XFxuXHRcdFx0XHRwbGFuYXIueSA9IHYueiAqIHNpZ25ZIC0gMi4wO1xcblxcblx0XHRcdH1cXG5cXG5cXG5cdFx0XHRyZXR1cm4gdmVjMiggMC4xMjUsIDAuMjUgKSAqIHBsYW5hciArIHZlYzIoIDAuMzc1LCAwLjc1ICk7XFxuXFxuXHRcdH1cXG5cXG5cdCNlbmRpZlxcblxcbiNlbmRpZlxcblwiO1xuXG5cdC8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3NoYWRvd21hcF9wYXJzX3ZlcnRleC5nbHNsXG5cblx0VEhSRUUuU2hhZGVyQ2h1bmtbICdzaGFkb3dtYXBfcGFyc192ZXJ0ZXgnXSA9IFwiI2lmZGVmIFVTRV9TSEFET1dNQVBcXG5cXG5cdHVuaWZvcm0gZmxvYXQgc2hhZG93RGFya25lc3NbIE1BWF9TSEFET1dTIF07XFxuXHR1bmlmb3JtIG1hdDQgc2hhZG93TWF0cml4WyBNQVhfU0hBRE9XUyBdO1xcblx0dmFyeWluZyB2ZWM0IHZTaGFkb3dDb29yZFsgTUFYX1NIQURPV1MgXTtcXG5cXG4jZW5kaWZcIjtcblxuXHQvLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9zaGFkb3dtYXBfdmVydGV4Lmdsc2xcblxuXHRUSFJFRS5TaGFkZXJDaHVua1sgJ3NoYWRvd21hcF92ZXJ0ZXgnXSA9IFwiI2lmZGVmIFVTRV9TSEFET1dNQVBcXG5cXG5cdGZvciAoIGludCBpID0gMDsgaSA8IE1BWF9TSEFET1dTOyBpICsrICkge1xcblxcblx0XHRcdHZTaGFkb3dDb29yZFsgaSBdID0gc2hhZG93TWF0cml4WyBpIF0gKiB3b3JsZFBvc2l0aW9uO1xcblxcblx0fVxcblxcbiNlbmRpZlwiO1xuXG5cdC8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3NraW5iYXNlX3ZlcnRleC5nbHNsXG5cblx0VEhSRUUuU2hhZGVyQ2h1bmtbICdza2luYmFzZV92ZXJ0ZXgnXSA9IFwiI2lmZGVmIFVTRV9TS0lOTklOR1xcblxcblx0bWF0NCBib25lTWF0WCA9IGdldEJvbmVNYXRyaXgoIHNraW5JbmRleC54ICk7XFxuXHRtYXQ0IGJvbmVNYXRZID0gZ2V0Qm9uZU1hdHJpeCggc2tpbkluZGV4LnkgKTtcXG5cdG1hdDQgYm9uZU1hdFogPSBnZXRCb25lTWF0cml4KCBza2luSW5kZXgueiApO1xcblx0bWF0NCBib25lTWF0VyA9IGdldEJvbmVNYXRyaXgoIHNraW5JbmRleC53ICk7XFxuXFxuI2VuZGlmXCI7XG5cblx0Ly8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvc2tpbm5pbmdfcGFyc192ZXJ0ZXguZ2xzbFxuXG5cdFRIUkVFLlNoYWRlckNodW5rWyAnc2tpbm5pbmdfcGFyc192ZXJ0ZXgnXSA9IFwiI2lmZGVmIFVTRV9TS0lOTklOR1xcblxcblx0dW5pZm9ybSBtYXQ0IGJpbmRNYXRyaXg7XFxuXHR1bmlmb3JtIG1hdDQgYmluZE1hdHJpeEludmVyc2U7XFxuXFxuXHQjaWZkZWYgQk9ORV9URVhUVVJFXFxuXFxuXHRcdHVuaWZvcm0gc2FtcGxlcjJEIGJvbmVUZXh0dXJlO1xcblx0XHR1bmlmb3JtIGludCBib25lVGV4dHVyZVdpZHRoO1xcblx0XHR1bmlmb3JtIGludCBib25lVGV4dHVyZUhlaWdodDtcXG5cXG5cdFx0bWF0NCBnZXRCb25lTWF0cml4KCBjb25zdCBpbiBmbG9hdCBpICkge1xcblxcblx0XHRcdGZsb2F0IGogPSBpICogNC4wO1xcblx0XHRcdGZsb2F0IHggPSBtb2QoIGosIGZsb2F0KCBib25lVGV4dHVyZVdpZHRoICkgKTtcXG5cdFx0XHRmbG9hdCB5ID0gZmxvb3IoIGogLyBmbG9hdCggYm9uZVRleHR1cmVXaWR0aCApICk7XFxuXFxuXHRcdFx0ZmxvYXQgZHggPSAxLjAgLyBmbG9hdCggYm9uZVRleHR1cmVXaWR0aCApO1xcblx0XHRcdGZsb2F0IGR5ID0gMS4wIC8gZmxvYXQoIGJvbmVUZXh0dXJlSGVpZ2h0ICk7XFxuXFxuXHRcdFx0eSA9IGR5ICogKCB5ICsgMC41ICk7XFxuXFxuXHRcdFx0dmVjNCB2MSA9IHRleHR1cmUyRCggYm9uZVRleHR1cmUsIHZlYzIoIGR4ICogKCB4ICsgMC41ICksIHkgKSApO1xcblx0XHRcdHZlYzQgdjIgPSB0ZXh0dXJlMkQoIGJvbmVUZXh0dXJlLCB2ZWMyKCBkeCAqICggeCArIDEuNSApLCB5ICkgKTtcXG5cdFx0XHR2ZWM0IHYzID0gdGV4dHVyZTJEKCBib25lVGV4dHVyZSwgdmVjMiggZHggKiAoIHggKyAyLjUgKSwgeSApICk7XFxuXHRcdFx0dmVjNCB2NCA9IHRleHR1cmUyRCggYm9uZVRleHR1cmUsIHZlYzIoIGR4ICogKCB4ICsgMy41ICksIHkgKSApO1xcblxcblx0XHRcdG1hdDQgYm9uZSA9IG1hdDQoIHYxLCB2MiwgdjMsIHY0ICk7XFxuXFxuXHRcdFx0cmV0dXJuIGJvbmU7XFxuXFxuXHRcdH1cXG5cXG5cdCNlbHNlXFxuXFxuXHRcdHVuaWZvcm0gbWF0NCBib25lR2xvYmFsTWF0cmljZXNbIE1BWF9CT05FUyBdO1xcblxcblx0XHRtYXQ0IGdldEJvbmVNYXRyaXgoIGNvbnN0IGluIGZsb2F0IGkgKSB7XFxuXFxuXHRcdFx0bWF0NCBib25lID0gYm9uZUdsb2JhbE1hdHJpY2VzWyBpbnQoaSkgXTtcXG5cdFx0XHRyZXR1cm4gYm9uZTtcXG5cXG5cdFx0fVxcblxcblx0I2VuZGlmXFxuXFxuI2VuZGlmXFxuXCI7XG5cblx0Ly8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvc2tpbm5pbmdfdmVydGV4Lmdsc2xcblxuXHRUSFJFRS5TaGFkZXJDaHVua1sgJ3NraW5uaW5nX3ZlcnRleCddID0gXCIjaWZkZWYgVVNFX1NLSU5OSU5HXFxuXFxuXHR2ZWM0IHNraW5WZXJ0ZXggPSBiaW5kTWF0cml4ICogdmVjNCggdHJhbnNmb3JtZWQsIDEuMCApO1xcblxcblx0dmVjNCBza2lubmVkID0gdmVjNCggMC4wICk7XFxuXHRza2lubmVkICs9IGJvbmVNYXRYICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQueDtcXG5cdHNraW5uZWQgKz0gYm9uZU1hdFkgKiBza2luVmVydGV4ICogc2tpbldlaWdodC55O1xcblx0c2tpbm5lZCArPSBib25lTWF0WiAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lno7XFxuXHRza2lubmVkICs9IGJvbmVNYXRXICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQudztcXG5cdHNraW5uZWQgID0gYmluZE1hdHJpeEludmVyc2UgKiBza2lubmVkO1xcblxcbiNlbmRpZlxcblwiO1xuXG5cdC8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3NraW5ub3JtYWxfdmVydGV4Lmdsc2xcblxuXHRUSFJFRS5TaGFkZXJDaHVua1sgJ3NraW5ub3JtYWxfdmVydGV4J10gPSBcIiNpZmRlZiBVU0VfU0tJTk5JTkdcXG5cXG5cdG1hdDQgc2tpbk1hdHJpeCA9IG1hdDQoIDAuMCApO1xcblx0c2tpbk1hdHJpeCArPSBza2luV2VpZ2h0LnggKiBib25lTWF0WDtcXG5cdHNraW5NYXRyaXggKz0gc2tpbldlaWdodC55ICogYm9uZU1hdFk7XFxuXHRza2luTWF0cml4ICs9IHNraW5XZWlnaHQueiAqIGJvbmVNYXRaO1xcblx0c2tpbk1hdHJpeCArPSBza2luV2VpZ2h0LncgKiBib25lTWF0VztcXG5cdHNraW5NYXRyaXggID0gYmluZE1hdHJpeEludmVyc2UgKiBza2luTWF0cml4ICogYmluZE1hdHJpeDtcXG5cXG5cdG9iamVjdE5vcm1hbCA9IHZlYzQoIHNraW5NYXRyaXggKiB2ZWM0KCBvYmplY3ROb3JtYWwsIDAuMCApICkueHl6O1xcblxcbiNlbmRpZlxcblwiO1xuXG5cdC8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3NwZWN1bGFybWFwX2ZyYWdtZW50Lmdsc2xcblxuXHRUSFJFRS5TaGFkZXJDaHVua1sgJ3NwZWN1bGFybWFwX2ZyYWdtZW50J10gPSBcImZsb2F0IHNwZWN1bGFyU3RyZW5ndGg7XFxuXFxuI2lmZGVmIFVTRV9TUEVDVUxBUk1BUFxcblxcblx0dmVjNCB0ZXhlbFNwZWN1bGFyID0gdGV4dHVyZTJEKCBzcGVjdWxhck1hcCwgdlV2ICk7XFxuXHRzcGVjdWxhclN0cmVuZ3RoID0gdGV4ZWxTcGVjdWxhci5yO1xcblxcbiNlbHNlXFxuXFxuXHRzcGVjdWxhclN0cmVuZ3RoID0gMS4wO1xcblxcbiNlbmRpZlwiO1xuXG5cdC8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3NwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnQuZ2xzbFxuXG5cdFRIUkVFLlNoYWRlckNodW5rWyAnc3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX1NQRUNVTEFSTUFQXFxuXFxuXHR1bmlmb3JtIHNhbXBsZXIyRCBzcGVjdWxhck1hcDtcXG5cXG4jZW5kaWZcIjtcblxuXHQvLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay91djJfcGFyc19mcmFnbWVudC5nbHNsXG5cblx0VEhSRUUuU2hhZGVyQ2h1bmtbICd1djJfcGFyc19mcmFnbWVudCddID0gXCIjaWYgZGVmaW5lZCggVVNFX0xJR0hUTUFQICkgfHwgZGVmaW5lZCggVVNFX0FPTUFQIClcXG5cXG5cdHZhcnlpbmcgdmVjMiB2VXYyO1xcblxcbiNlbmRpZlwiO1xuXG5cdC8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3V2Ml9wYXJzX3ZlcnRleC5nbHNsXG5cblx0VEhSRUUuU2hhZGVyQ2h1bmtbICd1djJfcGFyc192ZXJ0ZXgnXSA9IFwiI2lmIGRlZmluZWQoIFVTRV9MSUdIVE1BUCApIHx8IGRlZmluZWQoIFVTRV9BT01BUCApXFxuXFxuXHRhdHRyaWJ1dGUgdmVjMiB1djI7XFxuXHR2YXJ5aW5nIHZlYzIgdlV2MjtcXG5cXG4jZW5kaWZcIjtcblxuXHQvLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay91djJfdmVydGV4Lmdsc2xcblxuXHRUSFJFRS5TaGFkZXJDaHVua1sgJ3V2Ml92ZXJ0ZXgnXSA9IFwiI2lmIGRlZmluZWQoIFVTRV9MSUdIVE1BUCApIHx8IGRlZmluZWQoIFVTRV9BT01BUCApXFxuXFxuXHR2VXYyID0gdXYyO1xcblxcbiNlbmRpZlwiO1xuXG5cdC8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3V2X3BhcnNfZnJhZ21lbnQuZ2xzbFxuXG5cdFRIUkVFLlNoYWRlckNodW5rWyAndXZfcGFyc19mcmFnbWVudCddID0gXCIjaWYgZGVmaW5lZCggVVNFX01BUCApIHx8IGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApIHx8IGRlZmluZWQoIFVTRV9TUEVDVUxBUk1BUCApIHx8IGRlZmluZWQoIFVTRV9BTFBIQU1BUCApIHx8IGRlZmluZWQoIFVTRV9FTUlTU0lWRU1BUCApXFxuXFxuXHR2YXJ5aW5nIHZlYzIgdlV2O1xcblxcbiNlbmRpZlwiO1xuXG5cdC8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3V2X3BhcnNfdmVydGV4Lmdsc2xcblxuXHRUSFJFRS5TaGFkZXJDaHVua1sgJ3V2X3BhcnNfdmVydGV4J10gPSBcIiNpZiBkZWZpbmVkKCBVU0VfTUFQICkgfHwgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggVVNFX1NQRUNVTEFSTUFQICkgfHwgZGVmaW5lZCggVVNFX0FMUEhBTUFQICkgfHwgZGVmaW5lZCggVVNFX0VNSVNTSVZFTUFQIClcXG5cXG5cdHZhcnlpbmcgdmVjMiB2VXY7XFxuXHR1bmlmb3JtIHZlYzQgb2Zmc2V0UmVwZWF0O1xcblxcbiNlbmRpZlxcblwiO1xuXG5cdC8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3V2X3ZlcnRleC5nbHNsXG5cblx0VEhSRUUuU2hhZGVyQ2h1bmtbICd1dl92ZXJ0ZXgnXSA9IFwiI2lmIGRlZmluZWQoIFVTRV9NQVAgKSB8fCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBVU0VfU1BFQ1VMQVJNQVAgKSB8fCBkZWZpbmVkKCBVU0VfQUxQSEFNQVAgKSB8fCBkZWZpbmVkKCBVU0VfRU1JU1NJVkVNQVAgKVxcblxcblx0dlV2ID0gdXYgKiBvZmZzZXRSZXBlYXQuencgKyBvZmZzZXRSZXBlYXQueHk7XFxuXFxuI2VuZGlmXCI7XG5cblx0Ly8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvd29ybGRwb3NfdmVydGV4Lmdsc2xcblxuXHRUSFJFRS5TaGFkZXJDaHVua1sgJ3dvcmxkcG9zX3ZlcnRleCddID0gXCIjaWYgZGVmaW5lZCggVVNFX0VOVk1BUCApIHx8IGRlZmluZWQoIFBIT05HICkgfHwgZGVmaW5lZCggTEFNQkVSVCApIHx8IGRlZmluZWQgKCBVU0VfU0hBRE9XTUFQIClcXG5cXG5cdCNpZmRlZiBVU0VfU0tJTk5JTkdcXG5cXG5cdFx0dmVjNCB3b3JsZFBvc2l0aW9uID0gbW9kZWxNYXRyaXggKiBza2lubmVkO1xcblxcblx0I2Vsc2VcXG5cXG5cdFx0dmVjNCB3b3JsZFBvc2l0aW9uID0gbW9kZWxNYXRyaXggKiB2ZWM0KCB0cmFuc2Zvcm1lZCwgMS4wICk7XFxuXFxuXHQjZW5kaWZcXG5cXG4jZW5kaWZcXG5cIjtcblxuXHQvLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9Vbmlmb3Jtc1V0aWxzLmpzXG5cblx0LyoqXG5cdCAqIFVuaWZvcm0gVXRpbGl0aWVzXG5cdCAqL1xuXG5cdFRIUkVFLlVuaWZvcm1zVXRpbHMgPSB7XG5cblx0XHRtZXJnZTogZnVuY3Rpb24gKCB1bmlmb3JtcyApIHtcblxuXHRcdFx0dmFyIG1lcmdlZCA9IHt9O1xuXG5cdFx0XHRmb3IgKCB2YXIgdSA9IDA7IHUgPCB1bmlmb3Jtcy5sZW5ndGg7IHUgKysgKSB7XG5cblx0XHRcdFx0dmFyIHRtcCA9IHRoaXMuY2xvbmUoIHVuaWZvcm1zWyB1IF0gKTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgcCBpbiB0bXAgKSB7XG5cblx0XHRcdFx0XHRtZXJnZWRbIHAgXSA9IHRtcFsgcCBdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWVyZ2VkO1xuXG5cdFx0fSxcblxuXHRcdGNsb25lOiBmdW5jdGlvbiAoIHVuaWZvcm1zX3NyYyApIHtcblxuXHRcdFx0dmFyIHVuaWZvcm1zX2RzdCA9IHt9O1xuXG5cdFx0XHRmb3IgKCB2YXIgdSBpbiB1bmlmb3Jtc19zcmMgKSB7XG5cblx0XHRcdFx0dW5pZm9ybXNfZHN0WyB1IF0gPSB7fTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgcCBpbiB1bmlmb3Jtc19zcmNbIHUgXSApIHtcblxuXHRcdFx0XHRcdHZhciBwYXJhbWV0ZXJfc3JjID0gdW5pZm9ybXNfc3JjWyB1IF1bIHAgXTtcblxuXHRcdFx0XHRcdGlmICggcGFyYW1ldGVyX3NyYyBpbnN0YW5jZW9mIFRIUkVFLkNvbG9yIHx8XG5cdFx0XHRcdFx0XHQgcGFyYW1ldGVyX3NyYyBpbnN0YW5jZW9mIFRIUkVFLlZlY3RvcjIgfHxcblx0XHRcdFx0XHRcdCBwYXJhbWV0ZXJfc3JjIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yMyB8fFxuXHRcdFx0XHRcdFx0IHBhcmFtZXRlcl9zcmMgaW5zdGFuY2VvZiBUSFJFRS5WZWN0b3I0IHx8XG5cdFx0XHRcdFx0XHQgcGFyYW1ldGVyX3NyYyBpbnN0YW5jZW9mIFRIUkVFLk1hdHJpeDMgfHxcblx0XHRcdFx0XHRcdCBwYXJhbWV0ZXJfc3JjIGluc3RhbmNlb2YgVEhSRUUuTWF0cml4NCB8fFxuXHRcdFx0XHRcdFx0IHBhcmFtZXRlcl9zcmMgaW5zdGFuY2VvZiBUSFJFRS5UZXh0dXJlICkge1xuXG5cdFx0XHRcdFx0XHR1bmlmb3Jtc19kc3RbIHUgXVsgcCBdID0gcGFyYW1ldGVyX3NyYy5jbG9uZSgpO1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggQXJyYXkuaXNBcnJheSggcGFyYW1ldGVyX3NyYyApICkge1xuXG5cdFx0XHRcdFx0XHR1bmlmb3Jtc19kc3RbIHUgXVsgcCBdID0gcGFyYW1ldGVyX3NyYy5zbGljZSgpO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0dW5pZm9ybXNfZHN0WyB1IF1bIHAgXSA9IHBhcmFtZXRlcl9zcmM7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB1bmlmb3Jtc19kc3Q7XG5cblx0XHR9XG5cblx0fTtcblxuXHQvLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9Vbmlmb3Jtc0xpYi5qc1xuXG5cdC8qKlxuXHQgKiBVbmlmb3JtcyBsaWJyYXJ5IGZvciBzaGFyZWQgd2ViZ2wgc2hhZGVyc1xuXHQgKi9cblxuXHRUSFJFRS5Vbmlmb3Jtc0xpYiA9IHtcblxuXHRcdGNvbW1vbjoge1xuXG5cdFx0XHRcImRpZmZ1c2VcIiA6IHsgdHlwZTogXCJjXCIsIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoIDB4ZWVlZWVlICkgfSxcblx0XHRcdFwib3BhY2l0eVwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEuMCB9LFxuXG5cdFx0XHRcIm1hcFwiIDogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcblx0XHRcdFwib2Zmc2V0UmVwZWF0XCIgOiB7IHR5cGU6IFwidjRcIiwgdmFsdWU6IG5ldyBUSFJFRS5WZWN0b3I0KCAwLCAwLCAxLCAxICkgfSxcblxuXHRcdFx0XCJzcGVjdWxhck1hcFwiIDogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcblx0XHRcdFwiYWxwaGFNYXBcIiA6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXG5cblx0XHRcdFwiZW52TWFwXCIgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxuXHRcdFx0XCJmbGlwRW52TWFwXCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogLSAxIH0sXG5cdFx0XHRcInJlZmxlY3Rpdml0eVwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEuMCB9LFxuXHRcdFx0XCJyZWZyYWN0aW9uUmF0aW9cIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAwLjk4IH1cblxuXHRcdH0sXG5cblx0XHRhb21hcDoge1xuXG5cdFx0XHRcImFvTWFwXCIgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxuXHRcdFx0XCJhb01hcEludGVuc2l0eVwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEgfSxcblxuXHRcdH0sXG5cblx0XHRsaWdodG1hcDoge1xuXG5cdFx0XHRcImxpZ2h0TWFwXCIgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxuXHRcdFx0XCJsaWdodE1hcEludGVuc2l0eVwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEgfSxcblxuXHRcdH0sXG5cblx0XHRlbWlzc2l2ZW1hcDoge1xuXG5cdFx0XHRcImVtaXNzaXZlTWFwXCIgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxuXG5cdFx0fSxcblxuXHRcdGJ1bXBtYXA6IHtcblxuXHRcdFx0XCJidW1wTWFwXCIgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxuXHRcdFx0XCJidW1wU2NhbGVcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxIH1cblxuXHRcdH0sXG5cblx0XHRub3JtYWxtYXA6IHtcblxuXHRcdFx0XCJub3JtYWxNYXBcIiA6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXG5cdFx0XHRcIm5vcm1hbFNjYWxlXCIgOiB7IHR5cGU6IFwidjJcIiwgdmFsdWU6IG5ldyBUSFJFRS5WZWN0b3IyKCAxLCAxICkgfVxuXG5cdFx0fSxcblxuXHRcdGRpc3BsYWNlbWVudG1hcDoge1xuXG5cdFx0XHRcImRpc3BsYWNlbWVudE1hcFwiIDogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcblx0XHRcdFwiZGlzcGxhY2VtZW50U2NhbGVcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxIH0sXG5cdFx0XHRcImRpc3BsYWNlbWVudEJpYXNcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAwIH1cblxuXHRcdH0sXG5cblx0XHRmb2cgOiB7XG5cblx0XHRcdFwiZm9nRGVuc2l0eVwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDAuMDAwMjUgfSxcblx0XHRcdFwiZm9nTmVhclwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEgfSxcblx0XHRcdFwiZm9nRmFyXCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMjAwMCB9LFxuXHRcdFx0XCJmb2dDb2xvclwiIDogeyB0eXBlOiBcImNcIiwgdmFsdWU6IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKSB9XG5cblx0XHR9LFxuXG5cdFx0bGlnaHRzOiB7XG5cblx0XHRcdFwiYW1iaWVudExpZ2h0Q29sb3JcIiA6IHsgdHlwZTogXCJmdlwiLCB2YWx1ZTogW10gfSxcblxuXHRcdFx0XCJkaXJlY3Rpb25hbExpZ2h0RGlyZWN0aW9uXCIgOiB7IHR5cGU6IFwiZnZcIiwgdmFsdWU6IFtdIH0sXG5cdFx0XHRcImRpcmVjdGlvbmFsTGlnaHRDb2xvclwiIDogeyB0eXBlOiBcImZ2XCIsIHZhbHVlOiBbXSB9LFxuXG5cdFx0XHRcImhlbWlzcGhlcmVMaWdodERpcmVjdGlvblwiIDogeyB0eXBlOiBcImZ2XCIsIHZhbHVlOiBbXSB9LFxuXHRcdFx0XCJoZW1pc3BoZXJlTGlnaHRTa3lDb2xvclwiIDogeyB0eXBlOiBcImZ2XCIsIHZhbHVlOiBbXSB9LFxuXHRcdFx0XCJoZW1pc3BoZXJlTGlnaHRHcm91bmRDb2xvclwiIDogeyB0eXBlOiBcImZ2XCIsIHZhbHVlOiBbXSB9LFxuXG5cdFx0XHRcInBvaW50TGlnaHRDb2xvclwiIDogeyB0eXBlOiBcImZ2XCIsIHZhbHVlOiBbXSB9LFxuXHRcdFx0XCJwb2ludExpZ2h0UG9zaXRpb25cIiA6IHsgdHlwZTogXCJmdlwiLCB2YWx1ZTogW10gfSxcblx0XHRcdFwicG9pbnRMaWdodERpc3RhbmNlXCIgOiB7IHR5cGU6IFwiZnYxXCIsIHZhbHVlOiBbXSB9LFxuXHRcdFx0XCJwb2ludExpZ2h0RGVjYXlcIiA6IHsgdHlwZTogXCJmdjFcIiwgdmFsdWU6IFtdIH0sXG5cblx0XHRcdFwic3BvdExpZ2h0Q29sb3JcIiA6IHsgdHlwZTogXCJmdlwiLCB2YWx1ZTogW10gfSxcblx0XHRcdFwic3BvdExpZ2h0UG9zaXRpb25cIiA6IHsgdHlwZTogXCJmdlwiLCB2YWx1ZTogW10gfSxcblx0XHRcdFwic3BvdExpZ2h0RGlyZWN0aW9uXCIgOiB7IHR5cGU6IFwiZnZcIiwgdmFsdWU6IFtdIH0sXG5cdFx0XHRcInNwb3RMaWdodERpc3RhbmNlXCIgOiB7IHR5cGU6IFwiZnYxXCIsIHZhbHVlOiBbXSB9LFxuXHRcdFx0XCJzcG90TGlnaHRBbmdsZUNvc1wiIDogeyB0eXBlOiBcImZ2MVwiLCB2YWx1ZTogW10gfSxcblx0XHRcdFwic3BvdExpZ2h0RXhwb25lbnRcIiA6IHsgdHlwZTogXCJmdjFcIiwgdmFsdWU6IFtdIH0sXG5cdFx0XHRcInNwb3RMaWdodERlY2F5XCIgOiB7IHR5cGU6IFwiZnYxXCIsIHZhbHVlOiBbXSB9XG5cblx0XHR9LFxuXG5cdFx0cG9pbnRzOiB7XG5cblx0XHRcdFwicHNDb2xvclwiIDogeyB0eXBlOiBcImNcIiwgdmFsdWU6IG5ldyBUSFJFRS5Db2xvciggMHhlZWVlZWUgKSB9LFxuXHRcdFx0XCJvcGFjaXR5XCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH0sXG5cdFx0XHRcInNpemVcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxLjAgfSxcblx0XHRcdFwic2NhbGVcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxLjAgfSxcblx0XHRcdFwibWFwXCIgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxuXHRcdFx0XCJvZmZzZXRSZXBlYXRcIiA6IHsgdHlwZTogXCJ2NFwiLCB2YWx1ZTogbmV3IFRIUkVFLlZlY3RvcjQoIDAsIDAsIDEsIDEgKSB9LFxuXG5cdFx0XHRcImZvZ0RlbnNpdHlcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAwLjAwMDI1IH0sXG5cdFx0XHRcImZvZ05lYXJcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxIH0sXG5cdFx0XHRcImZvZ0ZhclwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDIwMDAgfSxcblx0XHRcdFwiZm9nQ29sb3JcIiA6IHsgdHlwZTogXCJjXCIsIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICkgfVxuXG5cdFx0fSxcblxuXHRcdHNoYWRvd21hcDoge1xuXG5cdFx0XHRcInNoYWRvd01hcFwiOiB7IHR5cGU6IFwidHZcIiwgdmFsdWU6IFtdIH0sXG5cdFx0XHRcInNoYWRvd01hcFNpemVcIjogeyB0eXBlOiBcInYydlwiLCB2YWx1ZTogW10gfSxcblxuXHRcdFx0XCJzaGFkb3dCaWFzXCIgOiB7IHR5cGU6IFwiZnYxXCIsIHZhbHVlOiBbXSB9LFxuXHRcdFx0XCJzaGFkb3dEYXJrbmVzc1wiOiB7IHR5cGU6IFwiZnYxXCIsIHZhbHVlOiBbXSB9LFxuXG5cdFx0XHRcInNoYWRvd01hdHJpeFwiIDogeyB0eXBlOiBcIm00dlwiLCB2YWx1ZTogW10gfVxuXG5cdFx0fVxuXG5cdH07XG5cblx0Ly8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyTGliLmpzXG5cblx0LyoqXG5cdCAqIFdlYmdsIFNoYWRlciBMaWJyYXJ5IGZvciB0aHJlZS5qc1xuXHQgKlxuXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuXHQgKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuXHQgKi9cblxuXG5cdFRIUkVFLlNoYWRlckxpYiA9IHtcblxuXHRcdCdiYXNpYyc6IHtcblxuXHRcdFx0dW5pZm9ybXM6IFRIUkVFLlVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcblxuXHRcdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJjb21tb25cIiBdLFxuXHRcdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJhb21hcFwiIF0sXG5cdFx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImZvZ1wiIF0sXG5cdFx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcInNoYWRvd21hcFwiIF1cblxuXHRcdFx0XSApLFxuXG5cdFx0XHR2ZXJ0ZXhTaGFkZXI6IFtcblxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJ1dl9wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInV2Ml9wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF9wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfdmVydGV4XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ19wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4XCIgXSxcblxuXHRcdFx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInV2X3ZlcnRleFwiIF0sXG5cdFx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwidXYyX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfdmVydGV4XCIgXSxcblx0XHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2luYmFzZV92ZXJ0ZXhcIiBdLFxuXG5cdFx0XHRcdFwiXHQjaWZkZWYgVVNFX0VOVk1BUFwiLFxuXG5cdFx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYmVnaW5ub3JtYWxfdmVydGV4XCIgXSxcblx0XHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaG5vcm1hbF92ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5ub3JtYWxfdmVydGV4XCIgXSxcblx0XHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJkZWZhdWx0bm9ybWFsX3ZlcnRleFwiIF0sXG5cblx0XHRcdFx0XCJcdCNlbmRpZlwiLFxuXG5cdFx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYmVnaW5fdmVydGV4XCIgXSxcblx0XHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF92ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwicHJvamVjdF92ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3ZlcnRleFwiIF0sXG5cblx0XHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJ3b3JsZHBvc192ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF92ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF92ZXJ0ZXhcIiBdLFxuXG5cdFx0XHRcdFwifVwiXG5cblx0XHRcdF0uam9pbiggXCJcXG5cIiApLFxuXG5cdFx0XHRmcmFnbWVudFNoYWRlcjogW1xuXG5cdFx0XHRcdFwidW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XCIsXG5cdFx0XHRcdFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxuXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJ1dl9wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwidXYyX3BhcnNfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImFscGhhbWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJhb21hcF9wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnRcIiBdLFxuXG5cdFx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxuXG5cdFx0XHRcdFwiXHR2ZWMzIG91dGdvaW5nTGlnaHQgPSB2ZWMzKCAwLjAgKTtcIixcblx0XHRcdFx0XCJcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1wiLFxuXHRcdFx0XHRcIlx0dmVjMyB0b3RhbEFtYmllbnRMaWdodCA9IHZlYzMoIDEuMCApO1wiLCAvLyBoYXJkd2lyZWRcblx0XHRcdFx0XCJcdHZlYzMgc2hhZG93TWFzayA9IHZlYzMoIDEuMCApO1wiLFxuXG5cdFx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF9mcmFnbWVudFwiIF0sXG5cdFx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImFscGhhbWFwX2ZyYWdtZW50XCIgXSxcblx0XHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJhbHBoYXRlc3RfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNwZWN1bGFybWFwX2ZyYWdtZW50XCIgXSxcblx0XHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJhb21hcF9mcmFnbWVudFwiIF0sXG5cdFx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX2ZyYWdtZW50XCIgXSxcblxuXHRcdFx0XHRcIlx0b3V0Z29pbmdMaWdodCA9IGRpZmZ1c2VDb2xvci5yZ2IgKiB0b3RhbEFtYmllbnRMaWdodCAqIHNoYWRvd01hc2s7XCIsXG5cblx0XHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfZnJhZ21lbnRcIiBdLFxuXG5cdFx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGluZWFyX3RvX2dhbW1hX2ZyYWdtZW50XCIgXSxcblxuXHRcdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19mcmFnbWVudFwiIF0sXG5cblx0XHRcdFx0XCJcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIG91dGdvaW5nTGlnaHQsIGRpZmZ1c2VDb2xvci5hICk7XCIsXG5cblx0XHRcdFx0XCJ9XCJcblxuXHRcdFx0XS5qb2luKCBcIlxcblwiIClcblxuXHRcdH0sXG5cblx0XHQnbGFtYmVydCc6IHtcblxuXHRcdFx0dW5pZm9ybXM6IFRIUkVFLlVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcblxuXHRcdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJjb21tb25cIiBdLFxuXHRcdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJmb2dcIiBdLFxuXHRcdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJsaWdodHNcIiBdLFxuXHRcdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJzaGFkb3dtYXBcIiBdLFxuXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRcImVtaXNzaXZlXCIgOiB7IHR5cGU6IFwiY1wiLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweDAwMDAwMCApIH1cblx0XHRcdFx0fVxuXG5cdFx0XHRdICksXG5cblx0XHRcdHZlcnRleFNoYWRlcjogW1xuXG5cdFx0XHRcdFwiI2RlZmluZSBMQU1CRVJUXCIsXG5cblx0XHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdkxpZ2h0RnJvbnQ7XCIsXG5cblx0XHRcdFx0XCIjaWZkZWYgRE9VQkxFX1NJREVEXCIsXG5cblx0XHRcdFx0XCJcdHZhcnlpbmcgdmVjMyB2TGlnaHRCYWNrO1wiLFxuXG5cdFx0XHRcdFwiI2VuZGlmXCIsXG5cblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwidXZfcGFyc192ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJ1djJfcGFyc192ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfcGFyc192ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodHNfbGFtYmVydF9wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfdmVydGV4XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ19wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4XCIgXSxcblxuXHRcdFx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInV2X3ZlcnRleFwiIF0sXG5cdFx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwidXYyX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfdmVydGV4XCIgXSxcblxuXHRcdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImJlZ2lubm9ybWFsX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGhub3JtYWxfdmVydGV4XCIgXSxcblx0XHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2luYmFzZV92ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5ub3JtYWxfdmVydGV4XCIgXSxcblx0XHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJkZWZhdWx0bm9ybWFsX3ZlcnRleFwiIF0sXG5cblx0XHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJiZWdpbl92ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3ZlcnRleFwiIF0sXG5cdFx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbm5pbmdfdmVydGV4XCIgXSxcblx0XHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJwcm9qZWN0X3ZlcnRleFwiIF0sXG5cdFx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfdmVydGV4XCIgXSxcblxuXHRcdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIndvcmxkcG9zX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRzX2xhbWJlcnRfdmVydGV4XCIgXSxcblx0XHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfdmVydGV4XCIgXSxcblxuXHRcdFx0XHRcIn1cIlxuXG5cdFx0XHRdLmpvaW4oIFwiXFxuXCIgKSxcblxuXHRcdFx0ZnJhZ21lbnRTaGFkZXI6IFtcblxuXHRcdFx0XHRcInVuaWZvcm0gdmVjMyBkaWZmdXNlO1wiLFxuXHRcdFx0XHRcInVuaWZvcm0gdmVjMyBlbWlzc2l2ZTtcIixcblx0XHRcdFx0XCJ1bmlmb3JtIGZsb2F0IG9wYWNpdHk7XCIsXG5cblx0XHRcdFx0XCJ1bmlmb3JtIHZlYzMgYW1iaWVudExpZ2h0Q29sb3I7XCIsXG5cblx0XHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdkxpZ2h0RnJvbnQ7XCIsXG5cblx0XHRcdFx0XCIjaWZkZWYgRE9VQkxFX1NJREVEXCIsXG5cblx0XHRcdFx0XCJcdHZhcnlpbmcgdmVjMyB2TGlnaHRCYWNrO1wiLFxuXG5cdFx0XHRcdFwiI2VuZGlmXCIsXG5cblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInV2X3BhcnNfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJ1djJfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYWxwaGFtYXBfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX3BhcnNfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50XCIgXSxcblxuXHRcdFx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XHRcIlx0dmVjMyBvdXRnb2luZ0xpZ2h0ID0gdmVjMyggMC4wICk7XCIsXHQvLyBvdXRnb2luZyBsaWdodCBkb2VzIG5vdCBoYXZlIGFuIGFscGhhLCB0aGUgc3VyZmFjZSBkb2VzXG5cdFx0XHRcdFwiXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcIixcblx0XHRcdFx0XCJcdHZlYzMgdG90YWxBbWJpZW50TGlnaHQgPSBhbWJpZW50TGlnaHRDb2xvcjtcIixcblx0XHRcdFx0XCJcdHZlYzMgc2hhZG93TWFzayA9IHZlYzMoIDEuMCApO1wiLFxuXG5cdFx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF9mcmFnbWVudFwiIF0sXG5cdFx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImFscGhhbWFwX2ZyYWdtZW50XCIgXSxcblx0XHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJhbHBoYXRlc3RfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNwZWN1bGFybWFwX2ZyYWdtZW50XCIgXSxcblx0XHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfZnJhZ21lbnRcIiBdLFxuXG5cdFx0XHRcdFwiXHQjaWZkZWYgRE9VQkxFX1NJREVEXCIsXG5cblx0XHRcdFx0XCJcdFx0aWYgKCBnbF9Gcm9udEZhY2luZyApXCIsXG5cdFx0XHRcdFwiXHRcdFx0b3V0Z29pbmdMaWdodCArPSBkaWZmdXNlQ29sb3IucmdiICogKCB2TGlnaHRGcm9udCAqIHNoYWRvd01hc2sgKyB0b3RhbEFtYmllbnRMaWdodCApICsgZW1pc3NpdmU7XCIsXG5cdFx0XHRcdFwiXHRcdGVsc2VcIixcblx0XHRcdFx0XCJcdFx0XHRvdXRnb2luZ0xpZ2h0ICs9IGRpZmZ1c2VDb2xvci5yZ2IgKiAoIHZMaWdodEJhY2sgKiBzaGFkb3dNYXNrICsgdG90YWxBbWJpZW50TGlnaHQgKSArIGVtaXNzaXZlO1wiLFxuXG5cdFx0XHRcdFwiXHQjZWxzZVwiLFxuXG5cdFx0XHRcdFwiXHRcdG91dGdvaW5nTGlnaHQgKz0gZGlmZnVzZUNvbG9yLnJnYiAqICggdkxpZ2h0RnJvbnQgKiBzaGFkb3dNYXNrICsgdG90YWxBbWJpZW50TGlnaHQgKSArIGVtaXNzaXZlO1wiLFxuXG5cdFx0XHRcdFwiXHQjZW5kaWZcIixcblxuXHRcdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF9mcmFnbWVudFwiIF0sXG5cblx0XHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaW5lYXJfdG9fZ2FtbWFfZnJhZ21lbnRcIiBdLFxuXG5cdFx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX2ZyYWdtZW50XCIgXSxcblxuXHRcdFx0XHRcIlx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggb3V0Z29pbmdMaWdodCwgZGlmZnVzZUNvbG9yLmEgKTtcIixcblxuXHRcdFx0XHRcIn1cIlxuXG5cdFx0XHRdLmpvaW4oIFwiXFxuXCIgKVxuXG5cdFx0fSxcblxuXHRcdCdwaG9uZyc6IHtcblxuXHRcdFx0dW5pZm9ybXM6IFRIUkVFLlVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcblxuXHRcdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJjb21tb25cIiBdLFxuXHRcdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJhb21hcFwiIF0sXG5cdFx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImxpZ2h0bWFwXCIgXSxcblx0XHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwiZW1pc3NpdmVtYXBcIiBdLFxuXHRcdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJidW1wbWFwXCIgXSxcblx0XHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwibm9ybWFsbWFwXCIgXSxcblx0XHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwiZGlzcGxhY2VtZW50bWFwXCIgXSxcblx0XHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwiZm9nXCIgXSxcblx0XHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwibGlnaHRzXCIgXSxcblx0XHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwic2hhZG93bWFwXCIgXSxcblxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0XCJlbWlzc2l2ZVwiIDogeyB0eXBlOiBcImNcIiwgdmFsdWU6IG5ldyBUSFJFRS5Db2xvciggMHgwMDAwMDAgKSB9LFxuXHRcdFx0XHRcdFwic3BlY3VsYXJcIiA6IHsgdHlwZTogXCJjXCIsIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoIDB4MTExMTExICkgfSxcblx0XHRcdFx0XHRcInNoaW5pbmVzc1wiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMzAgfVxuXHRcdFx0XHR9XG5cblx0XHRcdF0gKSxcblxuXHRcdFx0dmVydGV4U2hhZGVyOiBbXG5cblx0XHRcdFx0XCIjZGVmaW5lIFBIT05HXCIsXG5cblx0XHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcIixcblxuXHRcdFx0XHRcIiNpZm5kZWYgRkxBVF9TSEFERURcIixcblxuXHRcdFx0XHRcIlx0dmFyeWluZyB2ZWMzIHZOb3JtYWw7XCIsXG5cblx0XHRcdFx0XCIjZW5kaWZcIixcblxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJ1dl9wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInV2Ml9wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF9wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0c19waG9uZ19wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfdmVydGV4XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ19wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4XCIgXSxcblxuXHRcdFx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInV2X3ZlcnRleFwiIF0sXG5cdFx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwidXYyX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfdmVydGV4XCIgXSxcblxuXHRcdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImJlZ2lubm9ybWFsX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGhub3JtYWxfdmVydGV4XCIgXSxcblx0XHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2luYmFzZV92ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5ub3JtYWxfdmVydGV4XCIgXSxcblx0XHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJkZWZhdWx0bm9ybWFsX3ZlcnRleFwiIF0sXG5cblx0XHRcdFx0XCIjaWZuZGVmIEZMQVRfU0hBREVEXCIsIC8vIE5vcm1hbCBjb21wdXRlZCB3aXRoIGRlcml2YXRpdmVzIHdoZW4gRkxBVF9TSEFERURcblxuXHRcdFx0XHRcIlx0dk5vcm1hbCA9IG5vcm1hbGl6ZSggdHJhbnNmb3JtZWROb3JtYWwgKTtcIixcblxuXHRcdFx0XHRcIiNlbmRpZlwiLFxuXG5cdFx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYmVnaW5fdmVydGV4XCIgXSxcblx0XHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJkaXNwbGFjZW1lbnRtYXBfdmVydGV4XCIgXSxcblx0XHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF92ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwicHJvamVjdF92ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3ZlcnRleFwiIF0sXG5cblx0XHRcdFx0XCJcdHZWaWV3UG9zaXRpb24gPSAtIG12UG9zaXRpb24ueHl6O1wiLFxuXG5cdFx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwid29ybGRwb3NfdmVydGV4XCIgXSxcblx0XHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfdmVydGV4XCIgXSxcblx0XHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodHNfcGhvbmdfdmVydGV4XCIgXSxcblx0XHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfdmVydGV4XCIgXSxcblxuXHRcdFx0XHRcIn1cIlxuXG5cdFx0XHRdLmpvaW4oIFwiXFxuXCIgKSxcblxuXHRcdFx0ZnJhZ21lbnRTaGFkZXI6IFtcblxuXHRcdFx0XHRcIiNkZWZpbmUgUEhPTkdcIixcblxuXHRcdFx0XHRcInVuaWZvcm0gdmVjMyBkaWZmdXNlO1wiLFxuXHRcdFx0XHRcInVuaWZvcm0gdmVjMyBlbWlzc2l2ZTtcIixcblx0XHRcdFx0XCJ1bmlmb3JtIHZlYzMgc3BlY3VsYXI7XCIsXG5cdFx0XHRcdFwidW5pZm9ybSBmbG9hdCBzaGluaW5lc3M7XCIsXG5cdFx0XHRcdFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxuXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJ1dl9wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwidXYyX3BhcnNfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImFscGhhbWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJhb21hcF9wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRtYXBfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImVtaXNzaXZlbWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRzX3Bob25nX3BhcnNfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImJ1bXBtYXBfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm5vcm1hbG1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnRcIiBdLFxuXG5cdFx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxuXG5cdFx0XHRcdFwiXHR2ZWMzIG91dGdvaW5nTGlnaHQgPSB2ZWMzKCAwLjAgKTtcIixcblx0XHRcdFx0XCJcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1wiLFxuXHRcdFx0XHRcIlx0dmVjMyB0b3RhbEFtYmllbnRMaWdodCA9IGFtYmllbnRMaWdodENvbG9yO1wiLFxuXHRcdFx0XHRcIlx0dmVjMyB0b3RhbEVtaXNzaXZlTGlnaHQgPSBlbWlzc2l2ZTtcIixcblx0XHRcdFx0XCJcdHZlYzMgc2hhZG93TWFzayA9IHZlYzMoIDEuMCApO1wiLFxuXG5cdFx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF9mcmFnbWVudFwiIF0sXG5cdFx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImFscGhhbWFwX2ZyYWdtZW50XCIgXSxcblx0XHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJhbHBoYXRlc3RfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNwZWN1bGFybWFwX2ZyYWdtZW50XCIgXSxcblx0XHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJub3JtYWxfcGhvbmdfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0bWFwX2ZyYWdtZW50XCIgXSxcblx0XHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJoZW1pbGlnaHRfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImFvbWFwX2ZyYWdtZW50XCIgXSxcblx0XHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJlbWlzc2l2ZW1hcF9mcmFnbWVudFwiIF0sXG5cblx0XHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodHNfcGhvbmdfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9mcmFnbWVudFwiIF0sXG5cblx0XHRcdFx0XHRcInRvdGFsRGlmZnVzZUxpZ2h0ICo9IHNoYWRvd01hc2s7XCIsXG5cdFx0XHRcdFx0XCJ0b3RhbFNwZWN1bGFyTGlnaHQgKj0gc2hhZG93TWFzaztcIixcblxuXHRcdFx0XHRcdFwiI2lmZGVmIE1FVEFMXCIsXG5cblx0XHRcdFx0XHRcIlx0b3V0Z29pbmdMaWdodCArPSBkaWZmdXNlQ29sb3IucmdiICogKCB0b3RhbERpZmZ1c2VMaWdodCArIHRvdGFsQW1iaWVudExpZ2h0ICkgKiBzcGVjdWxhciArIHRvdGFsU3BlY3VsYXJMaWdodCArIHRvdGFsRW1pc3NpdmVMaWdodDtcIixcblxuXHRcdFx0XHRcdFwiI2Vsc2VcIixcblxuXHRcdFx0XHRcdFwiXHRvdXRnb2luZ0xpZ2h0ICs9IGRpZmZ1c2VDb2xvci5yZ2IgKiAoIHRvdGFsRGlmZnVzZUxpZ2h0ICsgdG90YWxBbWJpZW50TGlnaHQgKSArIHRvdGFsU3BlY3VsYXJMaWdodCArIHRvdGFsRW1pc3NpdmVMaWdodDtcIixcblxuXHRcdFx0XHRcdFwiI2VuZGlmXCIsXG5cblx0XHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfZnJhZ21lbnRcIiBdLFxuXG5cdFx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGluZWFyX3RvX2dhbW1hX2ZyYWdtZW50XCIgXSxcblxuXHRcdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19mcmFnbWVudFwiIF0sXG5cblx0XHRcdFx0XCJcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIG91dGdvaW5nTGlnaHQsIGRpZmZ1c2VDb2xvci5hICk7XCIsXG5cblx0XHRcdFx0XCJ9XCJcblxuXHRcdFx0XS5qb2luKCBcIlxcblwiIClcblxuXHRcdH0sXG5cblx0XHQncG9pbnRzJzoge1xuXG5cdFx0XHR1bmlmb3JtczogVEhSRUUuVW5pZm9ybXNVdGlscy5tZXJnZSggW1xuXG5cdFx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcInBvaW50c1wiIF0sXG5cdFx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcInNoYWRvd21hcFwiIF1cblxuXHRcdFx0XSApLFxuXG5cdFx0XHR2ZXJ0ZXhTaGFkZXI6IFtcblxuXHRcdFx0XHRcInVuaWZvcm0gZmxvYXQgc2l6ZTtcIixcblx0XHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHNjYWxlO1wiLFxuXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfdmVydGV4XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3BhcnNfdmVydGV4XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc192ZXJ0ZXhcIiBdLFxuXG5cdFx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxuXG5cdFx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfdmVydGV4XCIgXSxcblxuXHRcdFx0XHRcIlx0dmVjNCBtdlBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1wiLFxuXG5cdFx0XHRcdFwiXHQjaWZkZWYgVVNFX1NJWkVBVFRFTlVBVElPTlwiLFxuXHRcdFx0XHRcIlx0XHRnbF9Qb2ludFNpemUgPSBzaXplICogKCBzY2FsZSAvIGxlbmd0aCggbXZQb3NpdGlvbi54eXogKSApO1wiLFxuXHRcdFx0XHRcIlx0I2Vsc2VcIixcblx0XHRcdFx0XCJcdFx0Z2xfUG9pbnRTaXplID0gc2l6ZTtcIixcblx0XHRcdFx0XCJcdCNlbmRpZlwiLFxuXG5cdFx0XHRcdFwiXHRnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtdlBvc2l0aW9uO1wiLFxuXG5cdFx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfdmVydGV4XCIgXSxcblx0XHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJ3b3JsZHBvc192ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF92ZXJ0ZXhcIiBdLFxuXG5cdFx0XHRcdFwifVwiXG5cblx0XHRcdF0uam9pbiggXCJcXG5cIiApLFxuXG5cdFx0XHRmcmFnbWVudFNoYWRlcjogW1xuXG5cdFx0XHRcdFwidW5pZm9ybSB2ZWMzIHBzQ29sb3I7XCIsXG5cdFx0XHRcdFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxuXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfcGFydGljbGVfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50XCIgXSxcblxuXHRcdFx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XHRcIlx0dmVjMyBvdXRnb2luZ0xpZ2h0ID0gdmVjMyggMC4wICk7XCIsXG5cdFx0XHRcdFwiXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIHBzQ29sb3IsIG9wYWNpdHkgKTtcIixcblx0XHRcdFx0XCJcdHZlYzMgc2hhZG93TWFzayA9IHZlYzMoIDEuMCApO1wiLFxuXG5cdFx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF9wYXJ0aWNsZV9mcmFnbWVudFwiIF0sXG5cdFx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImFscGhhdGVzdF9mcmFnbWVudFwiIF0sXG5cdFx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX2ZyYWdtZW50XCIgXSxcblxuXHRcdFx0XHRcIlx0b3V0Z29pbmdMaWdodCA9IGRpZmZ1c2VDb2xvci5yZ2IgKiBzaGFkb3dNYXNrO1wiLFxuXG5cdFx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX2ZyYWdtZW50XCIgXSxcblxuXHRcdFx0XHRcIlx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggb3V0Z29pbmdMaWdodCwgZGlmZnVzZUNvbG9yLmEgKTtcIixcblxuXHRcdFx0XHRcIn1cIlxuXG5cdFx0XHRdLmpvaW4oIFwiXFxuXCIgKVxuXG5cdFx0fSxcblxuXHRcdCdkYXNoZWQnOiB7XG5cblx0XHRcdHVuaWZvcm1zOiBUSFJFRS5Vbmlmb3Jtc1V0aWxzLm1lcmdlKCBbXG5cblx0XHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwiY29tbW9uXCIgXSxcblx0XHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwiZm9nXCIgXSxcblxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0XCJzY2FsZVwiICAgIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEgfSxcblx0XHRcdFx0XHRcImRhc2hTaXplXCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMSB9LFxuXHRcdFx0XHRcdFwidG90YWxTaXplXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAyIH1cblx0XHRcdFx0fVxuXG5cdFx0XHRdICksXG5cblx0XHRcdHZlcnRleFNoYWRlcjogW1xuXG5cdFx0XHRcdFwidW5pZm9ybSBmbG9hdCBzY2FsZTtcIixcblx0XHRcdFx0XCJhdHRyaWJ1dGUgZmxvYXQgbGluZURpc3RhbmNlO1wiLFxuXG5cdFx0XHRcdFwidmFyeWluZyBmbG9hdCB2TGluZURpc3RhbmNlO1wiLFxuXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfdmVydGV4XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc192ZXJ0ZXhcIiBdLFxuXG5cdFx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxuXG5cdFx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfdmVydGV4XCIgXSxcblxuXHRcdFx0XHRcIlx0dkxpbmVEaXN0YW5jZSA9IHNjYWxlICogbGluZURpc3RhbmNlO1wiLFxuXG5cdFx0XHRcdFwiXHR2ZWM0IG12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XCIsXG5cdFx0XHRcdFwiXHRnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtdlBvc2l0aW9uO1wiLFxuXG5cdFx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfdmVydGV4XCIgXSxcblxuXHRcdFx0XHRcIn1cIlxuXG5cdFx0XHRdLmpvaW4oIFwiXFxuXCIgKSxcblxuXHRcdFx0ZnJhZ21lbnRTaGFkZXI6IFtcblxuXHRcdFx0XHRcInVuaWZvcm0gdmVjMyBkaWZmdXNlO1wiLFxuXHRcdFx0XHRcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcblxuXHRcdFx0XHRcInVuaWZvcm0gZmxvYXQgZGFzaFNpemU7XCIsXG5cdFx0XHRcdFwidW5pZm9ybSBmbG9hdCB0b3RhbFNpemU7XCIsXG5cblx0XHRcdFx0XCJ2YXJ5aW5nIGZsb2F0IHZMaW5lRGlzdGFuY2U7XCIsXG5cblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc19mcmFnbWVudFwiIF0sXG5cblx0XHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXG5cblx0XHRcdFx0XCJcdGlmICggbW9kKCB2TGluZURpc3RhbmNlLCB0b3RhbFNpemUgKSA+IGRhc2hTaXplICkge1wiLFxuXG5cdFx0XHRcdFwiXHRcdGRpc2NhcmQ7XCIsXG5cblx0XHRcdFx0XCJcdH1cIixcblxuXHRcdFx0XHRcIlx0dmVjMyBvdXRnb2luZ0xpZ2h0ID0gdmVjMyggMC4wICk7XCIsXG5cdFx0XHRcdFwiXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcIixcblxuXHRcdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX2ZyYWdtZW50XCIgXSxcblx0XHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9mcmFnbWVudFwiIF0sXG5cblx0XHRcdFx0XCJcdG91dGdvaW5nTGlnaHQgPSBkaWZmdXNlQ29sb3IucmdiO1wiLCAvLyBzaW1wbGUgc2hhZGVyXG5cblx0XHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfZnJhZ21lbnRcIiBdLFxuXG5cdFx0XHRcdFwiXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCBvdXRnb2luZ0xpZ2h0LCBkaWZmdXNlQ29sb3IuYSApO1wiLFxuXG5cdFx0XHRcdFwifVwiXG5cblx0XHRcdF0uam9pbiggXCJcXG5cIiApXG5cblx0XHR9LFxuXG5cdFx0J2RlcHRoJzoge1xuXG5cdFx0XHR1bmlmb3Jtczoge1xuXG5cdFx0XHRcdFwibU5lYXJcIjogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEuMCB9LFxuXHRcdFx0XHRcIm1GYXJcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAyMDAwLjAgfSxcblx0XHRcdFx0XCJvcGFjaXR5XCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH1cblxuXHRcdFx0fSxcblxuXHRcdFx0dmVydGV4U2hhZGVyOiBbXG5cblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleFwiIF0sXG5cblx0XHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXG5cblx0XHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJiZWdpbl92ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3ZlcnRleFwiIF0sXG5cdFx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwicHJvamVjdF92ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3ZlcnRleFwiIF0sXG5cblx0XHRcdFx0XCJ9XCJcblxuXHRcdFx0XS5qb2luKCBcIlxcblwiICksXG5cblx0XHRcdGZyYWdtZW50U2hhZGVyOiBbXG5cblx0XHRcdFx0XCJ1bmlmb3JtIGZsb2F0IG1OZWFyO1wiLFxuXHRcdFx0XHRcInVuaWZvcm0gZmxvYXQgbUZhcjtcIixcblx0XHRcdFx0XCJ1bmlmb3JtIGZsb2F0IG9wYWNpdHk7XCIsXG5cblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc19mcmFnbWVudFwiIF0sXG5cblx0XHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXG5cblx0XHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9mcmFnbWVudFwiIF0sXG5cblx0XHRcdFx0XCJcdCNpZmRlZiBVU0VfTE9HREVQVEhCVUZfRVhUXCIsXG5cblx0XHRcdFx0XCJcdFx0ZmxvYXQgZGVwdGggPSBnbF9GcmFnRGVwdGhFWFQgLyBnbF9GcmFnQ29vcmQudztcIixcblxuXHRcdFx0XHRcIlx0I2Vsc2VcIixcblxuXHRcdFx0XHRcIlx0XHRmbG9hdCBkZXB0aCA9IGdsX0ZyYWdDb29yZC56IC8gZ2xfRnJhZ0Nvb3JkLnc7XCIsXG5cblx0XHRcdFx0XCJcdCNlbmRpZlwiLFxuXG5cdFx0XHRcdFwiXHRmbG9hdCBjb2xvciA9IDEuMCAtIHNtb290aHN0ZXAoIG1OZWFyLCBtRmFyLCBkZXB0aCApO1wiLFxuXHRcdFx0XHRcIlx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggdmVjMyggY29sb3IgKSwgb3BhY2l0eSApO1wiLFxuXG5cdFx0XHRcdFwifVwiXG5cblx0XHRcdF0uam9pbiggXCJcXG5cIiApXG5cblx0XHR9LFxuXG5cdFx0J25vcm1hbCc6IHtcblxuXHRcdFx0dW5pZm9ybXM6IHtcblxuXHRcdFx0XHRcIm9wYWNpdHlcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxLjAgfVxuXG5cdFx0XHR9LFxuXG5cdFx0XHR2ZXJ0ZXhTaGFkZXI6IFtcblxuXHRcdFx0XHRcInZhcnlpbmcgdmVjMyB2Tm9ybWFsO1wiLFxuXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3BhcnNfdmVydGV4XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc192ZXJ0ZXhcIiBdLFxuXG5cdFx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxuXG5cdFx0XHRcdFwiXHR2Tm9ybWFsID0gbm9ybWFsaXplKCBub3JtYWxNYXRyaXggKiBub3JtYWwgKTtcIixcblxuXHRcdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImJlZ2luX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfdmVydGV4XCIgXSxcblx0XHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJwcm9qZWN0X3ZlcnRleFwiIF0sXG5cdFx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfdmVydGV4XCIgXSxcblxuXHRcdFx0XHRcIn1cIlxuXG5cdFx0XHRdLmpvaW4oIFwiXFxuXCIgKSxcblxuXHRcdFx0ZnJhZ21lbnRTaGFkZXI6IFtcblxuXHRcdFx0XHRcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcblx0XHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcIixcblxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50XCIgXSxcblxuXHRcdFx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XHRcIlx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggMC41ICogbm9ybWFsaXplKCB2Tm9ybWFsICkgKyAwLjUsIG9wYWNpdHkgKTtcIixcblxuXHRcdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX2ZyYWdtZW50XCIgXSxcblxuXHRcdFx0XHRcIn1cIlxuXG5cdFx0XHRdLmpvaW4oIFwiXFxuXCIgKVxuXG5cdFx0fSxcblxuXHRcdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0XHQvL1x0Q3ViZSBtYXAgc2hhZGVyXG5cdFx0IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHRcdCdjdWJlJzoge1xuXG5cdFx0XHR1bmlmb3JtczogeyBcInRDdWJlXCI6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXG5cdFx0XHRcdFx0XHRcInRGbGlwXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAtIDEgfSB9LFxuXG5cdFx0XHR2ZXJ0ZXhTaGFkZXI6IFtcblxuXHRcdFx0XHRcInZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcIixcblxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleFwiIF0sXG5cblx0XHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXG5cblx0XHRcdFx0XCJcdHZXb3JsZFBvc2l0aW9uID0gdHJhbnNmb3JtRGlyZWN0aW9uKCBwb3NpdGlvbiwgbW9kZWxNYXRyaXggKTtcIixcblxuXHRcdFx0XHRcIlx0Z2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1wiLFxuXG5cdFx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfdmVydGV4XCIgXSxcblxuXHRcdFx0XHRcIn1cIlxuXG5cdFx0XHRdLmpvaW4oIFwiXFxuXCIgKSxcblxuXHRcdFx0ZnJhZ21lbnRTaGFkZXI6IFtcblxuXHRcdFx0XHRcInVuaWZvcm0gc2FtcGxlckN1YmUgdEN1YmU7XCIsXG5cdFx0XHRcdFwidW5pZm9ybSBmbG9hdCB0RmxpcDtcIixcblxuXHRcdFx0XHRcInZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcIixcblxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50XCIgXSxcblxuXHRcdFx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XHRcIlx0Z2xfRnJhZ0NvbG9yID0gdGV4dHVyZUN1YmUoIHRDdWJlLCB2ZWMzKCB0RmxpcCAqIHZXb3JsZFBvc2l0aW9uLngsIHZXb3JsZFBvc2l0aW9uLnl6ICkgKTtcIixcblxuXHRcdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX2ZyYWdtZW50XCIgXSxcblxuXHRcdFx0XHRcIn1cIlxuXG5cdFx0XHRdLmpvaW4oIFwiXFxuXCIgKVxuXG5cdFx0fSxcblxuXHRcdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0XHQvL1x0Q3ViZSBtYXAgc2hhZGVyXG5cdFx0IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHRcdCdlcXVpcmVjdCc6IHtcblxuXHRcdFx0dW5pZm9ybXM6IHsgXCJ0RXF1aXJlY3RcIjogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcblx0XHRcdFx0XHRcdFwidEZsaXBcIjogeyB0eXBlOiBcImZcIiwgdmFsdWU6IC0gMSB9IH0sXG5cblx0XHRcdHZlcnRleFNoYWRlcjogW1xuXG5cdFx0XHRcdFwidmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1wiLFxuXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4XCIgXSxcblxuXHRcdFx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XHRcIlx0dldvcmxkUG9zaXRpb24gPSB0cmFuc2Zvcm1EaXJlY3Rpb24oIHBvc2l0aW9uLCBtb2RlbE1hdHJpeCApO1wiLFxuXG5cdFx0XHRcdFwiXHRnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XCIsXG5cblx0XHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl92ZXJ0ZXhcIiBdLFxuXG5cdFx0XHRcdFwifVwiXG5cblx0XHRcdF0uam9pbiggXCJcXG5cIiApLFxuXG5cdFx0XHRmcmFnbWVudFNoYWRlcjogW1xuXG5cdFx0XHRcdFwidW5pZm9ybSBzYW1wbGVyMkQgdEVxdWlyZWN0O1wiLFxuXHRcdFx0XHRcInVuaWZvcm0gZmxvYXQgdEZsaXA7XCIsXG5cblx0XHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XCIsXG5cblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc19mcmFnbWVudFwiIF0sXG5cblx0XHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXG5cblx0XHRcdFx0XHQvLyBcIlx0Z2xfRnJhZ0NvbG9yID0gdGV4dHVyZUN1YmUoIHRDdWJlLCB2ZWMzKCB0RmxpcCAqIHZXb3JsZFBvc2l0aW9uLngsIHZXb3JsZFBvc2l0aW9uLnl6ICkgKTtcIixcblx0XHRcdFx0XHRcInZlYzMgZGlyZWN0aW9uID0gbm9ybWFsaXplKCB2V29ybGRQb3NpdGlvbiApO1wiLFxuXHRcdFx0XHRcdFwidmVjMiBzYW1wbGVVVjtcIixcblx0XHRcdFx0XHRcInNhbXBsZVVWLnkgPSBzYXR1cmF0ZSggdEZsaXAgKiBkaXJlY3Rpb24ueSAqIC0wLjUgKyAwLjUgKTtcIixcblx0XHRcdFx0XHRcInNhbXBsZVVWLnggPSBhdGFuKCBkaXJlY3Rpb24ueiwgZGlyZWN0aW9uLnggKSAqIFJFQ0lQUk9DQUxfUEkyICsgMC41O1wiLFxuXHRcdFx0XHRcdFwiZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKCB0RXF1aXJlY3QsIHNhbXBsZVVWICk7XCIsXG5cblx0XHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9mcmFnbWVudFwiIF0sXG5cblx0XHRcdFx0XCJ9XCJcblxuXHRcdFx0XS5qb2luKCBcIlxcblwiIClcblxuXHRcdH0sXG5cblx0XHQvKiBEZXB0aCBlbmNvZGluZyBpbnRvIFJHQkEgdGV4dHVyZVxuXHRcdCAqXG5cdFx0ICogYmFzZWQgb24gU3BpZGVyR0wgc2hhZG93IG1hcCBleGFtcGxlXG5cdFx0ICogaHR0cDovL3NwaWRlcmdsLm9yZy9leGFtcGxlLnBocD9pZD02XG5cdFx0ICpcblx0XHQgKiBvcmlnaW5hbGx5IGZyb21cblx0XHQgKiBodHRwOi8vd3d3LmdhbWVkZXYubmV0L3RvcGljLzQ0MjEzOC1wYWNraW5nLWEtZmxvYXQtaW50by1hLWE4cjhnOGI4LXRleHR1cmUtc2hhZGVyL3BhZ2VfX3doaWNocGFnZV9fMSUyNUVGJTI1QkYlMjVCRFxuXHRcdCAqXG5cdFx0ICogc2VlIGFsc29cblx0XHQgKiBodHRwOi8vYXJhcy1wLmluZm8vYmxvZy8yMDA5LzA3LzMwL2VuY29kaW5nLWZsb2F0cy10by1yZ2JhLXRoZS1maW5hbC9cblx0XHQgKi9cblxuXHRcdCdkZXB0aFJHQkEnOiB7XG5cblx0XHRcdHVuaWZvcm1zOiB7fSxcblxuXHRcdFx0dmVydGV4U2hhZGVyOiBbXG5cblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ19wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4XCIgXSxcblxuXHRcdFx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5iYXNlX3ZlcnRleFwiIF0sXG5cblx0XHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJiZWdpbl92ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3ZlcnRleFwiIF0sXG5cdFx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbm5pbmdfdmVydGV4XCIgXSxcblx0XHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJwcm9qZWN0X3ZlcnRleFwiIF0sXG5cdFx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfdmVydGV4XCIgXSxcblxuXHRcdFx0XHRcIn1cIlxuXG5cdFx0XHRdLmpvaW4oIFwiXFxuXCIgKSxcblxuXHRcdFx0ZnJhZ21lbnRTaGFkZXI6IFtcblxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50XCIgXSxcblxuXHRcdFx0XHRcInZlYzQgcGFja19kZXB0aCggY29uc3QgaW4gZmxvYXQgZGVwdGggKSB7XCIsXG5cblx0XHRcdFx0XCJcdGNvbnN0IHZlYzQgYml0X3NoaWZ0ID0gdmVjNCggMjU2LjAgKiAyNTYuMCAqIDI1Ni4wLCAyNTYuMCAqIDI1Ni4wLCAyNTYuMCwgMS4wICk7XCIsXG5cdFx0XHRcdFwiXHRjb25zdCB2ZWM0IGJpdF9tYXNrID0gdmVjNCggMC4wLCAxLjAgLyAyNTYuMCwgMS4wIC8gMjU2LjAsIDEuMCAvIDI1Ni4wICk7XCIsXG5cdFx0XHRcdFwiXHR2ZWM0IHJlcyA9IG1vZCggZGVwdGggKiBiaXRfc2hpZnQgKiB2ZWM0KCAyNTUgKSwgdmVjNCggMjU2ICkgKSAvIHZlYzQoIDI1NSApO1wiLCAvLyBcIlx0dmVjNCByZXMgPSBmcmFjdCggZGVwdGggKiBiaXRfc2hpZnQgKTtcIixcblx0XHRcdFx0XCJcdHJlcyAtPSByZXMueHh5eiAqIGJpdF9tYXNrO1wiLFxuXHRcdFx0XHRcIlx0cmV0dXJuIHJlcztcIixcblxuXHRcdFx0XHRcIn1cIixcblxuXHRcdFx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX2ZyYWdtZW50XCIgXSxcblxuXHRcdFx0XHRcIlx0I2lmZGVmIFVTRV9MT0dERVBUSEJVRl9FWFRcIixcblxuXHRcdFx0XHRcIlx0XHRnbF9GcmFnRGF0YVsgMCBdID0gcGFja19kZXB0aCggZ2xfRnJhZ0RlcHRoRVhUICk7XCIsXG5cblx0XHRcdFx0XCJcdCNlbHNlXCIsXG5cblx0XHRcdFx0XCJcdFx0Z2xfRnJhZ0RhdGFbIDAgXSA9IHBhY2tfZGVwdGgoIGdsX0ZyYWdDb29yZC56ICk7XCIsXG5cblx0XHRcdFx0XCJcdCNlbmRpZlwiLFxuXG5cdFx0XHRcdFx0Ly9cImdsX0ZyYWdEYXRhWyAwIF0gPSBwYWNrX2RlcHRoKCBnbF9GcmFnQ29vcmQueiAvIGdsX0ZyYWdDb29yZC53ICk7XCIsXG5cdFx0XHRcdFx0Ly9cImZsb2F0IHogPSAoICggZ2xfRnJhZ0Nvb3JkLnogLyBnbF9GcmFnQ29vcmQudyApIC0gMy4wICkgLyAoIDQwMDAuMCAtIDMuMCApO1wiLFxuXHRcdFx0XHRcdC8vXCJnbF9GcmFnRGF0YVsgMCBdID0gcGFja19kZXB0aCggeiApO1wiLFxuXHRcdFx0XHRcdC8vXCJnbF9GcmFnRGF0YVsgMCBdID0gdmVjNCggeiwgeiwgeiwgMS4wICk7XCIsXG5cblx0XHRcdFx0XCJ9XCJcblxuXHRcdFx0XS5qb2luKCBcIlxcblwiIClcblxuXHRcdH0sXG5cblxuXHRcdCdkaXN0YW5jZVJHQkEnOiB7XG5cblx0XHRcdHVuaWZvcm1zOiB7XG5cblx0XHRcdFx0XCJsaWdodFBvc1wiOiB7IHR5cGU6IFwidjNcIiwgdmFsdWU6IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAwICkgfVxuXG5cdFx0XHR9LFxuXG5cdFx0XHR2ZXJ0ZXhTaGFkZXI6IFtcblxuXHRcdFx0XHRcInZhcnlpbmcgdmVjNCB2V29ybGRQb3NpdGlvbjtcIixcblxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF9wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3BhcnNfdmVydGV4XCIgXSxcblxuXHRcdFx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5iYXNlX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYmVnaW5fdmVydGV4XCIgXSxcblx0XHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF92ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwicHJvamVjdF92ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIndvcmxkcG9zX3ZlcnRleFwiIF0sXG5cblx0XHRcdFx0XHRcInZXb3JsZFBvc2l0aW9uID0gd29ybGRQb3NpdGlvbjtcIixcblxuXHRcdFx0XHRcIn1cIlxuXG5cdFx0XHRdLmpvaW4oIFwiXFxuXCIgKSxcblxuXHRcdFx0ZnJhZ21lbnRTaGFkZXI6IFtcblxuXHRcdFx0XHRcInVuaWZvcm0gdmVjMyBsaWdodFBvcztcIixcblx0XHRcdFx0XCJ2YXJ5aW5nIHZlYzQgdldvcmxkUG9zaXRpb247XCIsXG5cblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcblxuXHRcdFx0XHRcInZlYzQgcGFjazFLICggZmxvYXQgZGVwdGggKSB7XCIsXG5cblx0XHRcdFx0XCIgICBkZXB0aCAvPSAxMDAwLjA7XCIsXG5cdFx0XHRcdFwiICAgY29uc3QgdmVjNCBiaXRTaCA9IHZlYzQoIDI1Ni4wICogMjU2LjAgKiAyNTYuMCwgMjU2LjAgKiAyNTYuMCwgMjU2LjAsIDEuMCApO1wiLFxuXHQgIFx0XHRcdFwiXHRjb25zdCB2ZWM0IGJpdE1zayA9IHZlYzQoIDAuMCwgMS4wIC8gMjU2LjAsIDEuMCAvIDI1Ni4wLCAxLjAgLyAyNTYuMCApO1wiLFxuXHQgICBcdFx0XHRcIlx0dmVjNCByZXMgPSBmcmFjdCggZGVwdGggKiBiaXRTaCApO1wiLFxuXHQgICBcdFx0XHRcIlx0cmVzIC09IHJlcy54eHl6ICogYml0TXNrO1wiLFxuXHQgICBcdFx0XHRcIlx0cmV0dXJuIHJlczsgXCIsXG5cblx0XHRcdFx0XCJ9XCIsXG5cblx0XHRcdFx0XCJmbG9hdCB1bnBhY2sxSyAoIHZlYzQgY29sb3IgKSB7XCIsXG5cblx0XHRcdFx0XCJcdGNvbnN0IHZlYzQgYml0U2ggPSB2ZWM0KCAxLjAgLyAoIDI1Ni4wICogMjU2LjAgKiAyNTYuMCApLCAxLjAgLyAoIDI1Ni4wICogMjU2LjAgKSwgMS4wIC8gMjU2LjAsIDEuMCApO1wiLFxuXHRcdFx0XHRcIlx0cmV0dXJuIGRvdCggY29sb3IsIGJpdFNoICkgKiAxMDAwLjA7XCIsXG5cblx0XHRcdFx0XCJ9XCIsXG5cblx0XHRcdFx0XCJ2b2lkIG1haW4gKCkge1wiLFxuXG5cdFx0XHRcdFwiXHRnbF9GcmFnQ29sb3IgPSBwYWNrMUsoIGxlbmd0aCggdldvcmxkUG9zaXRpb24ueHl6IC0gbGlnaHRQb3MueHl6ICkgKTtcIixcblxuXHRcdFx0XHRcIn1cIlxuXG5cdFx0XHRdLmpvaW4oIFwiXFxuXCIgKVxuXG5cdFx0fVxuXG5cdH07XG5cblx0Ly8gRmlsZTpzcmMvcmVuZGVyZXJzL1dlYkdMUmVuZGVyZXIuanNcblxuXHQvKipcblx0ICogQGF1dGhvciBzdXBlcmVnZ2JlcnQgLyBodHRwOi8vd3d3LnBhdWxicnVudC5jby51ay9cblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cblx0ICogQGF1dGhvciBzemltZWsgLyBodHRwczovL2dpdGh1Yi5jb20vc3ppbWVrL1xuXHQgKi9cblxuXHRUSFJFRS5XZWJHTFJlbmRlcmVyID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xuXG5cdFx0Y29uc29sZS5sb2coICdUSFJFRS5XZWJHTFJlbmRlcmVyJywgVEhSRUUuUkVWSVNJT04gKTtcblxuXHRcdHBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzIHx8IHt9O1xuXG5cdFx0dmFyIF9jYW52YXMgPSBwYXJhbWV0ZXJzLmNhbnZhcyAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5jYW52YXMgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnY2FudmFzJyApLFxuXHRcdF9jb250ZXh0ID0gcGFyYW1ldGVycy5jb250ZXh0ICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmNvbnRleHQgOiBudWxsLFxuXG5cdFx0X3dpZHRoID0gX2NhbnZhcy53aWR0aCxcblx0XHRfaGVpZ2h0ID0gX2NhbnZhcy5oZWlnaHQsXG5cblx0XHRwaXhlbFJhdGlvID0gMSxcblxuXHRcdF9hbHBoYSA9IHBhcmFtZXRlcnMuYWxwaGEgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuYWxwaGEgOiBmYWxzZSxcblx0XHRfZGVwdGggPSBwYXJhbWV0ZXJzLmRlcHRoICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmRlcHRoIDogdHJ1ZSxcblx0XHRfc3RlbmNpbCA9IHBhcmFtZXRlcnMuc3RlbmNpbCAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5zdGVuY2lsIDogdHJ1ZSxcblx0XHRfYW50aWFsaWFzID0gcGFyYW1ldGVycy5hbnRpYWxpYXMgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuYW50aWFsaWFzIDogZmFsc2UsXG5cdFx0X3ByZW11bHRpcGxpZWRBbHBoYSA9IHBhcmFtZXRlcnMucHJlbXVsdGlwbGllZEFscGhhICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLnByZW11bHRpcGxpZWRBbHBoYSA6IHRydWUsXG5cdFx0X3ByZXNlcnZlRHJhd2luZ0J1ZmZlciA9IHBhcmFtZXRlcnMucHJlc2VydmVEcmF3aW5nQnVmZmVyICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLnByZXNlcnZlRHJhd2luZ0J1ZmZlciA6IGZhbHNlLFxuXG5cdFx0X2NsZWFyQ29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDB4MDAwMDAwICksXG5cdFx0X2NsZWFyQWxwaGEgPSAwO1xuXG5cdFx0dmFyIGxpZ2h0cyA9IFtdO1xuXG5cdFx0dmFyIG9wYXF1ZU9iamVjdHMgPSBbXTtcblx0XHR2YXIgb3BhcXVlT2JqZWN0c0xhc3RJbmRleCA9IC0gMTtcblx0XHR2YXIgdHJhbnNwYXJlbnRPYmplY3RzID0gW107XG5cdFx0dmFyIHRyYW5zcGFyZW50T2JqZWN0c0xhc3RJbmRleCA9IC0gMTtcblxuXHRcdHZhciBtb3JwaEluZmx1ZW5jZXMgPSBuZXcgRmxvYXQzMkFycmF5KCA4ICk7XG5cblxuXHRcdHZhciBzcHJpdGVzID0gW107XG5cdFx0dmFyIGxlbnNGbGFyZXMgPSBbXTtcblxuXHRcdC8vIHB1YmxpYyBwcm9wZXJ0aWVzXG5cblx0XHR0aGlzLmRvbUVsZW1lbnQgPSBfY2FudmFzO1xuXHRcdHRoaXMuY29udGV4dCA9IG51bGw7XG5cblx0XHQvLyBjbGVhcmluZ1xuXG5cdFx0dGhpcy5hdXRvQ2xlYXIgPSB0cnVlO1xuXHRcdHRoaXMuYXV0b0NsZWFyQ29sb3IgPSB0cnVlO1xuXHRcdHRoaXMuYXV0b0NsZWFyRGVwdGggPSB0cnVlO1xuXHRcdHRoaXMuYXV0b0NsZWFyU3RlbmNpbCA9IHRydWU7XG5cblx0XHQvLyBzY2VuZSBncmFwaFxuXG5cdFx0dGhpcy5zb3J0T2JqZWN0cyA9IHRydWU7XG5cblx0XHQvLyBwaHlzaWNhbGx5IGJhc2VkIHNoYWRpbmdcblxuXHRcdHRoaXMuZ2FtbWFGYWN0b3IgPSAyLjA7XHQvLyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblx0XHR0aGlzLmdhbW1hSW5wdXQgPSBmYWxzZTtcblx0XHR0aGlzLmdhbW1hT3V0cHV0ID0gZmFsc2U7XG5cblx0XHQvLyBtb3JwaHNcblxuXHRcdHRoaXMubWF4TW9ycGhUYXJnZXRzID0gODtcblx0XHR0aGlzLm1heE1vcnBoTm9ybWFscyA9IDQ7XG5cblx0XHQvLyBmbGFnc1xuXG5cdFx0dGhpcy5hdXRvU2NhbGVDdWJlbWFwcyA9IHRydWU7XG5cblx0XHQvLyBpbnRlcm5hbCBwcm9wZXJ0aWVzXG5cblx0XHR2YXIgX3RoaXMgPSB0aGlzLFxuXG5cdFx0Ly8gaW50ZXJuYWwgc3RhdGUgY2FjaGVcblxuXHRcdF9jdXJyZW50UHJvZ3JhbSA9IG51bGwsXG5cdFx0X2N1cnJlbnRGcmFtZWJ1ZmZlciA9IG51bGwsXG5cdFx0X2N1cnJlbnRNYXRlcmlhbElkID0gLSAxLFxuXHRcdF9jdXJyZW50R2VvbWV0cnlQcm9ncmFtID0gJycsXG5cdFx0X2N1cnJlbnRDYW1lcmEgPSBudWxsLFxuXG5cdFx0X3VzZWRUZXh0dXJlVW5pdHMgPSAwLFxuXG5cdFx0X3ZpZXdwb3J0WCA9IDAsXG5cdFx0X3ZpZXdwb3J0WSA9IDAsXG5cdFx0X3ZpZXdwb3J0V2lkdGggPSBfY2FudmFzLndpZHRoLFxuXHRcdF92aWV3cG9ydEhlaWdodCA9IF9jYW52YXMuaGVpZ2h0LFxuXHRcdF9jdXJyZW50V2lkdGggPSAwLFxuXHRcdF9jdXJyZW50SGVpZ2h0ID0gMCxcblxuXHRcdC8vIGZydXN0dW1cblxuXHRcdF9mcnVzdHVtID0gbmV3IFRIUkVFLkZydXN0dW0oKSxcblxuXHRcdCAvLyBjYW1lcmEgbWF0cmljZXMgY2FjaGVcblxuXHRcdF9wcm9qU2NyZWVuTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKSxcblxuXHRcdF92ZWN0b3IzID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcblxuXHRcdC8vIGxpZ2h0IGFycmF5cyBjYWNoZVxuXG5cdFx0X2RpcmVjdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG5cblx0XHRfbGlnaHRzTmVlZFVwZGF0ZSA9IHRydWUsXG5cblx0XHRfbGlnaHRzID0ge1xuXG5cdFx0XHRhbWJpZW50OiBbIDAsIDAsIDAgXSxcblx0XHRcdGRpcmVjdGlvbmFsOiB7IGxlbmd0aDogMCwgY29sb3JzOiBbXSwgcG9zaXRpb25zOiBbXSB9LFxuXHRcdFx0cG9pbnQ6IHsgbGVuZ3RoOiAwLCBjb2xvcnM6IFtdLCBwb3NpdGlvbnM6IFtdLCBkaXN0YW5jZXM6IFtdLCBkZWNheXM6IFtdIH0sXG5cdFx0XHRzcG90OiB7IGxlbmd0aDogMCwgY29sb3JzOiBbXSwgcG9zaXRpb25zOiBbXSwgZGlzdGFuY2VzOiBbXSwgZGlyZWN0aW9uczogW10sIGFuZ2xlc0NvczogW10sIGV4cG9uZW50czogW10sIGRlY2F5czogW10gfSxcblx0XHRcdGhlbWk6IHsgbGVuZ3RoOiAwLCBza3lDb2xvcnM6IFtdLCBncm91bmRDb2xvcnM6IFtdLCBwb3NpdGlvbnM6IFtdIH1cblxuXHRcdH0sXG5cblx0XHQvLyBpbmZvXG5cblx0XHRfaW5mb01lbW9yeSA9IHtcblxuXHRcdFx0Z2VvbWV0cmllczogMCxcblx0XHRcdHRleHR1cmVzOiAwXG5cblx0XHR9LFxuXG5cdFx0X2luZm9SZW5kZXIgPSB7XG5cblx0XHRcdGNhbGxzOiAwLFxuXHRcdFx0dmVydGljZXM6IDAsXG5cdFx0XHRmYWNlczogMCxcblx0XHRcdHBvaW50czogMFxuXG5cdFx0fTtcblxuXHRcdHRoaXMuaW5mbyA9IHtcblxuXHRcdFx0cmVuZGVyOiBfaW5mb1JlbmRlcixcblx0XHRcdG1lbW9yeTogX2luZm9NZW1vcnksXG5cdFx0XHRwcm9ncmFtczogbnVsbFxuXG5cdFx0fTtcblxuXG5cdFx0Ly8gaW5pdGlhbGl6ZVxuXG5cdFx0dmFyIF9nbDtcblxuXHRcdHRyeSB7XG5cblx0XHRcdHZhciBhdHRyaWJ1dGVzID0ge1xuXHRcdFx0XHRhbHBoYTogX2FscGhhLFxuXHRcdFx0XHRkZXB0aDogX2RlcHRoLFxuXHRcdFx0XHRzdGVuY2lsOiBfc3RlbmNpbCxcblx0XHRcdFx0YW50aWFsaWFzOiBfYW50aWFsaWFzLFxuXHRcdFx0XHRwcmVtdWx0aXBsaWVkQWxwaGE6IF9wcmVtdWx0aXBsaWVkQWxwaGEsXG5cdFx0XHRcdHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogX3ByZXNlcnZlRHJhd2luZ0J1ZmZlclxuXHRcdFx0fTtcblxuXHRcdFx0X2dsID0gX2NvbnRleHQgfHwgX2NhbnZhcy5nZXRDb250ZXh0KCAnd2ViZ2wnLCBhdHRyaWJ1dGVzICkgfHwgX2NhbnZhcy5nZXRDb250ZXh0KCAnZXhwZXJpbWVudGFsLXdlYmdsJywgYXR0cmlidXRlcyApO1xuXG5cdFx0XHRpZiAoIF9nbCA9PT0gbnVsbCApIHtcblxuXHRcdFx0XHRpZiAoIF9jYW52YXMuZ2V0Q29udGV4dCggJ3dlYmdsJyApICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0dGhyb3cgJ0Vycm9yIGNyZWF0aW5nIFdlYkdMIGNvbnRleHQgd2l0aCB5b3VyIHNlbGVjdGVkIGF0dHJpYnV0ZXMuJztcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dGhyb3cgJ0Vycm9yIGNyZWF0aW5nIFdlYkdMIGNvbnRleHQuJztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0X2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCAnd2ViZ2xjb250ZXh0bG9zdCcsIG9uQ29udGV4dExvc3QsIGZhbHNlICk7XG5cblx0XHR9IGNhdGNoICggZXJyb3IgKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAnICsgZXJyb3IgKTtcblxuXHRcdH1cblxuXHRcdHZhciBleHRlbnNpb25zID0gbmV3IFRIUkVFLldlYkdMRXh0ZW5zaW9ucyggX2dsICk7XG5cblx0XHRleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2Zsb2F0JyApO1xuXHRcdGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyJyApO1xuXHRcdGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfaGFsZl9mbG9hdCcgKTtcblx0XHRleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2hhbGZfZmxvYXRfbGluZWFyJyApO1xuXHRcdGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzJyApO1xuXHRcdGV4dGVuc2lvbnMuZ2V0KCAnQU5HTEVfaW5zdGFuY2VkX2FycmF5cycgKTtcblxuXHRcdGlmICggZXh0ZW5zaW9ucy5nZXQoICdPRVNfZWxlbWVudF9pbmRleF91aW50JyApICkge1xuXG5cdFx0XHRUSFJFRS5CdWZmZXJHZW9tZXRyeS5NYXhJbmRleCA9IDQyOTQ5NjcyOTY7XG5cblx0XHR9XG5cblx0XHR2YXIgY2FwYWJpbGl0aWVzID0gbmV3IFRIUkVFLldlYkdMQ2FwYWJpbGl0aWVzKCBfZ2wsIGV4dGVuc2lvbnMsIHBhcmFtZXRlcnMgKTtcblxuXHRcdHZhciBzdGF0ZSA9IG5ldyBUSFJFRS5XZWJHTFN0YXRlKCBfZ2wsIGV4dGVuc2lvbnMsIHBhcmFtVGhyZWVUb0dMICk7XG5cdFx0dmFyIHByb3BlcnRpZXMgPSBuZXcgVEhSRUUuV2ViR0xQcm9wZXJ0aWVzKCk7XG5cdFx0dmFyIG9iamVjdHMgPSBuZXcgVEhSRUUuV2ViR0xPYmplY3RzKCBfZ2wsIHByb3BlcnRpZXMsIHRoaXMuaW5mbyApO1xuXHRcdHZhciBwcm9ncmFtQ2FjaGUgPSBuZXcgVEhSRUUuV2ViR0xQcm9ncmFtcyggdGhpcywgY2FwYWJpbGl0aWVzICk7XG5cblx0XHR0aGlzLmluZm8ucHJvZ3JhbXMgPSBwcm9ncmFtQ2FjaGUucHJvZ3JhbXM7XG5cblx0XHR2YXIgYnVmZmVyUmVuZGVyZXIgPSBuZXcgVEhSRUUuV2ViR0xCdWZmZXJSZW5kZXJlciggX2dsLCBleHRlbnNpb25zLCBfaW5mb1JlbmRlciApO1xuXHRcdHZhciBpbmRleGVkQnVmZmVyUmVuZGVyZXIgPSBuZXcgVEhSRUUuV2ViR0xJbmRleGVkQnVmZmVyUmVuZGVyZXIoIF9nbCwgZXh0ZW5zaW9ucywgX2luZm9SZW5kZXIgKTtcblxuXHRcdC8vXG5cblx0XHRmdW5jdGlvbiBnbENsZWFyQ29sb3IoIHIsIGcsIGIsIGEgKSB7XG5cblx0XHRcdGlmICggX3ByZW11bHRpcGxpZWRBbHBoYSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRyICo9IGE7IGcgKj0gYTsgYiAqPSBhO1xuXG5cdFx0XHR9XG5cblx0XHRcdF9nbC5jbGVhckNvbG9yKCByLCBnLCBiLCBhICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBzZXREZWZhdWx0R0xTdGF0ZSgpIHtcblxuXHRcdFx0c3RhdGUuaW5pdCgpO1xuXG5cdFx0XHRfZ2wudmlld3BvcnQoIF92aWV3cG9ydFgsIF92aWV3cG9ydFksIF92aWV3cG9ydFdpZHRoLCBfdmlld3BvcnRIZWlnaHQgKTtcblxuXHRcdFx0Z2xDbGVhckNvbG9yKCBfY2xlYXJDb2xvci5yLCBfY2xlYXJDb2xvci5nLCBfY2xlYXJDb2xvci5iLCBfY2xlYXJBbHBoYSApO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVzZXRHTFN0YXRlKCkge1xuXG5cdFx0XHRfY3VycmVudFByb2dyYW0gPSBudWxsO1xuXHRcdFx0X2N1cnJlbnRDYW1lcmEgPSBudWxsO1xuXG5cdFx0XHRfY3VycmVudEdlb21ldHJ5UHJvZ3JhbSA9ICcnO1xuXHRcdFx0X2N1cnJlbnRNYXRlcmlhbElkID0gLSAxO1xuXG5cdFx0XHRfbGlnaHRzTmVlZFVwZGF0ZSA9IHRydWU7XG5cblx0XHRcdHN0YXRlLnJlc2V0KCk7XG5cblx0XHR9XG5cblx0XHRzZXREZWZhdWx0R0xTdGF0ZSgpO1xuXG5cdFx0dGhpcy5jb250ZXh0ID0gX2dsO1xuXHRcdHRoaXMuY2FwYWJpbGl0aWVzID0gY2FwYWJpbGl0aWVzO1xuXHRcdHRoaXMuZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnM7XG5cdFx0dGhpcy5zdGF0ZSA9IHN0YXRlO1xuXG5cdFx0Ly8gc2hhZG93IG1hcFxuXG5cdFx0dmFyIHNoYWRvd01hcCA9IG5ldyBUSFJFRS5XZWJHTFNoYWRvd01hcCggdGhpcywgbGlnaHRzLCBvYmplY3RzICk7XG5cblx0XHR0aGlzLnNoYWRvd01hcCA9IHNoYWRvd01hcDtcblxuXG5cdFx0Ly8gUGx1Z2luc1xuXG5cdFx0dmFyIHNwcml0ZVBsdWdpbiA9IG5ldyBUSFJFRS5TcHJpdGVQbHVnaW4oIHRoaXMsIHNwcml0ZXMgKTtcblx0XHR2YXIgbGVuc0ZsYXJlUGx1Z2luID0gbmV3IFRIUkVFLkxlbnNGbGFyZVBsdWdpbiggdGhpcywgbGVuc0ZsYXJlcyApO1xuXG5cdFx0Ly8gQVBJXG5cblx0XHR0aGlzLmdldENvbnRleHQgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiBfZ2w7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5nZXRDb250ZXh0QXR0cmlidXRlcyA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIF9nbC5nZXRDb250ZXh0QXR0cmlidXRlcygpO1xuXG5cdFx0fTtcblxuXHRcdHRoaXMuZm9yY2VDb250ZXh0TG9zcyA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0ZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9sb3NlX2NvbnRleHQnICkubG9zZUNvbnRleHQoKTtcblxuXHRcdH07XG5cblx0XHR0aGlzLmdldE1heEFuaXNvdHJvcHkgPSAoIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIHZhbHVlO1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gZ2V0TWF4QW5pc290cm9weSgpIHtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSByZXR1cm4gdmFsdWU7XG5cblx0XHRcdFx0dmFyIGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJyApO1xuXG5cdFx0XHRcdGlmICggZXh0ZW5zaW9uICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0dmFsdWUgPSBfZ2wuZ2V0UGFyYW1ldGVyKCBleHRlbnNpb24uTUFYX1RFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhUICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHZhbHVlID0gMDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXG5cdFx0XHR9XG5cblx0XHR9ICkoKTtcblxuXHRcdHRoaXMuZ2V0UHJlY2lzaW9uID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gY2FwYWJpbGl0aWVzLnByZWNpc2lvbjtcblxuXHRcdH07XG5cblx0XHR0aGlzLmdldFBpeGVsUmF0aW8gPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiBwaXhlbFJhdGlvO1xuXG5cdFx0fTtcblxuXHRcdHRoaXMuc2V0UGl4ZWxSYXRpbyA9IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHBpeGVsUmF0aW8gPSB2YWx1ZTtcblxuXHRcdH07XG5cblx0XHR0aGlzLmdldFNpemUgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHdpZHRoOiBfd2lkdGgsXG5cdFx0XHRcdGhlaWdodDogX2hlaWdodFxuXHRcdFx0fTtcblxuXHRcdH07XG5cblx0XHR0aGlzLnNldFNpemUgPSBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQsIHVwZGF0ZVN0eWxlICkge1xuXG5cdFx0XHRfd2lkdGggPSB3aWR0aDtcblx0XHRcdF9oZWlnaHQgPSBoZWlnaHQ7XG5cblx0XHRcdF9jYW52YXMud2lkdGggPSB3aWR0aCAqIHBpeGVsUmF0aW87XG5cdFx0XHRfY2FudmFzLmhlaWdodCA9IGhlaWdodCAqIHBpeGVsUmF0aW87XG5cblx0XHRcdGlmICggdXBkYXRlU3R5bGUgIT09IGZhbHNlICkge1xuXG5cdFx0XHRcdF9jYW52YXMuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG5cdFx0XHRcdF9jYW52YXMuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnNldFZpZXdwb3J0KCAwLCAwLCB3aWR0aCwgaGVpZ2h0ICk7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5zZXRWaWV3cG9ydCA9IGZ1bmN0aW9uICggeCwgeSwgd2lkdGgsIGhlaWdodCApIHtcblxuXHRcdFx0X3ZpZXdwb3J0WCA9IHggKiBwaXhlbFJhdGlvO1xuXHRcdFx0X3ZpZXdwb3J0WSA9IHkgKiBwaXhlbFJhdGlvO1xuXG5cdFx0XHRfdmlld3BvcnRXaWR0aCA9IHdpZHRoICogcGl4ZWxSYXRpbztcblx0XHRcdF92aWV3cG9ydEhlaWdodCA9IGhlaWdodCAqIHBpeGVsUmF0aW87XG5cblx0XHRcdF9nbC52aWV3cG9ydCggX3ZpZXdwb3J0WCwgX3ZpZXdwb3J0WSwgX3ZpZXdwb3J0V2lkdGgsIF92aWV3cG9ydEhlaWdodCApO1xuXG5cdFx0fTtcblxuXHRcdHRoaXMuZ2V0Vmlld3BvcnQgPSBmdW5jdGlvbiAoIGRpbWVuc2lvbnMgKSB7XG5cblx0XHRcdGRpbWVuc2lvbnMueCA9IF92aWV3cG9ydFggLyBwaXhlbFJhdGlvO1xuXHRcdFx0ZGltZW5zaW9ucy55ID0gX3ZpZXdwb3J0WSAvIHBpeGVsUmF0aW87XG5cblx0XHRcdGRpbWVuc2lvbnMueiA9IF92aWV3cG9ydFdpZHRoIC8gcGl4ZWxSYXRpbztcblx0XHRcdGRpbWVuc2lvbnMudyA9IF92aWV3cG9ydEhlaWdodCAvIHBpeGVsUmF0aW87XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5zZXRTY2lzc29yID0gZnVuY3Rpb24gKCB4LCB5LCB3aWR0aCwgaGVpZ2h0ICkge1xuXG5cdFx0XHRfZ2wuc2Npc3Nvcihcblx0XHRcdFx0eCAqIHBpeGVsUmF0aW8sXG5cdFx0XHRcdHkgKiBwaXhlbFJhdGlvLFxuXHRcdFx0XHR3aWR0aCAqIHBpeGVsUmF0aW8sXG5cdFx0XHRcdGhlaWdodCAqIHBpeGVsUmF0aW9cblx0XHRcdCk7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5lbmFibGVTY2lzc29yVGVzdCA9IGZ1bmN0aW9uICggYm9vbGVhbiApIHtcblxuXHRcdFx0c3RhdGUuc2V0U2Npc3NvclRlc3QoIGJvb2xlYW4gKTtcblxuXHRcdH07XG5cblx0XHQvLyBDbGVhcmluZ1xuXG5cdFx0dGhpcy5nZXRDbGVhckNvbG9yID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gX2NsZWFyQ29sb3I7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5zZXRDbGVhckNvbG9yID0gZnVuY3Rpb24gKCBjb2xvciwgYWxwaGEgKSB7XG5cblx0XHRcdF9jbGVhckNvbG9yLnNldCggY29sb3IgKTtcblxuXHRcdFx0X2NsZWFyQWxwaGEgPSBhbHBoYSAhPT0gdW5kZWZpbmVkID8gYWxwaGEgOiAxO1xuXG5cdFx0XHRnbENsZWFyQ29sb3IoIF9jbGVhckNvbG9yLnIsIF9jbGVhckNvbG9yLmcsIF9jbGVhckNvbG9yLmIsIF9jbGVhckFscGhhICk7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5nZXRDbGVhckFscGhhID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gX2NsZWFyQWxwaGE7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5zZXRDbGVhckFscGhhID0gZnVuY3Rpb24gKCBhbHBoYSApIHtcblxuXHRcdFx0X2NsZWFyQWxwaGEgPSBhbHBoYTtcblxuXHRcdFx0Z2xDbGVhckNvbG9yKCBfY2xlYXJDb2xvci5yLCBfY2xlYXJDb2xvci5nLCBfY2xlYXJDb2xvci5iLCBfY2xlYXJBbHBoYSApO1xuXG5cdFx0fTtcblxuXHRcdHRoaXMuY2xlYXIgPSBmdW5jdGlvbiAoIGNvbG9yLCBkZXB0aCwgc3RlbmNpbCApIHtcblxuXHRcdFx0dmFyIGJpdHMgPSAwO1xuXG5cdFx0XHRpZiAoIGNvbG9yID09PSB1bmRlZmluZWQgfHwgY29sb3IgKSBiaXRzIHw9IF9nbC5DT0xPUl9CVUZGRVJfQklUO1xuXHRcdFx0aWYgKCBkZXB0aCA9PT0gdW5kZWZpbmVkIHx8IGRlcHRoICkgYml0cyB8PSBfZ2wuREVQVEhfQlVGRkVSX0JJVDtcblx0XHRcdGlmICggc3RlbmNpbCA9PT0gdW5kZWZpbmVkIHx8IHN0ZW5jaWwgKSBiaXRzIHw9IF9nbC5TVEVOQ0lMX0JVRkZFUl9CSVQ7XG5cblx0XHRcdF9nbC5jbGVhciggYml0cyApO1xuXG5cdFx0fTtcblxuXHRcdHRoaXMuY2xlYXJDb2xvciA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0X2dsLmNsZWFyKCBfZ2wuQ09MT1JfQlVGRkVSX0JJVCApO1xuXG5cdFx0fTtcblxuXHRcdHRoaXMuY2xlYXJEZXB0aCA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0X2dsLmNsZWFyKCBfZ2wuREVQVEhfQlVGRkVSX0JJVCApO1xuXG5cdFx0fTtcblxuXHRcdHRoaXMuY2xlYXJTdGVuY2lsID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRfZ2wuY2xlYXIoIF9nbC5TVEVOQ0lMX0JVRkZFUl9CSVQgKTtcblxuXHRcdH07XG5cblx0XHR0aGlzLmNsZWFyVGFyZ2V0ID0gZnVuY3Rpb24gKCByZW5kZXJUYXJnZXQsIGNvbG9yLCBkZXB0aCwgc3RlbmNpbCApIHtcblxuXHRcdFx0dGhpcy5zZXRSZW5kZXJUYXJnZXQoIHJlbmRlclRhcmdldCApO1xuXHRcdFx0dGhpcy5jbGVhciggY29sb3IsIGRlcHRoLCBzdGVuY2lsICk7XG5cblx0XHR9O1xuXG5cdFx0Ly8gUmVzZXRcblxuXHRcdHRoaXMucmVzZXRHTFN0YXRlID0gcmVzZXRHTFN0YXRlO1xuXG5cdFx0dGhpcy5kaXNwb3NlID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdF9jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3dlYmdsY29udGV4dGxvc3QnLCBvbkNvbnRleHRMb3N0LCBmYWxzZSApO1xuXG5cdFx0fTtcblxuXHRcdC8vIEV2ZW50c1xuXG5cdFx0ZnVuY3Rpb24gb25Db250ZXh0TG9zdCggZXZlbnQgKSB7XG5cblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHRcdHJlc2V0R0xTdGF0ZSgpO1xuXHRcdFx0c2V0RGVmYXVsdEdMU3RhdGUoKTtcblxuXHRcdFx0cHJvcGVydGllcy5jbGVhcigpO1xuXG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIG9uVGV4dHVyZURpc3Bvc2UoIGV2ZW50ICkge1xuXG5cdFx0XHR2YXIgdGV4dHVyZSA9IGV2ZW50LnRhcmdldDtcblxuXHRcdFx0dGV4dHVyZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uVGV4dHVyZURpc3Bvc2UgKTtcblxuXHRcdFx0ZGVhbGxvY2F0ZVRleHR1cmUoIHRleHR1cmUgKTtcblxuXHRcdFx0X2luZm9NZW1vcnkudGV4dHVyZXMgLS07XG5cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG9uUmVuZGVyVGFyZ2V0RGlzcG9zZSggZXZlbnQgKSB7XG5cblx0XHRcdHZhciByZW5kZXJUYXJnZXQgPSBldmVudC50YXJnZXQ7XG5cblx0XHRcdHJlbmRlclRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uUmVuZGVyVGFyZ2V0RGlzcG9zZSApO1xuXG5cdFx0XHRkZWFsbG9jYXRlUmVuZGVyVGFyZ2V0KCByZW5kZXJUYXJnZXQgKTtcblxuXHRcdFx0X2luZm9NZW1vcnkudGV4dHVyZXMgLS07XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBvbk1hdGVyaWFsRGlzcG9zZSggZXZlbnQgKSB7XG5cblx0XHRcdHZhciBtYXRlcmlhbCA9IGV2ZW50LnRhcmdldDtcblxuXHRcdFx0bWF0ZXJpYWwucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvbk1hdGVyaWFsRGlzcG9zZSApO1xuXG5cdFx0XHRkZWFsbG9jYXRlTWF0ZXJpYWwoIG1hdGVyaWFsICk7XG5cblx0XHR9XG5cblx0XHQvLyBCdWZmZXIgZGVhbGxvY2F0aW9uXG5cblx0XHRmdW5jdGlvbiBkZWFsbG9jYXRlVGV4dHVyZSggdGV4dHVyZSApIHtcblxuXHRcdFx0dmFyIHRleHR1cmVQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIHRleHR1cmUgKTtcblxuXHRcdFx0aWYgKCB0ZXh0dXJlLmltYWdlICYmIHRleHR1cmVQcm9wZXJ0aWVzLl9faW1hZ2VfX3dlYmdsVGV4dHVyZUN1YmUgKSB7XG5cblx0XHRcdFx0Ly8gY3ViZSB0ZXh0dXJlXG5cblx0XHRcdFx0X2dsLmRlbGV0ZVRleHR1cmUoIHRleHR1cmVQcm9wZXJ0aWVzLl9faW1hZ2VfX3dlYmdsVGV4dHVyZUN1YmUgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyAyRCB0ZXh0dXJlXG5cblx0XHRcdFx0aWYgKCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsSW5pdCA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuXG5cdFx0XHRcdF9nbC5kZWxldGVUZXh0dXJlKCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHJlbW92ZSBhbGwgd2ViZ2wgcHJvcGVydGllc1xuXHRcdFx0cHJvcGVydGllcy5kZWxldGUoIHRleHR1cmUgKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGRlYWxsb2NhdGVSZW5kZXJUYXJnZXQoIHJlbmRlclRhcmdldCApIHtcblxuXHRcdFx0dmFyIHJlbmRlclRhcmdldFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0ICk7XG5cdFx0XHR2YXIgdGV4dHVyZVByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0LnRleHR1cmUgKTtcblxuXHRcdFx0aWYgKCAhIHJlbmRlclRhcmdldCB8fCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuXG5cdFx0XHRfZ2wuZGVsZXRlVGV4dHVyZSggdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgKTtcblxuXHRcdFx0aWYgKCByZW5kZXJUYXJnZXQgaW5zdGFuY2VvZiBUSFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmUgKSB7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSArKyApIHtcblxuXHRcdFx0XHRcdF9nbC5kZWxldGVGcmFtZWJ1ZmZlciggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXJbIGkgXSApO1xuXHRcdFx0XHRcdF9nbC5kZWxldGVSZW5kZXJidWZmZXIoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbFJlbmRlcmJ1ZmZlclsgaSBdICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdF9nbC5kZWxldGVGcmFtZWJ1ZmZlciggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIgKTtcblx0XHRcdFx0X2dsLmRlbGV0ZVJlbmRlcmJ1ZmZlciggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsUmVuZGVyYnVmZmVyICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cHJvcGVydGllcy5kZWxldGUoIHJlbmRlclRhcmdldC50ZXh0dXJlICk7XG5cdFx0XHRwcm9wZXJ0aWVzLmRlbGV0ZSggcmVuZGVyVGFyZ2V0ICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBkZWFsbG9jYXRlTWF0ZXJpYWwoIG1hdGVyaWFsICkge1xuXG5cdFx0XHRyZWxlYXNlTWF0ZXJpYWxQcm9ncmFtUmVmZXJlbmNlKCBtYXRlcmlhbCApO1xuXG5cdFx0XHRwcm9wZXJ0aWVzLmRlbGV0ZSggbWF0ZXJpYWwgKTtcblxuXHRcdH1cblxuXG5cdFx0ZnVuY3Rpb24gcmVsZWFzZU1hdGVyaWFsUHJvZ3JhbVJlZmVyZW5jZSggbWF0ZXJpYWwgKSB7XG5cblx0XHRcdHZhciBwcm9ncmFtSW5mbyA9IHByb3BlcnRpZXMuZ2V0KCBtYXRlcmlhbCApLnByb2dyYW07XG5cblx0XHRcdG1hdGVyaWFsLnByb2dyYW0gPSB1bmRlZmluZWQ7XG5cblx0XHRcdGlmICggcHJvZ3JhbUluZm8gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRwcm9ncmFtQ2FjaGUucmVsZWFzZVByb2dyYW0oIHByb2dyYW1JbmZvICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIEJ1ZmZlciByZW5kZXJpbmdcblxuXHRcdHRoaXMucmVuZGVyQnVmZmVySW1tZWRpYXRlID0gZnVuY3Rpb24gKCBvYmplY3QsIHByb2dyYW0sIG1hdGVyaWFsICkge1xuXG5cdFx0XHRzdGF0ZS5pbml0QXR0cmlidXRlcygpO1xuXG5cdFx0XHR2YXIgYnVmZmVycyA9IHByb3BlcnRpZXMuZ2V0KCBvYmplY3QgKTtcblxuXHRcdFx0aWYgKCBvYmplY3QuaGFzUG9zaXRpb25zICYmICEgYnVmZmVycy5wb3NpdGlvbiApIGJ1ZmZlcnMucG9zaXRpb24gPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XG5cdFx0XHRpZiAoIG9iamVjdC5oYXNOb3JtYWxzICYmICEgYnVmZmVycy5ub3JtYWwgKSBidWZmZXJzLm5vcm1hbCA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcblx0XHRcdGlmICggb2JqZWN0Lmhhc1V2cyAmJiAhIGJ1ZmZlcnMudXYgKSBidWZmZXJzLnV2ID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xuXHRcdFx0aWYgKCBvYmplY3QuaGFzQ29sb3JzICYmICEgYnVmZmVycy5jb2xvciApIGJ1ZmZlcnMuY29sb3IgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XG5cblx0XHRcdHZhciBhdHRyaWJ1dGVzID0gcHJvZ3JhbS5nZXRBdHRyaWJ1dGVzKCk7XG5cblx0XHRcdGlmICggb2JqZWN0Lmhhc1Bvc2l0aW9ucyApIHtcblxuXHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgYnVmZmVycy5wb3NpdGlvbiApO1xuXHRcdFx0XHRfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgb2JqZWN0LnBvc2l0aW9uQXJyYXksIF9nbC5EWU5BTUlDX0RSQVcgKTtcblxuXHRcdFx0XHRzdGF0ZS5lbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMucG9zaXRpb24gKTtcblx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMucG9zaXRpb24sIDMsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG9iamVjdC5oYXNOb3JtYWxzICkge1xuXG5cdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXJzLm5vcm1hbCApO1xuXG5cdFx0XHRcdGlmICggbWF0ZXJpYWwudHlwZSAhPT0gJ01lc2hQaG9uZ01hdGVyaWFsJyAmJiBtYXRlcmlhbC5zaGFkaW5nID09PSBUSFJFRS5GbGF0U2hhZGluZyApIHtcblxuXHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IG9iamVjdC5jb3VudCAqIDM7IGkgPCBsOyBpICs9IDkgKSB7XG5cblx0XHRcdFx0XHRcdHZhciBhcnJheSA9IG9iamVjdC5ub3JtYWxBcnJheTtcblxuXHRcdFx0XHRcdFx0dmFyIG54ID0gKCBhcnJheVsgaSArIDAgXSArIGFycmF5WyBpICsgMyBdICsgYXJyYXlbIGkgKyA2IF0gKSAvIDM7XG5cdFx0XHRcdFx0XHR2YXIgbnkgPSAoIGFycmF5WyBpICsgMSBdICsgYXJyYXlbIGkgKyA0IF0gKyBhcnJheVsgaSArIDcgXSApIC8gMztcblx0XHRcdFx0XHRcdHZhciBueiA9ICggYXJyYXlbIGkgKyAyIF0gKyBhcnJheVsgaSArIDUgXSArIGFycmF5WyBpICsgOCBdICkgLyAzO1xuXG5cdFx0XHRcdFx0XHRhcnJheVsgaSArIDAgXSA9IG54O1xuXHRcdFx0XHRcdFx0YXJyYXlbIGkgKyAxIF0gPSBueTtcblx0XHRcdFx0XHRcdGFycmF5WyBpICsgMiBdID0gbno7XG5cblx0XHRcdFx0XHRcdGFycmF5WyBpICsgMyBdID0gbng7XG5cdFx0XHRcdFx0XHRhcnJheVsgaSArIDQgXSA9IG55O1xuXHRcdFx0XHRcdFx0YXJyYXlbIGkgKyA1IF0gPSBuejtcblxuXHRcdFx0XHRcdFx0YXJyYXlbIGkgKyA2IF0gPSBueDtcblx0XHRcdFx0XHRcdGFycmF5WyBpICsgNyBdID0gbnk7XG5cdFx0XHRcdFx0XHRhcnJheVsgaSArIDggXSA9IG56O1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgb2JqZWN0Lm5vcm1hbEFycmF5LCBfZ2wuRFlOQU1JQ19EUkFXICk7XG5cblx0XHRcdFx0c3RhdGUuZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLm5vcm1hbCApO1xuXG5cdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLm5vcm1hbCwgMywgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggb2JqZWN0Lmhhc1V2cyAmJiBtYXRlcmlhbC5tYXAgKSB7XG5cblx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcnMudXYgKTtcblx0XHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIG9iamVjdC51dkFycmF5LCBfZ2wuRFlOQU1JQ19EUkFXICk7XG5cblx0XHRcdFx0c3RhdGUuZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLnV2ICk7XG5cblx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMudXYsIDIsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG9iamVjdC5oYXNDb2xvcnMgJiYgbWF0ZXJpYWwudmVydGV4Q29sb3JzICE9PSBUSFJFRS5Ob0NvbG9ycyApIHtcblxuXHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgYnVmZmVycy5jb2xvciApO1xuXHRcdFx0XHRfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgb2JqZWN0LmNvbG9yQXJyYXksIF9nbC5EWU5BTUlDX0RSQVcgKTtcblxuXHRcdFx0XHRzdGF0ZS5lbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMuY29sb3IgKTtcblxuXHRcdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy5jb2xvciwgMywgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHN0YXRlLmRpc2FibGVVbnVzZWRBdHRyaWJ1dGVzKCk7XG5cblx0XHRcdF9nbC5kcmF3QXJyYXlzKCBfZ2wuVFJJQU5HTEVTLCAwLCBvYmplY3QuY291bnQgKTtcblxuXHRcdFx0b2JqZWN0LmNvdW50ID0gMDtcblxuXHRcdH07XG5cblx0XHR0aGlzLnJlbmRlckJ1ZmZlckRpcmVjdCA9IGZ1bmN0aW9uICggY2FtZXJhLCBsaWdodHMsIGZvZywgZ2VvbWV0cnksIG1hdGVyaWFsLCBvYmplY3QsIGdyb3VwICkge1xuXG5cdFx0XHRzZXRNYXRlcmlhbCggbWF0ZXJpYWwgKTtcblxuXHRcdFx0dmFyIHByb2dyYW0gPSBzZXRQcm9ncmFtKCBjYW1lcmEsIGxpZ2h0cywgZm9nLCBtYXRlcmlhbCwgb2JqZWN0ICk7XG5cblx0XHRcdHZhciB1cGRhdGVCdWZmZXJzID0gZmFsc2U7XG5cdFx0XHR2YXIgZ2VvbWV0cnlQcm9ncmFtID0gZ2VvbWV0cnkuaWQgKyAnXycgKyBwcm9ncmFtLmlkICsgJ18nICsgbWF0ZXJpYWwud2lyZWZyYW1lO1xuXG5cdFx0XHRpZiAoIGdlb21ldHJ5UHJvZ3JhbSAhPT0gX2N1cnJlbnRHZW9tZXRyeVByb2dyYW0gKSB7XG5cblx0XHRcdFx0X2N1cnJlbnRHZW9tZXRyeVByb2dyYW0gPSBnZW9tZXRyeVByb2dyYW07XG5cdFx0XHRcdHVwZGF0ZUJ1ZmZlcnMgPSB0cnVlO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIG1vcnBoIHRhcmdldHNcblxuXHRcdFx0dmFyIG1vcnBoVGFyZ2V0SW5mbHVlbmNlcyA9IG9iamVjdC5tb3JwaFRhcmdldEluZmx1ZW5jZXM7XG5cblx0XHRcdGlmICggbW9ycGhUYXJnZXRJbmZsdWVuY2VzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0dmFyIGFjdGl2ZUluZmx1ZW5jZXMgPSBbXTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBtb3JwaFRhcmdldEluZmx1ZW5jZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHZhciBpbmZsdWVuY2UgPSBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIGkgXTtcblx0XHRcdFx0XHRhY3RpdmVJbmZsdWVuY2VzLnB1c2goIFsgaW5mbHVlbmNlLCBpIF0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0YWN0aXZlSW5mbHVlbmNlcy5zb3J0KCBudW1lcmljYWxTb3J0ICk7XG5cblx0XHRcdFx0aWYgKCBhY3RpdmVJbmZsdWVuY2VzLmxlbmd0aCA+IDggKSB7XG5cblx0XHRcdFx0XHRhY3RpdmVJbmZsdWVuY2VzLmxlbmd0aCA9IDg7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBtb3JwaEF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXM7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gYWN0aXZlSW5mbHVlbmNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIGluZmx1ZW5jZSA9IGFjdGl2ZUluZmx1ZW5jZXNbIGkgXTtcblx0XHRcdFx0XHRtb3JwaEluZmx1ZW5jZXNbIGkgXSA9IGluZmx1ZW5jZVsgMCBdO1xuXG5cdFx0XHRcdFx0aWYgKCBpbmZsdWVuY2VbIDAgXSAhPT0gMCApIHtcblxuXHRcdFx0XHRcdFx0dmFyIGluZGV4ID0gaW5mbHVlbmNlWyAxIF07XG5cblx0XHRcdFx0XHRcdGlmICggbWF0ZXJpYWwubW9ycGhUYXJnZXRzID09PSB0cnVlICYmIG1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbiApIGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ21vcnBoVGFyZ2V0JyArIGksIG1vcnBoQXR0cmlidXRlcy5wb3NpdGlvblsgaW5kZXggXSApO1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRlcmlhbC5tb3JwaE5vcm1hbHMgPT09IHRydWUgJiYgbW9ycGhBdHRyaWJ1dGVzLm5vcm1hbCApIGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ21vcnBoTm9ybWFsJyArIGksIG1vcnBoQXR0cmlidXRlcy5ub3JtYWxbIGluZGV4IF0gKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdGlmICggbWF0ZXJpYWwubW9ycGhUYXJnZXRzID09PSB0cnVlICkgZ2VvbWV0cnkucmVtb3ZlQXR0cmlidXRlKCAnbW9ycGhUYXJnZXQnICsgaSApO1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRlcmlhbC5tb3JwaE5vcm1hbHMgPT09IHRydWUgKSBnZW9tZXRyeS5yZW1vdmVBdHRyaWJ1dGUoICdtb3JwaE5vcm1hbCcgKyBpICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciB1bmlmb3JtcyA9IHByb2dyYW0uZ2V0VW5pZm9ybXMoKTtcblxuXHRcdFx0XHRpZiAoIHVuaWZvcm1zLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcyAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdF9nbC51bmlmb3JtMWZ2KCB1bmlmb3Jtcy5tb3JwaFRhcmdldEluZmx1ZW5jZXMsIG1vcnBoSW5mbHVlbmNlcyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR1cGRhdGVCdWZmZXJzID0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvL1xuXG5cdFx0XHR2YXIgaW5kZXggPSBnZW9tZXRyeS5pbmRleDtcblx0XHRcdHZhciBwb3NpdGlvbiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cblx0XHRcdGlmICggbWF0ZXJpYWwud2lyZWZyYW1lID09PSB0cnVlICkge1xuXG5cdFx0XHRcdGluZGV4ID0gb2JqZWN0cy5nZXRXaXJlZnJhbWVBdHRyaWJ1dGUoIGdlb21ldHJ5ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIHJlbmRlcmVyO1xuXG5cdFx0XHRpZiAoIGluZGV4ICE9PSBudWxsICkge1xuXG5cdFx0XHRcdHJlbmRlcmVyID0gaW5kZXhlZEJ1ZmZlclJlbmRlcmVyO1xuXHRcdFx0XHRyZW5kZXJlci5zZXRJbmRleCggaW5kZXggKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRyZW5kZXJlciA9IGJ1ZmZlclJlbmRlcmVyO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggdXBkYXRlQnVmZmVycyApIHtcblxuXHRcdFx0XHRzZXR1cFZlcnRleEF0dHJpYnV0ZXMoIG1hdGVyaWFsLCBwcm9ncmFtLCBnZW9tZXRyeSApO1xuXG5cdFx0XHRcdGlmICggaW5kZXggIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBvYmplY3RzLmdldEF0dHJpYnV0ZUJ1ZmZlciggaW5kZXggKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvL1xuXG5cdFx0XHR2YXIgZGF0YVN0YXJ0ID0gMDtcblx0XHRcdHZhciBkYXRhQ291bnQgPSBJbmZpbml0eTtcblxuXHRcdFx0aWYgKCBpbmRleCAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRkYXRhQ291bnQgPSBpbmRleC5jb3VudFxuXG5cdFx0XHR9IGVsc2UgaWYgKCBwb3NpdGlvbiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGRhdGFDb3VudCA9IHBvc2l0aW9uLmNvdW50O1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciByYW5nZVN0YXJ0ID0gZ2VvbWV0cnkuZHJhd1JhbmdlLnN0YXJ0O1xuXHRcdFx0dmFyIHJhbmdlQ291bnQgPSBnZW9tZXRyeS5kcmF3UmFuZ2UuY291bnQ7XG5cblx0XHRcdHZhciBncm91cFN0YXJ0ID0gZ3JvdXAgIT09IG51bGwgPyBncm91cC5zdGFydCA6IDA7XG5cdFx0XHR2YXIgZ3JvdXBDb3VudCA9IGdyb3VwICE9PSBudWxsID8gZ3JvdXAuY291bnQgOiBJbmZpbml0eTtcblxuXHRcdFx0dmFyIGRyYXdTdGFydCA9IE1hdGgubWF4KCBkYXRhU3RhcnQsIHJhbmdlU3RhcnQsIGdyb3VwU3RhcnQgKTtcblx0XHRcdHZhciBkcmF3RW5kID0gTWF0aC5taW4oIGRhdGFTdGFydCArIGRhdGFDb3VudCwgcmFuZ2VTdGFydCArIHJhbmdlQ291bnQsIGdyb3VwU3RhcnQgKyBncm91cENvdW50ICkgLSAxO1xuXG5cdFx0XHR2YXIgZHJhd0NvdW50ID0gTWF0aC5tYXgoIDAsIGRyYXdFbmQgLSBkcmF3U3RhcnQgKyAxICk7XG5cblx0XHRcdC8vXG5cblx0XHRcdGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTWVzaCApIHtcblxuXHRcdFx0XHRpZiAoIG1hdGVyaWFsLndpcmVmcmFtZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdHN0YXRlLnNldExpbmVXaWR0aCggbWF0ZXJpYWwud2lyZWZyYW1lTGluZXdpZHRoICogcGl4ZWxSYXRpbyApO1xuXHRcdFx0XHRcdHJlbmRlcmVyLnNldE1vZGUoIF9nbC5MSU5FUyApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRyZW5kZXJlci5zZXRNb2RlKCBfZ2wuVFJJQU5HTEVTICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSAmJiBnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudCA+IDAgKSB7XG5cblx0XHRcdFx0XHRyZW5kZXJlci5yZW5kZXJJbnN0YW5jZXMoIGdlb21ldHJ5ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHJlbmRlcmVyLnJlbmRlciggZHJhd1N0YXJ0LCBkcmF3Q291bnQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkxpbmUgKSB7XG5cblx0XHRcdFx0dmFyIGxpbmVXaWR0aCA9IG1hdGVyaWFsLmxpbmV3aWR0aDtcblxuXHRcdFx0XHRpZiAoIGxpbmVXaWR0aCA9PT0gdW5kZWZpbmVkICkgbGluZVdpZHRoID0gMTsgLy8gTm90IHVzaW5nIExpbmUqTWF0ZXJpYWxcblxuXHRcdFx0XHRzdGF0ZS5zZXRMaW5lV2lkdGgoIGxpbmVXaWR0aCAqIHBpeGVsUmF0aW8gKTtcblxuXHRcdFx0XHRpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkxpbmVTZWdtZW50cyApIHtcblxuXHRcdFx0XHRcdHJlbmRlcmVyLnNldE1vZGUoIF9nbC5MSU5FUyApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRyZW5kZXJlci5zZXRNb2RlKCBfZ2wuTElORV9TVFJJUCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZW5kZXJlci5yZW5kZXIoIGRyYXdTdGFydCwgZHJhd0NvdW50ICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlBvaW50cyApIHtcblxuXHRcdFx0XHRyZW5kZXJlci5zZXRNb2RlKCBfZ2wuUE9JTlRTICk7XG5cdFx0XHRcdHJlbmRlcmVyLnJlbmRlciggZHJhd1N0YXJ0LCBkcmF3Q291bnQgKTtcblxuXHRcdFx0fVxuXG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHNldHVwVmVydGV4QXR0cmlidXRlcyggbWF0ZXJpYWwsIHByb2dyYW0sIGdlb21ldHJ5LCBzdGFydEluZGV4ICkge1xuXG5cdFx0XHR2YXIgZXh0ZW5zaW9uO1xuXG5cdFx0XHRpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgKSB7XG5cblx0XHRcdFx0ZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyApO1xuXG5cdFx0XHRcdGlmICggZXh0ZW5zaW9uID09PSBudWxsICkge1xuXG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUmVuZGVyZXIuc2V0dXBWZXJ0ZXhBdHRyaWJ1dGVzOiB1c2luZyBUSFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSBidXQgaGFyZHdhcmUgZG9lcyBub3Qgc3VwcG9ydCBleHRlbnNpb24gQU5HTEVfaW5zdGFuY2VkX2FycmF5cy4nICk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHN0YXJ0SW5kZXggPT09IHVuZGVmaW5lZCApIHN0YXJ0SW5kZXggPSAwO1xuXG5cdFx0XHRzdGF0ZS5pbml0QXR0cmlidXRlcygpO1xuXG5cdFx0XHR2YXIgZ2VvbWV0cnlBdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcblxuXHRcdFx0dmFyIHByb2dyYW1BdHRyaWJ1dGVzID0gcHJvZ3JhbS5nZXRBdHRyaWJ1dGVzKCk7XG5cblx0XHRcdHZhciBtYXRlcmlhbERlZmF1bHRBdHRyaWJ1dGVWYWx1ZXMgPSBtYXRlcmlhbC5kZWZhdWx0QXR0cmlidXRlVmFsdWVzO1xuXG5cdFx0XHRmb3IgKCB2YXIgbmFtZSBpbiBwcm9ncmFtQXR0cmlidXRlcyApIHtcblxuXHRcdFx0XHR2YXIgcHJvZ3JhbUF0dHJpYnV0ZSA9IHByb2dyYW1BdHRyaWJ1dGVzWyBuYW1lIF07XG5cblx0XHRcdFx0aWYgKCBwcm9ncmFtQXR0cmlidXRlID49IDAgKSB7XG5cblx0XHRcdFx0XHR2YXIgZ2VvbWV0cnlBdHRyaWJ1dGUgPSBnZW9tZXRyeUF0dHJpYnV0ZXNbIG5hbWUgXTtcblxuXHRcdFx0XHRcdGlmICggZ2VvbWV0cnlBdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0dmFyIHNpemUgPSBnZW9tZXRyeUF0dHJpYnV0ZS5pdGVtU2l6ZTtcblx0XHRcdFx0XHRcdHZhciBidWZmZXIgPSBvYmplY3RzLmdldEF0dHJpYnV0ZUJ1ZmZlciggZ2VvbWV0cnlBdHRyaWJ1dGUgKTtcblxuXHRcdFx0XHRcdFx0aWYgKCBnZW9tZXRyeUF0dHJpYnV0ZSBpbnN0YW5jZW9mIFRIUkVFLkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICkge1xuXG5cdFx0XHRcdFx0XHRcdHZhciBkYXRhID0gZ2VvbWV0cnlBdHRyaWJ1dGUuZGF0YTtcblx0XHRcdFx0XHRcdFx0dmFyIHN0cmlkZSA9IGRhdGEuc3RyaWRlO1xuXHRcdFx0XHRcdFx0XHR2YXIgb2Zmc2V0ID0gZ2VvbWV0cnlBdHRyaWJ1dGUub2Zmc2V0O1xuXG5cdFx0XHRcdFx0XHRcdGlmICggZGF0YSBpbnN0YW5jZW9mIFRIUkVFLkluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0c3RhdGUuZW5hYmxlQXR0cmlidXRlQW5kRGl2aXNvciggcHJvZ3JhbUF0dHJpYnV0ZSwgZGF0YS5tZXNoUGVyQXR0cmlidXRlLCBleHRlbnNpb24gKTtcblxuXHRcdFx0XHRcdFx0XHRcdGlmICggZ2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Z2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQgPSBkYXRhLm1lc2hQZXJBdHRyaWJ1dGUgKiBkYXRhLmNvdW50O1xuXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRzdGF0ZS5lbmFibGVBdHRyaWJ1dGUoIHByb2dyYW1BdHRyaWJ1dGUgKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlciApO1xuXHRcdFx0XHRcdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggcHJvZ3JhbUF0dHJpYnV0ZSwgc2l6ZSwgX2dsLkZMT0FULCBmYWxzZSwgc3RyaWRlICogZGF0YS5hcnJheS5CWVRFU19QRVJfRUxFTUVOVCwgKCBzdGFydEluZGV4ICogc3RyaWRlICsgb2Zmc2V0ICkgKiBkYXRhLmFycmF5LkJZVEVTX1BFUl9FTEVNRU5UICk7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBnZW9tZXRyeUF0dHJpYnV0ZSBpbnN0YW5jZW9mIFRIUkVFLkluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdHN0YXRlLmVuYWJsZUF0dHJpYnV0ZUFuZERpdmlzb3IoIHByb2dyYW1BdHRyaWJ1dGUsIGdlb21ldHJ5QXR0cmlidXRlLm1lc2hQZXJBdHRyaWJ1dGUsIGV4dGVuc2lvbiApO1xuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudCA9IGdlb21ldHJ5QXR0cmlidXRlLm1lc2hQZXJBdHRyaWJ1dGUgKiBnZW9tZXRyeUF0dHJpYnV0ZS5jb3VudDtcblxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0c3RhdGUuZW5hYmxlQXR0cmlidXRlKCBwcm9ncmFtQXR0cmlidXRlICk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIgKTtcblx0XHRcdFx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIHByb2dyYW1BdHRyaWJ1dGUsIHNpemUsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIHN0YXJ0SW5kZXggKiBzaXplICogNCApOyAvLyA0IGJ5dGVzIHBlciBGbG9hdDMyXG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsRGVmYXVsdEF0dHJpYnV0ZVZhbHVlcyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgdmFsdWUgPSBtYXRlcmlhbERlZmF1bHRBdHRyaWJ1dGVWYWx1ZXNbIG5hbWUgXTtcblxuXHRcdFx0XHRcdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRcdHN3aXRjaCAoIHZhbHVlLmxlbmd0aCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGNhc2UgMjpcblx0XHRcdFx0XHRcdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWIyZnYoIHByb2dyYW1BdHRyaWJ1dGUsIHZhbHVlICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRcdGNhc2UgMzpcblx0XHRcdFx0XHRcdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWIzZnYoIHByb2dyYW1BdHRyaWJ1dGUsIHZhbHVlICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRcdGNhc2UgNDpcblx0XHRcdFx0XHRcdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWI0ZnYoIHByb2dyYW1BdHRyaWJ1dGUsIHZhbHVlICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdFx0XHRfZ2wudmVydGV4QXR0cmliMWZ2KCBwcm9ncmFtQXR0cmlidXRlLCB2YWx1ZSApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRzdGF0ZS5kaXNhYmxlVW51c2VkQXR0cmlidXRlcygpO1xuXG5cdFx0fVxuXG5cdFx0Ly8gU29ydGluZ1xuXG5cdFx0ZnVuY3Rpb24gbnVtZXJpY2FsU29ydCAoIGEsIGIgKSB7XG5cblx0XHRcdHJldHVybiBiWyAwIF0gLSBhWyAwIF07XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYWludGVyU29ydFN0YWJsZSAoIGEsIGIgKSB7XG5cblx0XHRcdGlmICggYS5vYmplY3QucmVuZGVyT3JkZXIgIT09IGIub2JqZWN0LnJlbmRlck9yZGVyICkge1xuXG5cdFx0XHRcdHJldHVybiBhLm9iamVjdC5yZW5kZXJPcmRlciAtIGIub2JqZWN0LnJlbmRlck9yZGVyO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBhLm1hdGVyaWFsLmlkICE9PSBiLm1hdGVyaWFsLmlkICkge1xuXG5cdFx0XHRcdHJldHVybiBhLm1hdGVyaWFsLmlkIC0gYi5tYXRlcmlhbC5pZDtcblxuXHRcdFx0fSBlbHNlIGlmICggYS56ICE9PSBiLnogKSB7XG5cblx0XHRcdFx0cmV0dXJuIGEueiAtIGIuejtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRyZXR1cm4gYS5pZCAtIGIuaWQ7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJldmVyc2VQYWludGVyU29ydFN0YWJsZSAoIGEsIGIgKSB7XG5cblx0XHRcdGlmICggYS5vYmplY3QucmVuZGVyT3JkZXIgIT09IGIub2JqZWN0LnJlbmRlck9yZGVyICkge1xuXG5cdFx0XHRcdHJldHVybiBhLm9iamVjdC5yZW5kZXJPcmRlciAtIGIub2JqZWN0LnJlbmRlck9yZGVyO1xuXG5cdFx0XHR9IGlmICggYS56ICE9PSBiLnogKSB7XG5cblx0XHRcdFx0cmV0dXJuIGIueiAtIGEuejtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRyZXR1cm4gYS5pZCAtIGIuaWQ7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIFJlbmRlcmluZ1xuXG5cdFx0dGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoIHNjZW5lLCBjYW1lcmEsIHJlbmRlclRhcmdldCwgZm9yY2VDbGVhciApIHtcblxuXHRcdFx0aWYgKCBjYW1lcmEgaW5zdGFuY2VvZiBUSFJFRS5DYW1lcmEgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyLnJlbmRlcjogY2FtZXJhIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBUSFJFRS5DYW1lcmEuJyApO1xuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIGZvZyA9IHNjZW5lLmZvZztcblxuXHRcdFx0Ly8gcmVzZXQgY2FjaGluZyBmb3IgdGhpcyBmcmFtZVxuXG5cdFx0XHRfY3VycmVudEdlb21ldHJ5UHJvZ3JhbSA9ICcnO1xuXHRcdFx0X2N1cnJlbnRNYXRlcmlhbElkID0gLSAxO1xuXHRcdFx0X2N1cnJlbnRDYW1lcmEgPSBudWxsO1xuXHRcdFx0X2xpZ2h0c05lZWRVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHQvLyB1cGRhdGUgc2NlbmUgZ3JhcGhcblxuXHRcdFx0aWYgKCBzY2VuZS5hdXRvVXBkYXRlID09PSB0cnVlICkgc2NlbmUudXBkYXRlTWF0cml4V29ybGQoKTtcblxuXHRcdFx0Ly8gdXBkYXRlIGNhbWVyYSBtYXRyaWNlcyBhbmQgZnJ1c3R1bVxuXG5cdFx0XHRpZiAoIGNhbWVyYS5wYXJlbnQgPT09IG51bGwgKSBjYW1lcmEudXBkYXRlTWF0cml4V29ybGQoKTtcblxuXHRcdFx0Y2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZS5nZXRJbnZlcnNlKCBjYW1lcmEubWF0cml4V29ybGQgKTtcblxuXHRcdFx0X3Byb2pTY3JlZW5NYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLnByb2plY3Rpb25NYXRyaXgsIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UgKTtcblx0XHRcdF9mcnVzdHVtLnNldEZyb21NYXRyaXgoIF9wcm9qU2NyZWVuTWF0cml4ICk7XG5cblx0XHRcdGxpZ2h0cy5sZW5ndGggPSAwO1xuXG5cdFx0XHRvcGFxdWVPYmplY3RzTGFzdEluZGV4ID0gLSAxO1xuXHRcdFx0dHJhbnNwYXJlbnRPYmplY3RzTGFzdEluZGV4ID0gLSAxO1xuXG5cdFx0XHRzcHJpdGVzLmxlbmd0aCA9IDA7XG5cdFx0XHRsZW5zRmxhcmVzLmxlbmd0aCA9IDA7XG5cblx0XHRcdHByb2plY3RPYmplY3QoIHNjZW5lLCBjYW1lcmEgKTtcblxuXHRcdFx0b3BhcXVlT2JqZWN0cy5sZW5ndGggPSBvcGFxdWVPYmplY3RzTGFzdEluZGV4ICsgMTtcblx0XHRcdHRyYW5zcGFyZW50T2JqZWN0cy5sZW5ndGggPSB0cmFuc3BhcmVudE9iamVjdHNMYXN0SW5kZXggKyAxO1xuXG5cdFx0XHRpZiAoIF90aGlzLnNvcnRPYmplY3RzID09PSB0cnVlICkge1xuXG5cdFx0XHRcdG9wYXF1ZU9iamVjdHMuc29ydCggcGFpbnRlclNvcnRTdGFibGUgKTtcblx0XHRcdFx0dHJhbnNwYXJlbnRPYmplY3RzLnNvcnQoIHJldmVyc2VQYWludGVyU29ydFN0YWJsZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vXG5cblx0XHRcdHNoYWRvd01hcC5yZW5kZXIoIHNjZW5lICk7XG5cblx0XHRcdC8vXG5cblx0XHRcdF9pbmZvUmVuZGVyLmNhbGxzID0gMDtcblx0XHRcdF9pbmZvUmVuZGVyLnZlcnRpY2VzID0gMDtcblx0XHRcdF9pbmZvUmVuZGVyLmZhY2VzID0gMDtcblx0XHRcdF9pbmZvUmVuZGVyLnBvaW50cyA9IDA7XG5cblx0XHRcdHRoaXMuc2V0UmVuZGVyVGFyZ2V0KCByZW5kZXJUYXJnZXQgKTtcblxuXHRcdFx0aWYgKCB0aGlzLmF1dG9DbGVhciB8fCBmb3JjZUNsZWFyICkge1xuXG5cdFx0XHRcdHRoaXMuY2xlYXIoIHRoaXMuYXV0b0NsZWFyQ29sb3IsIHRoaXMuYXV0b0NsZWFyRGVwdGgsIHRoaXMuYXV0b0NsZWFyU3RlbmNpbCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vXG5cblx0XHRcdGlmICggc2NlbmUub3ZlcnJpZGVNYXRlcmlhbCApIHtcblxuXHRcdFx0XHR2YXIgb3ZlcnJpZGVNYXRlcmlhbCA9IHNjZW5lLm92ZXJyaWRlTWF0ZXJpYWw7XG5cblx0XHRcdFx0cmVuZGVyT2JqZWN0cyggb3BhcXVlT2JqZWN0cywgY2FtZXJhLCBsaWdodHMsIGZvZywgb3ZlcnJpZGVNYXRlcmlhbCApO1xuXHRcdFx0XHRyZW5kZXJPYmplY3RzKCB0cmFuc3BhcmVudE9iamVjdHMsIGNhbWVyYSwgbGlnaHRzLCBmb2csIG92ZXJyaWRlTWF0ZXJpYWwgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBvcGFxdWUgcGFzcyAoZnJvbnQtdG8tYmFjayBvcmRlcilcblxuXHRcdFx0XHRzdGF0ZS5zZXRCbGVuZGluZyggVEhSRUUuTm9CbGVuZGluZyApO1xuXHRcdFx0XHRyZW5kZXJPYmplY3RzKCBvcGFxdWVPYmplY3RzLCBjYW1lcmEsIGxpZ2h0cywgZm9nICk7XG5cblx0XHRcdFx0Ly8gdHJhbnNwYXJlbnQgcGFzcyAoYmFjay10by1mcm9udCBvcmRlcilcblxuXHRcdFx0XHRyZW5kZXJPYmplY3RzKCB0cmFuc3BhcmVudE9iamVjdHMsIGNhbWVyYSwgbGlnaHRzLCBmb2cgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBjdXN0b20gcmVuZGVyIHBsdWdpbnMgKHBvc3QgcGFzcylcblxuXHRcdFx0c3ByaXRlUGx1Z2luLnJlbmRlciggc2NlbmUsIGNhbWVyYSApO1xuXHRcdFx0bGVuc0ZsYXJlUGx1Z2luLnJlbmRlciggc2NlbmUsIGNhbWVyYSwgX2N1cnJlbnRXaWR0aCwgX2N1cnJlbnRIZWlnaHQgKTtcblxuXHRcdFx0Ly8gR2VuZXJhdGUgbWlwbWFwIGlmIHdlJ3JlIHVzaW5nIGFueSBraW5kIG9mIG1pcG1hcCBmaWx0ZXJpbmdcblxuXHRcdFx0aWYgKCByZW5kZXJUYXJnZXQgKSB7XG5cblx0XHRcdFx0dmFyIHRleHR1cmUgPSByZW5kZXJUYXJnZXQudGV4dHVyZTtcblx0XHRcdFx0dmFyIGlzVGFyZ2V0UG93ZXJPZlR3byA9IGlzUG93ZXJPZlR3byggcmVuZGVyVGFyZ2V0ICk7XG5cdFx0XHRcdGlmICggdGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgJiYgaXNUYXJnZXRQb3dlck9mVHdvICYmIHRleHR1cmUubWluRmlsdGVyICE9PSBUSFJFRS5OZWFyZXN0RmlsdGVyICYmIHRleHR1cmUubWluRmlsdGVyICE9PSBUSFJFRS5MaW5lYXJGaWx0ZXIgKSB7XG5cblx0XHRcdFx0XHQgdXBkYXRlUmVuZGVyVGFyZ2V0TWlwbWFwKCByZW5kZXJUYXJnZXQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gRW5zdXJlIGRlcHRoIGJ1ZmZlciB3cml0aW5nIGlzIGVuYWJsZWQgc28gaXQgY2FuIGJlIGNsZWFyZWQgb24gbmV4dCByZW5kZXJcblxuXHRcdFx0c3RhdGUuc2V0RGVwdGhUZXN0KCB0cnVlICk7XG5cdFx0XHRzdGF0ZS5zZXREZXB0aFdyaXRlKCB0cnVlICk7XG5cdFx0XHRzdGF0ZS5zZXRDb2xvcldyaXRlKCB0cnVlICk7XG5cblx0XHRcdC8vIF9nbC5maW5pc2goKTtcblxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBwdXNoUmVuZGVySXRlbSggb2JqZWN0LCBnZW9tZXRyeSwgbWF0ZXJpYWwsIHosIGdyb3VwICkge1xuXG5cdFx0XHR2YXIgYXJyYXksIGluZGV4O1xuXG5cdFx0XHQvLyBhbGxvY2F0ZSB0aGUgbmV4dCBwb3NpdGlvbiBpbiB0aGUgYXBwcm9wcmlhdGUgYXJyYXlcblxuXHRcdFx0aWYgKCBtYXRlcmlhbC50cmFuc3BhcmVudCApIHtcblxuXHRcdFx0XHRhcnJheSA9IHRyYW5zcGFyZW50T2JqZWN0cztcblx0XHRcdFx0aW5kZXggPSArKyB0cmFuc3BhcmVudE9iamVjdHNMYXN0SW5kZXg7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0YXJyYXkgPSBvcGFxdWVPYmplY3RzO1xuXHRcdFx0XHRpbmRleCA9ICsrIG9wYXF1ZU9iamVjdHNMYXN0SW5kZXg7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gcmVjeWNsZSBleGlzdGluZyByZW5kZXIgaXRlbSBvciBncm93IHRoZSBhcnJheVxuXG5cdFx0XHR2YXIgcmVuZGVySXRlbSA9IGFycmF5WyBpbmRleCBdO1xuXG5cdFx0XHRpZiAoIHJlbmRlckl0ZW0gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRyZW5kZXJJdGVtLmlkID0gb2JqZWN0LmlkO1xuXHRcdFx0XHRyZW5kZXJJdGVtLm9iamVjdCA9IG9iamVjdDtcblx0XHRcdFx0cmVuZGVySXRlbS5nZW9tZXRyeSA9IGdlb21ldHJ5O1xuXHRcdFx0XHRyZW5kZXJJdGVtLm1hdGVyaWFsID0gbWF0ZXJpYWw7XG5cdFx0XHRcdHJlbmRlckl0ZW0ueiA9IF92ZWN0b3IzLno7XG5cdFx0XHRcdHJlbmRlckl0ZW0uZ3JvdXAgPSBncm91cDtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRyZW5kZXJJdGVtID0ge1xuXHRcdFx0XHRcdGlkOiBvYmplY3QuaWQsXG5cdFx0XHRcdFx0b2JqZWN0OiBvYmplY3QsXG5cdFx0XHRcdFx0Z2VvbWV0cnk6IGdlb21ldHJ5LFxuXHRcdFx0XHRcdG1hdGVyaWFsOiBtYXRlcmlhbCxcblx0XHRcdFx0XHR6OiBfdmVjdG9yMy56LFxuXHRcdFx0XHRcdGdyb3VwOiBncm91cFxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdC8vIGFzc2VydCggaW5kZXggPT09IGFycmF5Lmxlbmd0aCApO1xuXHRcdFx0XHRhcnJheS5wdXNoKCByZW5kZXJJdGVtICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHByb2plY3RPYmplY3QoIG9iamVjdCwgY2FtZXJhICkge1xuXG5cdFx0XHRpZiAoIG9iamVjdC52aXNpYmxlID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdFx0aWYgKCAoIG9iamVjdC5jaGFubmVscy5tYXNrICYgY2FtZXJhLmNoYW5uZWxzLm1hc2sgKSAhPT0gMCApIHtcblxuXHRcdFx0XHRpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkxpZ2h0ICkge1xuXG5cdFx0XHRcdFx0bGlnaHRzLnB1c2goIG9iamVjdCApO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlNwcml0ZSApIHtcblxuXHRcdFx0XHRcdHNwcml0ZXMucHVzaCggb2JqZWN0ICk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTGVuc0ZsYXJlICkge1xuXG5cdFx0XHRcdFx0bGVuc0ZsYXJlcy5wdXNoKCBvYmplY3QgKTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5JbW1lZGlhdGVSZW5kZXJPYmplY3QgKSB7XG5cblx0XHRcdFx0XHRpZiAoIF90aGlzLnNvcnRPYmplY3RzID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0XHRfdmVjdG9yMy5zZXRGcm9tTWF0cml4UG9zaXRpb24oIG9iamVjdC5tYXRyaXhXb3JsZCApO1xuXHRcdFx0XHRcdFx0X3ZlY3RvcjMuYXBwbHlQcm9qZWN0aW9uKCBfcHJvalNjcmVlbk1hdHJpeCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cHVzaFJlbmRlckl0ZW0oIG9iamVjdCwgbnVsbCwgb2JqZWN0Lm1hdGVyaWFsLCBfdmVjdG9yMy56LCBudWxsICk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTWVzaCB8fCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5MaW5lIHx8IG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlBvaW50cyApIHtcblxuXHRcdFx0XHRcdGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuU2tpbm5lZE1lc2ggKSB7XG5cblx0XHRcdFx0XHRcdG9iamVjdC5za2VsZXRvbi51cGRhdGUoKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggb2JqZWN0LmZydXN0dW1DdWxsZWQgPT09IGZhbHNlIHx8IF9mcnVzdHVtLmludGVyc2VjdHNPYmplY3QoIG9iamVjdCApID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgbWF0ZXJpYWwgPSBvYmplY3QubWF0ZXJpYWw7XG5cblx0XHRcdFx0XHRcdGlmICggbWF0ZXJpYWwudmlzaWJsZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIF90aGlzLnNvcnRPYmplY3RzID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0X3ZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBvYmplY3QubWF0cml4V29ybGQgKTtcblx0XHRcdFx0XHRcdFx0XHRfdmVjdG9yMy5hcHBseVByb2plY3Rpb24oIF9wcm9qU2NyZWVuTWF0cml4ICk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdHZhciBnZW9tZXRyeSA9IG9iamVjdHMudXBkYXRlKCBvYmplY3QgKTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaEZhY2VNYXRlcmlhbCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdHZhciBncm91cHMgPSBnZW9tZXRyeS5ncm91cHM7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIG1hdGVyaWFscyA9IG1hdGVyaWFsLm1hdGVyaWFscztcblxuXHRcdFx0XHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgZ3JvdXAgPSBncm91cHNbIGkgXTtcblx0XHRcdFx0XHRcdFx0XHRcdHZhciBncm91cE1hdGVyaWFsID0gbWF0ZXJpYWxzWyBncm91cC5tYXRlcmlhbEluZGV4IF07XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmICggZ3JvdXBNYXRlcmlhbC52aXNpYmxlID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHB1c2hSZW5kZXJJdGVtKCBvYmplY3QsIGdlb21ldHJ5LCBncm91cE1hdGVyaWFsLCBfdmVjdG9yMy56LCBncm91cCApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdHB1c2hSZW5kZXJJdGVtKCBvYmplY3QsIGdlb21ldHJ5LCBtYXRlcmlhbCwgX3ZlY3RvcjMueiwgbnVsbCApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgY2hpbGRyZW4gPSBvYmplY3QuY2hpbGRyZW47XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0cHJvamVjdE9iamVjdCggY2hpbGRyZW5bIGkgXSwgY2FtZXJhICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlbmRlck9iamVjdHMoIHJlbmRlckxpc3QsIGNhbWVyYSwgbGlnaHRzLCBmb2csIG92ZXJyaWRlTWF0ZXJpYWwgKSB7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHJlbmRlckxpc3QubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgcmVuZGVySXRlbSA9IHJlbmRlckxpc3RbIGkgXTtcblxuXHRcdFx0XHR2YXIgb2JqZWN0ID0gcmVuZGVySXRlbS5vYmplY3Q7XG5cdFx0XHRcdHZhciBnZW9tZXRyeSA9IHJlbmRlckl0ZW0uZ2VvbWV0cnk7XG5cdFx0XHRcdHZhciBtYXRlcmlhbCA9IG92ZXJyaWRlTWF0ZXJpYWwgPT09IHVuZGVmaW5lZCA/IHJlbmRlckl0ZW0ubWF0ZXJpYWwgOiBvdmVycmlkZU1hdGVyaWFsO1xuXHRcdFx0XHR2YXIgZ3JvdXAgPSByZW5kZXJJdGVtLmdyb3VwO1xuXG5cdFx0XHRcdG9iamVjdC5tb2RlbFZpZXdNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSwgb2JqZWN0Lm1hdHJpeFdvcmxkICk7XG5cdFx0XHRcdG9iamVjdC5ub3JtYWxNYXRyaXguZ2V0Tm9ybWFsTWF0cml4KCBvYmplY3QubW9kZWxWaWV3TWF0cml4ICk7XG5cblx0XHRcdFx0aWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5JbW1lZGlhdGVSZW5kZXJPYmplY3QgKSB7XG5cblx0XHRcdFx0XHRzZXRNYXRlcmlhbCggbWF0ZXJpYWwgKTtcblxuXHRcdFx0XHRcdHZhciBwcm9ncmFtID0gc2V0UHJvZ3JhbSggY2FtZXJhLCBsaWdodHMsIGZvZywgbWF0ZXJpYWwsIG9iamVjdCApO1xuXG5cdFx0XHRcdFx0X2N1cnJlbnRHZW9tZXRyeVByb2dyYW0gPSAnJztcblxuXHRcdFx0XHRcdG9iamVjdC5yZW5kZXIoIGZ1bmN0aW9uICggb2JqZWN0ICkge1xuXG5cdFx0XHRcdFx0XHRfdGhpcy5yZW5kZXJCdWZmZXJJbW1lZGlhdGUoIG9iamVjdCwgcHJvZ3JhbSwgbWF0ZXJpYWwgKTtcblxuXHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0X3RoaXMucmVuZGVyQnVmZmVyRGlyZWN0KCBjYW1lcmEsIGxpZ2h0cywgZm9nLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIG9iamVjdCwgZ3JvdXAgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGluaXRNYXRlcmlhbCggbWF0ZXJpYWwsIGxpZ2h0cywgZm9nLCBvYmplY3QgKSB7XG5cblx0XHRcdHZhciBtYXRlcmlhbFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggbWF0ZXJpYWwgKTtcblxuXHRcdFx0dmFyIHBhcmFtZXRlcnMgPSBwcm9ncmFtQ2FjaGUuZ2V0UGFyYW1ldGVycyggbWF0ZXJpYWwsIGxpZ2h0cywgZm9nLCBvYmplY3QgKTtcblx0XHRcdHZhciBjb2RlID0gcHJvZ3JhbUNhY2hlLmdldFByb2dyYW1Db2RlKCBtYXRlcmlhbCwgcGFyYW1ldGVycyApO1xuXG5cdFx0XHR2YXIgcHJvZ3JhbSA9IG1hdGVyaWFsUHJvcGVydGllcy5wcm9ncmFtO1xuXHRcdFx0dmFyIHByb2dyYW1DaGFuZ2UgPSB0cnVlO1xuXG5cdFx0XHRpZiAoIHByb2dyYW0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHQvLyBuZXcgbWF0ZXJpYWxcblx0XHRcdFx0bWF0ZXJpYWwuYWRkRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvbk1hdGVyaWFsRGlzcG9zZSApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBwcm9ncmFtLmNvZGUgIT09IGNvZGUgKSB7XG5cblx0XHRcdFx0Ly8gY2hhbmdlZCBnbHNsIG9yIHBhcmFtZXRlcnNcblx0XHRcdFx0cmVsZWFzZU1hdGVyaWFsUHJvZ3JhbVJlZmVyZW5jZSggbWF0ZXJpYWwgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggcGFyYW1ldGVycy5zaGFkZXJJRCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdC8vIHNhbWUgZ2xzbCBhbmQgdW5pZm9ybSBsaXN0XG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBvbmx5IHJlYnVpbGQgdW5pZm9ybSBsaXN0XG5cdFx0XHRcdHByb2dyYW1DaGFuZ2UgPSBmYWxzZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHByb2dyYW1DaGFuZ2UgKSB7XG5cblx0XHRcdFx0aWYgKCBwYXJhbWV0ZXJzLnNoYWRlcklEICkge1xuXG5cdFx0XHRcdFx0dmFyIHNoYWRlciA9IFRIUkVFLlNoYWRlckxpYlsgcGFyYW1ldGVycy5zaGFkZXJJRCBdO1xuXG5cdFx0XHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLl9fd2ViZ2xTaGFkZXIgPSB7XG5cdFx0XHRcdFx0XHRuYW1lOiBtYXRlcmlhbC50eXBlLFxuXHRcdFx0XHRcdFx0dW5pZm9ybXM6IFRIUkVFLlVuaWZvcm1zVXRpbHMuY2xvbmUoIHNoYWRlci51bmlmb3JtcyApLFxuXHRcdFx0XHRcdFx0dmVydGV4U2hhZGVyOiBzaGFkZXIudmVydGV4U2hhZGVyLFxuXHRcdFx0XHRcdFx0ZnJhZ21lbnRTaGFkZXI6IHNoYWRlci5mcmFnbWVudFNoYWRlclxuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdG1hdGVyaWFsUHJvcGVydGllcy5fX3dlYmdsU2hhZGVyID0ge1xuXHRcdFx0XHRcdFx0bmFtZTogbWF0ZXJpYWwudHlwZSxcblx0XHRcdFx0XHRcdHVuaWZvcm1zOiBtYXRlcmlhbC51bmlmb3Jtcyxcblx0XHRcdFx0XHRcdHZlcnRleFNoYWRlcjogbWF0ZXJpYWwudmVydGV4U2hhZGVyLFxuXHRcdFx0XHRcdFx0ZnJhZ21lbnRTaGFkZXI6IG1hdGVyaWFsLmZyYWdtZW50U2hhZGVyXG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0bWF0ZXJpYWwuX193ZWJnbFNoYWRlciA9IG1hdGVyaWFsUHJvcGVydGllcy5fX3dlYmdsU2hhZGVyO1xuXG5cdFx0XHRcdHByb2dyYW0gPSBwcm9ncmFtQ2FjaGUuYWNxdWlyZVByb2dyYW0oIG1hdGVyaWFsLCBwYXJhbWV0ZXJzLCBjb2RlICk7XG5cblx0XHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLnByb2dyYW0gPSBwcm9ncmFtO1xuXHRcdFx0XHRtYXRlcmlhbC5wcm9ncmFtID0gcHJvZ3JhbTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgYXR0cmlidXRlcyA9IHByb2dyYW0uZ2V0QXR0cmlidXRlcygpO1xuXG5cdFx0XHRpZiAoIG1hdGVyaWFsLm1vcnBoVGFyZ2V0cyApIHtcblxuXHRcdFx0XHRtYXRlcmlhbC5udW1TdXBwb3J0ZWRNb3JwaFRhcmdldHMgPSAwO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IF90aGlzLm1heE1vcnBoVGFyZ2V0czsgaSArKyApIHtcblxuXHRcdFx0XHRcdGlmICggYXR0cmlidXRlc1sgJ21vcnBoVGFyZ2V0JyArIGkgXSA+PSAwICkge1xuXG5cdFx0XHRcdFx0XHRtYXRlcmlhbC5udW1TdXBwb3J0ZWRNb3JwaFRhcmdldHMgKys7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbWF0ZXJpYWwubW9ycGhOb3JtYWxzICkge1xuXG5cdFx0XHRcdG1hdGVyaWFsLm51bVN1cHBvcnRlZE1vcnBoTm9ybWFscyA9IDA7XG5cblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBfdGhpcy5tYXhNb3JwaE5vcm1hbHM7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGF0dHJpYnV0ZXNbICdtb3JwaE5vcm1hbCcgKyBpIF0gPj0gMCApIHtcblxuXHRcdFx0XHRcdFx0bWF0ZXJpYWwubnVtU3VwcG9ydGVkTW9ycGhOb3JtYWxzICsrO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMudW5pZm9ybXNMaXN0ID0gW107XG5cblx0XHRcdHZhciB1bmlmb3JtTG9jYXRpb25zID0gbWF0ZXJpYWxQcm9wZXJ0aWVzLnByb2dyYW0uZ2V0VW5pZm9ybXMoKTtcblxuXHRcdFx0Zm9yICggdmFyIHUgaW4gbWF0ZXJpYWxQcm9wZXJ0aWVzLl9fd2ViZ2xTaGFkZXIudW5pZm9ybXMgKSB7XG5cblx0XHRcdFx0dmFyIGxvY2F0aW9uID0gdW5pZm9ybUxvY2F0aW9uc1sgdSBdO1xuXG5cdFx0XHRcdGlmICggbG9jYXRpb24gKSB7XG5cblx0XHRcdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMudW5pZm9ybXNMaXN0LnB1c2goIFsgbWF0ZXJpYWxQcm9wZXJ0aWVzLl9fd2ViZ2xTaGFkZXIudW5pZm9ybXNbIHUgXSwgbG9jYXRpb24gXSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gc2V0TWF0ZXJpYWwoIG1hdGVyaWFsICkge1xuXG5cdFx0XHRzZXRNYXRlcmlhbEZhY2VzKCBtYXRlcmlhbCApO1xuXG5cdFx0XHRpZiAoIG1hdGVyaWFsLnRyYW5zcGFyZW50ID09PSB0cnVlICkge1xuXG5cdFx0XHRcdHN0YXRlLnNldEJsZW5kaW5nKCBtYXRlcmlhbC5ibGVuZGluZywgbWF0ZXJpYWwuYmxlbmRFcXVhdGlvbiwgbWF0ZXJpYWwuYmxlbmRTcmMsIG1hdGVyaWFsLmJsZW5kRHN0LCBtYXRlcmlhbC5ibGVuZEVxdWF0aW9uQWxwaGEsIG1hdGVyaWFsLmJsZW5kU3JjQWxwaGEsIG1hdGVyaWFsLmJsZW5kRHN0QWxwaGEgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRzdGF0ZS5zZXRCbGVuZGluZyggVEhSRUUuTm9CbGVuZGluZyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHN0YXRlLnNldERlcHRoRnVuYyggbWF0ZXJpYWwuZGVwdGhGdW5jICk7XG5cdFx0XHRzdGF0ZS5zZXREZXB0aFRlc3QoIG1hdGVyaWFsLmRlcHRoVGVzdCApO1xuXHRcdFx0c3RhdGUuc2V0RGVwdGhXcml0ZSggbWF0ZXJpYWwuZGVwdGhXcml0ZSApO1xuXHRcdFx0c3RhdGUuc2V0Q29sb3JXcml0ZSggbWF0ZXJpYWwuY29sb3JXcml0ZSApO1xuXHRcdFx0c3RhdGUuc2V0UG9seWdvbk9mZnNldCggbWF0ZXJpYWwucG9seWdvbk9mZnNldCwgbWF0ZXJpYWwucG9seWdvbk9mZnNldEZhY3RvciwgbWF0ZXJpYWwucG9seWdvbk9mZnNldFVuaXRzICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBzZXRNYXRlcmlhbEZhY2VzKCBtYXRlcmlhbCApIHtcblxuXHRcdFx0bWF0ZXJpYWwuc2lkZSAhPT0gVEhSRUUuRG91YmxlU2lkZSA/IHN0YXRlLmVuYWJsZSggX2dsLkNVTExfRkFDRSApIDogc3RhdGUuZGlzYWJsZSggX2dsLkNVTExfRkFDRSApO1xuXHRcdFx0c3RhdGUuc2V0RmxpcFNpZGVkKCBtYXRlcmlhbC5zaWRlID09PSBUSFJFRS5CYWNrU2lkZSApO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gc2V0UHJvZ3JhbSggY2FtZXJhLCBsaWdodHMsIGZvZywgbWF0ZXJpYWwsIG9iamVjdCApIHtcblxuXHRcdFx0X3VzZWRUZXh0dXJlVW5pdHMgPSAwO1xuXG5cdFx0XHR2YXIgbWF0ZXJpYWxQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIG1hdGVyaWFsICk7XG5cblx0XHRcdGlmICggbWF0ZXJpYWwubmVlZHNVcGRhdGUgfHwgISBtYXRlcmlhbFByb3BlcnRpZXMucHJvZ3JhbSApIHtcblxuXHRcdFx0XHRpbml0TWF0ZXJpYWwoIG1hdGVyaWFsLCBsaWdodHMsIGZvZywgb2JqZWN0ICk7XG5cdFx0XHRcdG1hdGVyaWFsLm5lZWRzVXBkYXRlID0gZmFsc2U7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIHJlZnJlc2hQcm9ncmFtID0gZmFsc2U7XG5cdFx0XHR2YXIgcmVmcmVzaE1hdGVyaWFsID0gZmFsc2U7XG5cdFx0XHR2YXIgcmVmcmVzaExpZ2h0cyA9IGZhbHNlO1xuXG5cdFx0XHR2YXIgcHJvZ3JhbSA9IG1hdGVyaWFsUHJvcGVydGllcy5wcm9ncmFtLFxuXHRcdFx0XHRwX3VuaWZvcm1zID0gcHJvZ3JhbS5nZXRVbmlmb3JtcygpLFxuXHRcdFx0XHRtX3VuaWZvcm1zID0gbWF0ZXJpYWxQcm9wZXJ0aWVzLl9fd2ViZ2xTaGFkZXIudW5pZm9ybXM7XG5cblx0XHRcdGlmICggcHJvZ3JhbS5pZCAhPT0gX2N1cnJlbnRQcm9ncmFtICkge1xuXG5cdFx0XHRcdF9nbC51c2VQcm9ncmFtKCBwcm9ncmFtLnByb2dyYW0gKTtcblx0XHRcdFx0X2N1cnJlbnRQcm9ncmFtID0gcHJvZ3JhbS5pZDtcblxuXHRcdFx0XHRyZWZyZXNoUHJvZ3JhbSA9IHRydWU7XG5cdFx0XHRcdHJlZnJlc2hNYXRlcmlhbCA9IHRydWU7XG5cdFx0XHRcdHJlZnJlc2hMaWdodHMgPSB0cnVlO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbWF0ZXJpYWwuaWQgIT09IF9jdXJyZW50TWF0ZXJpYWxJZCApIHtcblxuXHRcdFx0XHRpZiAoIF9jdXJyZW50TWF0ZXJpYWxJZCA9PT0gLSAxICkgcmVmcmVzaExpZ2h0cyA9IHRydWU7XG5cdFx0XHRcdF9jdXJyZW50TWF0ZXJpYWxJZCA9IG1hdGVyaWFsLmlkO1xuXG5cdFx0XHRcdHJlZnJlc2hNYXRlcmlhbCA9IHRydWU7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCByZWZyZXNoUHJvZ3JhbSB8fCBjYW1lcmEgIT09IF9jdXJyZW50Q2FtZXJhICkge1xuXG5cdFx0XHRcdF9nbC51bmlmb3JtTWF0cml4NGZ2KCBwX3VuaWZvcm1zLnByb2plY3Rpb25NYXRyaXgsIGZhbHNlLCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeC5lbGVtZW50cyApO1xuXG5cdFx0XHRcdGlmICggY2FwYWJpbGl0aWVzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgKSB7XG5cblx0XHRcdFx0XHRfZ2wudW5pZm9ybTFmKCBwX3VuaWZvcm1zLmxvZ0RlcHRoQnVmRkMsIDIuMCAvICggTWF0aC5sb2coIGNhbWVyYS5mYXIgKyAxLjAgKSAvIE1hdGguTE4yICkgKTtcblxuXHRcdFx0XHR9XG5cblxuXHRcdFx0XHRpZiAoIGNhbWVyYSAhPT0gX2N1cnJlbnRDYW1lcmEgKSBfY3VycmVudENhbWVyYSA9IGNhbWVyYTtcblxuXHRcdFx0XHQvLyBsb2FkIG1hdGVyaWFsIHNwZWNpZmljIHVuaWZvcm1zXG5cdFx0XHRcdC8vIChzaGFkZXIgbWF0ZXJpYWwgYWxzbyBnZXRzIHRoZW0gZm9yIHRoZSBzYWtlIG9mIGdlbmVyaWNpdHkpXG5cblx0XHRcdFx0aWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLlNoYWRlck1hdGVyaWFsIHx8XG5cdFx0XHRcdFx0IG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwgfHxcblx0XHRcdFx0XHQgbWF0ZXJpYWwuZW52TWFwICkge1xuXG5cdFx0XHRcdFx0aWYgKCBwX3VuaWZvcm1zLmNhbWVyYVBvc2l0aW9uICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdF92ZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggY2FtZXJhLm1hdHJpeFdvcmxkICk7XG5cdFx0XHRcdFx0XHRfZ2wudW5pZm9ybTNmKCBwX3VuaWZvcm1zLmNhbWVyYVBvc2l0aW9uLCBfdmVjdG9yMy54LCBfdmVjdG9yMy55LCBfdmVjdG9yMy56ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbCB8fFxuXHRcdFx0XHRcdCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwgfHxcblx0XHRcdFx0XHQgbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCB8fFxuXHRcdFx0XHRcdCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLlNoYWRlck1hdGVyaWFsIHx8XG5cdFx0XHRcdFx0IG1hdGVyaWFsLnNraW5uaW5nICkge1xuXG5cdFx0XHRcdFx0aWYgKCBwX3VuaWZvcm1zLnZpZXdNYXRyaXggIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0X2dsLnVuaWZvcm1NYXRyaXg0ZnYoIHBfdW5pZm9ybXMudmlld01hdHJpeCwgZmFsc2UsIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UuZWxlbWVudHMgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gc2tpbm5pbmcgdW5pZm9ybXMgbXVzdCBiZSBzZXQgZXZlbiBpZiBtYXRlcmlhbCBkaWRuJ3QgY2hhbmdlXG5cdFx0XHQvLyBhdXRvLXNldHRpbmcgb2YgdGV4dHVyZSB1bml0IGZvciBib25lIHRleHR1cmUgbXVzdCBnbyBiZWZvcmUgb3RoZXIgdGV4dHVyZXNcblx0XHRcdC8vIG5vdCBzdXJlIHdoeSwgYnV0IG90aGVyd2lzZSB3ZWlyZCB0aGluZ3MgaGFwcGVuXG5cblx0XHRcdGlmICggbWF0ZXJpYWwuc2tpbm5pbmcgKSB7XG5cblx0XHRcdFx0aWYgKCBvYmplY3QuYmluZE1hdHJpeCAmJiBwX3VuaWZvcm1zLmJpbmRNYXRyaXggIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdF9nbC51bmlmb3JtTWF0cml4NGZ2KCBwX3VuaWZvcm1zLmJpbmRNYXRyaXgsIGZhbHNlLCBvYmplY3QuYmluZE1hdHJpeC5lbGVtZW50cyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIG9iamVjdC5iaW5kTWF0cml4SW52ZXJzZSAmJiBwX3VuaWZvcm1zLmJpbmRNYXRyaXhJbnZlcnNlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRfZ2wudW5pZm9ybU1hdHJpeDRmdiggcF91bmlmb3Jtcy5iaW5kTWF0cml4SW52ZXJzZSwgZmFsc2UsIG9iamVjdC5iaW5kTWF0cml4SW52ZXJzZS5lbGVtZW50cyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGNhcGFiaWxpdGllcy5mbG9hdFZlcnRleFRleHR1cmVzICYmIG9iamVjdC5za2VsZXRvbiAmJiBvYmplY3Quc2tlbGV0b24udXNlVmVydGV4VGV4dHVyZSApIHtcblxuXHRcdFx0XHRcdGlmICggcF91bmlmb3Jtcy5ib25lVGV4dHVyZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgdGV4dHVyZVVuaXQgPSBnZXRUZXh0dXJlVW5pdCgpO1xuXG5cdFx0XHRcdFx0XHRfZ2wudW5pZm9ybTFpKCBwX3VuaWZvcm1zLmJvbmVUZXh0dXJlLCB0ZXh0dXJlVW5pdCApO1xuXHRcdFx0XHRcdFx0X3RoaXMuc2V0VGV4dHVyZSggb2JqZWN0LnNrZWxldG9uLmJvbmVUZXh0dXJlLCB0ZXh0dXJlVW5pdCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBwX3VuaWZvcm1zLmJvbmVUZXh0dXJlV2lkdGggIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0X2dsLnVuaWZvcm0xaSggcF91bmlmb3Jtcy5ib25lVGV4dHVyZVdpZHRoLCBvYmplY3Quc2tlbGV0b24uYm9uZVRleHR1cmVXaWR0aCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBwX3VuaWZvcm1zLmJvbmVUZXh0dXJlSGVpZ2h0ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdF9nbC51bmlmb3JtMWkoIHBfdW5pZm9ybXMuYm9uZVRleHR1cmVIZWlnaHQsIG9iamVjdC5za2VsZXRvbi5ib25lVGV4dHVyZUhlaWdodCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdC5za2VsZXRvbiAmJiBvYmplY3Quc2tlbGV0b24uYm9uZU1hdHJpY2VzICkge1xuXG5cdFx0XHRcdFx0aWYgKCBwX3VuaWZvcm1zLmJvbmVHbG9iYWxNYXRyaWNlcyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRfZ2wudW5pZm9ybU1hdHJpeDRmdiggcF91bmlmb3Jtcy5ib25lR2xvYmFsTWF0cmljZXMsIGZhbHNlLCBvYmplY3Quc2tlbGV0b24uYm9uZU1hdHJpY2VzICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggcmVmcmVzaE1hdGVyaWFsICkge1xuXG5cdFx0XHRcdC8vIHJlZnJlc2ggdW5pZm9ybXMgY29tbW9uIHRvIHNldmVyYWwgbWF0ZXJpYWxzXG5cblx0XHRcdFx0aWYgKCBmb2cgJiYgbWF0ZXJpYWwuZm9nICkge1xuXG5cdFx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zRm9nKCBtX3VuaWZvcm1zLCBmb2cgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsIHx8XG5cdFx0XHRcdFx0IG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCB8fFxuXHRcdFx0XHRcdCBtYXRlcmlhbC5saWdodHMgKSB7XG5cblx0XHRcdFx0XHRpZiAoIF9saWdodHNOZWVkVXBkYXRlICkge1xuXG5cdFx0XHRcdFx0XHRyZWZyZXNoTGlnaHRzID0gdHJ1ZTtcblx0XHRcdFx0XHRcdHNldHVwTGlnaHRzKCBsaWdodHMsIGNhbWVyYSApO1xuXHRcdFx0XHRcdFx0X2xpZ2h0c05lZWRVcGRhdGUgPSBmYWxzZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggcmVmcmVzaExpZ2h0cyApIHtcblxuXHRcdFx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zTGlnaHRzKCBtX3VuaWZvcm1zLCBfbGlnaHRzICk7XG5cdFx0XHRcdFx0XHRtYXJrVW5pZm9ybXNMaWdodHNOZWVkc1VwZGF0ZSggbV91bmlmb3JtcywgdHJ1ZSApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0bWFya1VuaWZvcm1zTGlnaHRzTmVlZHNVcGRhdGUoIG1fdW5pZm9ybXMsIGZhbHNlICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCB8fFxuXHRcdFx0XHRcdCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwgfHxcblx0XHRcdFx0XHQgbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbCApIHtcblxuXHRcdFx0XHRcdHJlZnJlc2hVbmlmb3Jtc0NvbW1vbiggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gcmVmcmVzaCBzaW5nbGUgbWF0ZXJpYWwgc3BlY2lmaWMgdW5pZm9ybXNcblxuXHRcdFx0XHRpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNMaW5lKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTGluZURhc2hlZE1hdGVyaWFsICkge1xuXG5cdFx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zTGluZSggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcblx0XHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNEYXNoKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuUG9pbnRzTWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNQYXJ0aWNsZSggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsICkge1xuXG5cdFx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zUGhvbmcoIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoRGVwdGhNYXRlcmlhbCApIHtcblxuXHRcdFx0XHRcdG1fdW5pZm9ybXMubU5lYXIudmFsdWUgPSBjYW1lcmEubmVhcjtcblx0XHRcdFx0XHRtX3VuaWZvcm1zLm1GYXIudmFsdWUgPSBjYW1lcmEuZmFyO1xuXHRcdFx0XHRcdG1fdW5pZm9ybXMub3BhY2l0eS52YWx1ZSA9IG1hdGVyaWFsLm9wYWNpdHk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoTm9ybWFsTWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0XHRtX3VuaWZvcm1zLm9wYWNpdHkudmFsdWUgPSBtYXRlcmlhbC5vcGFjaXR5O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIG9iamVjdC5yZWNlaXZlU2hhZG93ICYmICEgbWF0ZXJpYWwuX3NoYWRvd1Bhc3MgKSB7XG5cblx0XHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNTaGFkb3coIG1fdW5pZm9ybXMsIGxpZ2h0cywgY2FtZXJhICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGxvYWQgY29tbW9uIHVuaWZvcm1zXG5cblx0XHRcdFx0bG9hZFVuaWZvcm1zR2VuZXJpYyggbWF0ZXJpYWxQcm9wZXJ0aWVzLnVuaWZvcm1zTGlzdCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGxvYWRVbmlmb3Jtc01hdHJpY2VzKCBwX3VuaWZvcm1zLCBvYmplY3QgKTtcblxuXHRcdFx0aWYgKCBwX3VuaWZvcm1zLm1vZGVsTWF0cml4ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0X2dsLnVuaWZvcm1NYXRyaXg0ZnYoIHBfdW5pZm9ybXMubW9kZWxNYXRyaXgsIGZhbHNlLCBvYmplY3QubWF0cml4V29ybGQuZWxlbWVudHMgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcHJvZ3JhbTtcblxuXHRcdH1cblxuXHRcdC8vIFVuaWZvcm1zIChyZWZyZXNoIHVuaWZvcm1zIG9iamVjdHMpXG5cblx0XHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNDb21tb24gKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XG5cblx0XHRcdHVuaWZvcm1zLm9wYWNpdHkudmFsdWUgPSBtYXRlcmlhbC5vcGFjaXR5O1xuXG5cdFx0XHR1bmlmb3Jtcy5kaWZmdXNlLnZhbHVlID0gbWF0ZXJpYWwuY29sb3I7XG5cblx0XHRcdGlmICggbWF0ZXJpYWwuZW1pc3NpdmUgKSB7XG5cblx0XHRcdFx0dW5pZm9ybXMuZW1pc3NpdmUudmFsdWUgPSBtYXRlcmlhbC5lbWlzc2l2ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHR1bmlmb3Jtcy5tYXAudmFsdWUgPSBtYXRlcmlhbC5tYXA7XG5cdFx0XHR1bmlmb3Jtcy5zcGVjdWxhck1hcC52YWx1ZSA9IG1hdGVyaWFsLnNwZWN1bGFyTWFwO1xuXHRcdFx0dW5pZm9ybXMuYWxwaGFNYXAudmFsdWUgPSBtYXRlcmlhbC5hbHBoYU1hcDtcblxuXHRcdFx0aWYgKCBtYXRlcmlhbC5hb01hcCApIHtcblxuXHRcdFx0XHR1bmlmb3Jtcy5hb01hcC52YWx1ZSA9IG1hdGVyaWFsLmFvTWFwO1xuXHRcdFx0XHR1bmlmb3Jtcy5hb01hcEludGVuc2l0eS52YWx1ZSA9IG1hdGVyaWFsLmFvTWFwSW50ZW5zaXR5O1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHV2IHJlcGVhdCBhbmQgb2Zmc2V0IHNldHRpbmcgcHJpb3JpdGllc1xuXHRcdFx0Ly8gMS4gY29sb3IgbWFwXG5cdFx0XHQvLyAyLiBzcGVjdWxhciBtYXBcblx0XHRcdC8vIDMuIG5vcm1hbCBtYXBcblx0XHRcdC8vIDQuIGJ1bXAgbWFwXG5cdFx0XHQvLyA1LiBhbHBoYSBtYXBcblx0XHRcdC8vIDYuIGVtaXNzaXZlIG1hcFxuXG5cdFx0XHR2YXIgdXZTY2FsZU1hcDtcblxuXHRcdFx0aWYgKCBtYXRlcmlhbC5tYXAgKSB7XG5cblx0XHRcdFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLm1hcDtcblxuXHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuc3BlY3VsYXJNYXAgKSB7XG5cblx0XHRcdFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLnNwZWN1bGFyTWFwO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXAgKSB7XG5cblx0XHRcdFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcDtcblxuXHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwubm9ybWFsTWFwICkge1xuXG5cdFx0XHRcdHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5ub3JtYWxNYXA7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmJ1bXBNYXAgKSB7XG5cblx0XHRcdFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLmJ1bXBNYXA7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmFscGhhTWFwICkge1xuXG5cdFx0XHRcdHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5hbHBoYU1hcDtcblxuXHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuZW1pc3NpdmVNYXAgKSB7XG5cblx0XHRcdFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLmVtaXNzaXZlTWFwO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggdXZTY2FsZU1hcCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGlmICggdXZTY2FsZU1hcCBpbnN0YW5jZW9mIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0ICkgdXZTY2FsZU1hcCA9IHV2U2NhbGVNYXAudGV4dHVyZTtcblx0XHRcdFx0dmFyIG9mZnNldCA9IHV2U2NhbGVNYXAub2Zmc2V0O1xuXHRcdFx0XHR2YXIgcmVwZWF0ID0gdXZTY2FsZU1hcC5yZXBlYXQ7XG5cblx0XHRcdFx0dW5pZm9ybXMub2Zmc2V0UmVwZWF0LnZhbHVlLnNldCggb2Zmc2V0LngsIG9mZnNldC55LCByZXBlYXQueCwgcmVwZWF0LnkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR1bmlmb3Jtcy5lbnZNYXAudmFsdWUgPSBtYXRlcmlhbC5lbnZNYXA7XG5cdFx0XHR1bmlmb3Jtcy5mbGlwRW52TWFwLnZhbHVlID0gKCBtYXRlcmlhbC5lbnZNYXAgaW5zdGFuY2VvZiBUSFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmUgKSA/IDEgOiAtIDE7XG5cblx0XHRcdHVuaWZvcm1zLnJlZmxlY3Rpdml0eS52YWx1ZSA9IG1hdGVyaWFsLnJlZmxlY3Rpdml0eTtcblx0XHRcdHVuaWZvcm1zLnJlZnJhY3Rpb25SYXRpby52YWx1ZSA9IG1hdGVyaWFsLnJlZnJhY3Rpb25SYXRpbztcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0xpbmUgKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XG5cblx0XHRcdHVuaWZvcm1zLmRpZmZ1c2UudmFsdWUgPSBtYXRlcmlhbC5jb2xvcjtcblx0XHRcdHVuaWZvcm1zLm9wYWNpdHkudmFsdWUgPSBtYXRlcmlhbC5vcGFjaXR5O1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zRGFzaCAoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcblxuXHRcdFx0dW5pZm9ybXMuZGFzaFNpemUudmFsdWUgPSBtYXRlcmlhbC5kYXNoU2l6ZTtcblx0XHRcdHVuaWZvcm1zLnRvdGFsU2l6ZS52YWx1ZSA9IG1hdGVyaWFsLmRhc2hTaXplICsgbWF0ZXJpYWwuZ2FwU2l6ZTtcblx0XHRcdHVuaWZvcm1zLnNjYWxlLnZhbHVlID0gbWF0ZXJpYWwuc2NhbGU7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNQYXJ0aWNsZSAoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcblxuXHRcdFx0dW5pZm9ybXMucHNDb2xvci52YWx1ZSA9IG1hdGVyaWFsLmNvbG9yO1xuXHRcdFx0dW5pZm9ybXMub3BhY2l0eS52YWx1ZSA9IG1hdGVyaWFsLm9wYWNpdHk7XG5cdFx0XHR1bmlmb3Jtcy5zaXplLnZhbHVlID0gbWF0ZXJpYWwuc2l6ZTtcblx0XHRcdHVuaWZvcm1zLnNjYWxlLnZhbHVlID0gX2NhbnZhcy5oZWlnaHQgLyAyLjA7IC8vIFRPRE86IENhY2hlIHRoaXMuXG5cblx0XHRcdHVuaWZvcm1zLm1hcC52YWx1ZSA9IG1hdGVyaWFsLm1hcDtcblxuXHRcdFx0aWYgKCBtYXRlcmlhbC5tYXAgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0dmFyIG9mZnNldCA9IG1hdGVyaWFsLm1hcC5vZmZzZXQ7XG5cdFx0XHRcdHZhciByZXBlYXQgPSBtYXRlcmlhbC5tYXAucmVwZWF0O1xuXG5cdFx0XHRcdHVuaWZvcm1zLm9mZnNldFJlcGVhdC52YWx1ZS5zZXQoIG9mZnNldC54LCBvZmZzZXQueSwgcmVwZWF0LngsIHJlcGVhdC55ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0ZvZyAoIHVuaWZvcm1zLCBmb2cgKSB7XG5cblx0XHRcdHVuaWZvcm1zLmZvZ0NvbG9yLnZhbHVlID0gZm9nLmNvbG9yO1xuXG5cdFx0XHRpZiAoIGZvZyBpbnN0YW5jZW9mIFRIUkVFLkZvZyApIHtcblxuXHRcdFx0XHR1bmlmb3Jtcy5mb2dOZWFyLnZhbHVlID0gZm9nLm5lYXI7XG5cdFx0XHRcdHVuaWZvcm1zLmZvZ0Zhci52YWx1ZSA9IGZvZy5mYXI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGZvZyBpbnN0YW5jZW9mIFRIUkVFLkZvZ0V4cDIgKSB7XG5cblx0XHRcdFx0dW5pZm9ybXMuZm9nRGVuc2l0eS52YWx1ZSA9IGZvZy5kZW5zaXR5O1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNQaG9uZyAoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcblxuXHRcdFx0dW5pZm9ybXMuc3BlY3VsYXIudmFsdWUgPSBtYXRlcmlhbC5zcGVjdWxhcjtcblx0XHRcdHVuaWZvcm1zLnNoaW5pbmVzcy52YWx1ZSA9IE1hdGgubWF4KCBtYXRlcmlhbC5zaGluaW5lc3MsIDFlLTQgKTsgLy8gdG8gcHJldmVudCBwb3coIDAuMCwgMC4wIClcblxuXHRcdFx0aWYgKCBtYXRlcmlhbC5saWdodE1hcCApIHtcblxuXHRcdFx0XHR1bmlmb3Jtcy5saWdodE1hcC52YWx1ZSA9IG1hdGVyaWFsLmxpZ2h0TWFwO1xuXHRcdFx0XHR1bmlmb3Jtcy5saWdodE1hcEludGVuc2l0eS52YWx1ZSA9IG1hdGVyaWFsLmxpZ2h0TWFwSW50ZW5zaXR5O1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbWF0ZXJpYWwuZW1pc3NpdmVNYXAgKSB7XG5cblx0XHRcdFx0dW5pZm9ybXMuZW1pc3NpdmVNYXAudmFsdWUgPSBtYXRlcmlhbC5lbWlzc2l2ZU1hcDtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG1hdGVyaWFsLmJ1bXBNYXAgKSB7XG5cblx0XHRcdFx0dW5pZm9ybXMuYnVtcE1hcC52YWx1ZSA9IG1hdGVyaWFsLmJ1bXBNYXA7XG5cdFx0XHRcdHVuaWZvcm1zLmJ1bXBTY2FsZS52YWx1ZSA9IG1hdGVyaWFsLmJ1bXBTY2FsZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG1hdGVyaWFsLm5vcm1hbE1hcCApIHtcblxuXHRcdFx0XHR1bmlmb3Jtcy5ub3JtYWxNYXAudmFsdWUgPSBtYXRlcmlhbC5ub3JtYWxNYXA7XG5cdFx0XHRcdHVuaWZvcm1zLm5vcm1hbFNjYWxlLnZhbHVlLmNvcHkoIG1hdGVyaWFsLm5vcm1hbFNjYWxlICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXAgKSB7XG5cblx0XHRcdFx0dW5pZm9ybXMuZGlzcGxhY2VtZW50TWFwLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwO1xuXHRcdFx0XHR1bmlmb3Jtcy5kaXNwbGFjZW1lbnRTY2FsZS52YWx1ZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudFNjYWxlO1xuXHRcdFx0XHR1bmlmb3Jtcy5kaXNwbGFjZW1lbnRCaWFzLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50QmlhcztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zTGlnaHRzICggdW5pZm9ybXMsIGxpZ2h0cyApIHtcblxuXHRcdFx0dW5pZm9ybXMuYW1iaWVudExpZ2h0Q29sb3IudmFsdWUgPSBsaWdodHMuYW1iaWVudDtcblxuXHRcdFx0dW5pZm9ybXMuZGlyZWN0aW9uYWxMaWdodENvbG9yLnZhbHVlID0gbGlnaHRzLmRpcmVjdGlvbmFsLmNvbG9ycztcblx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbmFsTGlnaHREaXJlY3Rpb24udmFsdWUgPSBsaWdodHMuZGlyZWN0aW9uYWwucG9zaXRpb25zO1xuXG5cdFx0XHR1bmlmb3Jtcy5wb2ludExpZ2h0Q29sb3IudmFsdWUgPSBsaWdodHMucG9pbnQuY29sb3JzO1xuXHRcdFx0dW5pZm9ybXMucG9pbnRMaWdodFBvc2l0aW9uLnZhbHVlID0gbGlnaHRzLnBvaW50LnBvc2l0aW9ucztcblx0XHRcdHVuaWZvcm1zLnBvaW50TGlnaHREaXN0YW5jZS52YWx1ZSA9IGxpZ2h0cy5wb2ludC5kaXN0YW5jZXM7XG5cdFx0XHR1bmlmb3Jtcy5wb2ludExpZ2h0RGVjYXkudmFsdWUgPSBsaWdodHMucG9pbnQuZGVjYXlzO1xuXG5cdFx0XHR1bmlmb3Jtcy5zcG90TGlnaHRDb2xvci52YWx1ZSA9IGxpZ2h0cy5zcG90LmNvbG9ycztcblx0XHRcdHVuaWZvcm1zLnNwb3RMaWdodFBvc2l0aW9uLnZhbHVlID0gbGlnaHRzLnNwb3QucG9zaXRpb25zO1xuXHRcdFx0dW5pZm9ybXMuc3BvdExpZ2h0RGlzdGFuY2UudmFsdWUgPSBsaWdodHMuc3BvdC5kaXN0YW5jZXM7XG5cdFx0XHR1bmlmb3Jtcy5zcG90TGlnaHREaXJlY3Rpb24udmFsdWUgPSBsaWdodHMuc3BvdC5kaXJlY3Rpb25zO1xuXHRcdFx0dW5pZm9ybXMuc3BvdExpZ2h0QW5nbGVDb3MudmFsdWUgPSBsaWdodHMuc3BvdC5hbmdsZXNDb3M7XG5cdFx0XHR1bmlmb3Jtcy5zcG90TGlnaHRFeHBvbmVudC52YWx1ZSA9IGxpZ2h0cy5zcG90LmV4cG9uZW50cztcblx0XHRcdHVuaWZvcm1zLnNwb3RMaWdodERlY2F5LnZhbHVlID0gbGlnaHRzLnNwb3QuZGVjYXlzO1xuXG5cdFx0XHR1bmlmb3Jtcy5oZW1pc3BoZXJlTGlnaHRTa3lDb2xvci52YWx1ZSA9IGxpZ2h0cy5oZW1pLnNreUNvbG9ycztcblx0XHRcdHVuaWZvcm1zLmhlbWlzcGhlcmVMaWdodEdyb3VuZENvbG9yLnZhbHVlID0gbGlnaHRzLmhlbWkuZ3JvdW5kQ29sb3JzO1xuXHRcdFx0dW5pZm9ybXMuaGVtaXNwaGVyZUxpZ2h0RGlyZWN0aW9uLnZhbHVlID0gbGlnaHRzLmhlbWkucG9zaXRpb25zO1xuXG5cdFx0fVxuXG5cdFx0Ly8gSWYgdW5pZm9ybXMgYXJlIG1hcmtlZCBhcyBjbGVhbiwgdGhleSBkb24ndCBuZWVkIHRvIGJlIGxvYWRlZCB0byB0aGUgR1BVLlxuXG5cdFx0ZnVuY3Rpb24gbWFya1VuaWZvcm1zTGlnaHRzTmVlZHNVcGRhdGUgKCB1bmlmb3JtcywgdmFsdWUgKSB7XG5cblx0XHRcdHVuaWZvcm1zLmFtYmllbnRMaWdodENvbG9yLm5lZWRzVXBkYXRlID0gdmFsdWU7XG5cblx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbmFsTGlnaHRDb2xvci5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuXHRcdFx0dW5pZm9ybXMuZGlyZWN0aW9uYWxMaWdodERpcmVjdGlvbi5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuXG5cdFx0XHR1bmlmb3Jtcy5wb2ludExpZ2h0Q29sb3IubmVlZHNVcGRhdGUgPSB2YWx1ZTtcblx0XHRcdHVuaWZvcm1zLnBvaW50TGlnaHRQb3NpdGlvbi5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuXHRcdFx0dW5pZm9ybXMucG9pbnRMaWdodERpc3RhbmNlLm5lZWRzVXBkYXRlID0gdmFsdWU7XG5cdFx0XHR1bmlmb3Jtcy5wb2ludExpZ2h0RGVjYXkubmVlZHNVcGRhdGUgPSB2YWx1ZTtcblxuXHRcdFx0dW5pZm9ybXMuc3BvdExpZ2h0Q29sb3IubmVlZHNVcGRhdGUgPSB2YWx1ZTtcblx0XHRcdHVuaWZvcm1zLnNwb3RMaWdodFBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdmFsdWU7XG5cdFx0XHR1bmlmb3Jtcy5zcG90TGlnaHREaXN0YW5jZS5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuXHRcdFx0dW5pZm9ybXMuc3BvdExpZ2h0RGlyZWN0aW9uLm5lZWRzVXBkYXRlID0gdmFsdWU7XG5cdFx0XHR1bmlmb3Jtcy5zcG90TGlnaHRBbmdsZUNvcy5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuXHRcdFx0dW5pZm9ybXMuc3BvdExpZ2h0RXhwb25lbnQubmVlZHNVcGRhdGUgPSB2YWx1ZTtcblx0XHRcdHVuaWZvcm1zLnNwb3RMaWdodERlY2F5Lm5lZWRzVXBkYXRlID0gdmFsdWU7XG5cblx0XHRcdHVuaWZvcm1zLmhlbWlzcGhlcmVMaWdodFNreUNvbG9yLm5lZWRzVXBkYXRlID0gdmFsdWU7XG5cdFx0XHR1bmlmb3Jtcy5oZW1pc3BoZXJlTGlnaHRHcm91bmRDb2xvci5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuXHRcdFx0dW5pZm9ybXMuaGVtaXNwaGVyZUxpZ2h0RGlyZWN0aW9uLm5lZWRzVXBkYXRlID0gdmFsdWU7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNTaGFkb3cgKCB1bmlmb3JtcywgbGlnaHRzLCBjYW1lcmEgKSB7XG5cblx0XHRcdGlmICggdW5pZm9ybXMuc2hhZG93TWF0cml4ICkge1xuXG5cdFx0XHRcdHZhciBqID0gMDtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gbGlnaHRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIGxpZ2h0ID0gbGlnaHRzWyBpIF07XG5cblx0XHRcdFx0XHRpZiAoIGxpZ2h0LmNhc3RTaGFkb3cgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5Qb2ludExpZ2h0IHx8IGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuU3BvdExpZ2h0IHx8IGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuRGlyZWN0aW9uYWxMaWdodCApIHtcblxuXHRcdFx0XHRcdFx0XHR2YXIgc2hhZG93ID0gbGlnaHQuc2hhZG93O1xuXG5cdFx0XHRcdFx0XHRcdGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5Qb2ludExpZ2h0ICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gZm9yIHBvaW50IGxpZ2h0cyB3ZSBzZXQgdGhlIHNoYWRvdyBtYXRyaXggdG8gYmUgYSB0cmFuc2xhdGlvbi1vbmx5IG1hdHJpeFxuXHRcdFx0XHRcdFx0XHRcdC8vIGVxdWFsIHRvIGludmVyc2Ugb2YgdGhlIGxpZ2h0J3MgcG9zaXRpb25cblx0XHRcdFx0XHRcdFx0XHRfdmVjdG9yMy5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0Lm1hdHJpeFdvcmxkICkubmVnYXRlKCk7XG5cdFx0XHRcdFx0XHRcdFx0c2hhZG93Lm1hdHJpeC5pZGVudGl0eSgpLnNldFBvc2l0aW9uKCBfdmVjdG9yMyApO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gZm9yIHBvaW50IGxpZ2h0cyB3ZSBzZXQgdGhlIHNpZ24gb2YgdGhlIHNoYWRvd0RhcmtuZXNzIHVuaWZvcm0gdG8gYmUgbmVnYXRpdmVcblx0XHRcdFx0XHRcdFx0XHR1bmlmb3Jtcy5zaGFkb3dEYXJrbmVzcy52YWx1ZVsgaiBdID0gLSBzaGFkb3cuZGFya25lc3M7XG5cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdHVuaWZvcm1zLnNoYWRvd0RhcmtuZXNzLnZhbHVlWyBqIF0gPSBzaGFkb3cuZGFya25lc3M7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdHVuaWZvcm1zLnNoYWRvd01hdHJpeC52YWx1ZVsgaiBdID0gc2hhZG93Lm1hdHJpeDtcblx0XHRcdFx0XHRcdFx0dW5pZm9ybXMuc2hhZG93TWFwLnZhbHVlWyBqIF0gPSBzaGFkb3cubWFwO1xuXHRcdFx0XHRcdFx0XHR1bmlmb3Jtcy5zaGFkb3dNYXBTaXplLnZhbHVlWyBqIF0gPSBzaGFkb3cubWFwU2l6ZTtcblx0XHRcdFx0XHRcdFx0dW5pZm9ybXMuc2hhZG93Qmlhcy52YWx1ZVsgaiBdID0gc2hhZG93LmJpYXM7XG5cblx0XHRcdFx0XHRcdFx0aiArKztcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gVW5pZm9ybXMgKGxvYWQgdG8gR1BVKVxuXG5cdFx0ZnVuY3Rpb24gbG9hZFVuaWZvcm1zTWF0cmljZXMgKCB1bmlmb3Jtcywgb2JqZWN0ICkge1xuXG5cdFx0XHRfZ2wudW5pZm9ybU1hdHJpeDRmdiggdW5pZm9ybXMubW9kZWxWaWV3TWF0cml4LCBmYWxzZSwgb2JqZWN0Lm1vZGVsVmlld01hdHJpeC5lbGVtZW50cyApO1xuXG5cdFx0XHRpZiAoIHVuaWZvcm1zLm5vcm1hbE1hdHJpeCApIHtcblxuXHRcdFx0XHRfZ2wudW5pZm9ybU1hdHJpeDNmdiggdW5pZm9ybXMubm9ybWFsTWF0cml4LCBmYWxzZSwgb2JqZWN0Lm5vcm1hbE1hdHJpeC5lbGVtZW50cyApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRUZXh0dXJlVW5pdCgpIHtcblxuXHRcdFx0dmFyIHRleHR1cmVVbml0ID0gX3VzZWRUZXh0dXJlVW5pdHM7XG5cblx0XHRcdGlmICggdGV4dHVyZVVuaXQgPj0gY2FwYWJpbGl0aWVzLm1heFRleHR1cmVzICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1dlYkdMUmVuZGVyZXI6IHRyeWluZyB0byB1c2UgJyArIHRleHR1cmVVbml0ICsgJyB0ZXh0dXJlIHVuaXRzIHdoaWxlIHRoaXMgR1BVIHN1cHBvcnRzIG9ubHkgJyArIGNhcGFiaWxpdGllcy5tYXhUZXh0dXJlcyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdF91c2VkVGV4dHVyZVVuaXRzICs9IDE7XG5cblx0XHRcdHJldHVybiB0ZXh0dXJlVW5pdDtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGxvYWRVbmlmb3Jtc0dlbmVyaWMgKCB1bmlmb3JtcyApIHtcblxuXHRcdFx0dmFyIHRleHR1cmUsIHRleHR1cmVVbml0O1xuXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gdW5pZm9ybXMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cblx0XHRcdFx0dmFyIHVuaWZvcm0gPSB1bmlmb3Jtc1sgaiBdWyAwIF07XG5cblx0XHRcdFx0Ly8gbmVlZHNVcGRhdGUgcHJvcGVydHkgaXMgbm90IGFkZGVkIHRvIGFsbCB1bmlmb3Jtcy5cblx0XHRcdFx0aWYgKCB1bmlmb3JtLm5lZWRzVXBkYXRlID09PSBmYWxzZSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdHZhciB0eXBlID0gdW5pZm9ybS50eXBlO1xuXHRcdFx0XHR2YXIgdmFsdWUgPSB1bmlmb3JtLnZhbHVlO1xuXHRcdFx0XHR2YXIgbG9jYXRpb24gPSB1bmlmb3Jtc1sgaiBdWyAxIF07XG5cblx0XHRcdFx0c3dpdGNoICggdHlwZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJzFpJzpcblx0XHRcdFx0XHRcdF9nbC51bmlmb3JtMWkoIGxvY2F0aW9uLCB2YWx1ZSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICcxZic6XG5cdFx0XHRcdFx0XHRfZ2wudW5pZm9ybTFmKCBsb2NhdGlvbiwgdmFsdWUgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnMmYnOlxuXHRcdFx0XHRcdFx0X2dsLnVuaWZvcm0yZiggbG9jYXRpb24sIHZhbHVlWyAwIF0sIHZhbHVlWyAxIF0gKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnM2YnOlxuXHRcdFx0XHRcdFx0X2dsLnVuaWZvcm0zZiggbG9jYXRpb24sIHZhbHVlWyAwIF0sIHZhbHVlWyAxIF0sIHZhbHVlWyAyIF0gKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnNGYnOlxuXHRcdFx0XHRcdFx0X2dsLnVuaWZvcm00ZiggbG9jYXRpb24sIHZhbHVlWyAwIF0sIHZhbHVlWyAxIF0sIHZhbHVlWyAyIF0sIHZhbHVlWyAzIF0gKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnMWl2Jzpcblx0XHRcdFx0XHRcdF9nbC51bmlmb3JtMWl2KCBsb2NhdGlvbiwgdmFsdWUgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnM2l2Jzpcblx0XHRcdFx0XHRcdF9nbC51bmlmb3JtM2l2KCBsb2NhdGlvbiwgdmFsdWUgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnMWZ2Jzpcblx0XHRcdFx0XHRcdF9nbC51bmlmb3JtMWZ2KCBsb2NhdGlvbiwgdmFsdWUgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnMmZ2Jzpcblx0XHRcdFx0XHRcdF9nbC51bmlmb3JtMmZ2KCBsb2NhdGlvbiwgdmFsdWUgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnM2Z2Jzpcblx0XHRcdFx0XHRcdF9nbC51bmlmb3JtM2Z2KCBsb2NhdGlvbiwgdmFsdWUgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnNGZ2Jzpcblx0XHRcdFx0XHRcdF9nbC51bmlmb3JtNGZ2KCBsb2NhdGlvbiwgdmFsdWUgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnTWF0cml4M2Z2Jzpcblx0XHRcdFx0XHRcdF9nbC51bmlmb3JtTWF0cml4M2Z2KCBsb2NhdGlvbiwgZmFsc2UsIHZhbHVlICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ01hdHJpeDRmdic6XG5cdFx0XHRcdFx0XHRfZ2wudW5pZm9ybU1hdHJpeDRmdiggbG9jYXRpb24sIGZhbHNlLCB2YWx1ZSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHQvL1xuXG5cdFx0XHRcdFx0Y2FzZSAnaSc6XG5cblx0XHRcdFx0XHRcdC8vIHNpbmdsZSBpbnRlZ2VyXG5cdFx0XHRcdFx0XHRfZ2wudW5pZm9ybTFpKCBsb2NhdGlvbiwgdmFsdWUgKTtcblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdmJzpcblxuXHRcdFx0XHRcdFx0Ly8gc2luZ2xlIGZsb2F0XG5cdFx0XHRcdFx0XHRfZ2wudW5pZm9ybTFmKCBsb2NhdGlvbiwgdmFsdWUgKTtcblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICd2Mic6XG5cblx0XHRcdFx0XHRcdC8vIHNpbmdsZSBUSFJFRS5WZWN0b3IyXG5cdFx0XHRcdFx0XHRfZ2wudW5pZm9ybTJmKCBsb2NhdGlvbiwgdmFsdWUueCwgdmFsdWUueSApO1xuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ3YzJzpcblxuXHRcdFx0XHRcdFx0Ly8gc2luZ2xlIFRIUkVFLlZlY3RvcjNcblx0XHRcdFx0XHRcdF9nbC51bmlmb3JtM2YoIGxvY2F0aW9uLCB2YWx1ZS54LCB2YWx1ZS55LCB2YWx1ZS56ICk7XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAndjQnOlxuXG5cdFx0XHRcdFx0XHQvLyBzaW5nbGUgVEhSRUUuVmVjdG9yNFxuXHRcdFx0XHRcdFx0X2dsLnVuaWZvcm00ZiggbG9jYXRpb24sIHZhbHVlLngsIHZhbHVlLnksIHZhbHVlLnosIHZhbHVlLncgKTtcblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdjJzpcblxuXHRcdFx0XHRcdFx0Ly8gc2luZ2xlIFRIUkVFLkNvbG9yXG5cdFx0XHRcdFx0XHRfZ2wudW5pZm9ybTNmKCBsb2NhdGlvbiwgdmFsdWUuciwgdmFsdWUuZywgdmFsdWUuYiApO1xuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ2l2MSc6XG5cblx0XHRcdFx0XHRcdC8vIGZsYXQgYXJyYXkgb2YgaW50ZWdlcnMgKEpTIG9yIHR5cGVkIGFycmF5KVxuXHRcdFx0XHRcdFx0X2dsLnVuaWZvcm0xaXYoIGxvY2F0aW9uLCB2YWx1ZSApO1xuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ2l2JzpcblxuXHRcdFx0XHRcdFx0Ly8gZmxhdCBhcnJheSBvZiBpbnRlZ2VycyB3aXRoIDMgeCBOIHNpemUgKEpTIG9yIHR5cGVkIGFycmF5KVxuXHRcdFx0XHRcdFx0X2dsLnVuaWZvcm0zaXYoIGxvY2F0aW9uLCB2YWx1ZSApO1xuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ2Z2MSc6XG5cblx0XHRcdFx0XHRcdC8vIGZsYXQgYXJyYXkgb2YgZmxvYXRzIChKUyBvciB0eXBlZCBhcnJheSlcblx0XHRcdFx0XHRcdF9nbC51bmlmb3JtMWZ2KCBsb2NhdGlvbiwgdmFsdWUgKTtcblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdmdic6XG5cblx0XHRcdFx0XHRcdC8vIGZsYXQgYXJyYXkgb2YgZmxvYXRzIHdpdGggMyB4IE4gc2l6ZSAoSlMgb3IgdHlwZWQgYXJyYXkpXG5cdFx0XHRcdFx0XHRfZ2wudW5pZm9ybTNmdiggbG9jYXRpb24sIHZhbHVlICk7XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAndjJ2JzpcblxuXHRcdFx0XHRcdFx0Ly8gYXJyYXkgb2YgVEhSRUUuVmVjdG9yMlxuXG5cdFx0XHRcdFx0XHRpZiAoIHVuaWZvcm0uX2FycmF5ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0dW5pZm9ybS5fYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCAyICogdmFsdWUubGVuZ3RoICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpMiA9IDAsIGlsID0gdmFsdWUubGVuZ3RoOyBpIDwgaWw7IGkgKyssIGkyICs9IDIgKSB7XG5cblx0XHRcdFx0XHRcdFx0dW5pZm9ybS5fYXJyYXlbIGkyICsgMCBdID0gdmFsdWVbIGkgXS54O1xuXHRcdFx0XHRcdFx0XHR1bmlmb3JtLl9hcnJheVsgaTIgKyAxIF0gPSB2YWx1ZVsgaSBdLnk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0X2dsLnVuaWZvcm0yZnYoIGxvY2F0aW9uLCB1bmlmb3JtLl9hcnJheSApO1xuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ3Yzdic6XG5cblx0XHRcdFx0XHRcdC8vIGFycmF5IG9mIFRIUkVFLlZlY3RvcjNcblxuXHRcdFx0XHRcdFx0aWYgKCB1bmlmb3JtLl9hcnJheSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRcdHVuaWZvcm0uX2FycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggMyAqIHZhbHVlLmxlbmd0aCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaTMgPSAwLCBpbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGlsOyBpICsrLCBpMyArPSAzICkge1xuXG5cdFx0XHRcdFx0XHRcdHVuaWZvcm0uX2FycmF5WyBpMyArIDAgXSA9IHZhbHVlWyBpIF0ueDtcblx0XHRcdFx0XHRcdFx0dW5pZm9ybS5fYXJyYXlbIGkzICsgMSBdID0gdmFsdWVbIGkgXS55O1xuXHRcdFx0XHRcdFx0XHR1bmlmb3JtLl9hcnJheVsgaTMgKyAyIF0gPSB2YWx1ZVsgaSBdLno7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0X2dsLnVuaWZvcm0zZnYoIGxvY2F0aW9uLCB1bmlmb3JtLl9hcnJheSApO1xuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ3Y0dic6XG5cblx0XHRcdFx0XHRcdC8vIGFycmF5IG9mIFRIUkVFLlZlY3RvcjRcblxuXHRcdFx0XHRcdFx0aWYgKCB1bmlmb3JtLl9hcnJheSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRcdHVuaWZvcm0uX2FycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggNCAqIHZhbHVlLmxlbmd0aCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaTQgPSAwLCBpbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGlsOyBpICsrLCBpNCArPSA0ICkge1xuXG5cdFx0XHRcdFx0XHRcdHVuaWZvcm0uX2FycmF5WyBpNCArIDAgXSA9IHZhbHVlWyBpIF0ueDtcblx0XHRcdFx0XHRcdFx0dW5pZm9ybS5fYXJyYXlbIGk0ICsgMSBdID0gdmFsdWVbIGkgXS55O1xuXHRcdFx0XHRcdFx0XHR1bmlmb3JtLl9hcnJheVsgaTQgKyAyIF0gPSB2YWx1ZVsgaSBdLno7XG5cdFx0XHRcdFx0XHRcdHVuaWZvcm0uX2FycmF5WyBpNCArIDMgXSA9IHZhbHVlWyBpIF0udztcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRfZ2wudW5pZm9ybTRmdiggbG9jYXRpb24sIHVuaWZvcm0uX2FycmF5ICk7XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnbTMnOlxuXG5cdFx0XHRcdFx0XHQvLyBzaW5nbGUgVEhSRUUuTWF0cml4M1xuXHRcdFx0XHRcdFx0X2dsLnVuaWZvcm1NYXRyaXgzZnYoIGxvY2F0aW9uLCBmYWxzZSwgdmFsdWUuZWxlbWVudHMgKTtcblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdtM3YnOlxuXG5cdFx0XHRcdFx0XHQvLyBhcnJheSBvZiBUSFJFRS5NYXRyaXgzXG5cblx0XHRcdFx0XHRcdGlmICggdW5pZm9ybS5fYXJyYXkgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0XHR1bmlmb3JtLl9hcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIDkgKiB2YWx1ZS5sZW5ndGggKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdmFsdWUubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0dmFsdWVbIGkgXS5mbGF0dGVuVG9BcnJheU9mZnNldCggdW5pZm9ybS5fYXJyYXksIGkgKiA5ICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0X2dsLnVuaWZvcm1NYXRyaXgzZnYoIGxvY2F0aW9uLCBmYWxzZSwgdW5pZm9ybS5fYXJyYXkgKTtcblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdtNCc6XG5cblx0XHRcdFx0XHRcdC8vIHNpbmdsZSBUSFJFRS5NYXRyaXg0XG5cdFx0XHRcdFx0XHRfZ2wudW5pZm9ybU1hdHJpeDRmdiggbG9jYXRpb24sIGZhbHNlLCB2YWx1ZS5lbGVtZW50cyApO1xuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ200dic6XG5cblx0XHRcdFx0XHRcdC8vIGFycmF5IG9mIFRIUkVFLk1hdHJpeDRcblxuXHRcdFx0XHRcdFx0aWYgKCB1bmlmb3JtLl9hcnJheSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRcdHVuaWZvcm0uX2FycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggMTYgKiB2YWx1ZS5sZW5ndGggKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdmFsdWUubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0dmFsdWVbIGkgXS5mbGF0dGVuVG9BcnJheU9mZnNldCggdW5pZm9ybS5fYXJyYXksIGkgKiAxNiApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdF9nbC51bmlmb3JtTWF0cml4NGZ2KCBsb2NhdGlvbiwgZmFsc2UsIHVuaWZvcm0uX2FycmF5ICk7XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAndCc6XG5cblx0XHRcdFx0XHRcdC8vIHNpbmdsZSBUSFJFRS5UZXh0dXJlICgyZCBvciBjdWJlKVxuXG5cdFx0XHRcdFx0XHR0ZXh0dXJlID0gdmFsdWU7XG5cdFx0XHRcdFx0XHR0ZXh0dXJlVW5pdCA9IGdldFRleHR1cmVVbml0KCk7XG5cblx0XHRcdFx0XHRcdF9nbC51bmlmb3JtMWkoIGxvY2F0aW9uLCB0ZXh0dXJlVW5pdCApO1xuXG5cdFx0XHRcdFx0XHRpZiAoICEgdGV4dHVyZSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdFx0XHRpZiAoIHRleHR1cmUgaW5zdGFuY2VvZiBUSFJFRS5DdWJlVGV4dHVyZSB8fFxuXHRcdFx0XHRcdFx0XHQgKCBBcnJheS5pc0FycmF5KCB0ZXh0dXJlLmltYWdlICkgJiYgdGV4dHVyZS5pbWFnZS5sZW5ndGggPT09IDYgKSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBDb21wcmVzc2VkVGV4dHVyZSBjYW4gaGF2ZSBBcnJheSBpbiBpbWFnZSA6L1xuXG5cdFx0XHRcdFx0XHRcdHNldEN1YmVUZXh0dXJlKCB0ZXh0dXJlLCB0ZXh0dXJlVW5pdCApO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0ZXh0dXJlIGluc3RhbmNlb2YgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlICkge1xuXG5cdFx0XHRcdFx0XHRcdHNldEN1YmVUZXh0dXJlRHluYW1pYyggdGV4dHVyZS50ZXh0dXJlLCB0ZXh0dXJlVW5pdCApO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0ZXh0dXJlIGluc3RhbmNlb2YgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQgKSB7XG5cblx0XHRcdFx0XHRcdFx0X3RoaXMuc2V0VGV4dHVyZSggdGV4dHVyZS50ZXh0dXJlLCB0ZXh0dXJlVW5pdCApO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdF90aGlzLnNldFRleHR1cmUoIHRleHR1cmUsIHRleHR1cmVVbml0ICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICd0dic6XG5cblx0XHRcdFx0XHRcdC8vIGFycmF5IG9mIFRIUkVFLlRleHR1cmUgKDJkIG9yIGN1YmUpXG5cblx0XHRcdFx0XHRcdGlmICggdW5pZm9ybS5fYXJyYXkgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0XHR1bmlmb3JtLl9hcnJheSA9IFtdO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSB1bmlmb3JtLnZhbHVlLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdHVuaWZvcm0uX2FycmF5WyBpIF0gPSBnZXRUZXh0dXJlVW5pdCgpO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdF9nbC51bmlmb3JtMWl2KCBsb2NhdGlvbiwgdW5pZm9ybS5fYXJyYXkgKTtcblxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHVuaWZvcm0udmFsdWUubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0dGV4dHVyZSA9IHVuaWZvcm0udmFsdWVbIGkgXTtcblx0XHRcdFx0XHRcdFx0dGV4dHVyZVVuaXQgPSB1bmlmb3JtLl9hcnJheVsgaSBdO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggISB0ZXh0dXJlICkgY29udGludWU7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCB0ZXh0dXJlIGluc3RhbmNlb2YgVEhSRUUuQ3ViZVRleHR1cmUgfHxcblx0XHRcdFx0XHRcdFx0XHQgKCB0ZXh0dXJlLmltYWdlIGluc3RhbmNlb2YgQXJyYXkgJiYgdGV4dHVyZS5pbWFnZS5sZW5ndGggPT09IDYgKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIENvbXByZXNzZWRUZXh0dXJlIGNhbiBoYXZlIEFycmF5IGluIGltYWdlIDovXG5cblx0XHRcdFx0XHRcdFx0XHRzZXRDdWJlVGV4dHVyZSggdGV4dHVyZSwgdGV4dHVyZVVuaXQgKTtcblxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0ZXh0dXJlIGluc3RhbmNlb2YgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRfdGhpcy5zZXRUZXh0dXJlKCB0ZXh0dXJlLnRleHR1cmUsIHRleHR1cmVVbml0ICk7XG5cblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggdGV4dHVyZSBpbnN0YW5jZW9mIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdHNldEN1YmVUZXh0dXJlRHluYW1pYyggdGV4dHVyZS50ZXh0dXJlLCB0ZXh0dXJlVW5pdCApO1xuXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRfdGhpcy5zZXRUZXh0dXJlKCB0ZXh0dXJlLCB0ZXh0dXJlVW5pdCApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFVua25vd24gdW5pZm9ybSB0eXBlOiAnICsgdHlwZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gc2V0Q29sb3JMaW5lYXIoIGFycmF5LCBvZmZzZXQsIGNvbG9yLCBpbnRlbnNpdHkgKSB7XG5cblx0XHRcdGFycmF5WyBvZmZzZXQgKyAwIF0gPSBjb2xvci5yICogaW50ZW5zaXR5O1xuXHRcdFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IGNvbG9yLmcgKiBpbnRlbnNpdHk7XG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsgMiBdID0gY29sb3IuYiAqIGludGVuc2l0eTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHNldHVwTGlnaHRzICggbGlnaHRzLCBjYW1lcmEgKSB7XG5cblx0XHRcdHZhciBsLCBsbCwgbGlnaHQsXG5cdFx0XHRyID0gMCwgZyA9IDAsIGIgPSAwLFxuXHRcdFx0Y29sb3IsIHNreUNvbG9yLCBncm91bmRDb2xvcixcblx0XHRcdGludGVuc2l0eSxcblx0XHRcdGRpc3RhbmNlLFxuXG5cdFx0XHR6bGlnaHRzID0gX2xpZ2h0cyxcblxuXHRcdFx0dmlld01hdHJpeCA9IGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UsXG5cblx0XHRcdGRpckNvbG9ycyA9IHpsaWdodHMuZGlyZWN0aW9uYWwuY29sb3JzLFxuXHRcdFx0ZGlyUG9zaXRpb25zID0gemxpZ2h0cy5kaXJlY3Rpb25hbC5wb3NpdGlvbnMsXG5cblx0XHRcdHBvaW50Q29sb3JzID0gemxpZ2h0cy5wb2ludC5jb2xvcnMsXG5cdFx0XHRwb2ludFBvc2l0aW9ucyA9IHpsaWdodHMucG9pbnQucG9zaXRpb25zLFxuXHRcdFx0cG9pbnREaXN0YW5jZXMgPSB6bGlnaHRzLnBvaW50LmRpc3RhbmNlcyxcblx0XHRcdHBvaW50RGVjYXlzID0gemxpZ2h0cy5wb2ludC5kZWNheXMsXG5cblx0XHRcdHNwb3RDb2xvcnMgPSB6bGlnaHRzLnNwb3QuY29sb3JzLFxuXHRcdFx0c3BvdFBvc2l0aW9ucyA9IHpsaWdodHMuc3BvdC5wb3NpdGlvbnMsXG5cdFx0XHRzcG90RGlzdGFuY2VzID0gemxpZ2h0cy5zcG90LmRpc3RhbmNlcyxcblx0XHRcdHNwb3REaXJlY3Rpb25zID0gemxpZ2h0cy5zcG90LmRpcmVjdGlvbnMsXG5cdFx0XHRzcG90QW5nbGVzQ29zID0gemxpZ2h0cy5zcG90LmFuZ2xlc0Nvcyxcblx0XHRcdHNwb3RFeHBvbmVudHMgPSB6bGlnaHRzLnNwb3QuZXhwb25lbnRzLFxuXHRcdFx0c3BvdERlY2F5cyA9IHpsaWdodHMuc3BvdC5kZWNheXMsXG5cblx0XHRcdGhlbWlTa3lDb2xvcnMgPSB6bGlnaHRzLmhlbWkuc2t5Q29sb3JzLFxuXHRcdFx0aGVtaUdyb3VuZENvbG9ycyA9IHpsaWdodHMuaGVtaS5ncm91bmRDb2xvcnMsXG5cdFx0XHRoZW1pUG9zaXRpb25zID0gemxpZ2h0cy5oZW1pLnBvc2l0aW9ucyxcblxuXHRcdFx0ZGlyTGVuZ3RoID0gMCxcblx0XHRcdHBvaW50TGVuZ3RoID0gMCxcblx0XHRcdHNwb3RMZW5ndGggPSAwLFxuXHRcdFx0aGVtaUxlbmd0aCA9IDAsXG5cblx0XHRcdGRpckNvdW50ID0gMCxcblx0XHRcdHBvaW50Q291bnQgPSAwLFxuXHRcdFx0c3BvdENvdW50ID0gMCxcblx0XHRcdGhlbWlDb3VudCA9IDAsXG5cblx0XHRcdGRpck9mZnNldCA9IDAsXG5cdFx0XHRwb2ludE9mZnNldCA9IDAsXG5cdFx0XHRzcG90T2Zmc2V0ID0gMCxcblx0XHRcdGhlbWlPZmZzZXQgPSAwO1xuXG5cdFx0XHRmb3IgKCBsID0gMCwgbGwgPSBsaWdodHMubGVuZ3RoOyBsIDwgbGw7IGwgKysgKSB7XG5cblx0XHRcdFx0bGlnaHQgPSBsaWdodHNbIGwgXTtcblxuXHRcdFx0XHRjb2xvciA9IGxpZ2h0LmNvbG9yO1xuXHRcdFx0XHRpbnRlbnNpdHkgPSBsaWdodC5pbnRlbnNpdHk7XG5cdFx0XHRcdGRpc3RhbmNlID0gbGlnaHQuZGlzdGFuY2U7XG5cblx0XHRcdFx0aWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLkFtYmllbnRMaWdodCApIHtcblxuXHRcdFx0XHRcdGlmICggISBsaWdodC52aXNpYmxlICkgY29udGludWU7XG5cblx0XHRcdFx0XHRyICs9IGNvbG9yLnI7XG5cdFx0XHRcdFx0ZyArPSBjb2xvci5nO1xuXHRcdFx0XHRcdGIgKz0gY29sb3IuYjtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQgKSB7XG5cblx0XHRcdFx0XHRkaXJDb3VudCArPSAxO1xuXG5cdFx0XHRcdFx0aWYgKCAhIGxpZ2h0LnZpc2libGUgKSBjb250aW51ZTtcblxuXHRcdFx0XHRcdF9kaXJlY3Rpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC5tYXRyaXhXb3JsZCApO1xuXHRcdFx0XHRcdF92ZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkICk7XG5cdFx0XHRcdFx0X2RpcmVjdGlvbi5zdWIoIF92ZWN0b3IzICk7XG5cdFx0XHRcdFx0X2RpcmVjdGlvbi50cmFuc2Zvcm1EaXJlY3Rpb24oIHZpZXdNYXRyaXggKTtcblxuXHRcdFx0XHRcdGRpck9mZnNldCA9IGRpckxlbmd0aCAqIDM7XG5cblx0XHRcdFx0XHRkaXJQb3NpdGlvbnNbIGRpck9mZnNldCArIDAgXSA9IF9kaXJlY3Rpb24ueDtcblx0XHRcdFx0XHRkaXJQb3NpdGlvbnNbIGRpck9mZnNldCArIDEgXSA9IF9kaXJlY3Rpb24ueTtcblx0XHRcdFx0XHRkaXJQb3NpdGlvbnNbIGRpck9mZnNldCArIDIgXSA9IF9kaXJlY3Rpb24uejtcblxuXHRcdFx0XHRcdHNldENvbG9yTGluZWFyKCBkaXJDb2xvcnMsIGRpck9mZnNldCwgY29sb3IsIGludGVuc2l0eSApO1xuXG5cdFx0XHRcdFx0ZGlyTGVuZ3RoICs9IDE7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5Qb2ludExpZ2h0ICkge1xuXG5cdFx0XHRcdFx0cG9pbnRDb3VudCArPSAxO1xuXG5cdFx0XHRcdFx0aWYgKCAhIGxpZ2h0LnZpc2libGUgKSBjb250aW51ZTtcblxuXHRcdFx0XHRcdHBvaW50T2Zmc2V0ID0gcG9pbnRMZW5ndGggKiAzO1xuXG5cdFx0XHRcdFx0c2V0Q29sb3JMaW5lYXIoIHBvaW50Q29sb3JzLCBwb2ludE9mZnNldCwgY29sb3IsIGludGVuc2l0eSApO1xuXG5cdFx0XHRcdFx0X3ZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC5tYXRyaXhXb3JsZCApO1xuXHRcdFx0XHRcdF92ZWN0b3IzLmFwcGx5TWF0cml4NCggdmlld01hdHJpeCApO1xuXG5cdFx0XHRcdFx0cG9pbnRQb3NpdGlvbnNbIHBvaW50T2Zmc2V0ICsgMCBdID0gX3ZlY3RvcjMueDtcblx0XHRcdFx0XHRwb2ludFBvc2l0aW9uc1sgcG9pbnRPZmZzZXQgKyAxIF0gPSBfdmVjdG9yMy55O1xuXHRcdFx0XHRcdHBvaW50UG9zaXRpb25zWyBwb2ludE9mZnNldCArIDIgXSA9IF92ZWN0b3IzLno7XG5cblx0XHRcdFx0XHQvLyBkaXN0YW5jZSBpcyAwIGlmIGRlY2F5IGlzIDAsIGJlY2F1c2UgdGhlcmUgaXMgbm8gYXR0ZW51YXRpb24gYXQgYWxsLlxuXHRcdFx0XHRcdHBvaW50RGlzdGFuY2VzWyBwb2ludExlbmd0aCBdID0gZGlzdGFuY2U7XG5cdFx0XHRcdFx0cG9pbnREZWNheXNbIHBvaW50TGVuZ3RoIF0gPSAoIGxpZ2h0LmRpc3RhbmNlID09PSAwICkgPyAwLjAgOiBsaWdodC5kZWNheTtcblxuXHRcdFx0XHRcdHBvaW50TGVuZ3RoICs9IDE7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5TcG90TGlnaHQgKSB7XG5cblx0XHRcdFx0XHRzcG90Q291bnQgKz0gMTtcblxuXHRcdFx0XHRcdGlmICggISBsaWdodC52aXNpYmxlICkgY29udGludWU7XG5cblx0XHRcdFx0XHRzcG90T2Zmc2V0ID0gc3BvdExlbmd0aCAqIDM7XG5cblx0XHRcdFx0XHRzZXRDb2xvckxpbmVhciggc3BvdENvbG9ycywgc3BvdE9mZnNldCwgY29sb3IsIGludGVuc2l0eSApO1xuXG5cdFx0XHRcdFx0X2RpcmVjdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0Lm1hdHJpeFdvcmxkICk7XG5cdFx0XHRcdFx0X3ZlY3RvcjMuY29weSggX2RpcmVjdGlvbiApLmFwcGx5TWF0cml4NCggdmlld01hdHJpeCApO1xuXG5cdFx0XHRcdFx0c3BvdFBvc2l0aW9uc1sgc3BvdE9mZnNldCArIDAgXSA9IF92ZWN0b3IzLng7XG5cdFx0XHRcdFx0c3BvdFBvc2l0aW9uc1sgc3BvdE9mZnNldCArIDEgXSA9IF92ZWN0b3IzLnk7XG5cdFx0XHRcdFx0c3BvdFBvc2l0aW9uc1sgc3BvdE9mZnNldCArIDIgXSA9IF92ZWN0b3IzLno7XG5cblx0XHRcdFx0XHRzcG90RGlzdGFuY2VzWyBzcG90TGVuZ3RoIF0gPSBkaXN0YW5jZTtcblxuXHRcdFx0XHRcdF92ZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkICk7XG5cdFx0XHRcdFx0X2RpcmVjdGlvbi5zdWIoIF92ZWN0b3IzICk7XG5cdFx0XHRcdFx0X2RpcmVjdGlvbi50cmFuc2Zvcm1EaXJlY3Rpb24oIHZpZXdNYXRyaXggKTtcblxuXHRcdFx0XHRcdHNwb3REaXJlY3Rpb25zWyBzcG90T2Zmc2V0ICsgMCBdID0gX2RpcmVjdGlvbi54O1xuXHRcdFx0XHRcdHNwb3REaXJlY3Rpb25zWyBzcG90T2Zmc2V0ICsgMSBdID0gX2RpcmVjdGlvbi55O1xuXHRcdFx0XHRcdHNwb3REaXJlY3Rpb25zWyBzcG90T2Zmc2V0ICsgMiBdID0gX2RpcmVjdGlvbi56O1xuXG5cdFx0XHRcdFx0c3BvdEFuZ2xlc0Nvc1sgc3BvdExlbmd0aCBdID0gTWF0aC5jb3MoIGxpZ2h0LmFuZ2xlICk7XG5cdFx0XHRcdFx0c3BvdEV4cG9uZW50c1sgc3BvdExlbmd0aCBdID0gbGlnaHQuZXhwb25lbnQ7XG5cdFx0XHRcdFx0c3BvdERlY2F5c1sgc3BvdExlbmd0aCBdID0gKCBsaWdodC5kaXN0YW5jZSA9PT0gMCApID8gMC4wIDogbGlnaHQuZGVjYXk7XG5cblx0XHRcdFx0XHRzcG90TGVuZ3RoICs9IDE7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5IZW1pc3BoZXJlTGlnaHQgKSB7XG5cblx0XHRcdFx0XHRoZW1pQ291bnQgKz0gMTtcblxuXHRcdFx0XHRcdGlmICggISBsaWdodC52aXNpYmxlICkgY29udGludWU7XG5cblx0XHRcdFx0XHRfZGlyZWN0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQubWF0cml4V29ybGQgKTtcblx0XHRcdFx0XHRfZGlyZWN0aW9uLnRyYW5zZm9ybURpcmVjdGlvbiggdmlld01hdHJpeCApO1xuXG5cdFx0XHRcdFx0aGVtaU9mZnNldCA9IGhlbWlMZW5ndGggKiAzO1xuXG5cdFx0XHRcdFx0aGVtaVBvc2l0aW9uc1sgaGVtaU9mZnNldCArIDAgXSA9IF9kaXJlY3Rpb24ueDtcblx0XHRcdFx0XHRoZW1pUG9zaXRpb25zWyBoZW1pT2Zmc2V0ICsgMSBdID0gX2RpcmVjdGlvbi55O1xuXHRcdFx0XHRcdGhlbWlQb3NpdGlvbnNbIGhlbWlPZmZzZXQgKyAyIF0gPSBfZGlyZWN0aW9uLno7XG5cblx0XHRcdFx0XHRza3lDb2xvciA9IGxpZ2h0LmNvbG9yO1xuXHRcdFx0XHRcdGdyb3VuZENvbG9yID0gbGlnaHQuZ3JvdW5kQ29sb3I7XG5cblx0XHRcdFx0XHRzZXRDb2xvckxpbmVhciggaGVtaVNreUNvbG9ycywgaGVtaU9mZnNldCwgc2t5Q29sb3IsIGludGVuc2l0eSApO1xuXHRcdFx0XHRcdHNldENvbG9yTGluZWFyKCBoZW1pR3JvdW5kQ29sb3JzLCBoZW1pT2Zmc2V0LCBncm91bmRDb2xvciwgaW50ZW5zaXR5ICk7XG5cblx0XHRcdFx0XHRoZW1pTGVuZ3RoICs9IDE7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIG51bGwgZXZlbnR1YWwgcmVtYWlucyBmcm9tIHJlbW92ZWQgbGlnaHRzXG5cdFx0XHQvLyAodGhpcyBpcyB0byBhdm9pZCBpZiBpbiBzaGFkZXIpXG5cblx0XHRcdGZvciAoIGwgPSBkaXJMZW5ndGggKiAzLCBsbCA9IE1hdGgubWF4KCBkaXJDb2xvcnMubGVuZ3RoLCBkaXJDb3VudCAqIDMgKTsgbCA8IGxsOyBsICsrICkgZGlyQ29sb3JzWyBsIF0gPSAwLjA7XG5cdFx0XHRmb3IgKCBsID0gcG9pbnRMZW5ndGggKiAzLCBsbCA9IE1hdGgubWF4KCBwb2ludENvbG9ycy5sZW5ndGgsIHBvaW50Q291bnQgKiAzICk7IGwgPCBsbDsgbCArKyApIHBvaW50Q29sb3JzWyBsIF0gPSAwLjA7XG5cdFx0XHRmb3IgKCBsID0gc3BvdExlbmd0aCAqIDMsIGxsID0gTWF0aC5tYXgoIHNwb3RDb2xvcnMubGVuZ3RoLCBzcG90Q291bnQgKiAzICk7IGwgPCBsbDsgbCArKyApIHNwb3RDb2xvcnNbIGwgXSA9IDAuMDtcblx0XHRcdGZvciAoIGwgPSBoZW1pTGVuZ3RoICogMywgbGwgPSBNYXRoLm1heCggaGVtaVNreUNvbG9ycy5sZW5ndGgsIGhlbWlDb3VudCAqIDMgKTsgbCA8IGxsOyBsICsrICkgaGVtaVNreUNvbG9yc1sgbCBdID0gMC4wO1xuXHRcdFx0Zm9yICggbCA9IGhlbWlMZW5ndGggKiAzLCBsbCA9IE1hdGgubWF4KCBoZW1pR3JvdW5kQ29sb3JzLmxlbmd0aCwgaGVtaUNvdW50ICogMyApOyBsIDwgbGw7IGwgKysgKSBoZW1pR3JvdW5kQ29sb3JzWyBsIF0gPSAwLjA7XG5cblx0XHRcdHpsaWdodHMuZGlyZWN0aW9uYWwubGVuZ3RoID0gZGlyTGVuZ3RoO1xuXHRcdFx0emxpZ2h0cy5wb2ludC5sZW5ndGggPSBwb2ludExlbmd0aDtcblx0XHRcdHpsaWdodHMuc3BvdC5sZW5ndGggPSBzcG90TGVuZ3RoO1xuXHRcdFx0emxpZ2h0cy5oZW1pLmxlbmd0aCA9IGhlbWlMZW5ndGg7XG5cblx0XHRcdHpsaWdodHMuYW1iaWVudFsgMCBdID0gcjtcblx0XHRcdHpsaWdodHMuYW1iaWVudFsgMSBdID0gZztcblx0XHRcdHpsaWdodHMuYW1iaWVudFsgMiBdID0gYjtcblxuXHRcdH1cblxuXHRcdC8vIEdMIHN0YXRlIHNldHRpbmdcblxuXHRcdHRoaXMuc2V0RmFjZUN1bGxpbmcgPSBmdW5jdGlvbiAoIGN1bGxGYWNlLCBmcm9udEZhY2VEaXJlY3Rpb24gKSB7XG5cblx0XHRcdGlmICggY3VsbEZhY2UgPT09IFRIUkVFLkN1bGxGYWNlTm9uZSApIHtcblxuXHRcdFx0XHRzdGF0ZS5kaXNhYmxlKCBfZ2wuQ1VMTF9GQUNFICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0aWYgKCBmcm9udEZhY2VEaXJlY3Rpb24gPT09IFRIUkVFLkZyb250RmFjZURpcmVjdGlvbkNXICkge1xuXG5cdFx0XHRcdFx0X2dsLmZyb250RmFjZSggX2dsLkNXICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdF9nbC5mcm9udEZhY2UoIF9nbC5DQ1cgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBjdWxsRmFjZSA9PT0gVEhSRUUuQ3VsbEZhY2VCYWNrICkge1xuXG5cdFx0XHRcdFx0X2dsLmN1bGxGYWNlKCBfZ2wuQkFDSyApO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGN1bGxGYWNlID09PSBUSFJFRS5DdWxsRmFjZUZyb250ICkge1xuXG5cdFx0XHRcdFx0X2dsLmN1bGxGYWNlKCBfZ2wuRlJPTlQgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0X2dsLmN1bGxGYWNlKCBfZ2wuRlJPTlRfQU5EX0JBQ0sgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0c3RhdGUuZW5hYmxlKCBfZ2wuQ1VMTF9GQUNFICk7XG5cblx0XHRcdH1cblxuXHRcdH07XG5cblx0XHQvLyBUZXh0dXJlc1xuXG5cdFx0ZnVuY3Rpb24gc2V0VGV4dHVyZVBhcmFtZXRlcnMgKCB0ZXh0dXJlVHlwZSwgdGV4dHVyZSwgaXNJbWFnZVBvd2VyT2ZUd28gKSB7XG5cblx0XHRcdHZhciBleHRlbnNpb247XG5cblx0XHRcdGlmICggaXNJbWFnZVBvd2VyT2ZUd28gKSB7XG5cblx0XHRcdFx0X2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9XUkFQX1MsIHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLndyYXBTICkgKTtcblx0XHRcdFx0X2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9XUkFQX1QsIHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLndyYXBUICkgKTtcblxuXHRcdFx0XHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX01BR19GSUxURVIsIHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLm1hZ0ZpbHRlciApICk7XG5cdFx0XHRcdF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgcGFyYW1UaHJlZVRvR0woIHRleHR1cmUubWluRmlsdGVyICkgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX1dSQVBfUywgX2dsLkNMQU1QX1RPX0VER0UgKTtcblx0XHRcdFx0X2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9XUkFQX1QsIF9nbC5DTEFNUF9UT19FREdFICk7XG5cblx0XHRcdFx0aWYgKCB0ZXh0dXJlLndyYXBTICE9PSBUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nIHx8IHRleHR1cmUud3JhcFQgIT09IFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmcgKSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBUZXh0dXJlIGlzIG5vdCBwb3dlciBvZiB0d28uIFRleHR1cmUud3JhcFMgYW5kIFRleHR1cmUud3JhcFQgc2hvdWxkIGJlIHNldCB0byBUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nLicsIHRleHR1cmUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0X2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBmaWx0ZXJGYWxsYmFjayggdGV4dHVyZS5tYWdGaWx0ZXIgKSApO1xuXHRcdFx0XHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX01JTl9GSUxURVIsIGZpbHRlckZhbGxiYWNrKCB0ZXh0dXJlLm1pbkZpbHRlciApICk7XG5cblx0XHRcdFx0aWYgKCB0ZXh0dXJlLm1pbkZpbHRlciAhPT0gVEhSRUUuTmVhcmVzdEZpbHRlciAmJiB0ZXh0dXJlLm1pbkZpbHRlciAhPT0gVEhSRUUuTGluZWFyRmlsdGVyICkge1xuXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogVGV4dHVyZSBpcyBub3QgcG93ZXIgb2YgdHdvLiBUZXh0dXJlLm1pbkZpbHRlciBzaG91bGQgYmUgc2V0IHRvIFRIUkVFLk5lYXJlc3RGaWx0ZXIgb3IgVEhSRUUuTGluZWFyRmlsdGVyLicsIHRleHR1cmUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0ZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnICk7XG5cblx0XHRcdGlmICggZXh0ZW5zaW9uICkge1xuXG5cdFx0XHRcdGlmICggdGV4dHVyZS50eXBlID09PSBUSFJFRS5GbG9hdFR5cGUgJiYgZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXInICkgPT09IG51bGwgKSByZXR1cm47XG5cdFx0XHRcdGlmICggdGV4dHVyZS50eXBlID09PSBUSFJFRS5IYWxmRmxvYXRUeXBlICYmIGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfaGFsZl9mbG9hdF9saW5lYXInICkgPT09IG51bGwgKSByZXR1cm47XG5cblx0XHRcdFx0aWYgKCB0ZXh0dXJlLmFuaXNvdHJvcHkgPiAxIHx8IHByb3BlcnRpZXMuZ2V0KCB0ZXh0dXJlICkuX19jdXJyZW50QW5pc290cm9weSApIHtcblxuXHRcdFx0XHRcdF9nbC50ZXhQYXJhbWV0ZXJmKCB0ZXh0dXJlVHlwZSwgZXh0ZW5zaW9uLlRFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhULCBNYXRoLm1pbiggdGV4dHVyZS5hbmlzb3Ryb3B5LCBfdGhpcy5nZXRNYXhBbmlzb3Ryb3B5KCkgKSApO1xuXHRcdFx0XHRcdHByb3BlcnRpZXMuZ2V0KCB0ZXh0dXJlICkuX19jdXJyZW50QW5pc290cm9weSA9IHRleHR1cmUuYW5pc290cm9weTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHVwbG9hZFRleHR1cmUoIHRleHR1cmVQcm9wZXJ0aWVzLCB0ZXh0dXJlLCBzbG90ICkge1xuXG5cdFx0XHRpZiAoIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xJbml0ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0dGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbEluaXQgPSB0cnVlO1xuXG5cdFx0XHRcdHRleHR1cmUuYWRkRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvblRleHR1cmVEaXNwb3NlICk7XG5cblx0XHRcdFx0dGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgPSBfZ2wuY3JlYXRlVGV4dHVyZSgpO1xuXG5cdFx0XHRcdF9pbmZvTWVtb3J5LnRleHR1cmVzICsrO1xuXG5cdFx0XHR9XG5cblx0XHRcdHN0YXRlLmFjdGl2ZVRleHR1cmUoIF9nbC5URVhUVVJFMCArIHNsb3QgKTtcblx0XHRcdHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgKTtcblxuXHRcdFx0X2dsLnBpeGVsU3RvcmVpKCBfZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgdGV4dHVyZS5mbGlwWSApO1xuXHRcdFx0X2dsLnBpeGVsU3RvcmVpKCBfZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCB0ZXh0dXJlLnByZW11bHRpcGx5QWxwaGEgKTtcblx0XHRcdF9nbC5waXhlbFN0b3JlaSggX2dsLlVOUEFDS19BTElHTk1FTlQsIHRleHR1cmUudW5wYWNrQWxpZ25tZW50ICk7XG5cblx0XHRcdHRleHR1cmUuaW1hZ2UgPSBjbGFtcFRvTWF4U2l6ZSggdGV4dHVyZS5pbWFnZSwgY2FwYWJpbGl0aWVzLm1heFRleHR1cmVTaXplICk7XG5cblx0XHRcdGlmICggdGV4dHVyZU5lZWRzUG93ZXJPZlR3byggdGV4dHVyZSApICYmIGlzUG93ZXJPZlR3byggdGV4dHVyZS5pbWFnZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHR0ZXh0dXJlLmltYWdlID0gbWFrZVBvd2VyT2ZUd28oIHRleHR1cmUuaW1hZ2UgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgaW1hZ2UgPSB0ZXh0dXJlLmltYWdlLFxuXHRcdFx0aXNJbWFnZVBvd2VyT2ZUd28gPSBpc1Bvd2VyT2ZUd28oIGltYWdlICksXG5cdFx0XHRnbEZvcm1hdCA9IHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLmZvcm1hdCApLFxuXHRcdFx0Z2xUeXBlID0gcGFyYW1UaHJlZVRvR0woIHRleHR1cmUudHlwZSApO1xuXG5cdFx0XHRzZXRUZXh0dXJlUGFyYW1ldGVycyggX2dsLlRFWFRVUkVfMkQsIHRleHR1cmUsIGlzSW1hZ2VQb3dlck9mVHdvICk7XG5cblx0XHRcdHZhciBtaXBtYXAsIG1pcG1hcHMgPSB0ZXh0dXJlLm1pcG1hcHM7XG5cblx0XHRcdGlmICggdGV4dHVyZSBpbnN0YW5jZW9mIFRIUkVFLkRhdGFUZXh0dXJlICkge1xuXG5cdFx0XHRcdC8vIHVzZSBtYW51YWxseSBjcmVhdGVkIG1pcG1hcHMgaWYgYXZhaWxhYmxlXG5cdFx0XHRcdC8vIGlmIHRoZXJlIGFyZSBubyBtYW51YWwgbWlwbWFwc1xuXHRcdFx0XHQvLyBzZXQgMCBsZXZlbCBtaXBtYXAgYW5kIHRoZW4gdXNlIEdMIHRvIGdlbmVyYXRlIG90aGVyIG1pcG1hcCBsZXZlbHNcblxuXHRcdFx0XHRpZiAoIG1pcG1hcHMubGVuZ3RoID4gMCAmJiBpc0ltYWdlUG93ZXJPZlR3byApIHtcblxuXHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBtaXBtYXBzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRtaXBtYXAgPSBtaXBtYXBzWyBpIF07XG5cdFx0XHRcdFx0XHRzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgaSwgZ2xGb3JtYXQsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbWlwbWFwLmRhdGEgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCAwLCBnbEZvcm1hdCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgaW1hZ2UuZGF0YSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIGlmICggdGV4dHVyZSBpbnN0YW5jZW9mIFRIUkVFLkNvbXByZXNzZWRUZXh0dXJlICkge1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBtaXBtYXBzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0bWlwbWFwID0gbWlwbWFwc1sgaSBdO1xuXG5cdFx0XHRcdFx0aWYgKCB0ZXh0dXJlLmZvcm1hdCAhPT0gVEhSRUUuUkdCQUZvcm1hdCAmJiB0ZXh0dXJlLmZvcm1hdCAhPT0gVEhSRUUuUkdCRm9ybWF0ICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIHN0YXRlLmdldENvbXByZXNzZWRUZXh0dXJlRm9ybWF0cygpLmluZGV4T2YoIGdsRm9ybWF0ICkgPiAtIDEgKSB7XG5cblx0XHRcdFx0XHRcdFx0c3RhdGUuY29tcHJlc3NlZFRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCBpLCBnbEZvcm1hdCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCAwLCBtaXBtYXAuZGF0YSApO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggXCJUSFJFRS5XZWJHTFJlbmRlcmVyOiBBdHRlbXB0IHRvIGxvYWQgdW5zdXBwb3J0ZWQgY29tcHJlc3NlZCB0ZXh0dXJlIGZvcm1hdCBpbiAudXBsb2FkVGV4dHVyZSgpXCIgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0c3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIGksIGdsRm9ybWF0LCBtaXBtYXAud2lkdGgsIG1pcG1hcC5oZWlnaHQsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIG1pcG1hcC5kYXRhICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIHJlZ3VsYXIgVGV4dHVyZSAoaW1hZ2UsIHZpZGVvLCBjYW52YXMpXG5cblx0XHRcdFx0Ly8gdXNlIG1hbnVhbGx5IGNyZWF0ZWQgbWlwbWFwcyBpZiBhdmFpbGFibGVcblx0XHRcdFx0Ly8gaWYgdGhlcmUgYXJlIG5vIG1hbnVhbCBtaXBtYXBzXG5cdFx0XHRcdC8vIHNldCAwIGxldmVsIG1pcG1hcCBhbmQgdGhlbiB1c2UgR0wgdG8gZ2VuZXJhdGUgb3RoZXIgbWlwbWFwIGxldmVsc1xuXG5cdFx0XHRcdGlmICggbWlwbWFwcy5sZW5ndGggPiAwICYmIGlzSW1hZ2VQb3dlck9mVHdvICkge1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IG1pcG1hcHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdG1pcG1hcCA9IG1pcG1hcHNbIGkgXTtcblx0XHRcdFx0XHRcdHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCBpLCBnbEZvcm1hdCwgZ2xGb3JtYXQsIGdsVHlwZSwgbWlwbWFwICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgMCwgZ2xGb3JtYXQsIGdsRm9ybWF0LCBnbFR5cGUsIHRleHR1cmUuaW1hZ2UgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyAmJiBpc0ltYWdlUG93ZXJPZlR3byApIF9nbC5nZW5lcmF0ZU1pcG1hcCggX2dsLlRFWFRVUkVfMkQgKTtcblxuXHRcdFx0dGV4dHVyZVByb3BlcnRpZXMuX192ZXJzaW9uID0gdGV4dHVyZS52ZXJzaW9uO1xuXG5cdFx0XHRpZiAoIHRleHR1cmUub25VcGRhdGUgKSB0ZXh0dXJlLm9uVXBkYXRlKCB0ZXh0dXJlICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLnNldFRleHR1cmUgPSBmdW5jdGlvbiAoIHRleHR1cmUsIHNsb3QgKSB7XG5cblx0XHRcdHZhciB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCB0ZXh0dXJlICk7XG5cblx0XHRcdGlmICggdGV4dHVyZS52ZXJzaW9uID4gMCAmJiB0ZXh0dXJlUHJvcGVydGllcy5fX3ZlcnNpb24gIT09IHRleHR1cmUudmVyc2lvbiApIHtcblxuXHRcdFx0XHR2YXIgaW1hZ2UgPSB0ZXh0dXJlLmltYWdlO1xuXG5cdFx0XHRcdGlmICggaW1hZ2UgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFRleHR1cmUgbWFya2VkIGZvciB1cGRhdGUgYnV0IGltYWdlIGlzIHVuZGVmaW5lZCcsIHRleHR1cmUgKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggaW1hZ2UuY29tcGxldGUgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogVGV4dHVyZSBtYXJrZWQgZm9yIHVwZGF0ZSBidXQgaW1hZ2UgaXMgaW5jb21wbGV0ZScsIHRleHR1cmUgKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHVwbG9hZFRleHR1cmUoIHRleHR1cmVQcm9wZXJ0aWVzLCB0ZXh0dXJlLCBzbG90ICk7XG5cblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHR9XG5cblx0XHRcdHN0YXRlLmFjdGl2ZVRleHR1cmUoIF9nbC5URVhUVVJFMCArIHNsb3QgKTtcblx0XHRcdHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgKTtcblxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBjbGFtcFRvTWF4U2l6ZSAoIGltYWdlLCBtYXhTaXplICkge1xuXG5cdFx0XHRpZiAoIGltYWdlLndpZHRoID4gbWF4U2l6ZSB8fCBpbWFnZS5oZWlnaHQgPiBtYXhTaXplICkge1xuXG5cdFx0XHRcdC8vIFdhcm5pbmc6IFNjYWxpbmcgdGhyb3VnaCB0aGUgY2FudmFzIHdpbGwgb25seSB3b3JrIHdpdGggaW1hZ2VzIHRoYXQgdXNlXG5cdFx0XHRcdC8vIHByZW11bHRpcGxpZWQgYWxwaGEuXG5cblx0XHRcdFx0dmFyIHNjYWxlID0gbWF4U2l6ZSAvIE1hdGgubWF4KCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0ICk7XG5cblx0XHRcdFx0dmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdjYW52YXMnICk7XG5cdFx0XHRcdGNhbnZhcy53aWR0aCA9IE1hdGguZmxvb3IoIGltYWdlLndpZHRoICogc2NhbGUgKTtcblx0XHRcdFx0Y2FudmFzLmhlaWdodCA9IE1hdGguZmxvb3IoIGltYWdlLmhlaWdodCAqIHNjYWxlICk7XG5cblx0XHRcdFx0dmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCggJzJkJyApO1xuXHRcdFx0XHRjb250ZXh0LmRyYXdJbWFnZSggaW1hZ2UsIDAsIDAsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQsIDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCApO1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IGltYWdlIGlzIHRvbyBiaWcgKCcgKyBpbWFnZS53aWR0aCArICd4JyArIGltYWdlLmhlaWdodCArICcpLiBSZXNpemVkIHRvICcgKyBjYW52YXMud2lkdGggKyAneCcgKyBjYW52YXMuaGVpZ2h0LCBpbWFnZSApO1xuXG5cdFx0XHRcdHJldHVybiBjYW52YXM7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGltYWdlO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaXNQb3dlck9mVHdvKCBpbWFnZSApIHtcblxuXHRcdFx0cmV0dXJuIFRIUkVFLk1hdGguaXNQb3dlck9mVHdvKCBpbWFnZS53aWR0aCApICYmIFRIUkVFLk1hdGguaXNQb3dlck9mVHdvKCBpbWFnZS5oZWlnaHQgKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHRleHR1cmVOZWVkc1Bvd2VyT2ZUd28oIHRleHR1cmUgKSB7XG5cblx0XHRcdGlmICggdGV4dHVyZS53cmFwUyAhPT0gVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZyB8fCB0ZXh0dXJlLndyYXBUICE9PSBUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nICkgcmV0dXJuIHRydWU7XG5cdFx0XHRpZiAoIHRleHR1cmUubWluRmlsdGVyICE9PSBUSFJFRS5OZWFyZXN0RmlsdGVyICYmIHRleHR1cmUubWluRmlsdGVyICE9PSBUSFJFRS5MaW5lYXJGaWx0ZXIgKSByZXR1cm4gdHJ1ZTtcblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gbWFrZVBvd2VyT2ZUd28oIGltYWdlICkge1xuXG5cdFx0XHRpZiAoIGltYWdlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCB8fCBpbWFnZSBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50ICkge1xuXG5cdFx0XHRcdHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnY2FudmFzJyApO1xuXHRcdFx0XHRjYW52YXMud2lkdGggPSBUSFJFRS5NYXRoLm5lYXJlc3RQb3dlck9mVHdvKCBpbWFnZS53aWR0aCApO1xuXHRcdFx0XHRjYW52YXMuaGVpZ2h0ID0gVEhSRUUuTWF0aC5uZWFyZXN0UG93ZXJPZlR3byggaW1hZ2UuaGVpZ2h0ICk7XG5cblx0XHRcdFx0dmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCggJzJkJyApO1xuXHRcdFx0XHRjb250ZXh0LmRyYXdJbWFnZSggaW1hZ2UsIDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCApO1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IGltYWdlIGlzIG5vdCBwb3dlciBvZiB0d28gKCcgKyBpbWFnZS53aWR0aCArICd4JyArIGltYWdlLmhlaWdodCArICcpLiBSZXNpemVkIHRvICcgKyBjYW52YXMud2lkdGggKyAneCcgKyBjYW52YXMuaGVpZ2h0LCBpbWFnZSApO1xuXG5cdFx0XHRcdHJldHVybiBjYW52YXM7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGltYWdlO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gc2V0Q3ViZVRleHR1cmUgKCB0ZXh0dXJlLCBzbG90ICkge1xuXG5cdFx0XHR2YXIgdGV4dHVyZVByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggdGV4dHVyZSApO1xuXG5cdFx0XHRpZiAoIHRleHR1cmUuaW1hZ2UubGVuZ3RoID09PSA2ICkge1xuXG5cdFx0XHRcdGlmICggdGV4dHVyZS52ZXJzaW9uID4gMCAmJiB0ZXh0dXJlUHJvcGVydGllcy5fX3ZlcnNpb24gIT09IHRleHR1cmUudmVyc2lvbiApIHtcblxuXHRcdFx0XHRcdGlmICggISB0ZXh0dXJlUHJvcGVydGllcy5fX2ltYWdlX193ZWJnbFRleHR1cmVDdWJlICkge1xuXG5cdFx0XHRcdFx0XHR0ZXh0dXJlLmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25UZXh0dXJlRGlzcG9zZSApO1xuXG5cdFx0XHRcdFx0XHR0ZXh0dXJlUHJvcGVydGllcy5fX2ltYWdlX193ZWJnbFRleHR1cmVDdWJlID0gX2dsLmNyZWF0ZVRleHR1cmUoKTtcblxuXHRcdFx0XHRcdFx0X2luZm9NZW1vcnkudGV4dHVyZXMgKys7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRzdGF0ZS5hY3RpdmVUZXh0dXJlKCBfZ2wuVEVYVFVSRTAgKyBzbG90ICk7XG5cdFx0XHRcdFx0c3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCB0ZXh0dXJlUHJvcGVydGllcy5fX2ltYWdlX193ZWJnbFRleHR1cmVDdWJlICk7XG5cblx0XHRcdFx0XHRfZ2wucGl4ZWxTdG9yZWkoIF9nbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCB0ZXh0dXJlLmZsaXBZICk7XG5cblx0XHRcdFx0XHR2YXIgaXNDb21wcmVzc2VkID0gdGV4dHVyZSBpbnN0YW5jZW9mIFRIUkVFLkNvbXByZXNzZWRUZXh0dXJlO1xuXHRcdFx0XHRcdHZhciBpc0RhdGFUZXh0dXJlID0gdGV4dHVyZS5pbWFnZVsgMCBdIGluc3RhbmNlb2YgVEhSRUUuRGF0YVRleHR1cmU7XG5cblx0XHRcdFx0XHR2YXIgY3ViZUltYWdlID0gW107XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIF90aGlzLmF1dG9TY2FsZUN1YmVtYXBzICYmICEgaXNDb21wcmVzc2VkICYmICEgaXNEYXRhVGV4dHVyZSApIHtcblxuXHRcdFx0XHRcdFx0XHRjdWJlSW1hZ2VbIGkgXSA9IGNsYW1wVG9NYXhTaXplKCB0ZXh0dXJlLmltYWdlWyBpIF0sIGNhcGFiaWxpdGllcy5tYXhDdWJlbWFwU2l6ZSApO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdGN1YmVJbWFnZVsgaSBdID0gaXNEYXRhVGV4dHVyZSA/IHRleHR1cmUuaW1hZ2VbIGkgXS5pbWFnZSA6IHRleHR1cmUuaW1hZ2VbIGkgXTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dmFyIGltYWdlID0gY3ViZUltYWdlWyAwIF0sXG5cdFx0XHRcdFx0aXNJbWFnZVBvd2VyT2ZUd28gPSBpc1Bvd2VyT2ZUd28oIGltYWdlICksXG5cdFx0XHRcdFx0Z2xGb3JtYXQgPSBwYXJhbVRocmVlVG9HTCggdGV4dHVyZS5mb3JtYXQgKSxcblx0XHRcdFx0XHRnbFR5cGUgPSBwYXJhbVRocmVlVG9HTCggdGV4dHVyZS50eXBlICk7XG5cblx0XHRcdFx0XHRzZXRUZXh0dXJlUGFyYW1ldGVycyggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHRleHR1cmUsIGlzSW1hZ2VQb3dlck9mVHdvICk7XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoICEgaXNDb21wcmVzc2VkICkge1xuXG5cdFx0XHRcdFx0XHRcdGlmICggaXNEYXRhVGV4dHVyZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpLCAwLCBnbEZvcm1hdCwgY3ViZUltYWdlWyBpIF0ud2lkdGgsIGN1YmVJbWFnZVsgaSBdLmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgY3ViZUltYWdlWyBpIF0uZGF0YSApO1xuXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgMCwgZ2xGb3JtYXQsIGdsRm9ybWF0LCBnbFR5cGUsIGN1YmVJbWFnZVsgaSBdICk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdHZhciBtaXBtYXAsIG1pcG1hcHMgPSBjdWJlSW1hZ2VbIGkgXS5taXBtYXBzO1xuXG5cdFx0XHRcdFx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBtaXBtYXBzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0bWlwbWFwID0gbWlwbWFwc1sgaiBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCB0ZXh0dXJlLmZvcm1hdCAhPT0gVEhSRUUuUkdCQUZvcm1hdCAmJiB0ZXh0dXJlLmZvcm1hdCAhPT0gVEhSRUUuUkdCRm9ybWF0ICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHN0YXRlLmdldENvbXByZXNzZWRUZXh0dXJlRm9ybWF0cygpLmluZGV4T2YoIGdsRm9ybWF0ICkgPiAtIDEgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0c3RhdGUuY29tcHJlc3NlZFRleEltYWdlMkQoIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpLCBqLCBnbEZvcm1hdCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCAwLCBtaXBtYXAuZGF0YSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggXCJUSFJFRS5XZWJHTFJlbmRlcmVyOiBBdHRlbXB0IHRvIGxvYWQgdW5zdXBwb3J0ZWQgY29tcHJlc3NlZCB0ZXh0dXJlIGZvcm1hdCBpbiAuc2V0Q3ViZVRleHR1cmUoKVwiICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpLCBqLCBnbEZvcm1hdCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXAuZGF0YSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCB0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyAmJiBpc0ltYWdlUG93ZXJPZlR3byApIHtcblxuXHRcdFx0XHRcdFx0X2dsLmdlbmVyYXRlTWlwbWFwKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dGV4dHVyZVByb3BlcnRpZXMuX192ZXJzaW9uID0gdGV4dHVyZS52ZXJzaW9uO1xuXG5cdFx0XHRcdFx0aWYgKCB0ZXh0dXJlLm9uVXBkYXRlICkgdGV4dHVyZS5vblVwZGF0ZSggdGV4dHVyZSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRzdGF0ZS5hY3RpdmVUZXh0dXJlKCBfZ2wuVEVYVFVSRTAgKyBzbG90ICk7XG5cdFx0XHRcdFx0c3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCB0ZXh0dXJlUHJvcGVydGllcy5fX2ltYWdlX193ZWJnbFRleHR1cmVDdWJlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBzZXRDdWJlVGV4dHVyZUR5bmFtaWMgKCB0ZXh0dXJlLCBzbG90ICkge1xuXG5cdFx0XHRzdGF0ZS5hY3RpdmVUZXh0dXJlKCBfZ2wuVEVYVFVSRTAgKyBzbG90ICk7XG5cdFx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHByb3BlcnRpZXMuZ2V0KCB0ZXh0dXJlICkuX193ZWJnbFRleHR1cmUgKTtcblxuXHRcdH1cblxuXHRcdC8vIFJlbmRlciB0YXJnZXRzXG5cblx0XHRmdW5jdGlvbiBzZXR1cEZyYW1lQnVmZmVyICggZnJhbWVidWZmZXIsIHJlbmRlclRhcmdldCwgdGV4dHVyZVRhcmdldCApIHtcblxuXHRcdFx0X2dsLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlciApO1xuXHRcdFx0X2dsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKCBfZ2wuRlJBTUVCVUZGRVIsIF9nbC5DT0xPUl9BVFRBQ0hNRU5UMCwgdGV4dHVyZVRhcmdldCwgcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldC50ZXh0dXJlICkuX193ZWJnbFRleHR1cmUsIDAgKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHNldHVwUmVuZGVyQnVmZmVyICggcmVuZGVyYnVmZmVyLCByZW5kZXJUYXJnZXQgKSB7XG5cblx0XHRcdF9nbC5iaW5kUmVuZGVyYnVmZmVyKCBfZ2wuUkVOREVSQlVGRkVSLCByZW5kZXJidWZmZXIgKTtcblxuXHRcdFx0aWYgKCByZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXIgJiYgISByZW5kZXJUYXJnZXQuc3RlbmNpbEJ1ZmZlciApIHtcblxuXHRcdFx0XHRfZ2wucmVuZGVyYnVmZmVyU3RvcmFnZSggX2dsLlJFTkRFUkJVRkZFUiwgX2dsLkRFUFRIX0NPTVBPTkVOVDE2LCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQgKTtcblx0XHRcdFx0X2dsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIF9nbC5ERVBUSF9BVFRBQ0hNRU5ULCBfZ2wuUkVOREVSQlVGRkVSLCByZW5kZXJidWZmZXIgKTtcblxuXHRcdFx0LyogRm9yIHNvbWUgcmVhc29uIHRoaXMgaXMgbm90IHdvcmtpbmcuIERlZmF1bHRpbmcgdG8gUkdCQTQuXG5cdFx0XHR9IGVsc2UgaWYgKCAhIHJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlciAmJiByZW5kZXJUYXJnZXQuc3RlbmNpbEJ1ZmZlciApIHtcblxuXHRcdFx0XHRfZ2wucmVuZGVyYnVmZmVyU3RvcmFnZSggX2dsLlJFTkRFUkJVRkZFUiwgX2dsLlNURU5DSUxfSU5ERVg4LCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQgKTtcblx0XHRcdFx0X2dsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIF9nbC5TVEVOQ0lMX0FUVEFDSE1FTlQsIF9nbC5SRU5ERVJCVUZGRVIsIHJlbmRlcmJ1ZmZlciApO1xuXHRcdFx0Ki9cblxuXHRcdFx0fSBlbHNlIGlmICggcmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyICYmIHJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyICkge1xuXG5cdFx0XHRcdF9nbC5yZW5kZXJidWZmZXJTdG9yYWdlKCBfZ2wuUkVOREVSQlVGRkVSLCBfZ2wuREVQVEhfU1RFTkNJTCwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0ICk7XG5cdFx0XHRcdF9nbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBfZ2wuREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5ULCBfZ2wuUkVOREVSQlVGRkVSLCByZW5kZXJidWZmZXIgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRfZ2wucmVuZGVyYnVmZmVyU3RvcmFnZSggX2dsLlJFTkRFUkJVRkZFUiwgX2dsLlJHQkE0LCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0dGhpcy5zZXRSZW5kZXJUYXJnZXQgPSBmdW5jdGlvbiAoIHJlbmRlclRhcmdldCApIHtcblxuXHRcdFx0dmFyIGlzQ3ViZSA9ICggcmVuZGVyVGFyZ2V0IGluc3RhbmNlb2YgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlICk7XG5cblx0XHRcdGlmICggcmVuZGVyVGFyZ2V0ICYmIHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQgKS5fX3dlYmdsRnJhbWVidWZmZXIgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHR2YXIgcmVuZGVyVGFyZ2V0UHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQgKTtcblx0XHRcdFx0dmFyIHRleHR1cmVQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldC50ZXh0dXJlICk7XG5cblx0XHRcdFx0aWYgKCByZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXIgPT09IHVuZGVmaW5lZCApIHJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlciA9IHRydWU7XG5cdFx0XHRcdGlmICggcmVuZGVyVGFyZ2V0LnN0ZW5jaWxCdWZmZXIgPT09IHVuZGVmaW5lZCApIHJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyID0gdHJ1ZTtcblxuXHRcdFx0XHRyZW5kZXJUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvblJlbmRlclRhcmdldERpc3Bvc2UgKTtcblxuXHRcdFx0XHR0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSA9IF9nbC5jcmVhdGVUZXh0dXJlKCk7XG5cblx0XHRcdFx0X2luZm9NZW1vcnkudGV4dHVyZXMgKys7XG5cblx0XHRcdFx0Ly8gU2V0dXAgdGV4dHVyZSwgY3JlYXRlIHJlbmRlciBhbmQgZnJhbWUgYnVmZmVyc1xuXG5cdFx0XHRcdHZhciBpc1RhcmdldFBvd2VyT2ZUd28gPSBpc1Bvd2VyT2ZUd28oIHJlbmRlclRhcmdldCApLFxuXHRcdFx0XHRcdGdsRm9ybWF0ID0gcGFyYW1UaHJlZVRvR0woIHJlbmRlclRhcmdldC50ZXh0dXJlLmZvcm1hdCApLFxuXHRcdFx0XHRcdGdsVHlwZSA9IHBhcmFtVGhyZWVUb0dMKCByZW5kZXJUYXJnZXQudGV4dHVyZS50eXBlICk7XG5cblx0XHRcdFx0aWYgKCBpc0N1YmUgKSB7XG5cblx0XHRcdFx0XHRyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlciA9IFtdO1xuXHRcdFx0XHRcdHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbFJlbmRlcmJ1ZmZlciA9IFtdO1xuXG5cdFx0XHRcdFx0c3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSApO1xuXG5cdFx0XHRcdFx0c2V0VGV4dHVyZVBhcmFtZXRlcnMoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCByZW5kZXJUYXJnZXQudGV4dHVyZSwgaXNUYXJnZXRQb3dlck9mVHdvICk7XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlclsgaSBdID0gX2dsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG5cdFx0XHRcdFx0XHRyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xSZW5kZXJidWZmZXJbIGkgXSA9IF9nbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcblx0XHRcdFx0XHRcdHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpLCAwLCBnbEZvcm1hdCwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBudWxsICk7XG5cblx0XHRcdFx0XHRcdHNldHVwRnJhbWVCdWZmZXIoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyWyBpIF0sIHJlbmRlclRhcmdldCwgX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGkgKTtcblx0XHRcdFx0XHRcdHNldHVwUmVuZGVyQnVmZmVyKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xSZW5kZXJidWZmZXJbIGkgXSwgcmVuZGVyVGFyZ2V0ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIHJlbmRlclRhcmdldC50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyAmJiBpc1RhcmdldFBvd2VyT2ZUd28gKSBfZ2wuZ2VuZXJhdGVNaXBtYXAoIF9nbC5URVhUVVJFX0NVQkVfTUFQICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyID0gX2dsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG5cblx0XHRcdFx0XHRpZiAoIHJlbmRlclRhcmdldC5zaGFyZURlcHRoRnJvbSApIHtcblxuXHRcdFx0XHRcdFx0cmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsUmVuZGVyYnVmZmVyID0gcmVuZGVyVGFyZ2V0LnNoYXJlRGVwdGhGcm9tLl9fd2ViZ2xSZW5kZXJidWZmZXI7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xSZW5kZXJidWZmZXIgPSBfZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfMkQsIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlICk7XG5cdFx0XHRcdFx0c2V0VGV4dHVyZVBhcmFtZXRlcnMoIF9nbC5URVhUVVJFXzJELCByZW5kZXJUYXJnZXQudGV4dHVyZSwgaXNUYXJnZXRQb3dlck9mVHdvICk7XG5cblx0XHRcdFx0XHRzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgMCwgZ2xGb3JtYXQsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbnVsbCApO1xuXG5cdFx0XHRcdFx0c2V0dXBGcmFtZUJ1ZmZlciggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIsIHJlbmRlclRhcmdldCwgX2dsLlRFWFRVUkVfMkQgKTtcblxuXHRcdFx0XHRcdGlmICggcmVuZGVyVGFyZ2V0LnNoYXJlRGVwdGhGcm9tICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIHJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlciAmJiAhIHJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyICkge1xuXG5cdFx0XHRcdFx0XHRcdF9nbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBfZ2wuREVQVEhfQVRUQUNITUVOVCwgX2dsLlJFTkRFUkJVRkZFUiwgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsUmVuZGVyYnVmZmVyICk7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIHJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlciAmJiByZW5kZXJUYXJnZXQuc3RlbmNpbEJ1ZmZlciApIHtcblxuXHRcdFx0XHRcdFx0XHRfZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVCwgX2dsLlJFTkRFUkJVRkZFUiwgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsUmVuZGVyYnVmZmVyICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdHNldHVwUmVuZGVyQnVmZmVyKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xSZW5kZXJidWZmZXIsIHJlbmRlclRhcmdldCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCByZW5kZXJUYXJnZXQudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgJiYgaXNUYXJnZXRQb3dlck9mVHdvICkgX2dsLmdlbmVyYXRlTWlwbWFwKCBfZ2wuVEVYVFVSRV8yRCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZWxlYXNlIGV2ZXJ5dGhpbmdcblxuXHRcdFx0XHRpZiAoIGlzQ3ViZSApIHtcblxuXHRcdFx0XHRcdHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgbnVsbCApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfMkQsIG51bGwgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0X2dsLmJpbmRSZW5kZXJidWZmZXIoIF9nbC5SRU5ERVJCVUZGRVIsIG51bGwgKTtcblx0XHRcdFx0X2dsLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBudWxsICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIGZyYW1lYnVmZmVyLCB3aWR0aCwgaGVpZ2h0LCB2eCwgdnk7XG5cblx0XHRcdGlmICggcmVuZGVyVGFyZ2V0ICkge1xuXG5cdFx0XHRcdHZhciByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldCApO1xuXG5cdFx0XHRcdGlmICggaXNDdWJlICkge1xuXG5cdFx0XHRcdFx0ZnJhbWVidWZmZXIgPSByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlclsgcmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlIF07XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGZyYW1lYnVmZmVyID0gcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXI7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHdpZHRoID0gcmVuZGVyVGFyZ2V0LndpZHRoO1xuXHRcdFx0XHRoZWlnaHQgPSByZW5kZXJUYXJnZXQuaGVpZ2h0O1xuXG5cdFx0XHRcdHZ4ID0gMDtcblx0XHRcdFx0dnkgPSAwO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGZyYW1lYnVmZmVyID0gbnVsbDtcblxuXHRcdFx0XHR3aWR0aCA9IF92aWV3cG9ydFdpZHRoO1xuXHRcdFx0XHRoZWlnaHQgPSBfdmlld3BvcnRIZWlnaHQ7XG5cblx0XHRcdFx0dnggPSBfdmlld3BvcnRYO1xuXHRcdFx0XHR2eSA9IF92aWV3cG9ydFk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBmcmFtZWJ1ZmZlciAhPT0gX2N1cnJlbnRGcmFtZWJ1ZmZlciApIHtcblxuXHRcdFx0XHRfZ2wuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyICk7XG5cdFx0XHRcdF9nbC52aWV3cG9ydCggdngsIHZ5LCB3aWR0aCwgaGVpZ2h0ICk7XG5cblx0XHRcdFx0X2N1cnJlbnRGcmFtZWJ1ZmZlciA9IGZyYW1lYnVmZmVyO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggaXNDdWJlICkge1xuXG5cdFx0XHRcdHZhciB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQudGV4dHVyZSApO1xuXHRcdFx0XHRfZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLkNPTE9SX0FUVEFDSE1FTlQwLCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgcmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlLCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSwgMCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdF9jdXJyZW50V2lkdGggPSB3aWR0aDtcblx0XHRcdF9jdXJyZW50SGVpZ2h0ID0gaGVpZ2h0O1xuXG5cdFx0fTtcblxuXHRcdHRoaXMucmVhZFJlbmRlclRhcmdldFBpeGVscyA9IGZ1bmN0aW9uICggcmVuZGVyVGFyZ2V0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBidWZmZXIgKSB7XG5cblx0XHRcdGlmICggcmVuZGVyVGFyZ2V0IGluc3RhbmNlb2YgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHM6IHJlbmRlclRhcmdldCBpcyBub3QgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQuJyApO1xuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIGZyYW1lYnVmZmVyID0gcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldCApLl9fd2ViZ2xGcmFtZWJ1ZmZlcjtcblxuXHRcdFx0aWYgKCBmcmFtZWJ1ZmZlciApIHtcblxuXHRcdFx0XHR2YXIgcmVzdG9yZSA9IGZhbHNlO1xuXG5cdFx0XHRcdGlmICggZnJhbWVidWZmZXIgIT09IF9jdXJyZW50RnJhbWVidWZmZXIgKSB7XG5cblx0XHRcdFx0XHRfZ2wuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyICk7XG5cblx0XHRcdFx0XHRyZXN0b3JlID0gdHJ1ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dHJ5IHtcblxuXHRcdFx0XHRcdHZhciB0ZXh0dXJlID0gcmVuZGVyVGFyZ2V0LnRleHR1cmU7XG5cblx0XHRcdFx0XHRpZiAoIHRleHR1cmUuZm9ybWF0ICE9PSBUSFJFRS5SR0JBRm9ybWF0XG5cdFx0XHRcdFx0XHQmJiBwYXJhbVRocmVlVG9HTCggdGV4dHVyZS5mb3JtYXQgKSAhPT0gX2dsLmdldFBhcmFtZXRlciggX2dsLklNUExFTUVOVEFUSU9OX0NPTE9SX1JFQURfRk9STUFUICkgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHM6IHJlbmRlclRhcmdldCBpcyBub3QgaW4gUkdCQSBvciBpbXBsZW1lbnRhdGlvbiBkZWZpbmVkIGZvcm1hdC4nICk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIHRleHR1cmUudHlwZSAhPT0gVEhSRUUuVW5zaWduZWRCeXRlVHlwZVxuXHRcdFx0XHRcdFx0JiYgcGFyYW1UaHJlZVRvR0woIHRleHR1cmUudHlwZSApICE9PSBfZ2wuZ2V0UGFyYW1ldGVyKCBfZ2wuSU1QTEVNRU5UQVRJT05fQ09MT1JfUkVBRF9UWVBFIClcblx0XHRcdFx0XHRcdCYmICEgKCB0ZXh0dXJlLnR5cGUgPT09IFRIUkVFLkZsb2F0VHlwZSAmJiBleHRlbnNpb25zLmdldCggJ1dFQkdMX2NvbG9yX2J1ZmZlcl9mbG9hdCcgKSApXG5cdFx0XHRcdFx0XHQmJiAhICggdGV4dHVyZS50eXBlID09PSBUSFJFRS5IYWxmRmxvYXRUeXBlICYmIGV4dGVuc2lvbnMuZ2V0KCAnRVhUX2NvbG9yX2J1ZmZlcl9oYWxmX2Zsb2F0JyApICkgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHM6IHJlbmRlclRhcmdldCBpcyBub3QgaW4gVW5zaWduZWRCeXRlVHlwZSBvciBpbXBsZW1lbnRhdGlvbiBkZWZpbmVkIHR5cGUuJyApO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBfZ2wuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyggX2dsLkZSQU1FQlVGRkVSICkgPT09IF9nbC5GUkFNRUJVRkZFUl9DT01QTEVURSApIHtcblxuXHRcdFx0XHRcdFx0X2dsLnJlYWRQaXhlbHMoIHgsIHksIHdpZHRoLCBoZWlnaHQsIHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLmZvcm1hdCApLCBwYXJhbVRocmVlVG9HTCggdGV4dHVyZS50eXBlICksIGJ1ZmZlciApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUmVuZGVyZXIucmVhZFJlbmRlclRhcmdldFBpeGVsczogcmVhZFBpeGVscyBmcm9tIHJlbmRlclRhcmdldCBmYWlsZWQuIEZyYW1lYnVmZmVyIG5vdCBjb21wbGV0ZS4nICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBmaW5hbGx5IHtcblxuXHRcdFx0XHRcdGlmICggcmVzdG9yZSApIHtcblxuXHRcdFx0XHRcdFx0X2dsLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBfY3VycmVudEZyYW1lYnVmZmVyICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gdXBkYXRlUmVuZGVyVGFyZ2V0TWlwbWFwKCByZW5kZXJUYXJnZXQgKSB7XG5cblx0XHRcdHZhciB0YXJnZXQgPSByZW5kZXJUYXJnZXQgaW5zdGFuY2VvZiBUSFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmUgPyBfZ2wuVEVYVFVSRV9DVUJFX01BUCA6IF9nbC5URVhUVVJFXzJEO1xuXHRcdFx0dmFyIHRleHR1cmUgPSBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0LnRleHR1cmUgKS5fX3dlYmdsVGV4dHVyZTtcblxuXHRcdFx0c3RhdGUuYmluZFRleHR1cmUoIHRhcmdldCwgdGV4dHVyZSApO1xuXHRcdFx0X2dsLmdlbmVyYXRlTWlwbWFwKCB0YXJnZXQgKTtcblx0XHRcdHN0YXRlLmJpbmRUZXh0dXJlKCB0YXJnZXQsIG51bGwgKTtcblxuXHRcdH1cblxuXHRcdC8vIEZhbGxiYWNrIGZpbHRlcnMgZm9yIG5vbi1wb3dlci1vZi0yIHRleHR1cmVzXG5cblx0XHRmdW5jdGlvbiBmaWx0ZXJGYWxsYmFjayAoIGYgKSB7XG5cblx0XHRcdGlmICggZiA9PT0gVEhSRUUuTmVhcmVzdEZpbHRlciB8fCBmID09PSBUSFJFRS5OZWFyZXN0TWlwTWFwTmVhcmVzdEZpbHRlciB8fCBmID09PSBUSFJFRS5OZWFyZXN0TWlwTWFwTGluZWFyRmlsdGVyICkge1xuXG5cdFx0XHRcdHJldHVybiBfZ2wuTkVBUkVTVDtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gX2dsLkxJTkVBUjtcblxuXHRcdH1cblxuXHRcdC8vIE1hcCB0aHJlZS5qcyBjb25zdGFudHMgdG8gV2ViR0wgY29uc3RhbnRzXG5cblx0XHRmdW5jdGlvbiBwYXJhbVRocmVlVG9HTCAoIHAgKSB7XG5cblx0XHRcdHZhciBleHRlbnNpb247XG5cblx0XHRcdGlmICggcCA9PT0gVEhSRUUuUmVwZWF0V3JhcHBpbmcgKSByZXR1cm4gX2dsLlJFUEVBVDtcblx0XHRcdGlmICggcCA9PT0gVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZyApIHJldHVybiBfZ2wuQ0xBTVBfVE9fRURHRTtcblx0XHRcdGlmICggcCA9PT0gVEhSRUUuTWlycm9yZWRSZXBlYXRXcmFwcGluZyApIHJldHVybiBfZ2wuTUlSUk9SRURfUkVQRUFUO1xuXG5cdFx0XHRpZiAoIHAgPT09IFRIUkVFLk5lYXJlc3RGaWx0ZXIgKSByZXR1cm4gX2dsLk5FQVJFU1Q7XG5cdFx0XHRpZiAoIHAgPT09IFRIUkVFLk5lYXJlc3RNaXBNYXBOZWFyZXN0RmlsdGVyICkgcmV0dXJuIF9nbC5ORUFSRVNUX01JUE1BUF9ORUFSRVNUO1xuXHRcdFx0aWYgKCBwID09PSBUSFJFRS5OZWFyZXN0TWlwTWFwTGluZWFyRmlsdGVyICkgcmV0dXJuIF9nbC5ORUFSRVNUX01JUE1BUF9MSU5FQVI7XG5cblx0XHRcdGlmICggcCA9PT0gVEhSRUUuTGluZWFyRmlsdGVyICkgcmV0dXJuIF9nbC5MSU5FQVI7XG5cdFx0XHRpZiAoIHAgPT09IFRIUkVFLkxpbmVhck1pcE1hcE5lYXJlc3RGaWx0ZXIgKSByZXR1cm4gX2dsLkxJTkVBUl9NSVBNQVBfTkVBUkVTVDtcblx0XHRcdGlmICggcCA9PT0gVEhSRUUuTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyICkgcmV0dXJuIF9nbC5MSU5FQVJfTUlQTUFQX0xJTkVBUjtcblxuXHRcdFx0aWYgKCBwID09PSBUSFJFRS5VbnNpZ25lZEJ5dGVUeXBlICkgcmV0dXJuIF9nbC5VTlNJR05FRF9CWVRFO1xuXHRcdFx0aWYgKCBwID09PSBUSFJFRS5VbnNpZ25lZFNob3J0NDQ0NFR5cGUgKSByZXR1cm4gX2dsLlVOU0lHTkVEX1NIT1JUXzRfNF80XzQ7XG5cdFx0XHRpZiAoIHAgPT09IFRIUkVFLlVuc2lnbmVkU2hvcnQ1NTUxVHlwZSApIHJldHVybiBfZ2wuVU5TSUdORURfU0hPUlRfNV81XzVfMTtcblx0XHRcdGlmICggcCA9PT0gVEhSRUUuVW5zaWduZWRTaG9ydDU2NVR5cGUgKSByZXR1cm4gX2dsLlVOU0lHTkVEX1NIT1JUXzVfNl81O1xuXG5cdFx0XHRpZiAoIHAgPT09IFRIUkVFLkJ5dGVUeXBlICkgcmV0dXJuIF9nbC5CWVRFO1xuXHRcdFx0aWYgKCBwID09PSBUSFJFRS5TaG9ydFR5cGUgKSByZXR1cm4gX2dsLlNIT1JUO1xuXHRcdFx0aWYgKCBwID09PSBUSFJFRS5VbnNpZ25lZFNob3J0VHlwZSApIHJldHVybiBfZ2wuVU5TSUdORURfU0hPUlQ7XG5cdFx0XHRpZiAoIHAgPT09IFRIUkVFLkludFR5cGUgKSByZXR1cm4gX2dsLklOVDtcblx0XHRcdGlmICggcCA9PT0gVEhSRUUuVW5zaWduZWRJbnRUeXBlICkgcmV0dXJuIF9nbC5VTlNJR05FRF9JTlQ7XG5cdFx0XHRpZiAoIHAgPT09IFRIUkVFLkZsb2F0VHlwZSApIHJldHVybiBfZ2wuRkxPQVQ7XG5cblx0XHRcdGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfaGFsZl9mbG9hdCcgKTtcblxuXHRcdFx0aWYgKCBleHRlbnNpb24gIT09IG51bGwgKSB7XG5cblx0XHRcdFx0aWYgKCBwID09PSBUSFJFRS5IYWxmRmxvYXRUeXBlICkgcmV0dXJuIGV4dGVuc2lvbi5IQUxGX0ZMT0FUX09FUztcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHAgPT09IFRIUkVFLkFscGhhRm9ybWF0ICkgcmV0dXJuIF9nbC5BTFBIQTtcblx0XHRcdGlmICggcCA9PT0gVEhSRUUuUkdCRm9ybWF0ICkgcmV0dXJuIF9nbC5SR0I7XG5cdFx0XHRpZiAoIHAgPT09IFRIUkVFLlJHQkFGb3JtYXQgKSByZXR1cm4gX2dsLlJHQkE7XG5cdFx0XHRpZiAoIHAgPT09IFRIUkVFLkx1bWluYW5jZUZvcm1hdCApIHJldHVybiBfZ2wuTFVNSU5BTkNFO1xuXHRcdFx0aWYgKCBwID09PSBUSFJFRS5MdW1pbmFuY2VBbHBoYUZvcm1hdCApIHJldHVybiBfZ2wuTFVNSU5BTkNFX0FMUEhBO1xuXG5cdFx0XHRpZiAoIHAgPT09IFRIUkVFLkFkZEVxdWF0aW9uICkgcmV0dXJuIF9nbC5GVU5DX0FERDtcblx0XHRcdGlmICggcCA9PT0gVEhSRUUuU3VidHJhY3RFcXVhdGlvbiApIHJldHVybiBfZ2wuRlVOQ19TVUJUUkFDVDtcblx0XHRcdGlmICggcCA9PT0gVEhSRUUuUmV2ZXJzZVN1YnRyYWN0RXF1YXRpb24gKSByZXR1cm4gX2dsLkZVTkNfUkVWRVJTRV9TVUJUUkFDVDtcblxuXHRcdFx0aWYgKCBwID09PSBUSFJFRS5aZXJvRmFjdG9yICkgcmV0dXJuIF9nbC5aRVJPO1xuXHRcdFx0aWYgKCBwID09PSBUSFJFRS5PbmVGYWN0b3IgKSByZXR1cm4gX2dsLk9ORTtcblx0XHRcdGlmICggcCA9PT0gVEhSRUUuU3JjQ29sb3JGYWN0b3IgKSByZXR1cm4gX2dsLlNSQ19DT0xPUjtcblx0XHRcdGlmICggcCA9PT0gVEhSRUUuT25lTWludXNTcmNDb2xvckZhY3RvciApIHJldHVybiBfZ2wuT05FX01JTlVTX1NSQ19DT0xPUjtcblx0XHRcdGlmICggcCA9PT0gVEhSRUUuU3JjQWxwaGFGYWN0b3IgKSByZXR1cm4gX2dsLlNSQ19BTFBIQTtcblx0XHRcdGlmICggcCA9PT0gVEhSRUUuT25lTWludXNTcmNBbHBoYUZhY3RvciApIHJldHVybiBfZ2wuT05FX01JTlVTX1NSQ19BTFBIQTtcblx0XHRcdGlmICggcCA9PT0gVEhSRUUuRHN0QWxwaGFGYWN0b3IgKSByZXR1cm4gX2dsLkRTVF9BTFBIQTtcblx0XHRcdGlmICggcCA9PT0gVEhSRUUuT25lTWludXNEc3RBbHBoYUZhY3RvciApIHJldHVybiBfZ2wuT05FX01JTlVTX0RTVF9BTFBIQTtcblxuXHRcdFx0aWYgKCBwID09PSBUSFJFRS5Ec3RDb2xvckZhY3RvciApIHJldHVybiBfZ2wuRFNUX0NPTE9SO1xuXHRcdFx0aWYgKCBwID09PSBUSFJFRS5PbmVNaW51c0RzdENvbG9yRmFjdG9yICkgcmV0dXJuIF9nbC5PTkVfTUlOVVNfRFNUX0NPTE9SO1xuXHRcdFx0aWYgKCBwID09PSBUSFJFRS5TcmNBbHBoYVNhdHVyYXRlRmFjdG9yICkgcmV0dXJuIF9nbC5TUkNfQUxQSEFfU0FUVVJBVEU7XG5cblx0XHRcdGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnICk7XG5cblx0XHRcdGlmICggZXh0ZW5zaW9uICE9PSBudWxsICkge1xuXG5cdFx0XHRcdGlmICggcCA9PT0gVEhSRUUuUkdCX1MzVENfRFhUMV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCX1MzVENfRFhUMV9FWFQ7XG5cdFx0XHRcdGlmICggcCA9PT0gVEhSRUUuUkdCQV9TM1RDX0RYVDFfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQxX0VYVDtcblx0XHRcdFx0aWYgKCBwID09PSBUSFJFRS5SR0JBX1MzVENfRFhUM19Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDNfRVhUO1xuXHRcdFx0XHRpZiAoIHAgPT09IFRIUkVFLlJHQkFfUzNUQ19EWFQ1X0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUNV9FWFQ7XG5cblx0XHRcdH1cblxuXHRcdFx0ZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnICk7XG5cblx0XHRcdGlmICggZXh0ZW5zaW9uICE9PSBudWxsICkge1xuXG5cdFx0XHRcdGlmICggcCA9PT0gVEhSRUUuUkdCX1BWUlRDXzRCUFBWMV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCX1BWUlRDXzRCUFBWMV9JTUc7XG5cdFx0XHRcdGlmICggcCA9PT0gVEhSRUUuUkdCX1BWUlRDXzJCUFBWMV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCX1BWUlRDXzJCUFBWMV9JTUc7XG5cdFx0XHRcdGlmICggcCA9PT0gVEhSRUUuUkdCQV9QVlJUQ180QlBQVjFfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfUFZSVENfNEJQUFYxX0lNRztcblx0XHRcdFx0aWYgKCBwID09PSBUSFJFRS5SR0JBX1BWUlRDXzJCUFBWMV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9QVlJUQ18yQlBQVjFfSU1HO1xuXG5cdFx0XHR9XG5cblx0XHRcdGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnRVhUX2JsZW5kX21pbm1heCcgKTtcblxuXHRcdFx0aWYgKCBleHRlbnNpb24gIT09IG51bGwgKSB7XG5cblx0XHRcdFx0aWYgKCBwID09PSBUSFJFRS5NaW5FcXVhdGlvbiApIHJldHVybiBleHRlbnNpb24uTUlOX0VYVDtcblx0XHRcdFx0aWYgKCBwID09PSBUSFJFRS5NYXhFcXVhdGlvbiApIHJldHVybiBleHRlbnNpb24uTUFYX0VYVDtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gMDtcblxuXHRcdH1cblxuXHRcdC8vIERFUFJFQ0FURURcblxuXHRcdHRoaXMuc3VwcG9ydHNGbG9hdFRleHR1cmVzID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc3VwcG9ydHNGbG9hdFRleHR1cmVzKCkgaXMgbm93IC5leHRlbnNpb25zLmdldCggXFwnT0VTX3RleHR1cmVfZmxvYXRcXCcgKS4nICk7XG5cdFx0XHRyZXR1cm4gZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9mbG9hdCcgKTtcblxuXHRcdH07XG5cblx0XHR0aGlzLnN1cHBvcnRzSGFsZkZsb2F0VGV4dHVyZXMgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zdXBwb3J0c0hhbGZGbG9hdFRleHR1cmVzKCkgaXMgbm93IC5leHRlbnNpb25zLmdldCggXFwnT0VTX3RleHR1cmVfaGFsZl9mbG9hdFxcJyApLicgKTtcblx0XHRcdHJldHVybiBleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2hhbGZfZmxvYXQnICk7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5zdXBwb3J0c1N0YW5kYXJkRGVyaXZhdGl2ZXMgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zdXBwb3J0c1N0YW5kYXJkRGVyaXZhdGl2ZXMoKSBpcyBub3cgLmV4dGVuc2lvbnMuZ2V0KCBcXCdPRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXNcXCcgKS4nICk7XG5cdFx0XHRyZXR1cm4gZXh0ZW5zaW9ucy5nZXQoICdPRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMnICk7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5zdXBwb3J0c0NvbXByZXNzZWRUZXh0dXJlUzNUQyA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnN1cHBvcnRzQ29tcHJlc3NlZFRleHR1cmVTM1RDKCkgaXMgbm93IC5leHRlbnNpb25zLmdldCggXFwnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGNcXCcgKS4nICk7XG5cdFx0XHRyZXR1cm4gZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycgKTtcblxuXHRcdH07XG5cblx0XHR0aGlzLnN1cHBvcnRzQ29tcHJlc3NlZFRleHR1cmVQVlJUQyA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnN1cHBvcnRzQ29tcHJlc3NlZFRleHR1cmVQVlJUQygpIGlzIG5vdyAuZXh0ZW5zaW9ucy5nZXQoIFxcJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0Y1xcJyApLicgKTtcblx0XHRcdHJldHVybiBleHRlbnNpb25zLmdldCggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0YycgKTtcblxuXHRcdH07XG5cblx0XHR0aGlzLnN1cHBvcnRzQmxlbmRNaW5NYXggPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zdXBwb3J0c0JsZW5kTWluTWF4KCkgaXMgbm93IC5leHRlbnNpb25zLmdldCggXFwnRVhUX2JsZW5kX21pbm1heFxcJyApLicgKTtcblx0XHRcdHJldHVybiBleHRlbnNpb25zLmdldCggJ0VYVF9ibGVuZF9taW5tYXgnICk7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5zdXBwb3J0c1ZlcnRleFRleHR1cmVzID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gY2FwYWJpbGl0aWVzLnZlcnRleFRleHR1cmVzO1xuXG5cdFx0fTtcblxuXHRcdHRoaXMuc3VwcG9ydHNJbnN0YW5jZWRBcnJheXMgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zdXBwb3J0c0luc3RhbmNlZEFycmF5cygpIGlzIG5vdyAuZXh0ZW5zaW9ucy5nZXQoIFxcJ0FOR0xFX2luc3RhbmNlZF9hcnJheXNcXCcgKS4nICk7XG5cdFx0XHRyZXR1cm4gZXh0ZW5zaW9ucy5nZXQoICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyApO1xuXG5cdFx0fTtcblxuXHRcdC8vXG5cblx0XHR0aGlzLmluaXRNYXRlcmlhbCA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLmluaXRNYXRlcmlhbCgpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuXG5cdFx0fTtcblxuXHRcdHRoaXMuYWRkUHJlUGx1Z2luID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuYWRkUHJlUGx1Z2luKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5hZGRQb3N0UGx1Z2luID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuYWRkUG9zdFBsdWdpbigpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuXG5cdFx0fTtcblxuXHRcdHRoaXMudXBkYXRlU2hhZG93TWFwID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAudXBkYXRlU2hhZG93TWFwKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG5cblx0XHR9O1xuXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIHRoaXMsIHtcblx0XHRcdHNoYWRvd01hcEVuYWJsZWQ6IHtcblx0XHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gc2hhZG93TWFwLmVuYWJsZWQ7XG5cblx0XHRcdFx0fSxcblx0XHRcdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnNoYWRvd01hcEVuYWJsZWQgaXMgbm93IC5zaGFkb3dNYXAuZW5hYmxlZC4nICk7XG5cdFx0XHRcdFx0c2hhZG93TWFwLmVuYWJsZWQgPSB2YWx1ZTtcblxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0c2hhZG93TWFwVHlwZToge1xuXHRcdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRcdHJldHVybiBzaGFkb3dNYXAudHlwZTtcblxuXHRcdFx0XHR9LFxuXHRcdFx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc2hhZG93TWFwVHlwZSBpcyBub3cgLnNoYWRvd01hcC50eXBlLicgKTtcblx0XHRcdFx0XHRzaGFkb3dNYXAudHlwZSA9IHZhbHVlO1xuXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRzaGFkb3dNYXBDdWxsRmFjZToge1xuXHRcdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRcdHJldHVybiBzaGFkb3dNYXAuY3VsbEZhY2U7XG5cblx0XHRcdFx0fSxcblx0XHRcdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnNoYWRvd01hcEN1bGxGYWNlIGlzIG5vdyAuc2hhZG93TWFwLmN1bGxGYWNlLicgKTtcblx0XHRcdFx0XHRzaGFkb3dNYXAuY3VsbEZhY2UgPSB2YWx1ZTtcblxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0c2hhZG93TWFwRGVidWc6IHtcblx0XHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gc2hhZG93TWFwLmRlYnVnO1xuXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zaGFkb3dNYXBEZWJ1ZyBpcyBub3cgLnNoYWRvd01hcC5kZWJ1Zy4nICk7XG5cdFx0XHRcdFx0c2hhZG93TWFwLmRlYnVnID0gdmFsdWU7XG5cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHR9O1xuXG5cdC8vIEZpbGU6c3JjL3JlbmRlcmVycy9XZWJHTFJlbmRlclRhcmdldC5qc1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIHN6aW1layAvIGh0dHBzOi8vZ2l0aHViLmNvbS9zemltZWsvXG5cdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG5cdCAqL1xuXG5cdFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0ID0gZnVuY3Rpb24gKCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zICkge1xuXG5cdFx0dGhpcy51dWlkID0gVEhSRUUuTWF0aC5nZW5lcmF0ZVVVSUQoKTtcblxuXHRcdHRoaXMud2lkdGggPSB3aWR0aDtcblx0XHR0aGlzLmhlaWdodCA9IGhlaWdodDtcblxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0aWYgKCBvcHRpb25zLm1pbkZpbHRlciA9PT0gdW5kZWZpbmVkICkgb3B0aW9ucy5taW5GaWx0ZXIgPSBUSFJFRS5MaW5lYXJGaWx0ZXI7XG5cblx0XHR0aGlzLnRleHR1cmUgPSBuZXcgVEhSRUUuVGV4dHVyZSggdW5kZWZpbmVkLCB1bmRlZmluZWQsIG9wdGlvbnMud3JhcFMsIG9wdGlvbnMud3JhcFQsIG9wdGlvbnMubWFnRmlsdGVyLCBvcHRpb25zLm1pbkZpbHRlciwgb3B0aW9ucy5mb3JtYXQsIG9wdGlvbnMudHlwZSwgb3B0aW9ucy5hbmlzb3Ryb3B5ICk7XG5cblx0XHR0aGlzLmRlcHRoQnVmZmVyID0gb3B0aW9ucy5kZXB0aEJ1ZmZlciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kZXB0aEJ1ZmZlciA6IHRydWU7XG5cdFx0dGhpcy5zdGVuY2lsQnVmZmVyID0gb3B0aW9ucy5zdGVuY2lsQnVmZmVyICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnN0ZW5jaWxCdWZmZXIgOiB0cnVlO1xuXG5cdFx0dGhpcy5zaGFyZURlcHRoRnJvbSA9IG9wdGlvbnMuc2hhcmVEZXB0aEZyb20gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc2hhcmVEZXB0aEZyb20gOiBudWxsO1xuXG5cdH07XG5cblx0VEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQucHJvdG90eXBlID0ge1xuXG5cdFx0Y29uc3RydWN0b3I6IFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0LFxuXG5cdFx0Z2V0IHdyYXBTKCkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLndyYXBTIGlzIG5vdyAudGV4dHVyZS53cmFwUy4nICk7XG5cblx0XHRcdHJldHVybiB0aGlzLnRleHR1cmUud3JhcFM7XG5cblx0XHR9LFxuXG5cdFx0c2V0IHdyYXBTKCB2YWx1ZSApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC53cmFwUyBpcyBub3cgLnRleHR1cmUud3JhcFMuJyApO1xuXG5cdFx0XHR0aGlzLnRleHR1cmUud3JhcFMgPSB2YWx1ZTtcblxuXHRcdH0sXG5cblx0XHRnZXQgd3JhcFQoKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAud3JhcFQgaXMgbm93IC50ZXh0dXJlLndyYXBULicgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXMudGV4dHVyZS53cmFwVDtcblxuXHRcdH0sXG5cblx0XHRzZXQgd3JhcFQoIHZhbHVlICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLndyYXBUIGlzIG5vdyAudGV4dHVyZS53cmFwVC4nICk7XG5cblx0XHRcdHRoaXMudGV4dHVyZS53cmFwVCA9IHZhbHVlO1xuXG5cdFx0fSxcblxuXHRcdGdldCBtYWdGaWx0ZXIoKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAubWFnRmlsdGVyIGlzIG5vdyAudGV4dHVyZS5tYWdGaWx0ZXIuJyApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcy50ZXh0dXJlLm1hZ0ZpbHRlcjtcblxuXHRcdH0sXG5cblx0XHRzZXQgbWFnRmlsdGVyKCB2YWx1ZSApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5tYWdGaWx0ZXIgaXMgbm93IC50ZXh0dXJlLm1hZ0ZpbHRlci4nICk7XG5cblx0XHRcdHRoaXMudGV4dHVyZS5tYWdGaWx0ZXIgPSB2YWx1ZTtcblxuXHRcdH0sXG5cblx0XHRnZXQgbWluRmlsdGVyKCkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLm1pbkZpbHRlciBpcyBub3cgLnRleHR1cmUubWluRmlsdGVyLicgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXMudGV4dHVyZS5taW5GaWx0ZXI7XG5cblx0XHR9LFxuXG5cdFx0c2V0IG1pbkZpbHRlciggdmFsdWUgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAubWluRmlsdGVyIGlzIG5vdyAudGV4dHVyZS5taW5GaWx0ZXIuJyApO1xuXG5cdFx0XHR0aGlzLnRleHR1cmUubWluRmlsdGVyID0gdmFsdWU7XG5cblx0XHR9LFxuXG5cdFx0Z2V0IGFuaXNvdHJvcHkoKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAuYW5pc290cm9weSBpcyBub3cgLnRleHR1cmUuYW5pc290cm9weS4nICk7XG5cblx0XHRcdHJldHVybiB0aGlzLnRleHR1cmUuYW5pc290cm9weTtcblxuXHRcdH0sXG5cblx0XHRzZXQgYW5pc290cm9weSggdmFsdWUgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAuYW5pc290cm9weSBpcyBub3cgLnRleHR1cmUuYW5pc290cm9weS4nICk7XG5cblx0XHRcdHRoaXMudGV4dHVyZS5hbmlzb3Ryb3B5ID0gdmFsdWU7XG5cblx0XHR9LFxuXG5cdFx0Z2V0IG9mZnNldCgpIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5vZmZzZXQgaXMgbm93IC50ZXh0dXJlLm9mZnNldC4nICk7XG5cblx0XHRcdHJldHVybiB0aGlzLnRleHR1cmUub2Zmc2V0O1xuXG5cdFx0fSxcblxuXHRcdHNldCBvZmZzZXQoIHZhbHVlICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLm9mZnNldCBpcyBub3cgLnRleHR1cmUub2Zmc2V0LicgKTtcblxuXHRcdFx0dGhpcy50ZXh0dXJlLm9mZnNldCA9IHZhbHVlO1xuXG5cdFx0fSxcblxuXHRcdGdldCByZXBlYXQoKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAucmVwZWF0IGlzIG5vdyAudGV4dHVyZS5yZXBlYXQuJyApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcy50ZXh0dXJlLnJlcGVhdDtcblxuXHRcdH0sXG5cblx0XHRzZXQgcmVwZWF0KCB2YWx1ZSApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5yZXBlYXQgaXMgbm93IC50ZXh0dXJlLnJlcGVhdC4nICk7XG5cblx0XHRcdHRoaXMudGV4dHVyZS5yZXBlYXQgPSB2YWx1ZTtcblxuXHRcdH0sXG5cblx0XHRnZXQgZm9ybWF0KCkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLmZvcm1hdCBpcyBub3cgLnRleHR1cmUuZm9ybWF0LicgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXMudGV4dHVyZS5mb3JtYXQ7XG5cblx0XHR9LFxuXG5cdFx0c2V0IGZvcm1hdCggdmFsdWUgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAuZm9ybWF0IGlzIG5vdyAudGV4dHVyZS5mb3JtYXQuJyApO1xuXG5cdFx0XHR0aGlzLnRleHR1cmUuZm9ybWF0ID0gdmFsdWU7XG5cblx0XHR9LFxuXG5cdFx0Z2V0IHR5cGUoKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAudHlwZSBpcyBub3cgLnRleHR1cmUudHlwZS4nICk7XG5cblx0XHRcdHJldHVybiB0aGlzLnRleHR1cmUudHlwZTtcblxuXHRcdH0sXG5cblx0XHRzZXQgdHlwZSggdmFsdWUgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAudHlwZSBpcyBub3cgLnRleHR1cmUudHlwZS4nICk7XG5cblx0XHRcdHRoaXMudGV4dHVyZS50eXBlID0gdmFsdWU7XG5cblx0XHR9LFxuXG5cdFx0Z2V0IGdlbmVyYXRlTWlwbWFwcygpIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5nZW5lcmF0ZU1pcG1hcHMgaXMgbm93IC50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcy4nICk7XG5cblx0XHRcdHJldHVybiB0aGlzLnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzO1xuXG5cdFx0fSxcblxuXHRcdHNldCBnZW5lcmF0ZU1pcG1hcHMoIHZhbHVlICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLmdlbmVyYXRlTWlwbWFwcyBpcyBub3cgLnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzLicgKTtcblxuXHRcdFx0dGhpcy50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IHZhbHVlO1xuXG5cdFx0fSxcblxuXHRcdC8vXG5cblx0XHRzZXRTaXplOiBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQgKSB7XG5cblx0XHRcdGlmICggdGhpcy53aWR0aCAhPT0gd2lkdGggfHwgdGhpcy5oZWlnaHQgIT09IGhlaWdodCApIHtcblxuXHRcdFx0XHR0aGlzLndpZHRoID0gd2lkdGg7XG5cdFx0XHRcdHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG5cdFx0XHRcdHRoaXMuZGlzcG9zZSgpO1xuXG5cdFx0XHR9XG5cblx0XHR9LFxuXG5cdFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG5cdFx0fSxcblxuXHRcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xuXG5cdFx0XHR0aGlzLndpZHRoID0gc291cmNlLndpZHRoO1xuXHRcdFx0dGhpcy5oZWlnaHQgPSBzb3VyY2UuaGVpZ2h0O1xuXG5cdFx0XHR0aGlzLnRleHR1cmUgPSBzb3VyY2UudGV4dHVyZS5jbG9uZSgpO1xuXG5cdFx0XHR0aGlzLmRlcHRoQnVmZmVyID0gc291cmNlLmRlcHRoQnVmZmVyO1xuXHRcdFx0dGhpcy5zdGVuY2lsQnVmZmVyID0gc291cmNlLnN0ZW5jaWxCdWZmZXI7XG5cblx0XHRcdHRoaXMuc2hhcmVEZXB0aEZyb20gPSBzb3VyY2Uuc2hhcmVEZXB0aEZyb207XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdkaXNwb3NlJyB9ICk7XG5cblx0XHR9XG5cblx0fTtcblxuXHRUSFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmFwcGx5KCBUSFJFRS5XZWJHTFJlbmRlclRhcmdldC5wcm90b3R5cGUgKTtcblxuXHQvLyBGaWxlOnNyYy9yZW5kZXJlcnMvV2ViR0xSZW5kZXJUYXJnZXRDdWJlLmpzXG5cblx0LyoqXG5cdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb21cblx0ICovXG5cblx0VEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlID0gZnVuY3Rpb24gKCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zICkge1xuXG5cdFx0VEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQuY2FsbCggdGhpcywgd2lkdGgsIGhlaWdodCwgb3B0aW9ucyApO1xuXG5cdFx0dGhpcy5hY3RpdmVDdWJlRmFjZSA9IDA7IC8vIFBYIDAsIE5YIDEsIFBZIDIsIE5ZIDMsIFBaIDQsIE5aIDVcblxuXHR9O1xuXG5cdFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5XZWJHTFJlbmRlclRhcmdldC5wcm90b3R5cGUgKTtcblx0VEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZTtcblxuXHQvLyBGaWxlOnNyYy9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xCdWZmZXJSZW5kZXJlci5qc1xuXG5cdC8qKlxuXHQqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCovXG5cblx0VEhSRUUuV2ViR0xCdWZmZXJSZW5kZXJlciA9IGZ1bmN0aW9uICggX2dsLCBleHRlbnNpb25zLCBfaW5mb1JlbmRlciApIHtcblxuXHRcdHZhciBtb2RlO1xuXG5cdFx0ZnVuY3Rpb24gc2V0TW9kZSggdmFsdWUgKSB7XG5cblx0XHRcdG1vZGUgPSB2YWx1ZTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlbmRlciggc3RhcnQsIGNvdW50ICkge1xuXG5cdFx0XHRfZ2wuZHJhd0FycmF5cyggbW9kZSwgc3RhcnQsIGNvdW50ICk7XG5cblx0XHRcdF9pbmZvUmVuZGVyLmNhbGxzICsrO1xuXHRcdFx0X2luZm9SZW5kZXIudmVydGljZXMgKz0gY291bnQ7XG5cdFx0XHRpZiAoIG1vZGUgPT09IF9nbC5UUklBTkdMRVMgKSBfaW5mb1JlbmRlci5mYWNlcyArPSBjb3VudCAvIDM7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZW5kZXJJbnN0YW5jZXMoIGdlb21ldHJ5ICkge1xuXG5cdFx0XHR2YXIgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyApO1xuXG5cdFx0XHRpZiAoIGV4dGVuc2lvbiA9PT0gbnVsbCApIHtcblxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xCdWZmZXJSZW5kZXJlcjogdXNpbmcgVEhSRUUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgYnV0IGhhcmR3YXJlIGRvZXMgbm90IHN1cHBvcnQgZXh0ZW5zaW9uIEFOR0xFX2luc3RhbmNlZF9hcnJheXMuJyApO1xuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIHBvc2l0aW9uID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblxuXHRcdFx0aWYgKCBwb3NpdGlvbiBpbnN0YW5jZW9mIFRIUkVFLkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICkge1xuXG5cdFx0XHRcdGV4dGVuc2lvbi5kcmF3QXJyYXlzSW5zdGFuY2VkQU5HTEUoIG1vZGUsIDAsIHBvc2l0aW9uLmRhdGEuY291bnQsIGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0ZXh0ZW5zaW9uLmRyYXdBcnJheXNJbnN0YW5jZWRBTkdMRSggbW9kZSwgMCwgcG9zaXRpb24uY291bnQsIGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHRoaXMuc2V0TW9kZSA9IHNldE1vZGU7XG5cdFx0dGhpcy5yZW5kZXIgPSByZW5kZXI7XG5cdFx0dGhpcy5yZW5kZXJJbnN0YW5jZXMgPSByZW5kZXJJbnN0YW5jZXM7XG5cblx0fTtcblxuXHQvLyBGaWxlOnNyYy9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xJbmRleGVkQnVmZmVyUmVuZGVyZXIuanNcblxuXHQvKipcblx0KiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuXHQqL1xuXG5cdFRIUkVFLldlYkdMSW5kZXhlZEJ1ZmZlclJlbmRlcmVyID0gZnVuY3Rpb24gKCBfZ2wsIGV4dGVuc2lvbnMsIF9pbmZvUmVuZGVyICkge1xuXG5cdFx0dmFyIG1vZGU7XG5cblx0XHRmdW5jdGlvbiBzZXRNb2RlKCB2YWx1ZSApIHtcblxuXHRcdFx0bW9kZSA9IHZhbHVlO1xuXG5cdFx0fVxuXG5cdFx0dmFyIHR5cGUsIHNpemU7XG5cblx0XHRmdW5jdGlvbiBzZXRJbmRleCggaW5kZXggKSB7XG5cblx0XHRcdGlmICggaW5kZXguYXJyYXkgaW5zdGFuY2VvZiBVaW50MzJBcnJheSAmJiBleHRlbnNpb25zLmdldCggJ09FU19lbGVtZW50X2luZGV4X3VpbnQnICkgKSB7XG5cblx0XHRcdFx0dHlwZSA9IF9nbC5VTlNJR05FRF9JTlQ7XG5cdFx0XHRcdHNpemUgPSA0O1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHR5cGUgPSBfZ2wuVU5TSUdORURfU0hPUlQ7XG5cdFx0XHRcdHNpemUgPSAyO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZW5kZXIoIHN0YXJ0LCBjb3VudCApIHtcblxuXHRcdFx0X2dsLmRyYXdFbGVtZW50cyggbW9kZSwgY291bnQsIHR5cGUsIHN0YXJ0ICogc2l6ZSApO1xuXG5cdFx0XHRfaW5mb1JlbmRlci5jYWxscyArKztcblx0XHRcdF9pbmZvUmVuZGVyLnZlcnRpY2VzICs9IGNvdW50O1xuXHRcdFx0aWYgKCBtb2RlID09PSBfZ2wuVFJJQU5HTEVTICkgX2luZm9SZW5kZXIuZmFjZXMgKz0gY291bnQgLyAzO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVuZGVySW5zdGFuY2VzKCBnZW9tZXRyeSApIHtcblxuXHRcdFx0dmFyIGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnQU5HTEVfaW5zdGFuY2VkX2FycmF5cycgKTtcblxuXHRcdFx0aWYgKCBleHRlbnNpb24gPT09IG51bGwgKSB7XG5cblx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMQnVmZmVyUmVuZGVyZXI6IHVzaW5nIFRIUkVFLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5IGJ1dCBoYXJkd2FyZSBkb2VzIG5vdCBzdXBwb3J0IGV4dGVuc2lvbiBBTkdMRV9pbnN0YW5jZWRfYXJyYXlzLicgKTtcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBpbmRleCA9IGdlb21ldHJ5LmluZGV4O1xuXG5cdFx0XHRleHRlbnNpb24uZHJhd0VsZW1lbnRzSW5zdGFuY2VkQU5HTEUoIG1vZGUsIGluZGV4LmFycmF5Lmxlbmd0aCwgdHlwZSwgMCwgZ2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuc2V0TW9kZSA9IHNldE1vZGU7XG5cdFx0dGhpcy5zZXRJbmRleCA9IHNldEluZGV4O1xuXHRcdHRoaXMucmVuZGVyID0gcmVuZGVyO1xuXHRcdHRoaXMucmVuZGVySW5zdGFuY2VzID0gcmVuZGVySW5zdGFuY2VzO1xuXG5cdH07XG5cblx0Ly8gRmlsZTpzcmMvcmVuZGVyZXJzL3dlYmdsL1dlYkdMRXh0ZW5zaW9ucy5qc1xuXG5cdC8qKlxuXHQqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCovXG5cblx0VEhSRUUuV2ViR0xFeHRlbnNpb25zID0gZnVuY3Rpb24gKCBnbCApIHtcblxuXHRcdHZhciBleHRlbnNpb25zID0ge307XG5cblx0XHR0aGlzLmdldCA9IGZ1bmN0aW9uICggbmFtZSApIHtcblxuXHRcdFx0aWYgKCBleHRlbnNpb25zWyBuYW1lIF0gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRyZXR1cm4gZXh0ZW5zaW9uc1sgbmFtZSBdO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBleHRlbnNpb247XG5cblx0XHRcdHN3aXRjaCAoIG5hbWUgKSB7XG5cblx0XHRcdFx0Y2FzZSAnRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJzpcblx0XHRcdFx0XHRleHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oICdFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnICkgfHwgZ2wuZ2V0RXh0ZW5zaW9uKCAnTU9aX0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycgKSB8fCBnbC5nZXRFeHRlbnNpb24oICdXRUJLSVRfRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJyApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJzpcblx0XHRcdFx0XHRleHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycgKSB8fCBnbC5nZXRFeHRlbnNpb24oICdNT1pfV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnICkgfHwgZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCS0lUX1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJyApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0Yyc6XG5cdFx0XHRcdFx0ZXh0ZW5zaW9uID0gZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJyApIHx8IGdsLmdldEV4dGVuc2lvbiggJ1dFQktJVF9XRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRleHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oIG5hbWUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGV4dGVuc2lvbiA9PT0gbnVsbCApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAnICsgbmFtZSArICcgZXh0ZW5zaW9uIG5vdCBzdXBwb3J0ZWQuJyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGV4dGVuc2lvbnNbIG5hbWUgXSA9IGV4dGVuc2lvbjtcblxuXHRcdFx0cmV0dXJuIGV4dGVuc2lvbjtcblxuXHRcdH07XG5cblx0fTtcblxuXHQvLyBGaWxlOnNyYy9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xDYXBhYmlsaXRpZXMuanNcblxuXHRUSFJFRS5XZWJHTENhcGFiaWxpdGllcyA9IGZ1bmN0aW9uICggZ2wsIGV4dGVuc2lvbnMsIHBhcmFtZXRlcnMgKSB7XG5cblx0XHRmdW5jdGlvbiBnZXRNYXhQcmVjaXNpb24oIHByZWNpc2lvbiApIHtcblxuXHRcdFx0aWYgKCBwcmVjaXNpb24gPT09ICdoaWdocCcgKSB7XG5cblx0XHRcdFx0aWYgKCBnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoIGdsLlZFUlRFWF9TSEFERVIsIGdsLkhJR0hfRkxPQVQgKS5wcmVjaXNpb24gPiAwICYmXG5cdFx0XHRcdCAgICAgZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KCBnbC5GUkFHTUVOVF9TSEFERVIsIGdsLkhJR0hfRkxPQVQgKS5wcmVjaXNpb24gPiAwICkge1xuXG5cdFx0XHRcdFx0cmV0dXJuICdoaWdocCc7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHByZWNpc2lvbiA9ICdtZWRpdW1wJztcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHByZWNpc2lvbiA9PT0gJ21lZGl1bXAnICkge1xuXG5cdFx0XHRcdGlmICggZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KCBnbC5WRVJURVhfU0hBREVSLCBnbC5NRURJVU1fRkxPQVQgKS5wcmVjaXNpb24gPiAwICYmXG5cdFx0XHRcdCAgICAgZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KCBnbC5GUkFHTUVOVF9TSEFERVIsIGdsLk1FRElVTV9GTE9BVCApLnByZWNpc2lvbiA+IDAgKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gJ21lZGl1bXAnO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gJ2xvd3AnO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5nZXRNYXhQcmVjaXNpb24gPSBnZXRNYXhQcmVjaXNpb247XG5cblx0XHR0aGlzLnByZWNpc2lvbiA9IHBhcmFtZXRlcnMucHJlY2lzaW9uICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLnByZWNpc2lvbiA6ICdoaWdocCcsXG5cdFx0dGhpcy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyID0gcGFyYW1ldGVycy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgOiBmYWxzZTtcblxuXHRcdHRoaXMubWF4VGV4dHVyZXMgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9URVhUVVJFX0lNQUdFX1VOSVRTICk7XG5cdFx0dGhpcy5tYXhWZXJ0ZXhUZXh0dXJlcyA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1ZFUlRFWF9URVhUVVJFX0lNQUdFX1VOSVRTICk7XG5cdFx0dGhpcy5tYXhUZXh0dXJlU2l6ZSA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1RFWFRVUkVfU0laRSApO1xuXHRcdHRoaXMubWF4Q3ViZW1hcFNpemUgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9DVUJFX01BUF9URVhUVVJFX1NJWkUgKTtcblxuXHRcdHRoaXMubWF4QXR0cmlidXRlcyA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1ZFUlRFWF9BVFRSSUJTICk7XG5cdFx0dGhpcy5tYXhWZXJ0ZXhVbmlmb3JtcyA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1ZFUlRFWF9VTklGT1JNX1ZFQ1RPUlMgKTtcblx0XHR0aGlzLm1heFZhcnlpbmdzID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfVkFSWUlOR19WRUNUT1JTICk7XG5cdFx0dGhpcy5tYXhGcmFnbWVudFVuaWZvcm1zID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfRlJBR01FTlRfVU5JRk9STV9WRUNUT1JTICk7XG5cblx0XHR0aGlzLnZlcnRleFRleHR1cmVzID0gdGhpcy5tYXhWZXJ0ZXhUZXh0dXJlcyA+IDA7XG5cdFx0dGhpcy5mbG9hdEZyYWdtZW50VGV4dHVyZXMgPSAhISBleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2Zsb2F0JyApO1xuXHRcdHRoaXMuZmxvYXRWZXJ0ZXhUZXh0dXJlcyA9IHRoaXMudmVydGV4VGV4dHVyZXMgJiYgdGhpcy5mbG9hdEZyYWdtZW50VGV4dHVyZXM7XG5cblx0XHR2YXIgX21heFByZWNpc2lvbiA9IGdldE1heFByZWNpc2lvbiggdGhpcy5wcmVjaXNpb24gKTtcblxuXHRcdGlmICggX21heFByZWNpc2lvbiAhPT0gdGhpcy5wcmVjaXNpb24gKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6JywgdGhpcy5wcmVjaXNpb24sICdub3Qgc3VwcG9ydGVkLCB1c2luZycsIF9tYXhQcmVjaXNpb24sICdpbnN0ZWFkLicgKTtcblx0XHRcdHRoaXMucHJlY2lzaW9uID0gX21heFByZWNpc2lvbjtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyICkge1xuXG5cdFx0XHR0aGlzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgPSAhISBleHRlbnNpb25zLmdldCggJ0VYVF9mcmFnX2RlcHRoJyApO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0Ly8gRmlsZTpzcmMvcmVuZGVyZXJzL3dlYmdsL1dlYkdMR2VvbWV0cmllcy5qc1xuXG5cdC8qKlxuXHQqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCovXG5cblx0VEhSRUUuV2ViR0xHZW9tZXRyaWVzID0gZnVuY3Rpb24gKCBnbCwgcHJvcGVydGllcywgaW5mbyApIHtcblxuXHRcdHZhciBnZW9tZXRyaWVzID0ge307XG5cblx0XHRmdW5jdGlvbiBnZXQoIG9iamVjdCApIHtcblxuXHRcdFx0dmFyIGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xuXG5cdFx0XHRpZiAoIGdlb21ldHJpZXNbIGdlb21ldHJ5LmlkIF0gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRyZXR1cm4gZ2VvbWV0cmllc1sgZ2VvbWV0cnkuaWQgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRnZW9tZXRyeS5hZGRFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uR2VvbWV0cnlEaXNwb3NlICk7XG5cblx0XHRcdHZhciBidWZmZXJnZW9tZXRyeTtcblxuXHRcdFx0aWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5ICkge1xuXG5cdFx0XHRcdGJ1ZmZlcmdlb21ldHJ5ID0gZ2VvbWV0cnk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuR2VvbWV0cnkgKSB7XG5cblx0XHRcdFx0aWYgKCBnZW9tZXRyeS5fYnVmZmVyR2VvbWV0cnkgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGdlb21ldHJ5Ll9idWZmZXJHZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpLnNldEZyb21PYmplY3QoIG9iamVjdCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRidWZmZXJnZW9tZXRyeSA9IGdlb21ldHJ5Ll9idWZmZXJHZW9tZXRyeTtcblxuXHRcdFx0fVxuXG5cdFx0XHRnZW9tZXRyaWVzWyBnZW9tZXRyeS5pZCBdID0gYnVmZmVyZ2VvbWV0cnk7XG5cblx0XHRcdGluZm8ubWVtb3J5Lmdlb21ldHJpZXMgKys7XG5cblx0XHRcdHJldHVybiBidWZmZXJnZW9tZXRyeTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG9uR2VvbWV0cnlEaXNwb3NlKCBldmVudCApIHtcblxuXHRcdFx0dmFyIGdlb21ldHJ5ID0gZXZlbnQudGFyZ2V0O1xuXHRcdFx0dmFyIGJ1ZmZlcmdlb21ldHJ5ID0gZ2VvbWV0cmllc1sgZ2VvbWV0cnkuaWQgXTtcblxuXHRcdFx0ZGVsZXRlQXR0cmlidXRlcyggYnVmZmVyZ2VvbWV0cnkuYXR0cmlidXRlcyApO1xuXG5cdFx0XHRnZW9tZXRyeS5yZW1vdmVFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uR2VvbWV0cnlEaXNwb3NlICk7XG5cblx0XHRcdGRlbGV0ZSBnZW9tZXRyaWVzWyBnZW9tZXRyeS5pZCBdO1xuXG5cdFx0XHR2YXIgcHJvcGVydHkgPSBwcm9wZXJ0aWVzLmdldCggZ2VvbWV0cnkgKTtcblx0XHRcdGlmICggcHJvcGVydHkud2lyZWZyYW1lICkgZGVsZXRlQXR0cmlidXRlKCBwcm9wZXJ0eS53aXJlZnJhbWUgKTtcblxuXHRcdFx0aW5mby5tZW1vcnkuZ2VvbWV0cmllcyAtLTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldEF0dHJpYnV0ZUJ1ZmZlciggYXR0cmlidXRlICkge1xuXG5cdFx0XHRpZiAoIGF0dHJpYnV0ZSBpbnN0YW5jZW9mIFRIUkVFLkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICkge1xuXG5cdFx0XHRcdHJldHVybiBwcm9wZXJ0aWVzLmdldCggYXR0cmlidXRlLmRhdGEgKS5fX3dlYmdsQnVmZmVyO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBwcm9wZXJ0aWVzLmdldCggYXR0cmlidXRlICkuX193ZWJnbEJ1ZmZlcjtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGRlbGV0ZUF0dHJpYnV0ZSggYXR0cmlidXRlICkge1xuXG5cdFx0XHR2YXIgYnVmZmVyID0gZ2V0QXR0cmlidXRlQnVmZmVyKCBhdHRyaWJ1dGUgKTtcblxuXHRcdFx0aWYgKCBidWZmZXIgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRnbC5kZWxldGVCdWZmZXIoIGJ1ZmZlciApO1xuXHRcdFx0XHRyZW1vdmVBdHRyaWJ1dGVCdWZmZXIoIGF0dHJpYnV0ZSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBkZWxldGVBdHRyaWJ1dGVzKCBhdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRmb3IgKCB2YXIgbmFtZSBpbiBhdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRcdGRlbGV0ZUF0dHJpYnV0ZSggYXR0cmlidXRlc1sgbmFtZSBdICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlbW92ZUF0dHJpYnV0ZUJ1ZmZlciggYXR0cmlidXRlICkge1xuXG5cdFx0XHRpZiAoIGF0dHJpYnV0ZSBpbnN0YW5jZW9mIFRIUkVFLkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICkge1xuXG5cdFx0XHRcdHByb3BlcnRpZXMuZGVsZXRlKCBhdHRyaWJ1dGUuZGF0YSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHByb3BlcnRpZXMuZGVsZXRlKCBhdHRyaWJ1dGUgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0dGhpcy5nZXQgPSBnZXQ7XG5cblx0fTtcblxuXHQvLyBGaWxlOnNyYy9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xPYmplY3RzLmpzXG5cblx0LyoqXG5cdCogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0Ki9cblxuXHRUSFJFRS5XZWJHTE9iamVjdHMgPSBmdW5jdGlvbiAoIGdsLCBwcm9wZXJ0aWVzLCBpbmZvICkge1xuXG5cdFx0dmFyIGdlb21ldHJpZXMgPSBuZXcgVEhSRUUuV2ViR0xHZW9tZXRyaWVzKCBnbCwgcHJvcGVydGllcywgaW5mbyApO1xuXG5cdFx0Ly9cblxuXHRcdGZ1bmN0aW9uIHVwZGF0ZSggb2JqZWN0ICkge1xuXG5cdFx0XHQvLyBUT0RPOiBBdm9pZCB1cGRhdGluZyB0d2ljZSAod2hlbiB1c2luZyBzaGFkb3dNYXApLiBNYXliZSBhZGQgZnJhbWUgY291bnRlci5cblxuXHRcdFx0dmFyIGdlb21ldHJ5ID0gZ2VvbWV0cmllcy5nZXQoIG9iamVjdCApO1xuXG5cdFx0XHRpZiAoIG9iamVjdC5nZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5ICkge1xuXG5cdFx0XHRcdGdlb21ldHJ5LnVwZGF0ZUZyb21PYmplY3QoIG9iamVjdCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBpbmRleCA9IGdlb21ldHJ5LmluZGV4O1xuXHRcdFx0dmFyIGF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xuXG5cdFx0XHRpZiAoIGluZGV4ICE9PSBudWxsICkge1xuXG5cdFx0XHRcdHVwZGF0ZUF0dHJpYnV0ZSggaW5kZXgsIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggdmFyIG5hbWUgaW4gYXR0cmlidXRlcyApIHtcblxuXHRcdFx0XHR1cGRhdGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXNbIG5hbWUgXSwgZ2wuQVJSQVlfQlVGRkVSICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gbW9ycGggdGFyZ2V0c1xuXG5cdFx0XHR2YXIgbW9ycGhBdHRyaWJ1dGVzID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzO1xuXG5cdFx0XHRmb3IgKCB2YXIgbmFtZSBpbiBtb3JwaEF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdFx0dmFyIGFycmF5ID0gbW9ycGhBdHRyaWJ1dGVzWyBuYW1lIF07XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gYXJyYXkubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHVwZGF0ZUF0dHJpYnV0ZSggYXJyYXlbIGkgXSwgZ2wuQVJSQVlfQlVGRkVSICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBnZW9tZXRyeTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHVwZGF0ZUF0dHJpYnV0ZSggYXR0cmlidXRlLCBidWZmZXJUeXBlICkge1xuXG5cdFx0XHR2YXIgZGF0YSA9ICggYXR0cmlidXRlIGluc3RhbmNlb2YgVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSA/IGF0dHJpYnV0ZS5kYXRhIDogYXR0cmlidXRlO1xuXG5cdFx0XHR2YXIgYXR0cmlidXRlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCBkYXRhICk7XG5cblx0XHRcdGlmICggYXR0cmlidXRlUHJvcGVydGllcy5fX3dlYmdsQnVmZmVyID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Y3JlYXRlQnVmZmVyKCBhdHRyaWJ1dGVQcm9wZXJ0aWVzLCBkYXRhLCBidWZmZXJUeXBlICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGF0dHJpYnV0ZVByb3BlcnRpZXMudmVyc2lvbiAhPT0gZGF0YS52ZXJzaW9uICkge1xuXG5cdFx0XHRcdHVwZGF0ZUJ1ZmZlciggYXR0cmlidXRlUHJvcGVydGllcywgZGF0YSwgYnVmZmVyVHlwZSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjcmVhdGVCdWZmZXIoIGF0dHJpYnV0ZVByb3BlcnRpZXMsIGRhdGEsIGJ1ZmZlclR5cGUgKSB7XG5cblx0XHRcdGF0dHJpYnV0ZVByb3BlcnRpZXMuX193ZWJnbEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuXHRcdFx0Z2wuYmluZEJ1ZmZlciggYnVmZmVyVHlwZSwgYXR0cmlidXRlUHJvcGVydGllcy5fX3dlYmdsQnVmZmVyICk7XG5cblx0XHRcdHZhciB1c2FnZSA9IGRhdGEuZHluYW1pYyA/IGdsLkRZTkFNSUNfRFJBVyA6IGdsLlNUQVRJQ19EUkFXO1xuXG5cdFx0XHRnbC5idWZmZXJEYXRhKCBidWZmZXJUeXBlLCBkYXRhLmFycmF5LCB1c2FnZSApO1xuXG5cdFx0XHRhdHRyaWJ1dGVQcm9wZXJ0aWVzLnZlcnNpb24gPSBkYXRhLnZlcnNpb247XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiB1cGRhdGVCdWZmZXIoIGF0dHJpYnV0ZVByb3BlcnRpZXMsIGRhdGEsIGJ1ZmZlclR5cGUgKSB7XG5cblx0XHRcdGdsLmJpbmRCdWZmZXIoIGJ1ZmZlclR5cGUsIGF0dHJpYnV0ZVByb3BlcnRpZXMuX193ZWJnbEJ1ZmZlciApO1xuXG5cdFx0XHRpZiAoIGRhdGEuZHluYW1pYyA9PT0gZmFsc2UgfHwgZGF0YS51cGRhdGVSYW5nZS5jb3VudCA9PT0gLSAxICkge1xuXG5cdFx0XHRcdC8vIE5vdCB1c2luZyB1cGRhdGUgcmFuZ2VzXG5cblx0XHRcdFx0Z2wuYnVmZmVyU3ViRGF0YSggYnVmZmVyVHlwZSwgMCwgZGF0YS5hcnJheSApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBkYXRhLnVwZGF0ZVJhbmdlLmNvdW50ID09PSAwICkge1xuXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTE9iamVjdHMudXBkYXRlQnVmZmVyOiBkeW5hbWljIFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSBtYXJrZWQgYXMgbmVlZHNVcGRhdGUgYnV0IHVwZGF0ZVJhbmdlLmNvdW50IGlzIDAsIGVuc3VyZSB5b3UgYXJlIHVzaW5nIHNldCBtZXRob2RzIG9yIHVwZGF0aW5nIG1hbnVhbGx5LicgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRnbC5idWZmZXJTdWJEYXRhKCBidWZmZXJUeXBlLCBkYXRhLnVwZGF0ZVJhbmdlLm9mZnNldCAqIGRhdGEuYXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG5cdFx0XHRcdFx0XHRcdFx0ICBkYXRhLmFycmF5LnN1YmFycmF5KCBkYXRhLnVwZGF0ZVJhbmdlLm9mZnNldCwgZGF0YS51cGRhdGVSYW5nZS5vZmZzZXQgKyBkYXRhLnVwZGF0ZVJhbmdlLmNvdW50ICkgKTtcblxuXHRcdFx0XHRkYXRhLnVwZGF0ZVJhbmdlLmNvdW50ID0gMDsgLy8gcmVzZXQgcmFuZ2VcblxuXHRcdFx0fVxuXG5cdFx0XHRhdHRyaWJ1dGVQcm9wZXJ0aWVzLnZlcnNpb24gPSBkYXRhLnZlcnNpb247XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRBdHRyaWJ1dGVCdWZmZXIoIGF0dHJpYnV0ZSApIHtcblxuXHRcdFx0aWYgKCBhdHRyaWJ1dGUgaW5zdGFuY2VvZiBUSFJFRS5JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSApIHtcblxuXHRcdFx0XHRyZXR1cm4gcHJvcGVydGllcy5nZXQoIGF0dHJpYnV0ZS5kYXRhICkuX193ZWJnbEJ1ZmZlcjtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcHJvcGVydGllcy5nZXQoIGF0dHJpYnV0ZSApLl9fd2ViZ2xCdWZmZXI7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRXaXJlZnJhbWVBdHRyaWJ1dGUoIGdlb21ldHJ5ICkge1xuXG5cdFx0XHR2YXIgcHJvcGVydHkgPSBwcm9wZXJ0aWVzLmdldCggZ2VvbWV0cnkgKTtcblxuXHRcdFx0aWYgKCBwcm9wZXJ0eS53aXJlZnJhbWUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRyZXR1cm4gcHJvcGVydHkud2lyZWZyYW1lO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBpbmRpY2VzID0gW107XG5cblx0XHRcdHZhciBpbmRleCA9IGdlb21ldHJ5LmluZGV4O1xuXHRcdFx0dmFyIGF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xuXHRcdFx0dmFyIHBvc2l0aW9uID0gYXR0cmlidXRlcy5wb3NpdGlvbjtcblxuXHRcdFx0Ly8gY29uc29sZS50aW1lKCAnd2lyZWZyYW1lJyApO1xuXG5cdFx0XHRpZiAoIGluZGV4ICE9PSBudWxsICkge1xuXG5cdFx0XHRcdHZhciBlZGdlcyA9IHt9O1xuXHRcdFx0XHR2YXIgYXJyYXkgPSBpbmRleC5hcnJheTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBhcnJheS5sZW5ndGg7IGkgPCBsOyBpICs9IDMgKSB7XG5cblx0XHRcdFx0XHR2YXIgYSA9IGFycmF5WyBpICsgMCBdO1xuXHRcdFx0XHRcdHZhciBiID0gYXJyYXlbIGkgKyAxIF07XG5cdFx0XHRcdFx0dmFyIGMgPSBhcnJheVsgaSArIDIgXTtcblxuXHRcdFx0XHRcdGlmICggY2hlY2tFZGdlKCBlZGdlcywgYSwgYiApICkgaW5kaWNlcy5wdXNoKCBhLCBiICk7XG5cdFx0XHRcdFx0aWYgKCBjaGVja0VkZ2UoIGVkZ2VzLCBiLCBjICkgKSBpbmRpY2VzLnB1c2goIGIsIGMgKTtcblx0XHRcdFx0XHRpZiAoIGNoZWNrRWRnZSggZWRnZXMsIGMsIGEgKSApIGluZGljZXMucHVzaCggYywgYSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR2YXIgYXJyYXkgPSBhdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9ICggYXJyYXkubGVuZ3RoIC8gMyApIC0gMTsgaSA8IGw7IGkgKz0gMyApIHtcblxuXHRcdFx0XHRcdHZhciBhID0gaSArIDA7XG5cdFx0XHRcdFx0dmFyIGIgPSBpICsgMTtcblx0XHRcdFx0XHR2YXIgYyA9IGkgKyAyO1xuXG5cdFx0XHRcdFx0aW5kaWNlcy5wdXNoKCBhLCBiLCBiLCBjLCBjLCBhICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGNvbnNvbGUudGltZUVuZCggJ3dpcmVmcmFtZScgKTtcblxuXHRcdFx0dmFyIFR5cGVBcnJheSA9IHBvc2l0aW9uLmNvdW50ID4gNjU1MzUgPyBVaW50MzJBcnJheSA6IFVpbnQxNkFycmF5O1xuXHRcdFx0dmFyIGF0dHJpYnV0ZSA9IG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBUeXBlQXJyYXkoIGluZGljZXMgKSwgMSApO1xuXG5cdFx0XHR1cGRhdGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZSwgZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIgKTtcblxuXHRcdFx0cHJvcGVydHkud2lyZWZyYW1lID0gYXR0cmlidXRlO1xuXG5cdFx0XHRyZXR1cm4gYXR0cmlidXRlO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY2hlY2tFZGdlKCBlZGdlcywgYSwgYiApIHtcblxuXHRcdFx0aWYgKCBhID4gYiApIHtcblxuXHRcdFx0XHR2YXIgdG1wID0gYTtcblx0XHRcdFx0YSA9IGI7XG5cdFx0XHRcdGIgPSB0bXA7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIGxpc3QgPSBlZGdlc1sgYSBdO1xuXG5cdFx0XHRpZiAoIGxpc3QgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRlZGdlc1sgYSBdID0gWyBiIF07XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBsaXN0LmluZGV4T2YoIGIgKSA9PT0gLTEgKSB7XG5cblx0XHRcdFx0bGlzdC5wdXNoKCBiICk7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdH1cblxuXHRcdHRoaXMuZ2V0QXR0cmlidXRlQnVmZmVyID0gZ2V0QXR0cmlidXRlQnVmZmVyO1xuXHRcdHRoaXMuZ2V0V2lyZWZyYW1lQXR0cmlidXRlID0gZ2V0V2lyZWZyYW1lQXR0cmlidXRlO1xuXG5cdFx0dGhpcy51cGRhdGUgPSB1cGRhdGU7XG5cblx0fTtcblxuXHQvLyBGaWxlOnNyYy9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xQcm9ncmFtLmpzXG5cblx0VEhSRUUuV2ViR0xQcm9ncmFtID0gKCBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgcHJvZ3JhbUlkQ291bnQgPSAwO1xuXG5cdFx0ZnVuY3Rpb24gZ2VuZXJhdGVEZWZpbmVzKCBkZWZpbmVzICkge1xuXG5cdFx0XHR2YXIgY2h1bmtzID0gW107XG5cblx0XHRcdGZvciAoIHZhciBuYW1lIGluIGRlZmluZXMgKSB7XG5cblx0XHRcdFx0dmFyIHZhbHVlID0gZGVmaW5lc1sgbmFtZSBdO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgPT09IGZhbHNlICkgY29udGludWU7XG5cblx0XHRcdFx0Y2h1bmtzLnB1c2goICcjZGVmaW5lICcgKyBuYW1lICsgJyAnICsgdmFsdWUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gY2h1bmtzLmpvaW4oICdcXG4nICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBmZXRjaFVuaWZvcm1Mb2NhdGlvbnMoIGdsLCBwcm9ncmFtLCBpZGVudGlmaWVycyApIHtcblxuXHRcdFx0dmFyIHVuaWZvcm1zID0ge307XG5cblx0XHRcdHZhciBuID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlciggcHJvZ3JhbSwgZ2wuQUNUSVZFX1VOSUZPUk1TICk7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IG47IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGluZm8gPSBnbC5nZXRBY3RpdmVVbmlmb3JtKCBwcm9ncmFtLCBpICk7XG5cdFx0XHRcdHZhciBuYW1lID0gaW5mby5uYW1lO1xuXHRcdFx0XHR2YXIgbG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sIG5hbWUgKTtcblxuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyhcIlRIUkVFLldlYkdMUHJvZ3JhbTogQUNUSVZFIFVOSUZPUk06XCIsIG5hbWUpO1xuXG5cdFx0XHRcdHZhciBzdWZmaXhQb3MgPSBuYW1lLmxhc3RJbmRleE9mKCAnWzBdJyApO1xuXHRcdFx0XHRpZiAoIHN1ZmZpeFBvcyAhPT0gLSAxICYmIHN1ZmZpeFBvcyA9PT0gbmFtZS5sZW5ndGggLSAzICkge1xuXG5cdFx0XHRcdFx0dW5pZm9ybXNbIG5hbWUuc3Vic3RyKCAwLCBzdWZmaXhQb3MgKSBdID0gbG9jYXRpb247XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHVuaWZvcm1zWyBuYW1lIF0gPSBsb2NhdGlvbjtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdW5pZm9ybXM7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBmZXRjaEF0dHJpYnV0ZUxvY2F0aW9ucyggZ2wsIHByb2dyYW0sIGlkZW50aWZpZXJzICkge1xuXG5cdFx0XHR2YXIgYXR0cmlidXRlcyA9IHt9O1xuXG5cdFx0XHR2YXIgbiA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIoIHByb2dyYW0sIGdsLkFDVElWRV9BVFRSSUJVVEVTICk7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IG47IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGluZm8gPSBnbC5nZXRBY3RpdmVBdHRyaWIoIHByb2dyYW0sIGkgKTtcblx0XHRcdFx0dmFyIG5hbWUgPSBpbmZvLm5hbWU7XG5cblx0XHRcdFx0Ly8gY29uc29sZS5sb2coXCJUSFJFRS5XZWJHTFByb2dyYW06IEFDVElWRSBWRVJURVggQVRUUklCVVRFOlwiLCBuYW1lLCBpICk7XG5cblx0XHRcdFx0YXR0cmlidXRlc1sgbmFtZSBdID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24oIHByb2dyYW0sIG5hbWUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYXR0cmlidXRlcztcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGZpbHRlckVtcHR5TGluZSggc3RyaW5nICkge1xuXG5cdFx0XHRyZXR1cm4gc3RyaW5nICE9PSAnJztcblxuXHRcdH1cblxuXHRcdHJldHVybiBmdW5jdGlvbiBXZWJHTFByb2dyYW0oIHJlbmRlcmVyLCBjb2RlLCBtYXRlcmlhbCwgcGFyYW1ldGVycyApIHtcblxuXHRcdFx0dmFyIGdsID0gcmVuZGVyZXIuY29udGV4dDtcblxuXHRcdFx0dmFyIGRlZmluZXMgPSBtYXRlcmlhbC5kZWZpbmVzO1xuXG5cdFx0XHR2YXIgdmVydGV4U2hhZGVyID0gbWF0ZXJpYWwuX193ZWJnbFNoYWRlci52ZXJ0ZXhTaGFkZXI7XG5cdFx0XHR2YXIgZnJhZ21lbnRTaGFkZXIgPSBtYXRlcmlhbC5fX3dlYmdsU2hhZGVyLmZyYWdtZW50U2hhZGVyO1xuXG5cdFx0XHR2YXIgc2hhZG93TWFwVHlwZURlZmluZSA9ICdTSEFET1dNQVBfVFlQRV9CQVNJQyc7XG5cblx0XHRcdGlmICggcGFyYW1ldGVycy5zaGFkb3dNYXBUeXBlID09PSBUSFJFRS5QQ0ZTaGFkb3dNYXAgKSB7XG5cblx0XHRcdFx0c2hhZG93TWFwVHlwZURlZmluZSA9ICdTSEFET1dNQVBfVFlQRV9QQ0YnO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBwYXJhbWV0ZXJzLnNoYWRvd01hcFR5cGUgPT09IFRIUkVFLlBDRlNvZnRTaGFkb3dNYXAgKSB7XG5cblx0XHRcdFx0c2hhZG93TWFwVHlwZURlZmluZSA9ICdTSEFET1dNQVBfVFlQRV9QQ0ZfU09GVCc7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIGVudk1hcFR5cGVEZWZpbmUgPSAnRU5WTUFQX1RZUEVfQ1VCRSc7XG5cdFx0XHR2YXIgZW52TWFwTW9kZURlZmluZSA9ICdFTlZNQVBfTU9ERV9SRUZMRUNUSU9OJztcblx0XHRcdHZhciBlbnZNYXBCbGVuZGluZ0RlZmluZSA9ICdFTlZNQVBfQkxFTkRJTkdfTVVMVElQTFknO1xuXG5cdFx0XHRpZiAoIHBhcmFtZXRlcnMuZW52TWFwICkge1xuXG5cdFx0XHRcdHN3aXRjaCAoIG1hdGVyaWFsLmVudk1hcC5tYXBwaW5nICkge1xuXG5cdFx0XHRcdFx0Y2FzZSBUSFJFRS5DdWJlUmVmbGVjdGlvbk1hcHBpbmc6XG5cdFx0XHRcdFx0Y2FzZSBUSFJFRS5DdWJlUmVmcmFjdGlvbk1hcHBpbmc6XG5cdFx0XHRcdFx0XHRlbnZNYXBUeXBlRGVmaW5lID0gJ0VOVk1BUF9UWVBFX0NVQkUnO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlIFRIUkVFLkVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nOlxuXHRcdFx0XHRcdGNhc2UgVEhSRUUuRXF1aXJlY3Rhbmd1bGFyUmVmcmFjdGlvbk1hcHBpbmc6XG5cdFx0XHRcdFx0XHRlbnZNYXBUeXBlRGVmaW5lID0gJ0VOVk1BUF9UWVBFX0VRVUlSRUMnO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlIFRIUkVFLlNwaGVyaWNhbFJlZmxlY3Rpb25NYXBwaW5nOlxuXHRcdFx0XHRcdFx0ZW52TWFwVHlwZURlZmluZSA9ICdFTlZNQVBfVFlQRV9TUEhFUkUnO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHN3aXRjaCAoIG1hdGVyaWFsLmVudk1hcC5tYXBwaW5nICkge1xuXG5cdFx0XHRcdFx0Y2FzZSBUSFJFRS5DdWJlUmVmcmFjdGlvbk1hcHBpbmc6XG5cdFx0XHRcdFx0Y2FzZSBUSFJFRS5FcXVpcmVjdGFuZ3VsYXJSZWZyYWN0aW9uTWFwcGluZzpcblx0XHRcdFx0XHRcdGVudk1hcE1vZGVEZWZpbmUgPSAnRU5WTUFQX01PREVfUkVGUkFDVElPTic7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0c3dpdGNoICggbWF0ZXJpYWwuY29tYmluZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgVEhSRUUuTXVsdGlwbHlPcGVyYXRpb246XG5cdFx0XHRcdFx0XHRlbnZNYXBCbGVuZGluZ0RlZmluZSA9ICdFTlZNQVBfQkxFTkRJTkdfTVVMVElQTFknO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlIFRIUkVFLk1peE9wZXJhdGlvbjpcblx0XHRcdFx0XHRcdGVudk1hcEJsZW5kaW5nRGVmaW5lID0gJ0VOVk1BUF9CTEVORElOR19NSVgnO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlIFRIUkVFLkFkZE9wZXJhdGlvbjpcblx0XHRcdFx0XHRcdGVudk1hcEJsZW5kaW5nRGVmaW5lID0gJ0VOVk1BUF9CTEVORElOR19BREQnO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBnYW1tYUZhY3RvckRlZmluZSA9ICggcmVuZGVyZXIuZ2FtbWFGYWN0b3IgPiAwICkgPyByZW5kZXJlci5nYW1tYUZhY3RvciA6IDEuMDtcblxuXHRcdFx0Ly8gY29uc29sZS5sb2coICdidWlsZGluZyBuZXcgcHJvZ3JhbSAnICk7XG5cblx0XHRcdC8vXG5cblx0XHRcdHZhciBjdXN0b21EZWZpbmVzID0gZ2VuZXJhdGVEZWZpbmVzKCBkZWZpbmVzICk7XG5cblx0XHRcdC8vXG5cblx0XHRcdHZhciBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuXG5cdFx0XHR2YXIgcHJlZml4VmVydGV4LCBwcmVmaXhGcmFnbWVudDtcblxuXHRcdFx0aWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLlJhd1NoYWRlck1hdGVyaWFsICkge1xuXG5cdFx0XHRcdHByZWZpeFZlcnRleCA9ICcnO1xuXHRcdFx0XHRwcmVmaXhGcmFnbWVudCA9ICcnO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHByZWZpeFZlcnRleCA9IFtcblxuXHRcdFx0XHRcdCdwcmVjaXNpb24gJyArIHBhcmFtZXRlcnMucHJlY2lzaW9uICsgJyBmbG9hdDsnLFxuXHRcdFx0XHRcdCdwcmVjaXNpb24gJyArIHBhcmFtZXRlcnMucHJlY2lzaW9uICsgJyBpbnQ7JyxcblxuXHRcdFx0XHRcdCcjZGVmaW5lIFNIQURFUl9OQU1FICcgKyBtYXRlcmlhbC5fX3dlYmdsU2hhZGVyLm5hbWUsXG5cblx0XHRcdFx0XHRjdXN0b21EZWZpbmVzLFxuXG5cdFx0XHRcdFx0cGFyYW1ldGVycy5zdXBwb3J0c1ZlcnRleFRleHR1cmVzID8gJyNkZWZpbmUgVkVSVEVYX1RFWFRVUkVTJyA6ICcnLFxuXG5cdFx0XHRcdFx0cmVuZGVyZXIuZ2FtbWFJbnB1dCA/ICcjZGVmaW5lIEdBTU1BX0lOUFVUJyA6ICcnLFxuXHRcdFx0XHRcdHJlbmRlcmVyLmdhbW1hT3V0cHV0ID8gJyNkZWZpbmUgR0FNTUFfT1VUUFVUJyA6ICcnLFxuXHRcdFx0XHRcdCcjZGVmaW5lIEdBTU1BX0ZBQ1RPUiAnICsgZ2FtbWFGYWN0b3JEZWZpbmUsXG5cblx0XHRcdFx0XHQnI2RlZmluZSBNQVhfRElSX0xJR0hUUyAnICsgcGFyYW1ldGVycy5tYXhEaXJMaWdodHMsXG5cdFx0XHRcdFx0JyNkZWZpbmUgTUFYX1BPSU5UX0xJR0hUUyAnICsgcGFyYW1ldGVycy5tYXhQb2ludExpZ2h0cyxcblx0XHRcdFx0XHQnI2RlZmluZSBNQVhfU1BPVF9MSUdIVFMgJyArIHBhcmFtZXRlcnMubWF4U3BvdExpZ2h0cyxcblx0XHRcdFx0XHQnI2RlZmluZSBNQVhfSEVNSV9MSUdIVFMgJyArIHBhcmFtZXRlcnMubWF4SGVtaUxpZ2h0cyxcblxuXHRcdFx0XHRcdCcjZGVmaW5lIE1BWF9TSEFET1dTICcgKyBwYXJhbWV0ZXJzLm1heFNoYWRvd3MsXG5cblx0XHRcdFx0XHQnI2RlZmluZSBNQVhfQk9ORVMgJyArIHBhcmFtZXRlcnMubWF4Qm9uZXMsXG5cblx0XHRcdFx0XHRwYXJhbWV0ZXJzLm1hcCA/ICcjZGVmaW5lIFVTRV9NQVAnIDogJycsXG5cdFx0XHRcdFx0cGFyYW1ldGVycy5lbnZNYXAgPyAnI2RlZmluZSBVU0VfRU5WTUFQJyA6ICcnLFxuXHRcdFx0XHRcdHBhcmFtZXRlcnMuZW52TWFwID8gJyNkZWZpbmUgJyArIGVudk1hcE1vZGVEZWZpbmUgOiAnJyxcblx0XHRcdFx0XHRwYXJhbWV0ZXJzLmxpZ2h0TWFwID8gJyNkZWZpbmUgVVNFX0xJR0hUTUFQJyA6ICcnLFxuXHRcdFx0XHRcdHBhcmFtZXRlcnMuYW9NYXAgPyAnI2RlZmluZSBVU0VfQU9NQVAnIDogJycsXG5cdFx0XHRcdFx0cGFyYW1ldGVycy5lbWlzc2l2ZU1hcCA/ICcjZGVmaW5lIFVTRV9FTUlTU0lWRU1BUCcgOiAnJyxcblx0XHRcdFx0XHRwYXJhbWV0ZXJzLmJ1bXBNYXAgPyAnI2RlZmluZSBVU0VfQlVNUE1BUCcgOiAnJyxcblx0XHRcdFx0XHRwYXJhbWV0ZXJzLm5vcm1hbE1hcCA/ICcjZGVmaW5lIFVTRV9OT1JNQUxNQVAnIDogJycsXG5cdFx0XHRcdFx0cGFyYW1ldGVycy5kaXNwbGFjZW1lbnRNYXAgJiYgcGFyYW1ldGVycy5zdXBwb3J0c1ZlcnRleFRleHR1cmVzID8gJyNkZWZpbmUgVVNFX0RJU1BMQUNFTUVOVE1BUCcgOiAnJyxcblx0XHRcdFx0XHRwYXJhbWV0ZXJzLnNwZWN1bGFyTWFwID8gJyNkZWZpbmUgVVNFX1NQRUNVTEFSTUFQJyA6ICcnLFxuXHRcdFx0XHRcdHBhcmFtZXRlcnMuYWxwaGFNYXAgPyAnI2RlZmluZSBVU0VfQUxQSEFNQVAnIDogJycsXG5cdFx0XHRcdFx0cGFyYW1ldGVycy52ZXJ0ZXhDb2xvcnMgPyAnI2RlZmluZSBVU0VfQ09MT1InIDogJycsXG5cblx0XHRcdFx0XHRwYXJhbWV0ZXJzLmZsYXRTaGFkaW5nID8gJyNkZWZpbmUgRkxBVF9TSEFERUQnIDogJycsXG5cblx0XHRcdFx0XHRwYXJhbWV0ZXJzLnNraW5uaW5nID8gJyNkZWZpbmUgVVNFX1NLSU5OSU5HJyA6ICcnLFxuXHRcdFx0XHRcdHBhcmFtZXRlcnMudXNlVmVydGV4VGV4dHVyZSA/ICcjZGVmaW5lIEJPTkVfVEVYVFVSRScgOiAnJyxcblxuXHRcdFx0XHRcdHBhcmFtZXRlcnMubW9ycGhUYXJnZXRzID8gJyNkZWZpbmUgVVNFX01PUlBIVEFSR0VUUycgOiAnJyxcblx0XHRcdFx0XHRwYXJhbWV0ZXJzLm1vcnBoTm9ybWFscyAmJiBwYXJhbWV0ZXJzLmZsYXRTaGFkaW5nID09PSBmYWxzZSA/ICcjZGVmaW5lIFVTRV9NT1JQSE5PUk1BTFMnIDogJycsXG5cdFx0XHRcdFx0cGFyYW1ldGVycy5kb3VibGVTaWRlZCA/ICcjZGVmaW5lIERPVUJMRV9TSURFRCcgOiAnJyxcblx0XHRcdFx0XHRwYXJhbWV0ZXJzLmZsaXBTaWRlZCA/ICcjZGVmaW5lIEZMSVBfU0lERUQnIDogJycsXG5cblx0XHRcdFx0XHRwYXJhbWV0ZXJzLnNoYWRvd01hcEVuYWJsZWQgPyAnI2RlZmluZSBVU0VfU0hBRE9XTUFQJyA6ICcnLFxuXHRcdFx0XHRcdHBhcmFtZXRlcnMuc2hhZG93TWFwRW5hYmxlZCA/ICcjZGVmaW5lICcgKyBzaGFkb3dNYXBUeXBlRGVmaW5lIDogJycsXG5cdFx0XHRcdFx0cGFyYW1ldGVycy5zaGFkb3dNYXBEZWJ1ZyA/ICcjZGVmaW5lIFNIQURPV01BUF9ERUJVRycgOiAnJyxcblx0XHRcdFx0XHRwYXJhbWV0ZXJzLnBvaW50TGlnaHRTaGFkb3dzID4gMCA/ICcjZGVmaW5lIFBPSU5UX0xJR0hUX1NIQURPV1MnIDogJycsXG5cblx0XHRcdFx0XHRwYXJhbWV0ZXJzLnNpemVBdHRlbnVhdGlvbiA/ICcjZGVmaW5lIFVTRV9TSVpFQVRURU5VQVRJT04nIDogJycsXG5cblx0XHRcdFx0XHRwYXJhbWV0ZXJzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgPyAnI2RlZmluZSBVU0VfTE9HREVQVEhCVUYnIDogJycsXG5cdFx0XHRcdFx0cGFyYW1ldGVycy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyICYmIHJlbmRlcmVyLmV4dGVuc2lvbnMuZ2V0KCAnRVhUX2ZyYWdfZGVwdGgnICkgPyAnI2RlZmluZSBVU0VfTE9HREVQVEhCVUZfRVhUJyA6ICcnLFxuXG5cblx0XHRcdFx0XHQndW5pZm9ybSBtYXQ0IG1vZGVsTWF0cml4OycsXG5cdFx0XHRcdFx0J3VuaWZvcm0gbWF0NCBtb2RlbFZpZXdNYXRyaXg7Jyxcblx0XHRcdFx0XHQndW5pZm9ybSBtYXQ0IHByb2plY3Rpb25NYXRyaXg7Jyxcblx0XHRcdFx0XHQndW5pZm9ybSBtYXQ0IHZpZXdNYXRyaXg7Jyxcblx0XHRcdFx0XHQndW5pZm9ybSBtYXQzIG5vcm1hbE1hdHJpeDsnLFxuXHRcdFx0XHRcdCd1bmlmb3JtIHZlYzMgY2FtZXJhUG9zaXRpb247JyxcblxuXHRcdFx0XHRcdCdhdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbjsnLFxuXHRcdFx0XHRcdCdhdHRyaWJ1dGUgdmVjMyBub3JtYWw7Jyxcblx0XHRcdFx0XHQnYXR0cmlidXRlIHZlYzIgdXY7JyxcblxuXHRcdFx0XHRcdCcjaWZkZWYgVVNFX0NPTE9SJyxcblxuXHRcdFx0XHRcdCdcdGF0dHJpYnV0ZSB2ZWMzIGNvbG9yOycsXG5cblx0XHRcdFx0XHQnI2VuZGlmJyxcblxuXHRcdFx0XHRcdCcjaWZkZWYgVVNFX01PUlBIVEFSR0VUUycsXG5cblx0XHRcdFx0XHQnXHRhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDA7Jyxcblx0XHRcdFx0XHQnXHRhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDE7Jyxcblx0XHRcdFx0XHQnXHRhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDI7Jyxcblx0XHRcdFx0XHQnXHRhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDM7JyxcblxuXHRcdFx0XHRcdCdcdCNpZmRlZiBVU0VfTU9SUEhOT1JNQUxTJyxcblxuXHRcdFx0XHRcdCdcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhOb3JtYWwwOycsXG5cdFx0XHRcdFx0J1x0XHRhdHRyaWJ1dGUgdmVjMyBtb3JwaE5vcm1hbDE7Jyxcblx0XHRcdFx0XHQnXHRcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoTm9ybWFsMjsnLFxuXHRcdFx0XHRcdCdcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhOb3JtYWwzOycsXG5cblx0XHRcdFx0XHQnXHQjZWxzZScsXG5cblx0XHRcdFx0XHQnXHRcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0NDsnLFxuXHRcdFx0XHRcdCdcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ1OycsXG5cdFx0XHRcdFx0J1x0XHRhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDY7Jyxcblx0XHRcdFx0XHQnXHRcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0NzsnLFxuXG5cdFx0XHRcdFx0J1x0I2VuZGlmJyxcblxuXHRcdFx0XHRcdCcjZW5kaWYnLFxuXG5cdFx0XHRcdFx0JyNpZmRlZiBVU0VfU0tJTk5JTkcnLFxuXG5cdFx0XHRcdFx0J1x0YXR0cmlidXRlIHZlYzQgc2tpbkluZGV4OycsXG5cdFx0XHRcdFx0J1x0YXR0cmlidXRlIHZlYzQgc2tpbldlaWdodDsnLFxuXG5cdFx0XHRcdFx0JyNlbmRpZicsXG5cblx0XHRcdFx0XHQnXFxuJ1xuXG5cdFx0XHRcdF0uZmlsdGVyKCBmaWx0ZXJFbXB0eUxpbmUgKS5qb2luKCAnXFxuJyApO1xuXG5cdFx0XHRcdHByZWZpeEZyYWdtZW50ID0gW1xuXG5cdFx0XHRcdFx0cGFyYW1ldGVycy5idW1wTWFwIHx8IHBhcmFtZXRlcnMubm9ybWFsTWFwIHx8IHBhcmFtZXRlcnMuZmxhdFNoYWRpbmcgfHwgbWF0ZXJpYWwuZGVyaXZhdGl2ZXMgPyAnI2V4dGVuc2lvbiBHTF9PRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMgOiBlbmFibGUnIDogJycsXG5cdFx0XHRcdFx0cGFyYW1ldGVycy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyICYmIHJlbmRlcmVyLmV4dGVuc2lvbnMuZ2V0KCAnRVhUX2ZyYWdfZGVwdGgnICkgPyAnI2V4dGVuc2lvbiBHTF9FWFRfZnJhZ19kZXB0aCA6IGVuYWJsZScgOiAnJyxcblxuXHRcdFx0XHRcdCdwcmVjaXNpb24gJyArIHBhcmFtZXRlcnMucHJlY2lzaW9uICsgJyBmbG9hdDsnLFxuXHRcdFx0XHRcdCdwcmVjaXNpb24gJyArIHBhcmFtZXRlcnMucHJlY2lzaW9uICsgJyBpbnQ7JyxcblxuXHRcdFx0XHRcdCcjZGVmaW5lIFNIQURFUl9OQU1FICcgKyBtYXRlcmlhbC5fX3dlYmdsU2hhZGVyLm5hbWUsXG5cblx0XHRcdFx0XHRjdXN0b21EZWZpbmVzLFxuXG5cdFx0XHRcdFx0JyNkZWZpbmUgTUFYX0RJUl9MSUdIVFMgJyArIHBhcmFtZXRlcnMubWF4RGlyTGlnaHRzLFxuXHRcdFx0XHRcdCcjZGVmaW5lIE1BWF9QT0lOVF9MSUdIVFMgJyArIHBhcmFtZXRlcnMubWF4UG9pbnRMaWdodHMsXG5cdFx0XHRcdFx0JyNkZWZpbmUgTUFYX1NQT1RfTElHSFRTICcgKyBwYXJhbWV0ZXJzLm1heFNwb3RMaWdodHMsXG5cdFx0XHRcdFx0JyNkZWZpbmUgTUFYX0hFTUlfTElHSFRTICcgKyBwYXJhbWV0ZXJzLm1heEhlbWlMaWdodHMsXG5cblx0XHRcdFx0XHQnI2RlZmluZSBNQVhfU0hBRE9XUyAnICsgcGFyYW1ldGVycy5tYXhTaGFkb3dzLFxuXG5cdFx0XHRcdFx0cGFyYW1ldGVycy5hbHBoYVRlc3QgPyAnI2RlZmluZSBBTFBIQVRFU1QgJyArIHBhcmFtZXRlcnMuYWxwaGFUZXN0IDogJycsXG5cblx0XHRcdFx0XHRyZW5kZXJlci5nYW1tYUlucHV0ID8gJyNkZWZpbmUgR0FNTUFfSU5QVVQnIDogJycsXG5cdFx0XHRcdFx0cmVuZGVyZXIuZ2FtbWFPdXRwdXQgPyAnI2RlZmluZSBHQU1NQV9PVVRQVVQnIDogJycsXG5cdFx0XHRcdFx0JyNkZWZpbmUgR0FNTUFfRkFDVE9SICcgKyBnYW1tYUZhY3RvckRlZmluZSxcblxuXHRcdFx0XHRcdCggcGFyYW1ldGVycy51c2VGb2cgJiYgcGFyYW1ldGVycy5mb2cgKSA/ICcjZGVmaW5lIFVTRV9GT0cnIDogJycsXG5cdFx0XHRcdFx0KCBwYXJhbWV0ZXJzLnVzZUZvZyAmJiBwYXJhbWV0ZXJzLmZvZ0V4cCApID8gJyNkZWZpbmUgRk9HX0VYUDInIDogJycsXG5cblx0XHRcdFx0XHRwYXJhbWV0ZXJzLm1hcCA/ICcjZGVmaW5lIFVTRV9NQVAnIDogJycsXG5cdFx0XHRcdFx0cGFyYW1ldGVycy5lbnZNYXAgPyAnI2RlZmluZSBVU0VfRU5WTUFQJyA6ICcnLFxuXHRcdFx0XHRcdHBhcmFtZXRlcnMuZW52TWFwID8gJyNkZWZpbmUgJyArIGVudk1hcFR5cGVEZWZpbmUgOiAnJyxcblx0XHRcdFx0XHRwYXJhbWV0ZXJzLmVudk1hcCA/ICcjZGVmaW5lICcgKyBlbnZNYXBNb2RlRGVmaW5lIDogJycsXG5cdFx0XHRcdFx0cGFyYW1ldGVycy5lbnZNYXAgPyAnI2RlZmluZSAnICsgZW52TWFwQmxlbmRpbmdEZWZpbmUgOiAnJyxcblx0XHRcdFx0XHRwYXJhbWV0ZXJzLmxpZ2h0TWFwID8gJyNkZWZpbmUgVVNFX0xJR0hUTUFQJyA6ICcnLFxuXHRcdFx0XHRcdHBhcmFtZXRlcnMuYW9NYXAgPyAnI2RlZmluZSBVU0VfQU9NQVAnIDogJycsXG5cdFx0XHRcdFx0cGFyYW1ldGVycy5lbWlzc2l2ZU1hcCA/ICcjZGVmaW5lIFVTRV9FTUlTU0lWRU1BUCcgOiAnJyxcblx0XHRcdFx0XHRwYXJhbWV0ZXJzLmJ1bXBNYXAgPyAnI2RlZmluZSBVU0VfQlVNUE1BUCcgOiAnJyxcblx0XHRcdFx0XHRwYXJhbWV0ZXJzLm5vcm1hbE1hcCA/ICcjZGVmaW5lIFVTRV9OT1JNQUxNQVAnIDogJycsXG5cdFx0XHRcdFx0cGFyYW1ldGVycy5zcGVjdWxhck1hcCA/ICcjZGVmaW5lIFVTRV9TUEVDVUxBUk1BUCcgOiAnJyxcblx0XHRcdFx0XHRwYXJhbWV0ZXJzLmFscGhhTWFwID8gJyNkZWZpbmUgVVNFX0FMUEhBTUFQJyA6ICcnLFxuXHRcdFx0XHRcdHBhcmFtZXRlcnMudmVydGV4Q29sb3JzID8gJyNkZWZpbmUgVVNFX0NPTE9SJyA6ICcnLFxuXG5cdFx0XHRcdFx0cGFyYW1ldGVycy5mbGF0U2hhZGluZyA/ICcjZGVmaW5lIEZMQVRfU0hBREVEJyA6ICcnLFxuXG5cdFx0XHRcdFx0cGFyYW1ldGVycy5tZXRhbCA/ICcjZGVmaW5lIE1FVEFMJyA6ICcnLFxuXHRcdFx0XHRcdHBhcmFtZXRlcnMuZG91YmxlU2lkZWQgPyAnI2RlZmluZSBET1VCTEVfU0lERUQnIDogJycsXG5cdFx0XHRcdFx0cGFyYW1ldGVycy5mbGlwU2lkZWQgPyAnI2RlZmluZSBGTElQX1NJREVEJyA6ICcnLFxuXG5cdFx0XHRcdFx0cGFyYW1ldGVycy5zaGFkb3dNYXBFbmFibGVkID8gJyNkZWZpbmUgVVNFX1NIQURPV01BUCcgOiAnJyxcblx0XHRcdFx0XHRwYXJhbWV0ZXJzLnNoYWRvd01hcEVuYWJsZWQgPyAnI2RlZmluZSAnICsgc2hhZG93TWFwVHlwZURlZmluZSA6ICcnLFxuXHRcdFx0XHRcdHBhcmFtZXRlcnMuc2hhZG93TWFwRGVidWcgPyAnI2RlZmluZSBTSEFET1dNQVBfREVCVUcnIDogJycsXG5cdFx0XHRcdFx0cGFyYW1ldGVycy5wb2ludExpZ2h0U2hhZG93cyA+IDAgPyAnI2RlZmluZSBQT0lOVF9MSUdIVF9TSEFET1dTJyA6ICcnLFxuXG5cdFx0XHRcdFx0cGFyYW1ldGVycy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyID8gJyNkZWZpbmUgVVNFX0xPR0RFUFRIQlVGJyA6ICcnLFxuXHRcdFx0XHRcdHBhcmFtZXRlcnMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciAmJiByZW5kZXJlci5leHRlbnNpb25zLmdldCggJ0VYVF9mcmFnX2RlcHRoJyApID8gJyNkZWZpbmUgVVNFX0xPR0RFUFRIQlVGX0VYVCcgOiAnJyxcblxuXHRcdFx0XHRcdCd1bmlmb3JtIG1hdDQgdmlld01hdHJpeDsnLFxuXHRcdFx0XHRcdCd1bmlmb3JtIHZlYzMgY2FtZXJhUG9zaXRpb247JyxcblxuXHRcdFx0XHRcdCdcXG4nXG5cblx0XHRcdFx0XS5maWx0ZXIoIGZpbHRlckVtcHR5TGluZSApLmpvaW4oICdcXG4nICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIHZlcnRleEdsc2wgPSBwcmVmaXhWZXJ0ZXggKyB2ZXJ0ZXhTaGFkZXI7XG5cdFx0XHR2YXIgZnJhZ21lbnRHbHNsID0gcHJlZml4RnJhZ21lbnQgKyBmcmFnbWVudFNoYWRlcjtcblxuXHRcdFx0dmFyIGdsVmVydGV4U2hhZGVyID0gVEhSRUUuV2ViR0xTaGFkZXIoIGdsLCBnbC5WRVJURVhfU0hBREVSLCB2ZXJ0ZXhHbHNsICk7XG5cdFx0XHR2YXIgZ2xGcmFnbWVudFNoYWRlciA9IFRIUkVFLldlYkdMU2hhZGVyKCBnbCwgZ2wuRlJBR01FTlRfU0hBREVSLCBmcmFnbWVudEdsc2wgKTtcblxuXHRcdFx0Z2wuYXR0YWNoU2hhZGVyKCBwcm9ncmFtLCBnbFZlcnRleFNoYWRlciApO1xuXHRcdFx0Z2wuYXR0YWNoU2hhZGVyKCBwcm9ncmFtLCBnbEZyYWdtZW50U2hhZGVyICk7XG5cblx0XHRcdC8vIEZvcmNlIGEgcGFydGljdWxhciBhdHRyaWJ1dGUgdG8gaW5kZXggMC5cblxuXHRcdFx0aWYgKCBtYXRlcmlhbC5pbmRleDBBdHRyaWJ1dGVOYW1lICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Z2wuYmluZEF0dHJpYkxvY2F0aW9uKCBwcm9ncmFtLCAwLCBtYXRlcmlhbC5pbmRleDBBdHRyaWJ1dGVOYW1lICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHBhcmFtZXRlcnMubW9ycGhUYXJnZXRzID09PSB0cnVlICkge1xuXG5cdFx0XHRcdC8vIHByb2dyYW1zIHdpdGggbW9ycGhUYXJnZXRzIGRpc3BsYWNlIHBvc2l0aW9uIG91dCBvZiBhdHRyaWJ1dGUgMFxuXHRcdFx0XHRnbC5iaW5kQXR0cmliTG9jYXRpb24oIHByb2dyYW0sIDAsICdwb3NpdGlvbicgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRnbC5saW5rUHJvZ3JhbSggcHJvZ3JhbSApO1xuXG5cdFx0XHR2YXIgcHJvZ3JhbUxvZyA9IGdsLmdldFByb2dyYW1JbmZvTG9nKCBwcm9ncmFtICk7XG5cdFx0XHR2YXIgdmVydGV4TG9nID0gZ2wuZ2V0U2hhZGVySW5mb0xvZyggZ2xWZXJ0ZXhTaGFkZXIgKTtcblx0XHRcdHZhciBmcmFnbWVudExvZyA9IGdsLmdldFNoYWRlckluZm9Mb2coIGdsRnJhZ21lbnRTaGFkZXIgKTtcblxuXHRcdFx0dmFyIHJ1bm5hYmxlID0gdHJ1ZTtcblx0XHRcdHZhciBoYXZlRGlhZ25vc3RpY3MgPSB0cnVlO1xuXG5cdFx0XHRpZiAoIGdsLmdldFByb2dyYW1QYXJhbWV0ZXIoIHByb2dyYW0sIGdsLkxJTktfU1RBVFVTICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdHJ1bm5hYmxlID0gZmFsc2U7XG5cblx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUHJvZ3JhbTogc2hhZGVyIGVycm9yOiAnLCBnbC5nZXRFcnJvcigpLCAnZ2wuVkFMSURBVEVfU1RBVFVTJywgZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlciggcHJvZ3JhbSwgZ2wuVkFMSURBVEVfU1RBVFVTICksICdnbC5nZXRQcm9ncmFtSW5mb0xvZycsIHByb2dyYW1Mb2csIHZlcnRleExvZywgZnJhZ21lbnRMb2cgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggcHJvZ3JhbUxvZyAhPT0gJycgKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xQcm9ncmFtOiBnbC5nZXRQcm9ncmFtSW5mb0xvZygpJywgcHJvZ3JhbUxvZyApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCB2ZXJ0ZXhMb2cgPT09ICcnIHx8IGZyYWdtZW50TG9nID09PSAnJyApIHtcblxuXHRcdFx0XHRoYXZlRGlhZ25vc3RpY3MgPSBmYWxzZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhhdmVEaWFnbm9zdGljcyApIHtcblxuXHRcdFx0XHR0aGlzLmRpYWdub3N0aWNzID0ge1xuXG5cdFx0XHRcdFx0cnVubmFibGU6IHJ1bm5hYmxlLFxuXHRcdFx0XHRcdG1hdGVyaWFsOiBtYXRlcmlhbCxcblxuXHRcdFx0XHRcdHByb2dyYW1Mb2c6IHByb2dyYW1Mb2csXG5cblx0XHRcdFx0XHR2ZXJ0ZXhTaGFkZXI6IHtcblxuXHRcdFx0XHRcdFx0bG9nOiB2ZXJ0ZXhMb2csXG5cdFx0XHRcdFx0XHRwcmVmaXg6IHByZWZpeFZlcnRleFxuXG5cdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdGZyYWdtZW50U2hhZGVyOiB7XG5cblx0XHRcdFx0XHRcdGxvZzogZnJhZ21lbnRMb2csXG5cdFx0XHRcdFx0XHRwcmVmaXg6IHByZWZpeEZyYWdtZW50XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBjbGVhbiB1cFxuXG5cdFx0XHRnbC5kZWxldGVTaGFkZXIoIGdsVmVydGV4U2hhZGVyICk7XG5cdFx0XHRnbC5kZWxldGVTaGFkZXIoIGdsRnJhZ21lbnRTaGFkZXIgKTtcblxuXHRcdFx0Ly8gc2V0IHVwIGNhY2hpbmcgZm9yIHVuaWZvcm0gbG9jYXRpb25zXG5cblx0XHRcdHZhciBjYWNoZWRVbmlmb3JtcztcblxuXHRcdFx0dGhpcy5nZXRVbmlmb3JtcyA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdGlmICggY2FjaGVkVW5pZm9ybXMgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGNhY2hlZFVuaWZvcm1zID0gZmV0Y2hVbmlmb3JtTG9jYXRpb25zKCBnbCwgcHJvZ3JhbSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gY2FjaGVkVW5pZm9ybXM7XG5cblx0XHRcdH07XG5cblx0XHRcdC8vIHNldCB1cCBjYWNoaW5nIGZvciBhdHRyaWJ1dGUgbG9jYXRpb25zXG5cblx0XHRcdHZhciBjYWNoZWRBdHRyaWJ1dGVzO1xuXG5cdFx0XHR0aGlzLmdldEF0dHJpYnV0ZXMgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHRpZiAoIGNhY2hlZEF0dHJpYnV0ZXMgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGNhY2hlZEF0dHJpYnV0ZXMgPSBmZXRjaEF0dHJpYnV0ZUxvY2F0aW9ucyggZ2wsIHByb2dyYW0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGNhY2hlZEF0dHJpYnV0ZXM7XG5cblx0XHRcdH07XG5cblx0XHRcdC8vIGZyZWUgcmVzb3VyY2VcblxuXHRcdFx0dGhpcy5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0Z2wuZGVsZXRlUHJvZ3JhbSggcHJvZ3JhbSApO1xuXHRcdFx0XHR0aGlzLnByb2dyYW0gPSB1bmRlZmluZWQ7XG5cblx0XHRcdH07XG5cblx0XHRcdC8vIERFUFJFQ0FURURcblxuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIHRoaXMsIHtcblxuXHRcdFx0XHR1bmlmb3Jtczoge1xuXHRcdFx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUHJvZ3JhbTogLnVuaWZvcm1zIGlzIG5vdyAuZ2V0VW5pZm9ybXMoKS4nICk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5nZXRVbmlmb3JtcygpO1xuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdGF0dHJpYnV0ZXM6IHtcblx0XHRcdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFByb2dyYW06IC5hdHRyaWJ1dGVzIGlzIG5vdyAuZ2V0QXR0cmlidXRlcygpLicgKTtcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZXMoKTtcblxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHR9ICk7XG5cblxuXHRcdFx0Ly9cblxuXHRcdFx0dGhpcy5pZCA9IHByb2dyYW1JZENvdW50ICsrO1xuXHRcdFx0dGhpcy5jb2RlID0gY29kZTtcblx0XHRcdHRoaXMudXNlZFRpbWVzID0gMTtcblx0XHRcdHRoaXMucHJvZ3JhbSA9IHByb2dyYW07XG5cdFx0XHR0aGlzLnZlcnRleFNoYWRlciA9IGdsVmVydGV4U2hhZGVyO1xuXHRcdFx0dGhpcy5mcmFnbWVudFNoYWRlciA9IGdsRnJhZ21lbnRTaGFkZXI7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fTtcblxuXHR9ICkoKTtcblxuXHQvLyBGaWxlOnNyYy9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xQcm9ncmFtcy5qc1xuXG5cdFRIUkVFLldlYkdMUHJvZ3JhbXMgPSBmdW5jdGlvbiAoIHJlbmRlcmVyLCBjYXBhYmlsaXRpZXMgKSB7XG5cblx0XHR2YXIgcHJvZ3JhbXMgPSBbXTtcblxuXHRcdHZhciBzaGFkZXJJRHMgPSB7XG5cdFx0XHRNZXNoRGVwdGhNYXRlcmlhbDogJ2RlcHRoJyxcblx0XHRcdE1lc2hOb3JtYWxNYXRlcmlhbDogJ25vcm1hbCcsXG5cdFx0XHRNZXNoQmFzaWNNYXRlcmlhbDogJ2Jhc2ljJyxcblx0XHRcdE1lc2hMYW1iZXJ0TWF0ZXJpYWw6ICdsYW1iZXJ0Jyxcblx0XHRcdE1lc2hQaG9uZ01hdGVyaWFsOiAncGhvbmcnLFxuXHRcdFx0TGluZUJhc2ljTWF0ZXJpYWw6ICdiYXNpYycsXG5cdFx0XHRMaW5lRGFzaGVkTWF0ZXJpYWw6ICdkYXNoZWQnLFxuXHRcdFx0UG9pbnRzTWF0ZXJpYWw6ICdwb2ludHMnXG5cdFx0fTtcblxuXHRcdHZhciBwYXJhbWV0ZXJOYW1lcyA9IFtcblx0XHRcdFwicHJlY2lzaW9uXCIsIFwic3VwcG9ydHNWZXJ0ZXhUZXh0dXJlc1wiLCBcIm1hcFwiLCBcImVudk1hcFwiLCBcImVudk1hcE1vZGVcIixcblx0XHRcdFwibGlnaHRNYXBcIiwgXCJhb01hcFwiLCBcImVtaXNzaXZlTWFwXCIsIFwiYnVtcE1hcFwiLCBcIm5vcm1hbE1hcFwiLCBcImRpc3BsYWNlbWVudE1hcFwiLCBcInNwZWN1bGFyTWFwXCIsXG5cdFx0XHRcImFscGhhTWFwXCIsIFwiY29tYmluZVwiLCBcInZlcnRleENvbG9yc1wiLCBcImZvZ1wiLCBcInVzZUZvZ1wiLCBcImZvZ0V4cFwiLFxuXHRcdFx0XCJmbGF0U2hhZGluZ1wiLCBcInNpemVBdHRlbnVhdGlvblwiLCBcImxvZ2FyaXRobWljRGVwdGhCdWZmZXJcIiwgXCJza2lubmluZ1wiLFxuXHRcdFx0XCJtYXhCb25lc1wiLCBcInVzZVZlcnRleFRleHR1cmVcIiwgXCJtb3JwaFRhcmdldHNcIiwgXCJtb3JwaE5vcm1hbHNcIixcblx0XHRcdFwibWF4TW9ycGhUYXJnZXRzXCIsIFwibWF4TW9ycGhOb3JtYWxzXCIsIFwibWF4RGlyTGlnaHRzXCIsIFwibWF4UG9pbnRMaWdodHNcIixcblx0XHRcdFwibWF4U3BvdExpZ2h0c1wiLCBcIm1heEhlbWlMaWdodHNcIiwgXCJtYXhTaGFkb3dzXCIsIFwic2hhZG93TWFwRW5hYmxlZFwiLCBcInBvaW50TGlnaHRTaGFkb3dzXCIsXG5cdFx0XHRcInNoYWRvd01hcFR5cGVcIiwgXCJzaGFkb3dNYXBEZWJ1Z1wiLCBcImFscGhhVGVzdFwiLCBcIm1ldGFsXCIsIFwiZG91YmxlU2lkZWRcIixcblx0XHRcdFwiZmxpcFNpZGVkXCJcblx0XHRdO1xuXG5cblx0XHRmdW5jdGlvbiBhbGxvY2F0ZUJvbmVzICggb2JqZWN0ICkge1xuXG5cdFx0XHRpZiAoIGNhcGFiaWxpdGllcy5mbG9hdFZlcnRleFRleHR1cmVzICYmIG9iamVjdCAmJiBvYmplY3Quc2tlbGV0b24gJiYgb2JqZWN0LnNrZWxldG9uLnVzZVZlcnRleFRleHR1cmUgKSB7XG5cblx0XHRcdFx0cmV0dXJuIDEwMjQ7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gZGVmYXVsdCBmb3Igd2hlbiBvYmplY3QgaXMgbm90IHNwZWNpZmllZFxuXHRcdFx0XHQvLyAoIGZvciBleGFtcGxlIHdoZW4gcHJlYnVpbGRpbmcgc2hhZGVyIHRvIGJlIHVzZWQgd2l0aCBtdWx0aXBsZSBvYmplY3RzIClcblx0XHRcdFx0Ly9cblx0XHRcdFx0Ly8gIC0gbGVhdmUgc29tZSBleHRyYSBzcGFjZSBmb3Igb3RoZXIgdW5pZm9ybXNcblx0XHRcdFx0Ly8gIC0gbGltaXQgaGVyZSBpcyBBTkdMRSdzIDI1NCBtYXggdW5pZm9ybSB2ZWN0b3JzXG5cdFx0XHRcdC8vICAgICh1cCB0byA1NCBzaG91bGQgYmUgc2FmZSlcblxuXHRcdFx0XHR2YXIgblZlcnRleFVuaWZvcm1zID0gY2FwYWJpbGl0aWVzLm1heFZlcnRleFVuaWZvcm1zO1xuXHRcdFx0XHR2YXIgblZlcnRleE1hdHJpY2VzID0gTWF0aC5mbG9vciggKCBuVmVydGV4VW5pZm9ybXMgLSAyMCApIC8gNCApO1xuXG5cdFx0XHRcdHZhciBtYXhCb25lcyA9IG5WZXJ0ZXhNYXRyaWNlcztcblxuXHRcdFx0XHRpZiAoIG9iamVjdCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlNraW5uZWRNZXNoICkge1xuXG5cdFx0XHRcdFx0bWF4Qm9uZXMgPSBNYXRoLm1pbiggb2JqZWN0LnNrZWxldG9uLmJvbmVzLmxlbmd0aCwgbWF4Qm9uZXMgKTtcblxuXHRcdFx0XHRcdGlmICggbWF4Qm9uZXMgPCBvYmplY3Quc2tlbGV0b24uYm9uZXMubGVuZ3RoICkge1xuXG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdXZWJHTFJlbmRlcmVyOiB0b28gbWFueSBib25lcyAtICcgKyBvYmplY3Quc2tlbGV0b24uYm9uZXMubGVuZ3RoICsgJywgdGhpcyBHUFUgc3VwcG9ydHMganVzdCAnICsgbWF4Qm9uZXMgKyAnICh0cnkgT3BlbkdMIGluc3RlYWQgb2YgQU5HTEUpJyApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gbWF4Qm9uZXM7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGFsbG9jYXRlTGlnaHRzKCBsaWdodHMgKSB7XG5cblx0XHRcdHZhciBkaXJMaWdodHMgPSAwO1xuXHRcdFx0dmFyIHBvaW50TGlnaHRzID0gMDtcblx0XHRcdHZhciBzcG90TGlnaHRzID0gMDtcblx0XHRcdHZhciBoZW1pTGlnaHRzID0gMDtcblxuXHRcdFx0Zm9yICggdmFyIGwgPSAwLCBsbCA9IGxpZ2h0cy5sZW5ndGg7IGwgPCBsbDsgbCArKyApIHtcblxuXHRcdFx0XHR2YXIgbGlnaHQgPSBsaWdodHNbIGwgXTtcblxuXHRcdFx0XHRpZiAoIGxpZ2h0LnZpc2libGUgPT09IGZhbHNlICkgY29udGludWU7XG5cblx0XHRcdFx0aWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQgKSBkaXJMaWdodHMgKys7XG5cdFx0XHRcdGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5Qb2ludExpZ2h0ICkgcG9pbnRMaWdodHMgKys7XG5cdFx0XHRcdGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5TcG90TGlnaHQgKSBzcG90TGlnaHRzICsrO1xuXHRcdFx0XHRpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuSGVtaXNwaGVyZUxpZ2h0ICkgaGVtaUxpZ2h0cyArKztcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4geyAnZGlyZWN0aW9uYWwnOiBkaXJMaWdodHMsICdwb2ludCc6IHBvaW50TGlnaHRzLCAnc3BvdCc6IHNwb3RMaWdodHMsICdoZW1pJzogaGVtaUxpZ2h0cyB9O1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYWxsb2NhdGVTaGFkb3dzKCBsaWdodHMgKSB7XG5cblx0XHRcdHZhciBtYXhTaGFkb3dzID0gMDtcblx0XHRcdHZhciBwb2ludExpZ2h0U2hhZG93cyA9IDA7XG5cblx0XHRcdGZvciAoIHZhciBsID0gMCwgbGwgPSBsaWdodHMubGVuZ3RoOyBsIDwgbGw7IGwgKysgKSB7XG5cblx0XHRcdFx0dmFyIGxpZ2h0ID0gbGlnaHRzWyBsIF07XG5cblx0XHRcdFx0aWYgKCAhIGxpZ2h0LmNhc3RTaGFkb3cgKSBjb250aW51ZTtcblxuXHRcdFx0XHRpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuU3BvdExpZ2h0IHx8IGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuRGlyZWN0aW9uYWxMaWdodCApIG1heFNoYWRvd3MgKys7XG5cdFx0XHRcdGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5Qb2ludExpZ2h0ICkge1xuXG5cdFx0XHRcdFx0bWF4U2hhZG93cyArKztcblx0XHRcdFx0XHRwb2ludExpZ2h0U2hhZG93cyArKztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHsgJ21heFNoYWRvd3MnOiBtYXhTaGFkb3dzLCAncG9pbnRMaWdodFNoYWRvd3MnOiBwb2ludExpZ2h0U2hhZG93cyB9O1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5nZXRQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCBtYXRlcmlhbCwgbGlnaHRzLCBmb2csIG9iamVjdCApIHtcblxuXHRcdFx0dmFyIHNoYWRlcklEID0gc2hhZGVySURzWyBtYXRlcmlhbC50eXBlIF07XG5cdFx0XHQvLyBoZXVyaXN0aWNzIHRvIGNyZWF0ZSBzaGFkZXIgcGFyYW1ldGVycyBhY2NvcmRpbmcgdG8gbGlnaHRzIGluIHRoZSBzY2VuZVxuXHRcdFx0Ly8gKG5vdCB0byBibG93IG92ZXIgbWF4TGlnaHRzIGJ1ZGdldClcblxuXHRcdFx0dmFyIG1heExpZ2h0Q291bnQgPSBhbGxvY2F0ZUxpZ2h0cyggbGlnaHRzICk7XG5cdFx0XHR2YXIgYWxsb2NhdGVkU2hhZG93cyA9IGFsbG9jYXRlU2hhZG93cyggbGlnaHRzICk7XG5cdFx0XHR2YXIgbWF4Qm9uZXMgPSBhbGxvY2F0ZUJvbmVzKCBvYmplY3QgKTtcblx0XHRcdHZhciBwcmVjaXNpb24gPSByZW5kZXJlci5nZXRQcmVjaXNpb24oKTtcblxuXHRcdFx0aWYgKCBtYXRlcmlhbC5wcmVjaXNpb24gIT09IG51bGwgKSB7XG5cblx0XHRcdFx0cHJlY2lzaW9uID0gY2FwYWJpbGl0aWVzLmdldE1heFByZWNpc2lvbiggbWF0ZXJpYWwucHJlY2lzaW9uICk7XG5cblx0XHRcdFx0aWYgKCBwcmVjaXNpb24gIT09IG1hdGVyaWFsLnByZWNpc2lvbiApIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXIuaW5pdE1hdGVyaWFsOicsIG1hdGVyaWFsLnByZWNpc2lvbiwgJ25vdCBzdXBwb3J0ZWQsIHVzaW5nJywgcHJlY2lzaW9uLCAnaW5zdGVhZC4nICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBwYXJhbWV0ZXJzID0ge1xuXG5cdFx0XHRcdHNoYWRlcklEOiBzaGFkZXJJRCxcblxuXHRcdFx0XHRwcmVjaXNpb246IHByZWNpc2lvbixcblx0XHRcdFx0c3VwcG9ydHNWZXJ0ZXhUZXh0dXJlczogY2FwYWJpbGl0aWVzLnZlcnRleFRleHR1cmVzLFxuXG5cdFx0XHRcdG1hcDogISEgbWF0ZXJpYWwubWFwLFxuXHRcdFx0XHRlbnZNYXA6ICEhIG1hdGVyaWFsLmVudk1hcCxcblx0XHRcdFx0ZW52TWFwTW9kZTogbWF0ZXJpYWwuZW52TWFwICYmIG1hdGVyaWFsLmVudk1hcC5tYXBwaW5nLFxuXHRcdFx0XHRsaWdodE1hcDogISEgbWF0ZXJpYWwubGlnaHRNYXAsXG5cdFx0XHRcdGFvTWFwOiAhISBtYXRlcmlhbC5hb01hcCxcblx0XHRcdFx0ZW1pc3NpdmVNYXA6ICEhIG1hdGVyaWFsLmVtaXNzaXZlTWFwLFxuXHRcdFx0XHRidW1wTWFwOiAhISBtYXRlcmlhbC5idW1wTWFwLFxuXHRcdFx0XHRub3JtYWxNYXA6ICEhIG1hdGVyaWFsLm5vcm1hbE1hcCxcblx0XHRcdFx0ZGlzcGxhY2VtZW50TWFwOiAhISBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXAsXG5cdFx0XHRcdHNwZWN1bGFyTWFwOiAhISBtYXRlcmlhbC5zcGVjdWxhck1hcCxcblx0XHRcdFx0YWxwaGFNYXA6ICEhIG1hdGVyaWFsLmFscGhhTWFwLFxuXG5cdFx0XHRcdGNvbWJpbmU6IG1hdGVyaWFsLmNvbWJpbmUsXG5cblx0XHRcdFx0dmVydGV4Q29sb3JzOiBtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMsXG5cblx0XHRcdFx0Zm9nOiBmb2csXG5cdFx0XHRcdHVzZUZvZzogbWF0ZXJpYWwuZm9nLFxuXHRcdFx0XHRmb2dFeHA6IGZvZyBpbnN0YW5jZW9mIFRIUkVFLkZvZ0V4cDIsXG5cblx0XHRcdFx0ZmxhdFNoYWRpbmc6IG1hdGVyaWFsLnNoYWRpbmcgPT09IFRIUkVFLkZsYXRTaGFkaW5nLFxuXG5cdFx0XHRcdHNpemVBdHRlbnVhdGlvbjogbWF0ZXJpYWwuc2l6ZUF0dGVudWF0aW9uLFxuXHRcdFx0XHRsb2dhcml0aG1pY0RlcHRoQnVmZmVyOiBjYXBhYmlsaXRpZXMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlcixcblxuXHRcdFx0XHRza2lubmluZzogbWF0ZXJpYWwuc2tpbm5pbmcsXG5cdFx0XHRcdG1heEJvbmVzOiBtYXhCb25lcyxcblx0XHRcdFx0dXNlVmVydGV4VGV4dHVyZTogY2FwYWJpbGl0aWVzLmZsb2F0VmVydGV4VGV4dHVyZXMgJiYgb2JqZWN0ICYmIG9iamVjdC5za2VsZXRvbiAmJiBvYmplY3Quc2tlbGV0b24udXNlVmVydGV4VGV4dHVyZSxcblxuXHRcdFx0XHRtb3JwaFRhcmdldHM6IG1hdGVyaWFsLm1vcnBoVGFyZ2V0cyxcblx0XHRcdFx0bW9ycGhOb3JtYWxzOiBtYXRlcmlhbC5tb3JwaE5vcm1hbHMsXG5cdFx0XHRcdG1heE1vcnBoVGFyZ2V0czogcmVuZGVyZXIubWF4TW9ycGhUYXJnZXRzLFxuXHRcdFx0XHRtYXhNb3JwaE5vcm1hbHM6IHJlbmRlcmVyLm1heE1vcnBoTm9ybWFscyxcblxuXHRcdFx0XHRtYXhEaXJMaWdodHM6IG1heExpZ2h0Q291bnQuZGlyZWN0aW9uYWwsXG5cdFx0XHRcdG1heFBvaW50TGlnaHRzOiBtYXhMaWdodENvdW50LnBvaW50LFxuXHRcdFx0XHRtYXhTcG90TGlnaHRzOiBtYXhMaWdodENvdW50LnNwb3QsXG5cdFx0XHRcdG1heEhlbWlMaWdodHM6IG1heExpZ2h0Q291bnQuaGVtaSxcblxuXHRcdFx0XHRtYXhTaGFkb3dzOiBhbGxvY2F0ZWRTaGFkb3dzLm1heFNoYWRvd3MsXG5cdFx0XHRcdHBvaW50TGlnaHRTaGFkb3dzOiBhbGxvY2F0ZWRTaGFkb3dzLnBvaW50TGlnaHRTaGFkb3dzLFxuXHRcdFx0XHRzaGFkb3dNYXBFbmFibGVkOiByZW5kZXJlci5zaGFkb3dNYXAuZW5hYmxlZCAmJiBvYmplY3QucmVjZWl2ZVNoYWRvdyAmJiBhbGxvY2F0ZWRTaGFkb3dzLm1heFNoYWRvd3MgPiAwLFxuXHRcdFx0XHRzaGFkb3dNYXBUeXBlOiByZW5kZXJlci5zaGFkb3dNYXAudHlwZSxcblx0XHRcdFx0c2hhZG93TWFwRGVidWc6IHJlbmRlcmVyLnNoYWRvd01hcC5kZWJ1ZyxcblxuXHRcdFx0XHRhbHBoYVRlc3Q6IG1hdGVyaWFsLmFscGhhVGVzdCxcblx0XHRcdFx0bWV0YWw6IG1hdGVyaWFsLm1ldGFsLFxuXHRcdFx0XHRkb3VibGVTaWRlZDogbWF0ZXJpYWwuc2lkZSA9PT0gVEhSRUUuRG91YmxlU2lkZSxcblx0XHRcdFx0ZmxpcFNpZGVkOiBtYXRlcmlhbC5zaWRlID09PSBUSFJFRS5CYWNrU2lkZVxuXG5cdFx0XHR9O1xuXG5cdFx0XHRyZXR1cm4gcGFyYW1ldGVycztcblxuXHRcdH07XG5cblx0XHR0aGlzLmdldFByb2dyYW1Db2RlID0gZnVuY3Rpb24gKCBtYXRlcmlhbCwgcGFyYW1ldGVycyApIHtcblxuXHRcdFx0dmFyIGNodW5rcyA9IFtdO1xuXG5cdFx0XHRpZiAoIHBhcmFtZXRlcnMuc2hhZGVySUQgKSB7XG5cblx0XHRcdFx0Y2h1bmtzLnB1c2goIHBhcmFtZXRlcnMuc2hhZGVySUQgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRjaHVua3MucHVzaCggbWF0ZXJpYWwuZnJhZ21lbnRTaGFkZXIgKTtcblx0XHRcdFx0Y2h1bmtzLnB1c2goIG1hdGVyaWFsLnZlcnRleFNoYWRlciApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbWF0ZXJpYWwuZGVmaW5lcyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGZvciAoIHZhciBuYW1lIGluIG1hdGVyaWFsLmRlZmluZXMgKSB7XG5cblx0XHRcdFx0XHRjaHVua3MucHVzaCggbmFtZSApO1xuXHRcdFx0XHRcdGNodW5rcy5wdXNoKCBtYXRlcmlhbC5kZWZpbmVzWyBuYW1lIF0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgcGFyYW1ldGVyTmFtZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBwYXJhbWV0ZXJOYW1lID0gcGFyYW1ldGVyTmFtZXNbIGkgXTtcblx0XHRcdFx0Y2h1bmtzLnB1c2goIHBhcmFtZXRlck5hbWUgKTtcblx0XHRcdFx0Y2h1bmtzLnB1c2goIHBhcmFtZXRlcnNbIHBhcmFtZXRlck5hbWUgXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBjaHVua3Muam9pbigpO1xuXG5cdFx0fTtcblxuXHRcdHRoaXMuYWNxdWlyZVByb2dyYW0gPSBmdW5jdGlvbiAoIG1hdGVyaWFsLCBwYXJhbWV0ZXJzLCBjb2RlICkge1xuXG5cdFx0XHR2YXIgcHJvZ3JhbTtcblxuXHRcdFx0Ly8gQ2hlY2sgaWYgY29kZSBoYXMgYmVlbiBhbHJlYWR5IGNvbXBpbGVkXG5cdFx0XHRmb3IgKCB2YXIgcCA9IDAsIHBsID0gcHJvZ3JhbXMubGVuZ3RoOyBwIDwgcGw7IHAgKysgKSB7XG5cblx0XHRcdFx0dmFyIHByb2dyYW1JbmZvID0gcHJvZ3JhbXNbIHAgXTtcblxuXHRcdFx0XHRpZiAoIHByb2dyYW1JbmZvLmNvZGUgPT09IGNvZGUgKSB7XG5cblx0XHRcdFx0XHRwcm9ncmFtID0gcHJvZ3JhbUluZm87XG5cdFx0XHRcdFx0KysgcHJvZ3JhbS51c2VkVGltZXM7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBwcm9ncmFtID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cHJvZ3JhbSA9IG5ldyBUSFJFRS5XZWJHTFByb2dyYW0oIHJlbmRlcmVyLCBjb2RlLCBtYXRlcmlhbCwgcGFyYW1ldGVycyApO1xuXHRcdFx0XHRwcm9ncmFtcy5wdXNoKCBwcm9ncmFtICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHByb2dyYW07XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5yZWxlYXNlUHJvZ3JhbSA9IGZ1bmN0aW9uKCBwcm9ncmFtICkge1xuXG5cdFx0XHRpZiAoIC0tIHByb2dyYW0udXNlZFRpbWVzID09PSAwICkge1xuXG5cdFx0XHRcdC8vIFJlbW92ZSBmcm9tIHVub3JkZXJlZCBzZXRcblx0XHRcdFx0dmFyIGkgPSBwcm9ncmFtcy5pbmRleE9mKCBwcm9ncmFtICk7XG5cdFx0XHRcdHByb2dyYW1zWyBpIF0gPSBwcm9ncmFtc1sgcHJvZ3JhbXMubGVuZ3RoIC0gMSBdO1xuXHRcdFx0XHRwcm9ncmFtcy5wb3AoKTtcblxuXHRcdFx0XHQvLyBGcmVlIFdlYkdMIHJlc291cmNlc1xuXHRcdFx0XHRwcm9ncmFtLmRlc3Ryb3koKTtcblxuXHRcdFx0fVxuXG5cdFx0fTtcblxuXHRcdC8vIEV4cG9zZWQgZm9yIHJlc291cmNlIG1vbml0b3JpbmcgJiBlcnJvciBmZWVkYmFjayB2aWEgcmVuZGVyZXIuaW5mbzpcblx0XHR0aGlzLnByb2dyYW1zID0gcHJvZ3JhbXM7XG5cblx0fTtcblxuXHQvLyBGaWxlOnNyYy9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xQcm9wZXJ0aWVzLmpzXG5cblx0LyoqXG5cdCogQGF1dGhvciBmb3JkYWNpb3VzIC8gZm9yZGFjaW91cy5naXRodWIuaW9cblx0Ki9cblxuXHRUSFJFRS5XZWJHTFByb3BlcnRpZXMgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgcHJvcGVydGllcyA9IHt9O1xuXG5cdFx0dGhpcy5nZXQgPSBmdW5jdGlvbiAoIG9iamVjdCApIHtcblxuXHRcdFx0dmFyIHV1aWQgPSBvYmplY3QudXVpZDtcblx0XHRcdHZhciBtYXAgPSBwcm9wZXJ0aWVzWyB1dWlkIF07XG5cblx0XHRcdGlmICggbWFwID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0bWFwID0ge307XG5cdFx0XHRcdHByb3BlcnRpZXNbIHV1aWQgXSA9IG1hcDtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWFwO1xuXG5cdFx0fTtcblxuXHRcdHRoaXMuZGVsZXRlID0gZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cblx0XHRcdGRlbGV0ZSBwcm9wZXJ0aWVzWyBvYmplY3QudXVpZCBdO1xuXG5cdFx0fTtcblxuXHRcdHRoaXMuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHByb3BlcnRpZXMgPSB7fTtcblxuXHRcdH07XG5cblx0fTtcblxuXHQvLyBGaWxlOnNyYy9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xTaGFkZXIuanNcblxuXHRUSFJFRS5XZWJHTFNoYWRlciA9ICggZnVuY3Rpb24gKCkge1xuXG5cdFx0ZnVuY3Rpb24gYWRkTGluZU51bWJlcnMoIHN0cmluZyApIHtcblxuXHRcdFx0dmFyIGxpbmVzID0gc3RyaW5nLnNwbGl0KCAnXFxuJyApO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0bGluZXNbIGkgXSA9ICggaSArIDEgKSArICc6ICcgKyBsaW5lc1sgaSBdO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBsaW5lcy5qb2luKCAnXFxuJyApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFdlYkdMU2hhZGVyKCBnbCwgdHlwZSwgc3RyaW5nICkge1xuXG5cdFx0XHR2YXIgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKCB0eXBlICk7XG5cblx0XHRcdGdsLnNoYWRlclNvdXJjZSggc2hhZGVyLCBzdHJpbmcgKTtcblx0XHRcdGdsLmNvbXBpbGVTaGFkZXIoIHNoYWRlciApO1xuXG5cdFx0XHRpZiAoIGdsLmdldFNoYWRlclBhcmFtZXRlciggc2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUyApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xTaGFkZXI6IFNoYWRlciBjb3VsZG5cXCd0IGNvbXBpbGUuJyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggZ2wuZ2V0U2hhZGVySW5mb0xvZyggc2hhZGVyICkgIT09ICcnICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMU2hhZGVyOiBnbC5nZXRTaGFkZXJJbmZvTG9nKCknLCB0eXBlID09PSBnbC5WRVJURVhfU0hBREVSID8gJ3ZlcnRleCcgOiAnZnJhZ21lbnQnLCBnbC5nZXRTaGFkZXJJbmZvTG9nKCBzaGFkZXIgKSwgYWRkTGluZU51bWJlcnMoIHN0cmluZyApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gLS1lbmFibGUtcHJpdmlsZWdlZC13ZWJnbC1leHRlbnNpb25cblx0XHRcdC8vIGNvbnNvbGUubG9nKCB0eXBlLCBnbC5nZXRFeHRlbnNpb24oICdXRUJHTF9kZWJ1Z19zaGFkZXJzJyApLmdldFRyYW5zbGF0ZWRTaGFkZXJTb3VyY2UoIHNoYWRlciApICk7XG5cblx0XHRcdHJldHVybiBzaGFkZXI7XG5cblx0XHR9O1xuXG5cdH0gKSgpO1xuXG5cdC8vIEZpbGU6c3JjL3JlbmRlcmVycy93ZWJnbC9XZWJHTFNoYWRvd01hcC5qc1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuXHQgKi9cblxuXHRUSFJFRS5XZWJHTFNoYWRvd01hcCA9IGZ1bmN0aW9uICggX3JlbmRlcmVyLCBfbGlnaHRzLCBfb2JqZWN0cyApIHtcblxuXHRcdHZhciBfZ2wgPSBfcmVuZGVyZXIuY29udGV4dCxcblx0XHRfc3RhdGUgPSBfcmVuZGVyZXIuc3RhdGUsXG5cdFx0X2ZydXN0dW0gPSBuZXcgVEhSRUUuRnJ1c3R1bSgpLFxuXHRcdF9wcm9qU2NyZWVuTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKSxcblxuXHRcdF9taW4gPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuXHRcdF9tYXggPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuXG5cdFx0X2xvb2tUYXJnZXQgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuXHRcdF9saWdodFBvc2l0aW9uV29ybGQgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuXG5cdFx0X3JlbmRlckxpc3QgPSBbXSxcblxuXHRcdF9Nb3JwaGluZ0ZsYWcgPSAxLFxuXHRcdF9Ta2lubmluZ0ZsYWcgPSAyLFxuXG5cdFx0X051bWJlck9mTWF0ZXJpYWxWYXJpYW50cyA9ICggX01vcnBoaW5nRmxhZyB8IF9Ta2lubmluZ0ZsYWcgKSArIDEsXG5cblx0XHRfZGVwdGhNYXRlcmlhbHMgPSBuZXcgQXJyYXkoIF9OdW1iZXJPZk1hdGVyaWFsVmFyaWFudHMgKSxcblx0XHRfZGlzdGFuY2VNYXRlcmlhbHMgPSBuZXcgQXJyYXkoIF9OdW1iZXJPZk1hdGVyaWFsVmFyaWFudHMgKTtcblxuXHRcdHZhciBjdWJlRGlyZWN0aW9ucyA9IFtcblx0XHRcdG5ldyBUSFJFRS5WZWN0b3IzKCAxLCAwLCAwICksIG5ldyBUSFJFRS5WZWN0b3IzKCAtIDEsIDAsIDAgKSwgbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIDEgKSxcblx0XHRcdG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAtIDEgKSwgbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDEsIDAgKSwgbmV3IFRIUkVFLlZlY3RvcjMoIDAsIC0gMSwgMCApXG5cdFx0XTtcblxuXHRcdHZhciBjdWJlVXBzID0gW1xuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjMoIDAsIDEsIDAgKSwgbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDEsIDAgKSwgbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDEsIDAgKSxcblx0XHRcdG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICksIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAxICksXHRuZXcgVEhSRUUuVmVjdG9yMyggMCwgMCwgLSAxIClcblx0XHRdO1xuXG5cdFx0dmFyIGN1YmUyRFZpZXdQb3J0cyA9IFtcblx0XHRcdG5ldyBUSFJFRS5WZWN0b3I0KCksIG5ldyBUSFJFRS5WZWN0b3I0KCksIG5ldyBUSFJFRS5WZWN0b3I0KCksXG5cdFx0XHRuZXcgVEhSRUUuVmVjdG9yNCgpLCBuZXcgVEhSRUUuVmVjdG9yNCgpLCBuZXcgVEhSRUUuVmVjdG9yNCgpXG5cdFx0XTtcblxuXHRcdHZhciBfdmVjdG9yNCA9IG5ldyBUSFJFRS5WZWN0b3I0KCk7XG5cblx0XHQvLyBpbml0XG5cblx0XHR2YXIgZGVwdGhTaGFkZXIgPSBUSFJFRS5TaGFkZXJMaWJbIFwiZGVwdGhSR0JBXCIgXTtcblx0XHR2YXIgZGVwdGhVbmlmb3JtcyA9IFRIUkVFLlVuaWZvcm1zVXRpbHMuY2xvbmUoIGRlcHRoU2hhZGVyLnVuaWZvcm1zICk7XG5cblx0XHR2YXIgZGlzdGFuY2VTaGFkZXIgPSBUSFJFRS5TaGFkZXJMaWJbIFwiZGlzdGFuY2VSR0JBXCIgXTtcblx0XHR2YXIgZGlzdGFuY2VVbmlmb3JtcyA9IFRIUkVFLlVuaWZvcm1zVXRpbHMuY2xvbmUoIGRpc3RhbmNlU2hhZGVyLnVuaWZvcm1zICk7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IF9OdW1iZXJPZk1hdGVyaWFsVmFyaWFudHM7ICsrIGkgKSB7XG5cblx0XHRcdHZhciB1c2VNb3JwaGluZyA9ICggaSAmIF9Nb3JwaGluZ0ZsYWcgKSAhPT0gMDtcblx0XHRcdHZhciB1c2VTa2lubmluZyA9ICggaSAmIF9Ta2lubmluZ0ZsYWcgKSAhPT0gMDtcblxuXHRcdFx0dmFyIGRlcHRoTWF0ZXJpYWwgPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoIHtcblx0XHRcdFx0dW5pZm9ybXM6IGRlcHRoVW5pZm9ybXMsXG5cdFx0XHRcdHZlcnRleFNoYWRlcjogZGVwdGhTaGFkZXIudmVydGV4U2hhZGVyLFxuXHRcdFx0XHRmcmFnbWVudFNoYWRlcjogZGVwdGhTaGFkZXIuZnJhZ21lbnRTaGFkZXIsXG5cdFx0XHRcdG1vcnBoVGFyZ2V0czogdXNlTW9ycGhpbmcsXG5cdFx0XHRcdHNraW5uaW5nOiB1c2VTa2lubmluZ1xuXHRcdFx0fSApO1xuXG5cdFx0XHRkZXB0aE1hdGVyaWFsLl9zaGFkb3dQYXNzID0gdHJ1ZTtcblxuXHRcdFx0X2RlcHRoTWF0ZXJpYWxzWyBpIF0gPSBkZXB0aE1hdGVyaWFsO1xuXG5cdFx0XHR2YXIgZGlzdGFuY2VNYXRlcmlhbCA9IG5ldyBUSFJFRS5TaGFkZXJNYXRlcmlhbCgge1xuXHRcdFx0XHR1bmlmb3JtczogZGlzdGFuY2VVbmlmb3Jtcyxcblx0XHRcdFx0dmVydGV4U2hhZGVyOiBkaXN0YW5jZVNoYWRlci52ZXJ0ZXhTaGFkZXIsXG5cdFx0XHRcdGZyYWdtZW50U2hhZGVyOiBkaXN0YW5jZVNoYWRlci5mcmFnbWVudFNoYWRlcixcblx0XHRcdFx0bW9ycGhUYXJnZXRzOiB1c2VNb3JwaGluZyxcblx0XHRcdFx0c2tpbm5pbmc6IHVzZVNraW5uaW5nXG5cdFx0XHR9ICk7XG5cblx0XHRcdGRpc3RhbmNlTWF0ZXJpYWwuX3NoYWRvd1Bhc3MgPSB0cnVlO1xuXG5cdFx0XHRfZGlzdGFuY2VNYXRlcmlhbHNbIGkgXSA9IGRpc3RhbmNlTWF0ZXJpYWw7XG5cblx0XHR9XG5cblx0XHQvL1xuXG5cdFx0dmFyIHNjb3BlID0gdGhpcztcblxuXHRcdHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuXG5cdFx0dGhpcy5hdXRvVXBkYXRlID0gdHJ1ZTtcblx0XHR0aGlzLm5lZWRzVXBkYXRlID0gZmFsc2U7XG5cblx0XHR0aGlzLnR5cGUgPSBUSFJFRS5QQ0ZTaGFkb3dNYXA7XG5cdFx0dGhpcy5jdWxsRmFjZSA9IFRIUkVFLkN1bGxGYWNlRnJvbnQ7XG5cblx0XHR0aGlzLnJlbmRlciA9IGZ1bmN0aW9uICggc2NlbmUgKSB7XG5cblx0XHRcdHZhciBmYWNlQ291bnQsIGlzUG9pbnRMaWdodDtcblxuXHRcdFx0aWYgKCBzY29wZS5lbmFibGVkID09PSBmYWxzZSApIHJldHVybjtcblx0XHRcdGlmICggc2NvcGUuYXV0b1VwZGF0ZSA9PT0gZmFsc2UgJiYgc2NvcGUubmVlZHNVcGRhdGUgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0XHQvLyBTZXQgR0wgc3RhdGUgZm9yIGRlcHRoIG1hcC5cblx0XHRcdF9nbC5jbGVhckNvbG9yKCAxLCAxLCAxLCAxICk7XG5cdFx0XHRfc3RhdGUuZGlzYWJsZSggX2dsLkJMRU5EICk7XG5cdFx0XHRfc3RhdGUuZW5hYmxlKCBfZ2wuQ1VMTF9GQUNFICk7XG5cdFx0XHRfZ2wuZnJvbnRGYWNlKCBfZ2wuQ0NXICk7XG5cdFx0XHRfZ2wuY3VsbEZhY2UoIHNjb3BlLmN1bGxGYWNlID09PSBUSFJFRS5DdWxsRmFjZUZyb250ID8gX2dsLkZST05UIDogX2dsLkJBQ0sgKTtcblx0XHRcdF9zdGF0ZS5zZXREZXB0aFRlc3QoIHRydWUgKTtcblxuXHRcdFx0Ly8gc2F2ZSB0aGUgZXhpc3Rpbmcgdmlld3BvcnQgc28gaXQgY2FuIGJlIHJlc3RvcmVkIGxhdGVyXG5cdFx0XHRfcmVuZGVyZXIuZ2V0Vmlld3BvcnQoIF92ZWN0b3I0ICk7XG5cblx0XHRcdC8vIHJlbmRlciBkZXB0aCBtYXBcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IF9saWdodHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGxpZ2h0ID0gX2xpZ2h0c1sgaSBdO1xuXG5cdFx0XHRcdGlmICggbGlnaHQuY2FzdFNoYWRvdyA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdHZhciBzaGFkb3cgPSBsaWdodC5zaGFkb3c7XG5cdFx0XHRcdFx0dmFyIHNoYWRvd0NhbWVyYSA9IHNoYWRvdy5jYW1lcmE7XG5cdFx0XHRcdFx0dmFyIHNoYWRvd01hcFNpemUgPSBzaGFkb3cubWFwU2l6ZTtcblxuXHRcdFx0XHRcdGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5Qb2ludExpZ2h0ICkge1xuXG5cdFx0XHRcdFx0XHRmYWNlQ291bnQgPSA2O1xuXHRcdFx0XHRcdFx0aXNQb2ludExpZ2h0ID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0dmFyIHZwV2lkdGggPSBzaGFkb3dNYXBTaXplLnggLyA0LjA7XG5cdFx0XHRcdFx0XHR2YXIgdnBIZWlnaHQgPSBzaGFkb3dNYXBTaXplLnkgLyAyLjA7XG5cblx0XHRcdFx0XHRcdC8vIFRoZXNlIHZpZXdwb3J0cyBtYXAgYSBjdWJlLW1hcCBvbnRvIGEgMkQgdGV4dHVyZSB3aXRoIHRoZVxuXHRcdFx0XHRcdFx0Ly8gZm9sbG93aW5nIG9yaWVudGF0aW9uOlxuXHRcdFx0XHRcdFx0Ly9cblx0XHRcdFx0XHRcdC8vICB4elhaXG5cdFx0XHRcdFx0XHQvLyAgIHkgWVxuXHRcdFx0XHRcdFx0Ly9cblx0XHRcdFx0XHRcdC8vIFggLSBQb3NpdGl2ZSB4IGRpcmVjdGlvblxuXHRcdFx0XHRcdFx0Ly8geCAtIE5lZ2F0aXZlIHggZGlyZWN0aW9uXG5cdFx0XHRcdFx0XHQvLyBZIC0gUG9zaXRpdmUgeSBkaXJlY3Rpb25cblx0XHRcdFx0XHRcdC8vIHkgLSBOZWdhdGl2ZSB5IGRpcmVjdGlvblxuXHRcdFx0XHRcdFx0Ly8gWiAtIFBvc2l0aXZlIHogZGlyZWN0aW9uXG5cdFx0XHRcdFx0XHQvLyB6IC0gTmVnYXRpdmUgeiBkaXJlY3Rpb25cblxuXHRcdFx0XHRcdFx0Ly8gcG9zaXRpdmUgWFxuXHRcdFx0XHRcdFx0Y3ViZTJEVmlld1BvcnRzWyAwIF0uc2V0KCB2cFdpZHRoICogMiwgdnBIZWlnaHQsIHZwV2lkdGgsIHZwSGVpZ2h0ICk7XG5cdFx0XHRcdFx0XHQvLyBuZWdhdGl2ZSBYXG5cdFx0XHRcdFx0XHRjdWJlMkRWaWV3UG9ydHNbIDEgXS5zZXQoIDAsIHZwSGVpZ2h0LCB2cFdpZHRoLCB2cEhlaWdodCApO1xuXHRcdFx0XHRcdFx0Ly8gcG9zaXRpdmUgWlxuXHRcdFx0XHRcdFx0Y3ViZTJEVmlld1BvcnRzWyAyIF0uc2V0KCB2cFdpZHRoICogMywgdnBIZWlnaHQsIHZwV2lkdGgsIHZwSGVpZ2h0ICk7XG5cdFx0XHRcdFx0XHQvLyBuZWdhdGl2ZSBaXG5cdFx0XHRcdFx0XHRjdWJlMkRWaWV3UG9ydHNbIDMgXS5zZXQoIHZwV2lkdGgsIHZwSGVpZ2h0LCB2cFdpZHRoLCB2cEhlaWdodCApO1xuXHRcdFx0XHRcdFx0Ly8gcG9zaXRpdmUgWVxuXHRcdFx0XHRcdFx0Y3ViZTJEVmlld1BvcnRzWyA0IF0uc2V0KCB2cFdpZHRoICogMywgMCwgdnBXaWR0aCwgdnBIZWlnaHQgKTtcblx0XHRcdFx0XHRcdC8vIG5lZ2F0aXZlIFlcblx0XHRcdFx0XHRcdGN1YmUyRFZpZXdQb3J0c1sgNSBdLnNldCggdnBXaWR0aCwgMCwgdnBXaWR0aCwgdnBIZWlnaHQgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdGZhY2VDb3VudCA9IDE7XG5cdFx0XHRcdFx0XHRpc1BvaW50TGlnaHQgPSBmYWxzZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggc2hhZG93Lm1hcCA9PT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdFx0dmFyIHNoYWRvd0ZpbHRlciA9IFRIUkVFLkxpbmVhckZpbHRlcjtcblxuXHRcdFx0XHRcdFx0aWYgKCBzY29wZS50eXBlID09PSBUSFJFRS5QQ0ZTb2Z0U2hhZG93TWFwICkge1xuXG5cdFx0XHRcdFx0XHRcdHNoYWRvd0ZpbHRlciA9IFRIUkVFLk5lYXJlc3RGaWx0ZXI7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0dmFyIHBhcnMgPSB7IG1pbkZpbHRlcjogc2hhZG93RmlsdGVyLCBtYWdGaWx0ZXI6IHNoYWRvd0ZpbHRlciwgZm9ybWF0OiBUSFJFRS5SR0JBRm9ybWF0IH07XG5cblx0XHRcdFx0XHRcdHNoYWRvdy5tYXAgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQoIHNoYWRvd01hcFNpemUueCwgc2hhZG93TWFwU2l6ZS55LCBwYXJzICk7XG5cdFx0XHRcdFx0XHRzaGFkb3cubWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuXHRcdFx0XHRcdFx0Ly9cblxuXHRcdFx0XHRcdFx0aWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLlNwb3RMaWdodCApIHtcblxuXHRcdFx0XHRcdFx0XHRzaGFkb3dDYW1lcmEuYXNwZWN0ID0gc2hhZG93TWFwU2l6ZS54IC8gc2hhZG93TWFwU2l6ZS55O1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHNoYWRvd0NhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR2YXIgc2hhZG93TWFwID0gc2hhZG93Lm1hcDtcblx0XHRcdFx0XHR2YXIgc2hhZG93TWF0cml4ID0gc2hhZG93Lm1hdHJpeDtcblxuXHRcdFx0XHRcdF9saWdodFBvc2l0aW9uV29ybGQuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC5tYXRyaXhXb3JsZCApO1xuXHRcdFx0XHRcdHNoYWRvd0NhbWVyYS5wb3NpdGlvbi5jb3B5KCBfbGlnaHRQb3NpdGlvbldvcmxkICk7XG5cblx0XHRcdFx0XHRfcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KCBzaGFkb3dNYXAgKTtcblx0XHRcdFx0XHRfcmVuZGVyZXIuY2xlYXIoKTtcblxuXHRcdFx0XHRcdC8vIHJlbmRlciBzaGFkb3cgbWFwIGZvciBlYWNoIGN1YmUgZmFjZSAoaWYgb21uaS1kaXJlY3Rpb25hbCkgb3Jcblx0XHRcdFx0XHQvLyBydW4gYSBzaW5nbGUgcGFzcyBpZiBub3RcblxuXHRcdFx0XHRcdGZvciAoIHZhciBmYWNlID0gMDsgZmFjZSA8IGZhY2VDb3VudDsgZmFjZSArKyApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBpc1BvaW50TGlnaHQgKSB7XG5cblx0XHRcdFx0XHRcdFx0X2xvb2tUYXJnZXQuY29weSggc2hhZG93Q2FtZXJhLnBvc2l0aW9uICk7XG5cdFx0XHRcdFx0XHRcdF9sb29rVGFyZ2V0LmFkZCggY3ViZURpcmVjdGlvbnNbIGZhY2UgXSApO1xuXHRcdFx0XHRcdFx0XHRzaGFkb3dDYW1lcmEudXAuY29weSggY3ViZVVwc1sgZmFjZSBdICk7XG5cdFx0XHRcdFx0XHRcdHNoYWRvd0NhbWVyYS5sb29rQXQoIF9sb29rVGFyZ2V0ICk7XG5cdFx0XHRcdFx0XHRcdHZhciB2cERpbWVuc2lvbnMgPSBjdWJlMkRWaWV3UG9ydHNbIGZhY2UgXTtcblx0XHRcdFx0XHRcdFx0X3JlbmRlcmVyLnNldFZpZXdwb3J0KCB2cERpbWVuc2lvbnMueCwgdnBEaW1lbnNpb25zLnksIHZwRGltZW5zaW9ucy56LCB2cERpbWVuc2lvbnMudyApO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdF9sb29rVGFyZ2V0LnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkICk7XG5cdFx0XHRcdFx0XHRcdHNoYWRvd0NhbWVyYS5sb29rQXQoIF9sb29rVGFyZ2V0ICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0c2hhZG93Q2FtZXJhLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cdFx0XHRcdFx0XHRzaGFkb3dDYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLmdldEludmVyc2UoIHNoYWRvd0NhbWVyYS5tYXRyaXhXb3JsZCApO1xuXG5cdFx0XHRcdFx0XHQvLyBjb21wdXRlIHNoYWRvdyBtYXRyaXhcblxuXHRcdFx0XHRcdFx0c2hhZG93TWF0cml4LnNldChcblx0XHRcdFx0XHRcdFx0MC41LCAwLjAsIDAuMCwgMC41LFxuXHRcdFx0XHRcdFx0XHQwLjAsIDAuNSwgMC4wLCAwLjUsXG5cdFx0XHRcdFx0XHRcdDAuMCwgMC4wLCAwLjUsIDAuNSxcblx0XHRcdFx0XHRcdFx0MC4wLCAwLjAsIDAuMCwgMS4wXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRzaGFkb3dNYXRyaXgubXVsdGlwbHkoIHNoYWRvd0NhbWVyYS5wcm9qZWN0aW9uTWF0cml4ICk7XG5cdFx0XHRcdFx0XHRzaGFkb3dNYXRyaXgubXVsdGlwbHkoIHNoYWRvd0NhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UgKTtcblxuXHRcdFx0XHRcdFx0Ly8gdXBkYXRlIGNhbWVyYSBtYXRyaWNlcyBhbmQgZnJ1c3R1bVxuXG5cdFx0XHRcdFx0XHRfcHJvalNjcmVlbk1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBzaGFkb3dDYW1lcmEucHJvamVjdGlvbk1hdHJpeCwgc2hhZG93Q2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSApO1xuXHRcdFx0XHRcdFx0X2ZydXN0dW0uc2V0RnJvbU1hdHJpeCggX3Byb2pTY3JlZW5NYXRyaXggKTtcblxuXHRcdFx0XHRcdFx0Ly8gc2V0IG9iamVjdCBtYXRyaWNlcyAmIGZydXN0dW0gY3VsbGluZ1xuXG5cdFx0XHRcdFx0XHRfcmVuZGVyTGlzdC5sZW5ndGggPSAwO1xuXG5cdFx0XHRcdFx0XHRwcm9qZWN0T2JqZWN0KCBzY2VuZSwgc2hhZG93Q2FtZXJhICk7XG5cblx0XHRcdFx0XHRcdC8vIHJlbmRlciBzaGFkb3cgbWFwXG5cdFx0XHRcdFx0XHQvLyByZW5kZXIgcmVndWxhciBvYmplY3RzXG5cblx0XHRcdFx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBfcmVuZGVyTGlzdC5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHRcdFx0XHR2YXIgb2JqZWN0ID0gX3JlbmRlckxpc3RbIGogXTtcblx0XHRcdFx0XHRcdFx0dmFyIGdlb21ldHJ5ID0gX29iamVjdHMudXBkYXRlKCBvYmplY3QgKTtcblx0XHRcdFx0XHRcdFx0dmFyIG1hdGVyaWFsID0gb2JqZWN0Lm1hdGVyaWFsO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoRmFjZU1hdGVyaWFsICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0dmFyIGdyb3VwcyA9IGdlb21ldHJ5Lmdyb3Vwcztcblx0XHRcdFx0XHRcdFx0XHR2YXIgbWF0ZXJpYWxzID0gbWF0ZXJpYWwubWF0ZXJpYWxzO1xuXG5cdFx0XHRcdFx0XHRcdFx0Zm9yICggdmFyIGsgPSAwLCBrbCA9IGdyb3Vwcy5sZW5ndGg7IGsgPCBrbDsgayArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIGdyb3VwID0gZ3JvdXBzWyBrIF07XG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgZ3JvdXBNYXRlcmlhbCA9IG1hdGVyaWFsc1sgZ3JvdXAubWF0ZXJpYWxJbmRleCBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGdyb3VwTWF0ZXJpYWwudmlzaWJsZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHR2YXIgZGVwdGhNYXRlcmlhbCA9IGdldERlcHRoTWF0ZXJpYWwoIG9iamVjdCwgZ3JvdXBNYXRlcmlhbCwgaXNQb2ludExpZ2h0LCBfbGlnaHRQb3NpdGlvbldvcmxkICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdF9yZW5kZXJlci5yZW5kZXJCdWZmZXJEaXJlY3QoIHNoYWRvd0NhbWVyYSwgX2xpZ2h0cywgbnVsbCwgZ2VvbWV0cnksIGRlcHRoTWF0ZXJpYWwsIG9iamVjdCwgZ3JvdXAgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHR2YXIgZGVwdGhNYXRlcmlhbCA9IGdldERlcHRoTWF0ZXJpYWwoIG9iamVjdCwgbWF0ZXJpYWwsIGlzUG9pbnRMaWdodCwgX2xpZ2h0UG9zaXRpb25Xb3JsZCApO1xuXHRcdFx0XHRcdFx0XHRcdF9yZW5kZXJlci5yZW5kZXJCdWZmZXJEaXJlY3QoIHNoYWRvd0NhbWVyYSwgX2xpZ2h0cywgbnVsbCwgZ2VvbWV0cnksIGRlcHRoTWF0ZXJpYWwsIG9iamVjdCwgbnVsbCApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gV2UgbXVzdCBjYWxsIF9yZW5kZXJlci5yZXNldEdMU3RhdGUoKSBhdCB0aGUgZW5kIG9mIGVhY2ggaXRlcmF0aW9uIG9mXG5cdFx0XHRcdFx0Ly8gdGhlIGxpZ2h0IGxvb3AgaW4gb3JkZXIgdG8gZm9yY2UgbWF0ZXJpYWwgdXBkYXRlcyBmb3IgZWFjaCBsaWdodC5cblx0XHRcdFx0XHRfcmVuZGVyZXIucmVzZXRHTFN0YXRlKCk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdF9yZW5kZXJlci5zZXRWaWV3cG9ydCggX3ZlY3RvcjQueCwgX3ZlY3RvcjQueSwgX3ZlY3RvcjQueiwgX3ZlY3RvcjQudyApO1xuXG5cdFx0XHQvLyBSZXN0b3JlIEdMIHN0YXRlLlxuXHRcdFx0dmFyIGNsZWFyQ29sb3IgPSBfcmVuZGVyZXIuZ2V0Q2xlYXJDb2xvcigpLFxuXHRcdFx0Y2xlYXJBbHBoYSA9IF9yZW5kZXJlci5nZXRDbGVhckFscGhhKCk7XG5cdFx0XHRfcmVuZGVyZXIuc2V0Q2xlYXJDb2xvciggY2xlYXJDb2xvciwgY2xlYXJBbHBoYSApO1xuXHRcdFx0X3N0YXRlLmVuYWJsZSggX2dsLkJMRU5EICk7XG5cblx0XHRcdGlmICggc2NvcGUuY3VsbEZhY2UgPT09IFRIUkVFLkN1bGxGYWNlRnJvbnQgKSB7XG5cblx0XHRcdFx0X2dsLmN1bGxGYWNlKCBfZ2wuQkFDSyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdF9yZW5kZXJlci5yZXNldEdMU3RhdGUoKTtcblxuXHRcdFx0c2NvcGUubmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBnZXREZXB0aE1hdGVyaWFsKCBvYmplY3QsIG1hdGVyaWFsLCBpc1BvaW50TGlnaHQsIGxpZ2h0UG9zaXRpb25Xb3JsZCApIHtcblxuXHRcdFx0dmFyIGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xuXG5cdFx0XHR2YXIgbmV3TWF0ZXJpYWwgPSBudWxsO1xuXG5cdFx0XHR2YXIgbWF0ZXJpYWxWYXJpYW50cyA9IF9kZXB0aE1hdGVyaWFscztcblx0XHRcdHZhciBjdXN0b21NYXRlcmlhbCA9IG9iamVjdC5jdXN0b21EZXB0aE1hdGVyaWFsO1xuXG5cdFx0XHRpZiAoIGlzUG9pbnRMaWdodCApIHtcblxuXHRcdFx0XHRtYXRlcmlhbFZhcmlhbnRzID0gX2Rpc3RhbmNlTWF0ZXJpYWxzO1xuXHRcdFx0XHRjdXN0b21NYXRlcmlhbCA9IG9iamVjdC5jdXN0b21EaXN0YW5jZU1hdGVyaWFsO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggISBjdXN0b21NYXRlcmlhbCApIHtcblxuXHRcdFx0XHR2YXIgdXNlTW9ycGhpbmcgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHMgIT09IHVuZGVmaW5lZCAmJlxuXHRcdFx0XHRcdFx0Z2VvbWV0cnkubW9ycGhUYXJnZXRzLmxlbmd0aCA+IDAgJiYgbWF0ZXJpYWwubW9ycGhUYXJnZXRzO1xuXG5cdFx0XHRcdHZhciB1c2VTa2lubmluZyA9IG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlNraW5uZWRNZXNoICYmIG1hdGVyaWFsLnNraW5uaW5nO1xuXG5cdFx0XHRcdHZhciB2YXJpYW50SW5kZXggPSAwO1xuXG5cdFx0XHRcdGlmICggdXNlTW9ycGhpbmcgKSB2YXJpYW50SW5kZXggfD0gX01vcnBoaW5nRmxhZztcblx0XHRcdFx0aWYgKCB1c2VTa2lubmluZyApIHZhcmlhbnRJbmRleCB8PSBfU2tpbm5pbmdGbGFnO1xuXG5cdFx0XHRcdG5ld01hdGVyaWFsID0gbWF0ZXJpYWxWYXJpYW50c1sgdmFyaWFudEluZGV4IF07XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0bmV3TWF0ZXJpYWwgPSBjdXN0b21NYXRlcmlhbDtcblxuXHRcdFx0fVxuXG5cdFx0XHRuZXdNYXRlcmlhbC52aXNpYmxlID0gbWF0ZXJpYWwudmlzaWJsZTtcblx0XHRcdG5ld01hdGVyaWFsLndpcmVmcmFtZSA9IG1hdGVyaWFsLndpcmVmcmFtZTtcblx0XHRcdG5ld01hdGVyaWFsLndpcmVmcmFtZUxpbmV3aWR0aCA9IG1hdGVyaWFsLndpcmVmcmFtZUxpbmV3aWR0aDtcblxuXHRcdFx0aWYgKCBpc1BvaW50TGlnaHQgJiYgbmV3TWF0ZXJpYWwudW5pZm9ybXMubGlnaHRQb3MgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRuZXdNYXRlcmlhbC51bmlmb3Jtcy5saWdodFBvcy52YWx1ZS5jb3B5KCBsaWdodFBvc2l0aW9uV29ybGQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbmV3TWF0ZXJpYWw7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwcm9qZWN0T2JqZWN0KCBvYmplY3QsIGNhbWVyYSApIHtcblxuXHRcdFx0aWYgKCBvYmplY3QudmlzaWJsZSA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRcdGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTWVzaCB8fCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5MaW5lIHx8IG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlBvaW50cyApIHtcblxuXHRcdFx0XHRpZiAoIG9iamVjdC5jYXN0U2hhZG93ICYmICggb2JqZWN0LmZydXN0dW1DdWxsZWQgPT09IGZhbHNlIHx8IF9mcnVzdHVtLmludGVyc2VjdHNPYmplY3QoIG9iamVjdCApID09PSB0cnVlICkgKSB7XG5cblx0XHRcdFx0XHR2YXIgbWF0ZXJpYWwgPSBvYmplY3QubWF0ZXJpYWw7XG5cblx0XHRcdFx0XHRpZiAoIG1hdGVyaWFsLnZpc2libGUgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRcdG9iamVjdC5tb2RlbFZpZXdNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSwgb2JqZWN0Lm1hdHJpeFdvcmxkICk7XG5cdFx0XHRcdFx0XHRfcmVuZGVyTGlzdC5wdXNoKCBvYmplY3QgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIGNoaWxkcmVuID0gb2JqZWN0LmNoaWxkcmVuO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHByb2plY3RPYmplY3QoIGNoaWxkcmVuWyBpIF0sIGNhbWVyYSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fTtcblxuXHQvLyBGaWxlOnNyYy9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xTdGF0ZS5qc1xuXG5cdC8qKlxuXHQqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCovXG5cblx0VEhSRUUuV2ViR0xTdGF0ZSA9IGZ1bmN0aW9uICggZ2wsIGV4dGVuc2lvbnMsIHBhcmFtVGhyZWVUb0dMICkge1xuXG5cdFx0dmFyIF90aGlzID0gdGhpcztcblxuXHRcdHZhciBuZXdBdHRyaWJ1dGVzID0gbmV3IFVpbnQ4QXJyYXkoIDE2ICk7XG5cdFx0dmFyIGVuYWJsZWRBdHRyaWJ1dGVzID0gbmV3IFVpbnQ4QXJyYXkoIDE2ICk7XG5cdFx0dmFyIGF0dHJpYnV0ZURpdmlzb3JzID0gbmV3IFVpbnQ4QXJyYXkoIDE2ICk7XG5cblx0XHR2YXIgY2FwYWJpbGl0aWVzID0ge307XG5cblx0XHR2YXIgY29tcHJlc3NlZFRleHR1cmVGb3JtYXRzID0gbnVsbDtcblxuXHRcdHZhciBjdXJyZW50QmxlbmRpbmcgPSBudWxsO1xuXHRcdHZhciBjdXJyZW50QmxlbmRFcXVhdGlvbiA9IG51bGw7XG5cdFx0dmFyIGN1cnJlbnRCbGVuZFNyYyA9IG51bGw7XG5cdFx0dmFyIGN1cnJlbnRCbGVuZERzdCA9IG51bGw7XG5cdFx0dmFyIGN1cnJlbnRCbGVuZEVxdWF0aW9uQWxwaGEgPSBudWxsO1xuXHRcdHZhciBjdXJyZW50QmxlbmRTcmNBbHBoYSA9IG51bGw7XG5cdFx0dmFyIGN1cnJlbnRCbGVuZERzdEFscGhhID0gbnVsbDtcblxuXHRcdHZhciBjdXJyZW50RGVwdGhGdW5jID0gbnVsbDtcblx0XHR2YXIgY3VycmVudERlcHRoV3JpdGUgPSBudWxsO1xuXG5cdFx0dmFyIGN1cnJlbnRDb2xvcldyaXRlID0gbnVsbDtcblxuXHRcdHZhciBjdXJyZW50RmxpcFNpZGVkID0gbnVsbDtcblxuXHRcdHZhciBjdXJyZW50TGluZVdpZHRoID0gbnVsbDtcblxuXHRcdHZhciBjdXJyZW50UG9seWdvbk9mZnNldEZhY3RvciA9IG51bGw7XG5cdFx0dmFyIGN1cnJlbnRQb2x5Z29uT2Zmc2V0VW5pdHMgPSBudWxsO1xuXG5cdFx0dmFyIG1heFRleHR1cmVzID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfVEVYVFVSRV9JTUFHRV9VTklUUyApO1xuXG5cdFx0dmFyIGN1cnJlbnRUZXh0dXJlU2xvdCA9IHVuZGVmaW5lZDtcblx0XHR2YXIgY3VycmVudEJvdW5kVGV4dHVyZXMgPSB7fTtcblxuXHRcdHRoaXMuaW5pdCA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Z2wuY2xlYXJDb2xvciggMCwgMCwgMCwgMSApO1xuXHRcdFx0Z2wuY2xlYXJEZXB0aCggMSApO1xuXHRcdFx0Z2wuY2xlYXJTdGVuY2lsKCAwICk7XG5cblx0XHRcdHRoaXMuZW5hYmxlKCBnbC5ERVBUSF9URVNUICk7XG5cdFx0XHRnbC5kZXB0aEZ1bmMoIGdsLkxFUVVBTCApO1xuXG5cdFx0XHRnbC5mcm9udEZhY2UoIGdsLkNDVyApO1xuXHRcdFx0Z2wuY3VsbEZhY2UoIGdsLkJBQ0sgKTtcblx0XHRcdHRoaXMuZW5hYmxlKCBnbC5DVUxMX0ZBQ0UgKTtcblxuXHRcdFx0dGhpcy5lbmFibGUoIGdsLkJMRU5EICk7XG5cdFx0XHRnbC5ibGVuZEVxdWF0aW9uKCBnbC5GVU5DX0FERCApO1xuXHRcdFx0Z2wuYmxlbmRGdW5jKCBnbC5TUkNfQUxQSEEsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEgKTtcblxuXHRcdH07XG5cblx0XHR0aGlzLmluaXRBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBuZXdBdHRyaWJ1dGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0bmV3QXR0cmlidXRlc1sgaSBdID0gMDtcblxuXHRcdFx0fVxuXG5cdFx0fTtcblxuXHRcdHRoaXMuZW5hYmxlQXR0cmlidXRlID0gZnVuY3Rpb24gKCBhdHRyaWJ1dGUgKSB7XG5cblx0XHRcdG5ld0F0dHJpYnV0ZXNbIGF0dHJpYnV0ZSBdID0gMTtcblxuXHRcdFx0aWYgKCBlbmFibGVkQXR0cmlidXRlc1sgYXR0cmlidXRlIF0gPT09IDAgKSB7XG5cblx0XHRcdFx0Z2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoIGF0dHJpYnV0ZSApO1xuXHRcdFx0XHRlbmFibGVkQXR0cmlidXRlc1sgYXR0cmlidXRlIF0gPSAxO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggYXR0cmlidXRlRGl2aXNvcnNbIGF0dHJpYnV0ZSBdICE9PSAwICkge1xuXG5cdFx0XHRcdHZhciBleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnICk7XG5cblx0XHRcdFx0ZXh0ZW5zaW9uLnZlcnRleEF0dHJpYkRpdmlzb3JBTkdMRSggYXR0cmlidXRlLCAwICk7XG5cdFx0XHRcdGF0dHJpYnV0ZURpdmlzb3JzWyBhdHRyaWJ1dGUgXSA9IDA7XG5cblx0XHRcdH1cblxuXHRcdH07XG5cblx0XHR0aGlzLmVuYWJsZUF0dHJpYnV0ZUFuZERpdmlzb3IgPSBmdW5jdGlvbiAoIGF0dHJpYnV0ZSwgbWVzaFBlckF0dHJpYnV0ZSwgZXh0ZW5zaW9uICkge1xuXG5cdFx0XHRuZXdBdHRyaWJ1dGVzWyBhdHRyaWJ1dGUgXSA9IDE7XG5cblx0XHRcdGlmICggZW5hYmxlZEF0dHJpYnV0ZXNbIGF0dHJpYnV0ZSBdID09PSAwICkge1xuXG5cdFx0XHRcdGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KCBhdHRyaWJ1dGUgKTtcblx0XHRcdFx0ZW5hYmxlZEF0dHJpYnV0ZXNbIGF0dHJpYnV0ZSBdID0gMTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGF0dHJpYnV0ZURpdmlzb3JzWyBhdHRyaWJ1dGUgXSAhPT0gbWVzaFBlckF0dHJpYnV0ZSApIHtcblxuXHRcdFx0XHRleHRlbnNpb24udmVydGV4QXR0cmliRGl2aXNvckFOR0xFKCBhdHRyaWJ1dGUsIG1lc2hQZXJBdHRyaWJ1dGUgKTtcblx0XHRcdFx0YXR0cmlidXRlRGl2aXNvcnNbIGF0dHJpYnV0ZSBdID0gbWVzaFBlckF0dHJpYnV0ZTtcblxuXHRcdFx0fVxuXG5cdFx0fTtcblxuXHRcdHRoaXMuZGlzYWJsZVVudXNlZEF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGVuYWJsZWRBdHRyaWJ1dGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0aWYgKCBlbmFibGVkQXR0cmlidXRlc1sgaSBdICE9PSBuZXdBdHRyaWJ1dGVzWyBpIF0gKSB7XG5cblx0XHRcdFx0XHRnbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoIGkgKTtcblx0XHRcdFx0XHRlbmFibGVkQXR0cmlidXRlc1sgaSBdID0gMDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH07XG5cblx0XHR0aGlzLmVuYWJsZSA9IGZ1bmN0aW9uICggaWQgKSB7XG5cblx0XHRcdGlmICggY2FwYWJpbGl0aWVzWyBpZCBdICE9PSB0cnVlICkge1xuXG5cdFx0XHRcdGdsLmVuYWJsZSggaWQgKTtcblx0XHRcdFx0Y2FwYWJpbGl0aWVzWyBpZCBdID0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0fTtcblxuXHRcdHRoaXMuZGlzYWJsZSA9IGZ1bmN0aW9uICggaWQgKSB7XG5cblx0XHRcdGlmICggY2FwYWJpbGl0aWVzWyBpZCBdICE9PSBmYWxzZSApIHtcblxuXHRcdFx0XHRnbC5kaXNhYmxlKCBpZCApO1xuXHRcdFx0XHRjYXBhYmlsaXRpZXNbIGlkIF0gPSBmYWxzZTtcblxuXHRcdFx0fVxuXG5cdFx0fTtcblxuXHRcdHRoaXMuZ2V0Q29tcHJlc3NlZFRleHR1cmVGb3JtYXRzID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRpZiAoIGNvbXByZXNzZWRUZXh0dXJlRm9ybWF0cyA9PT0gbnVsbCApIHtcblxuXHRcdFx0XHRjb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMgPSBbXTtcblxuXHRcdFx0XHRpZiAoIGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJyApIHx8XG5cdFx0XHRcdCAgICAgZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycgKSApIHtcblxuXHRcdFx0XHRcdHZhciBmb3JtYXRzID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5DT01QUkVTU0VEX1RFWFRVUkVfRk9STUFUUyApO1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZm9ybWF0cy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdGNvbXByZXNzZWRUZXh0dXJlRm9ybWF0cy5wdXNoKCBmb3JtYXRzWyBpIF0gKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGNvbXByZXNzZWRUZXh0dXJlRm9ybWF0cztcblxuXHRcdH07XG5cblx0XHR0aGlzLnNldEJsZW5kaW5nID0gZnVuY3Rpb24gKCBibGVuZGluZywgYmxlbmRFcXVhdGlvbiwgYmxlbmRTcmMsIGJsZW5kRHN0LCBibGVuZEVxdWF0aW9uQWxwaGEsIGJsZW5kU3JjQWxwaGEsIGJsZW5kRHN0QWxwaGEgKSB7XG5cblx0XHRcdGlmICggYmxlbmRpbmcgIT09IGN1cnJlbnRCbGVuZGluZyApIHtcblxuXHRcdFx0XHRpZiAoIGJsZW5kaW5nID09PSBUSFJFRS5Ob0JsZW5kaW5nICkge1xuXG5cdFx0XHRcdFx0dGhpcy5kaXNhYmxlKCBnbC5CTEVORCApO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGJsZW5kaW5nID09PSBUSFJFRS5BZGRpdGl2ZUJsZW5kaW5nICkge1xuXG5cdFx0XHRcdFx0dGhpcy5lbmFibGUoIGdsLkJMRU5EICk7XG5cdFx0XHRcdFx0Z2wuYmxlbmRFcXVhdGlvbiggZ2wuRlVOQ19BREQgKTtcblx0XHRcdFx0XHRnbC5ibGVuZEZ1bmMoIGdsLlNSQ19BTFBIQSwgZ2wuT05FICk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggYmxlbmRpbmcgPT09IFRIUkVFLlN1YnRyYWN0aXZlQmxlbmRpbmcgKSB7XG5cblx0XHRcdFx0XHQvLyBUT0RPOiBGaW5kIGJsZW5kRnVuY1NlcGFyYXRlKCkgY29tYmluYXRpb25cblxuXHRcdFx0XHRcdHRoaXMuZW5hYmxlKCBnbC5CTEVORCApO1xuXHRcdFx0XHRcdGdsLmJsZW5kRXF1YXRpb24oIGdsLkZVTkNfQUREICk7XG5cdFx0XHRcdFx0Z2wuYmxlbmRGdW5jKCBnbC5aRVJPLCBnbC5PTkVfTUlOVVNfU1JDX0NPTE9SICk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggYmxlbmRpbmcgPT09IFRIUkVFLk11bHRpcGx5QmxlbmRpbmcgKSB7XG5cblx0XHRcdFx0XHQvLyBUT0RPOiBGaW5kIGJsZW5kRnVuY1NlcGFyYXRlKCkgY29tYmluYXRpb25cblxuXHRcdFx0XHRcdHRoaXMuZW5hYmxlKCBnbC5CTEVORCApO1xuXHRcdFx0XHRcdGdsLmJsZW5kRXF1YXRpb24oIGdsLkZVTkNfQUREICk7XG5cdFx0XHRcdFx0Z2wuYmxlbmRGdW5jKCBnbC5aRVJPLCBnbC5TUkNfQ09MT1IgKTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBibGVuZGluZyA9PT0gVEhSRUUuQ3VzdG9tQmxlbmRpbmcgKSB7XG5cblx0XHRcdFx0XHR0aGlzLmVuYWJsZSggZ2wuQkxFTkQgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dGhpcy5lbmFibGUoIGdsLkJMRU5EICk7XG5cdFx0XHRcdFx0Z2wuYmxlbmRFcXVhdGlvblNlcGFyYXRlKCBnbC5GVU5DX0FERCwgZ2wuRlVOQ19BREQgKTtcblx0XHRcdFx0XHRnbC5ibGVuZEZ1bmNTZXBhcmF0ZSggZ2wuU1JDX0FMUEhBLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBLCBnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y3VycmVudEJsZW5kaW5nID0gYmxlbmRpbmc7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBibGVuZGluZyA9PT0gVEhSRUUuQ3VzdG9tQmxlbmRpbmcgKSB7XG5cblx0XHRcdFx0YmxlbmRFcXVhdGlvbkFscGhhID0gYmxlbmRFcXVhdGlvbkFscGhhIHx8IGJsZW5kRXF1YXRpb247XG5cdFx0XHRcdGJsZW5kU3JjQWxwaGEgPSBibGVuZFNyY0FscGhhIHx8IGJsZW5kU3JjO1xuXHRcdFx0XHRibGVuZERzdEFscGhhID0gYmxlbmREc3RBbHBoYSB8fCBibGVuZERzdDtcblxuXHRcdFx0XHRpZiAoIGJsZW5kRXF1YXRpb24gIT09IGN1cnJlbnRCbGVuZEVxdWF0aW9uIHx8IGJsZW5kRXF1YXRpb25BbHBoYSAhPT0gY3VycmVudEJsZW5kRXF1YXRpb25BbHBoYSApIHtcblxuXHRcdFx0XHRcdGdsLmJsZW5kRXF1YXRpb25TZXBhcmF0ZSggcGFyYW1UaHJlZVRvR0woIGJsZW5kRXF1YXRpb24gKSwgcGFyYW1UaHJlZVRvR0woIGJsZW5kRXF1YXRpb25BbHBoYSApICk7XG5cblx0XHRcdFx0XHRjdXJyZW50QmxlbmRFcXVhdGlvbiA9IGJsZW5kRXF1YXRpb247XG5cdFx0XHRcdFx0Y3VycmVudEJsZW5kRXF1YXRpb25BbHBoYSA9IGJsZW5kRXF1YXRpb25BbHBoYTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBibGVuZFNyYyAhPT0gY3VycmVudEJsZW5kU3JjIHx8IGJsZW5kRHN0ICE9PSBjdXJyZW50QmxlbmREc3QgfHwgYmxlbmRTcmNBbHBoYSAhPT0gY3VycmVudEJsZW5kU3JjQWxwaGEgfHwgYmxlbmREc3RBbHBoYSAhPT0gY3VycmVudEJsZW5kRHN0QWxwaGEgKSB7XG5cblx0XHRcdFx0XHRnbC5ibGVuZEZ1bmNTZXBhcmF0ZSggcGFyYW1UaHJlZVRvR0woIGJsZW5kU3JjICksIHBhcmFtVGhyZWVUb0dMKCBibGVuZERzdCApLCBwYXJhbVRocmVlVG9HTCggYmxlbmRTcmNBbHBoYSApLCBwYXJhbVRocmVlVG9HTCggYmxlbmREc3RBbHBoYSApICk7XG5cblx0XHRcdFx0XHRjdXJyZW50QmxlbmRTcmMgPSBibGVuZFNyYztcblx0XHRcdFx0XHRjdXJyZW50QmxlbmREc3QgPSBibGVuZERzdDtcblx0XHRcdFx0XHRjdXJyZW50QmxlbmRTcmNBbHBoYSA9IGJsZW5kU3JjQWxwaGE7XG5cdFx0XHRcdFx0Y3VycmVudEJsZW5kRHN0QWxwaGEgPSBibGVuZERzdEFscGhhO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRjdXJyZW50QmxlbmRFcXVhdGlvbiA9IG51bGw7XG5cdFx0XHRcdGN1cnJlbnRCbGVuZFNyYyA9IG51bGw7XG5cdFx0XHRcdGN1cnJlbnRCbGVuZERzdCA9IG51bGw7XG5cdFx0XHRcdGN1cnJlbnRCbGVuZEVxdWF0aW9uQWxwaGEgPSBudWxsO1xuXHRcdFx0XHRjdXJyZW50QmxlbmRTcmNBbHBoYSA9IG51bGw7XG5cdFx0XHRcdGN1cnJlbnRCbGVuZERzdEFscGhhID0gbnVsbDtcblxuXHRcdFx0fVxuXG5cdFx0fTtcblxuXHRcdHRoaXMuc2V0RGVwdGhGdW5jID0gZnVuY3Rpb24gKCBkZXB0aEZ1bmMgKSB7XG5cblx0XHRcdGlmICggY3VycmVudERlcHRoRnVuYyAhPT0gZGVwdGhGdW5jICkge1xuXG5cdFx0XHRcdGlmICggZGVwdGhGdW5jICkge1xuXG5cdFx0XHRcdFx0c3dpdGNoICggZGVwdGhGdW5jICkge1xuXG5cdFx0XHRcdFx0XHRjYXNlIFRIUkVFLk5ldmVyRGVwdGg6XG5cblx0XHRcdFx0XHRcdFx0Z2wuZGVwdGhGdW5jKCBnbC5ORVZFUiApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSBUSFJFRS5BbHdheXNEZXB0aDpcblxuXHRcdFx0XHRcdFx0XHRnbC5kZXB0aEZ1bmMoIGdsLkFMV0FZUyApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSBUSFJFRS5MZXNzRGVwdGg6XG5cblx0XHRcdFx0XHRcdFx0Z2wuZGVwdGhGdW5jKCBnbC5MRVNTICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlIFRIUkVFLkxlc3NFcXVhbERlcHRoOlxuXG5cdFx0XHRcdFx0XHRcdGdsLmRlcHRoRnVuYyggZ2wuTEVRVUFMICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlIFRIUkVFLkVxdWFsRGVwdGg6XG5cblx0XHRcdFx0XHRcdFx0Z2wuZGVwdGhGdW5jKCBnbC5FUVVBTCApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSBUSFJFRS5HcmVhdGVyRXF1YWxEZXB0aDpcblxuXHRcdFx0XHRcdFx0XHRnbC5kZXB0aEZ1bmMoIGdsLkdFUVVBTCApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSBUSFJFRS5HcmVhdGVyRGVwdGg6XG5cblx0XHRcdFx0XHRcdFx0Z2wuZGVwdGhGdW5jKCBnbC5HUkVBVEVSICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlIFRIUkVFLk5vdEVxdWFsRGVwdGg6XG5cblx0XHRcdFx0XHRcdFx0Z2wuZGVwdGhGdW5jKCBnbC5OT1RFUVVBTCApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblxuXHRcdFx0XHRcdFx0XHRnbC5kZXB0aEZ1bmMoIGdsLkxFUVVBTCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRnbC5kZXB0aEZ1bmMoIGdsLkxFUVVBTCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjdXJyZW50RGVwdGhGdW5jID0gZGVwdGhGdW5jO1xuXG5cdFx0XHR9XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5zZXREZXB0aFRlc3QgPSBmdW5jdGlvbiAoIGRlcHRoVGVzdCApIHtcblxuXHRcdFx0aWYgKCBkZXB0aFRlc3QgKSB7XG5cblx0XHRcdFx0dGhpcy5lbmFibGUoIGdsLkRFUFRIX1RFU1QgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR0aGlzLmRpc2FibGUoIGdsLkRFUFRIX1RFU1QgKTtcblxuXHRcdFx0fVxuXG5cdFx0fTtcblxuXHRcdHRoaXMuc2V0RGVwdGhXcml0ZSA9IGZ1bmN0aW9uICggZGVwdGhXcml0ZSApIHtcblxuXHRcdFx0aWYgKCBjdXJyZW50RGVwdGhXcml0ZSAhPT0gZGVwdGhXcml0ZSApIHtcblxuXHRcdFx0XHRnbC5kZXB0aE1hc2soIGRlcHRoV3JpdGUgKTtcblx0XHRcdFx0Y3VycmVudERlcHRoV3JpdGUgPSBkZXB0aFdyaXRlO1xuXG5cdFx0XHR9XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5zZXRDb2xvcldyaXRlID0gZnVuY3Rpb24gKCBjb2xvcldyaXRlICkge1xuXG5cdFx0XHRpZiAoIGN1cnJlbnRDb2xvcldyaXRlICE9PSBjb2xvcldyaXRlICkge1xuXG5cdFx0XHRcdGdsLmNvbG9yTWFzayggY29sb3JXcml0ZSwgY29sb3JXcml0ZSwgY29sb3JXcml0ZSwgY29sb3JXcml0ZSApO1xuXHRcdFx0XHRjdXJyZW50Q29sb3JXcml0ZSA9IGNvbG9yV3JpdGU7XG5cblx0XHRcdH1cblxuXHRcdH07XG5cblx0XHR0aGlzLnNldEZsaXBTaWRlZCA9IGZ1bmN0aW9uICggZmxpcFNpZGVkICkge1xuXG5cdFx0XHRpZiAoIGN1cnJlbnRGbGlwU2lkZWQgIT09IGZsaXBTaWRlZCApIHtcblxuXHRcdFx0XHRpZiAoIGZsaXBTaWRlZCApIHtcblxuXHRcdFx0XHRcdGdsLmZyb250RmFjZSggZ2wuQ1cgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Z2wuZnJvbnRGYWNlKCBnbC5DQ1cgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y3VycmVudEZsaXBTaWRlZCA9IGZsaXBTaWRlZDtcblxuXHRcdFx0fVxuXG5cdFx0fTtcblxuXHRcdHRoaXMuc2V0TGluZVdpZHRoID0gZnVuY3Rpb24gKCB3aWR0aCApIHtcblxuXHRcdFx0aWYgKCB3aWR0aCAhPT0gY3VycmVudExpbmVXaWR0aCApIHtcblxuXHRcdFx0XHRnbC5saW5lV2lkdGgoIHdpZHRoICk7XG5cblx0XHRcdFx0Y3VycmVudExpbmVXaWR0aCA9IHdpZHRoO1xuXG5cdFx0XHR9XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5zZXRQb2x5Z29uT2Zmc2V0ID0gZnVuY3Rpb24gKCBwb2x5Z29uT2Zmc2V0LCBmYWN0b3IsIHVuaXRzICkge1xuXG5cdFx0XHRpZiAoIHBvbHlnb25PZmZzZXQgKSB7XG5cblx0XHRcdFx0dGhpcy5lbmFibGUoIGdsLlBPTFlHT05fT0ZGU0VUX0ZJTEwgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR0aGlzLmRpc2FibGUoIGdsLlBPTFlHT05fT0ZGU0VUX0ZJTEwgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHBvbHlnb25PZmZzZXQgJiYgKCBjdXJyZW50UG9seWdvbk9mZnNldEZhY3RvciAhPT0gZmFjdG9yIHx8IGN1cnJlbnRQb2x5Z29uT2Zmc2V0VW5pdHMgIT09IHVuaXRzICkgKSB7XG5cblx0XHRcdFx0Z2wucG9seWdvbk9mZnNldCggZmFjdG9yLCB1bml0cyApO1xuXG5cdFx0XHRcdGN1cnJlbnRQb2x5Z29uT2Zmc2V0RmFjdG9yID0gZmFjdG9yO1xuXHRcdFx0XHRjdXJyZW50UG9seWdvbk9mZnNldFVuaXRzID0gdW5pdHM7XG5cblx0XHRcdH1cblxuXHRcdH07XG5cblx0XHR0aGlzLnNldFNjaXNzb3JUZXN0ID0gZnVuY3Rpb24gKCBzY2lzc29yVGVzdCApIHtcblxuXHRcdFx0aWYgKCBzY2lzc29yVGVzdCApIHtcblxuXHRcdFx0XHR0aGlzLmVuYWJsZSggZ2wuU0NJU1NPUl9URVNUICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dGhpcy5kaXNhYmxlKCBnbC5TQ0lTU09SX1RFU1QgKTtcblxuXHRcdFx0fVxuXG5cdFx0fTtcblxuXHRcdC8vIHRleHR1cmVcblxuXHRcdHRoaXMuYWN0aXZlVGV4dHVyZSA9IGZ1bmN0aW9uICggd2ViZ2xTbG90ICkge1xuXG5cdFx0XHRpZiAoIHdlYmdsU2xvdCA9PT0gdW5kZWZpbmVkICkgd2ViZ2xTbG90ID0gZ2wuVEVYVFVSRTAgKyBtYXhUZXh0dXJlcyAtIDE7XG5cblx0XHRcdGlmICggY3VycmVudFRleHR1cmVTbG90ICE9PSB3ZWJnbFNsb3QgKSB7XG5cblx0XHRcdFx0Z2wuYWN0aXZlVGV4dHVyZSggd2ViZ2xTbG90ICk7XG5cdFx0XHRcdGN1cnJlbnRUZXh0dXJlU2xvdCA9IHdlYmdsU2xvdDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0dGhpcy5iaW5kVGV4dHVyZSA9IGZ1bmN0aW9uICggd2ViZ2xUeXBlLCB3ZWJnbFRleHR1cmUgKSB7XG5cblx0XHRcdGlmICggY3VycmVudFRleHR1cmVTbG90ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0X3RoaXMuYWN0aXZlVGV4dHVyZSgpO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBib3VuZFRleHR1cmUgPSBjdXJyZW50Qm91bmRUZXh0dXJlc1sgY3VycmVudFRleHR1cmVTbG90IF07XG5cblx0XHRcdGlmICggYm91bmRUZXh0dXJlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Ym91bmRUZXh0dXJlID0geyB0eXBlOiB1bmRlZmluZWQsIHRleHR1cmU6IHVuZGVmaW5lZCB9O1xuXHRcdFx0XHRjdXJyZW50Qm91bmRUZXh0dXJlc1sgY3VycmVudFRleHR1cmVTbG90IF0gPSBib3VuZFRleHR1cmU7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBib3VuZFRleHR1cmUudHlwZSAhPT0gd2ViZ2xUeXBlIHx8IGJvdW5kVGV4dHVyZS50ZXh0dXJlICE9PSB3ZWJnbFRleHR1cmUgKSB7XG5cblx0XHRcdFx0Z2wuYmluZFRleHR1cmUoIHdlYmdsVHlwZSwgd2ViZ2xUZXh0dXJlICk7XG5cblx0XHRcdFx0Ym91bmRUZXh0dXJlLnR5cGUgPSB3ZWJnbFR5cGU7XG5cdFx0XHRcdGJvdW5kVGV4dHVyZS50ZXh0dXJlID0gd2ViZ2xUZXh0dXJlO1xuXG5cdFx0XHR9XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5jb21wcmVzc2VkVGV4SW1hZ2UyRCA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dHJ5IHtcblxuXHRcdFx0XHRnbC5jb21wcmVzc2VkVGV4SW1hZ2UyRC5hcHBseSggZ2wsIGFyZ3VtZW50cyApO1xuXG5cdFx0XHR9IGNhdGNoICggZXJyb3IgKSB7XG5cblx0XHRcdFx0Y29uc29sZS5lcnJvciggZXJyb3IgKTtcblxuXHRcdFx0fVxuXG5cdFx0fTtcblxuXHRcdHRoaXMudGV4SW1hZ2UyRCA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dHJ5IHtcblxuXHRcdFx0XHRnbC50ZXhJbWFnZTJELmFwcGx5KCBnbCwgYXJndW1lbnRzICk7XG5cblx0XHRcdH0gY2F0Y2ggKCBlcnJvciApIHtcblxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCBlcnJvciApO1xuXG5cdFx0XHR9XG5cblx0XHR9O1xuXG5cdFx0Ly9cblxuXHRcdHRoaXMucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGVuYWJsZWRBdHRyaWJ1dGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRpZiAoIGVuYWJsZWRBdHRyaWJ1dGVzWyBpIF0gPT09IDEgKSB7XG5cblx0XHRcdFx0XHRnbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoIGkgKTtcblx0XHRcdFx0XHRlbmFibGVkQXR0cmlidXRlc1sgaSBdID0gMDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Y2FwYWJpbGl0aWVzID0ge307XG5cblx0XHRcdGNvbXByZXNzZWRUZXh0dXJlRm9ybWF0cyA9IG51bGw7XG5cblx0XHRcdGN1cnJlbnRCbGVuZGluZyA9IG51bGw7XG5cblx0XHRcdGN1cnJlbnREZXB0aFdyaXRlID0gbnVsbDtcblx0XHRcdGN1cnJlbnRDb2xvcldyaXRlID0gbnVsbDtcblxuXHRcdFx0Y3VycmVudEZsaXBTaWRlZCA9IG51bGw7XG5cblx0XHR9O1xuXG5cdH07XG5cblx0Ly8gRmlsZTpzcmMvcmVuZGVyZXJzL3dlYmdsL3BsdWdpbnMvTGVuc0ZsYXJlUGx1Z2luLmpzXG5cblx0LyoqXG5cdCAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG5cdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG5cdCAqL1xuXG5cdFRIUkVFLkxlbnNGbGFyZVBsdWdpbiA9IGZ1bmN0aW9uICggcmVuZGVyZXIsIGZsYXJlcyApIHtcblxuXHRcdHZhciBnbCA9IHJlbmRlcmVyLmNvbnRleHQ7XG5cdFx0dmFyIHN0YXRlID0gcmVuZGVyZXIuc3RhdGU7XG5cblx0XHR2YXIgdmVydGV4QnVmZmVyLCBlbGVtZW50QnVmZmVyO1xuXHRcdHZhciBwcm9ncmFtLCBhdHRyaWJ1dGVzLCB1bmlmb3Jtcztcblx0XHR2YXIgaGFzVmVydGV4VGV4dHVyZTtcblxuXHRcdHZhciB0ZW1wVGV4dHVyZSwgb2NjbHVzaW9uVGV4dHVyZTtcblxuXHRcdGZ1bmN0aW9uIGluaXQoKSB7XG5cblx0XHRcdHZhciB2ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIFtcblx0XHRcdFx0LSAxLCAtIDEsICAwLCAwLFxuXHRcdFx0XHQgMSwgLSAxLCAgMSwgMCxcblx0XHRcdFx0IDEsICAxLCAgMSwgMSxcblx0XHRcdFx0LSAxLCAgMSwgIDAsIDFcblx0XHRcdF0gKTtcblxuXHRcdFx0dmFyIGZhY2VzID0gbmV3IFVpbnQxNkFycmF5KCBbXG5cdFx0XHRcdDAsIDEsIDIsXG5cdFx0XHRcdDAsIDIsIDNcblx0XHRcdF0gKTtcblxuXHRcdFx0Ly8gYnVmZmVyc1xuXG5cdFx0XHR2ZXJ0ZXhCdWZmZXIgICAgID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG5cdFx0XHRlbGVtZW50QnVmZmVyICAgID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG5cblx0XHRcdGdsLmJpbmRCdWZmZXIoIGdsLkFSUkFZX0JVRkZFUiwgdmVydGV4QnVmZmVyICk7XG5cdFx0XHRnbC5idWZmZXJEYXRhKCBnbC5BUlJBWV9CVUZGRVIsIHZlcnRpY2VzLCBnbC5TVEFUSUNfRFJBVyApO1xuXG5cdFx0XHRnbC5iaW5kQnVmZmVyKCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZWxlbWVudEJ1ZmZlciApO1xuXHRcdFx0Z2wuYnVmZmVyRGF0YSggZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGZhY2VzLCBnbC5TVEFUSUNfRFJBVyApO1xuXG5cdFx0XHQvLyB0ZXh0dXJlc1xuXG5cdFx0XHR0ZW1wVGV4dHVyZSAgICAgID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuXHRcdFx0b2NjbHVzaW9uVGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcblxuXHRcdFx0c3RhdGUuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIHRlbXBUZXh0dXJlICk7XG5cdFx0XHRnbC50ZXhJbWFnZTJEKCBnbC5URVhUVVJFXzJELCAwLCBnbC5SR0IsIDE2LCAxNiwgMCwgZ2wuUkdCLCBnbC5VTlNJR05FRF9CWVRFLCBudWxsICk7XG5cdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSApO1xuXHRcdFx0Z2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UgKTtcblx0XHRcdGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCApO1xuXHRcdFx0Z2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUICk7XG5cblx0XHRcdHN0YXRlLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCBvY2NsdXNpb25UZXh0dXJlICk7XG5cdFx0XHRnbC50ZXhJbWFnZTJEKCBnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCAxNiwgMTYsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwgKTtcblx0XHRcdGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFICk7XG5cdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSApO1xuXHRcdFx0Z2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUICk7XG5cdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QgKTtcblxuXHRcdFx0aGFzVmVydGV4VGV4dHVyZSA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1ZFUlRFWF9URVhUVVJFX0lNQUdFX1VOSVRTICkgPiAwO1xuXG5cdFx0XHR2YXIgc2hhZGVyO1xuXG5cdFx0XHRpZiAoIGhhc1ZlcnRleFRleHR1cmUgKSB7XG5cblx0XHRcdFx0c2hhZGVyID0ge1xuXG5cdFx0XHRcdFx0dmVydGV4U2hhZGVyOiBbXG5cblx0XHRcdFx0XHRcdFwidW5pZm9ybSBsb3dwIGludCByZW5kZXJUeXBlO1wiLFxuXG5cdFx0XHRcdFx0XHRcInVuaWZvcm0gdmVjMyBzY3JlZW5Qb3NpdGlvbjtcIixcblx0XHRcdFx0XHRcdFwidW5pZm9ybSB2ZWMyIHNjYWxlO1wiLFxuXHRcdFx0XHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHJvdGF0aW9uO1wiLFxuXG5cdFx0XHRcdFx0XHRcInVuaWZvcm0gc2FtcGxlcjJEIG9jY2x1c2lvbk1hcDtcIixcblxuXHRcdFx0XHRcdFx0XCJhdHRyaWJ1dGUgdmVjMiBwb3NpdGlvbjtcIixcblx0XHRcdFx0XHRcdFwiYXR0cmlidXRlIHZlYzIgdXY7XCIsXG5cblx0XHRcdFx0XHRcdFwidmFyeWluZyB2ZWMyIHZVVjtcIixcblx0XHRcdFx0XHRcdFwidmFyeWluZyBmbG9hdCB2VmlzaWJpbGl0eTtcIixcblxuXHRcdFx0XHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXG5cblx0XHRcdFx0XHRcdFx0XCJ2VVYgPSB1djtcIixcblxuXHRcdFx0XHRcdFx0XHRcInZlYzIgcG9zID0gcG9zaXRpb247XCIsXG5cblx0XHRcdFx0XHRcdFx0XCJpZiAoIHJlbmRlclR5cGUgPT0gMiApIHtcIixcblxuXHRcdFx0XHRcdFx0XHRcdFwidmVjNCB2aXNpYmlsaXR5ID0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuMSwgMC4xICkgKTtcIixcblx0XHRcdFx0XHRcdFx0XHRcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuNSwgMC4xICkgKTtcIixcblx0XHRcdFx0XHRcdFx0XHRcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuOSwgMC4xICkgKTtcIixcblx0XHRcdFx0XHRcdFx0XHRcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuOSwgMC41ICkgKTtcIixcblx0XHRcdFx0XHRcdFx0XHRcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuOSwgMC45ICkgKTtcIixcblx0XHRcdFx0XHRcdFx0XHRcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuNSwgMC45ICkgKTtcIixcblx0XHRcdFx0XHRcdFx0XHRcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuMSwgMC45ICkgKTtcIixcblx0XHRcdFx0XHRcdFx0XHRcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuMSwgMC41ICkgKTtcIixcblx0XHRcdFx0XHRcdFx0XHRcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuNSwgMC41ICkgKTtcIixcblxuXHRcdFx0XHRcdFx0XHRcdFwidlZpc2liaWxpdHkgPSAgICAgICAgdmlzaWJpbGl0eS5yIC8gOS4wO1wiLFxuXHRcdFx0XHRcdFx0XHRcdFwidlZpc2liaWxpdHkgKj0gMS4wIC0gdmlzaWJpbGl0eS5nIC8gOS4wO1wiLFxuXHRcdFx0XHRcdFx0XHRcdFwidlZpc2liaWxpdHkgKj0gICAgICAgdmlzaWJpbGl0eS5iIC8gOS4wO1wiLFxuXHRcdFx0XHRcdFx0XHRcdFwidlZpc2liaWxpdHkgKj0gMS4wIC0gdmlzaWJpbGl0eS5hIC8gOS4wO1wiLFxuXG5cdFx0XHRcdFx0XHRcdFx0XCJwb3MueCA9IGNvcyggcm90YXRpb24gKSAqIHBvc2l0aW9uLnggLSBzaW4oIHJvdGF0aW9uICkgKiBwb3NpdGlvbi55O1wiLFxuXHRcdFx0XHRcdFx0XHRcdFwicG9zLnkgPSBzaW4oIHJvdGF0aW9uICkgKiBwb3NpdGlvbi54ICsgY29zKCByb3RhdGlvbiApICogcG9zaXRpb24ueTtcIixcblxuXHRcdFx0XHRcdFx0XHRcIn1cIixcblxuXHRcdFx0XHRcdFx0XHRcImdsX1Bvc2l0aW9uID0gdmVjNCggKCBwb3MgKiBzY2FsZSArIHNjcmVlblBvc2l0aW9uLnh5ICkueHksIHNjcmVlblBvc2l0aW9uLnosIDEuMCApO1wiLFxuXG5cdFx0XHRcdFx0XHRcIn1cIlxuXG5cdFx0XHRcdFx0XS5qb2luKCBcIlxcblwiICksXG5cblx0XHRcdFx0XHRmcmFnbWVudFNoYWRlcjogW1xuXG5cdFx0XHRcdFx0XHRcInVuaWZvcm0gbG93cCBpbnQgcmVuZGVyVHlwZTtcIixcblxuXHRcdFx0XHRcdFx0XCJ1bmlmb3JtIHNhbXBsZXIyRCBtYXA7XCIsXG5cdFx0XHRcdFx0XHRcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcblx0XHRcdFx0XHRcdFwidW5pZm9ybSB2ZWMzIGNvbG9yO1wiLFxuXG5cdFx0XHRcdFx0XHRcInZhcnlpbmcgdmVjMiB2VVY7XCIsXG5cdFx0XHRcdFx0XHRcInZhcnlpbmcgZmxvYXQgdlZpc2liaWxpdHk7XCIsXG5cblx0XHRcdFx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxuXG5cdFx0XHRcdFx0XHRcdC8vIHBpbmsgc3F1YXJlXG5cblx0XHRcdFx0XHRcdFx0XCJpZiAoIHJlbmRlclR5cGUgPT0gMCApIHtcIixcblxuXHRcdFx0XHRcdFx0XHRcdFwiZ2xfRnJhZ0NvbG9yID0gdmVjNCggMS4wLCAwLjAsIDEuMCwgMC4wICk7XCIsXG5cblx0XHRcdFx0XHRcdFx0Ly8gcmVzdG9yZVxuXG5cdFx0XHRcdFx0XHRcdFwifSBlbHNlIGlmICggcmVuZGVyVHlwZSA9PSAxICkge1wiLFxuXG5cdFx0XHRcdFx0XHRcdFx0XCJnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQoIG1hcCwgdlVWICk7XCIsXG5cblx0XHRcdFx0XHRcdFx0Ly8gZmxhcmVcblxuXHRcdFx0XHRcdFx0XHRcIn0gZWxzZSB7XCIsXG5cblx0XHRcdFx0XHRcdFx0XHRcInZlYzQgdGV4dHVyZSA9IHRleHR1cmUyRCggbWFwLCB2VVYgKTtcIixcblx0XHRcdFx0XHRcdFx0XHRcInRleHR1cmUuYSAqPSBvcGFjaXR5ICogdlZpc2liaWxpdHk7XCIsXG5cdFx0XHRcdFx0XHRcdFx0XCJnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlO1wiLFxuXHRcdFx0XHRcdFx0XHRcdFwiZ2xfRnJhZ0NvbG9yLnJnYiAqPSBjb2xvcjtcIixcblxuXHRcdFx0XHRcdFx0XHRcIn1cIixcblxuXHRcdFx0XHRcdFx0XCJ9XCJcblxuXHRcdFx0XHRcdF0uam9pbiggXCJcXG5cIiApXG5cblx0XHRcdFx0fTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRzaGFkZXIgPSB7XG5cblx0XHRcdFx0XHR2ZXJ0ZXhTaGFkZXI6IFtcblxuXHRcdFx0XHRcdFx0XCJ1bmlmb3JtIGxvd3AgaW50IHJlbmRlclR5cGU7XCIsXG5cblx0XHRcdFx0XHRcdFwidW5pZm9ybSB2ZWMzIHNjcmVlblBvc2l0aW9uO1wiLFxuXHRcdFx0XHRcdFx0XCJ1bmlmb3JtIHZlYzIgc2NhbGU7XCIsXG5cdFx0XHRcdFx0XHRcInVuaWZvcm0gZmxvYXQgcm90YXRpb247XCIsXG5cblx0XHRcdFx0XHRcdFwiYXR0cmlidXRlIHZlYzIgcG9zaXRpb247XCIsXG5cdFx0XHRcdFx0XHRcImF0dHJpYnV0ZSB2ZWMyIHV2O1wiLFxuXG5cdFx0XHRcdFx0XHRcInZhcnlpbmcgdmVjMiB2VVY7XCIsXG5cblx0XHRcdFx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxuXG5cdFx0XHRcdFx0XHRcdFwidlVWID0gdXY7XCIsXG5cblx0XHRcdFx0XHRcdFx0XCJ2ZWMyIHBvcyA9IHBvc2l0aW9uO1wiLFxuXG5cdFx0XHRcdFx0XHRcdFwiaWYgKCByZW5kZXJUeXBlID09IDIgKSB7XCIsXG5cblx0XHRcdFx0XHRcdFx0XHRcInBvcy54ID0gY29zKCByb3RhdGlvbiApICogcG9zaXRpb24ueCAtIHNpbiggcm90YXRpb24gKSAqIHBvc2l0aW9uLnk7XCIsXG5cdFx0XHRcdFx0XHRcdFx0XCJwb3MueSA9IHNpbiggcm90YXRpb24gKSAqIHBvc2l0aW9uLnggKyBjb3MoIHJvdGF0aW9uICkgKiBwb3NpdGlvbi55O1wiLFxuXG5cdFx0XHRcdFx0XHRcdFwifVwiLFxuXG5cdFx0XHRcdFx0XHRcdFwiZ2xfUG9zaXRpb24gPSB2ZWM0KCAoIHBvcyAqIHNjYWxlICsgc2NyZWVuUG9zaXRpb24ueHkgKS54eSwgc2NyZWVuUG9zaXRpb24ueiwgMS4wICk7XCIsXG5cblx0XHRcdFx0XHRcdFwifVwiXG5cblx0XHRcdFx0XHRdLmpvaW4oIFwiXFxuXCIgKSxcblxuXHRcdFx0XHRcdGZyYWdtZW50U2hhZGVyOiBbXG5cblx0XHRcdFx0XHRcdFwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XCIsXG5cblx0XHRcdFx0XHRcdFwidW5pZm9ybSBsb3dwIGludCByZW5kZXJUeXBlO1wiLFxuXG5cdFx0XHRcdFx0XHRcInVuaWZvcm0gc2FtcGxlcjJEIG1hcDtcIixcblx0XHRcdFx0XHRcdFwidW5pZm9ybSBzYW1wbGVyMkQgb2NjbHVzaW9uTWFwO1wiLFxuXHRcdFx0XHRcdFx0XCJ1bmlmb3JtIGZsb2F0IG9wYWNpdHk7XCIsXG5cdFx0XHRcdFx0XHRcInVuaWZvcm0gdmVjMyBjb2xvcjtcIixcblxuXHRcdFx0XHRcdFx0XCJ2YXJ5aW5nIHZlYzIgdlVWO1wiLFxuXG5cdFx0XHRcdFx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XHRcdFx0XHQvLyBwaW5rIHNxdWFyZVxuXG5cdFx0XHRcdFx0XHRcdFwiaWYgKCByZW5kZXJUeXBlID09IDAgKSB7XCIsXG5cblx0XHRcdFx0XHRcdFx0XHRcImdsX0ZyYWdDb2xvciA9IHZlYzQoIHRleHR1cmUyRCggbWFwLCB2VVYgKS5yZ2IsIDAuMCApO1wiLFxuXG5cdFx0XHRcdFx0XHRcdC8vIHJlc3RvcmVcblxuXHRcdFx0XHRcdFx0XHRcIn0gZWxzZSBpZiAoIHJlbmRlclR5cGUgPT0gMSApIHtcIixcblxuXHRcdFx0XHRcdFx0XHRcdFwiZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKCBtYXAsIHZVViApO1wiLFxuXG5cdFx0XHRcdFx0XHRcdC8vIGZsYXJlXG5cblx0XHRcdFx0XHRcdFx0XCJ9IGVsc2Uge1wiLFxuXG5cdFx0XHRcdFx0XHRcdFx0XCJmbG9hdCB2aXNpYmlsaXR5ID0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuNSwgMC4xICkgKS5hO1wiLFxuXHRcdFx0XHRcdFx0XHRcdFwidmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC45LCAwLjUgKSApLmE7XCIsXG5cdFx0XHRcdFx0XHRcdFx0XCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjUsIDAuOSApICkuYTtcIixcblx0XHRcdFx0XHRcdFx0XHRcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuMSwgMC41ICkgKS5hO1wiLFxuXHRcdFx0XHRcdFx0XHRcdFwidmlzaWJpbGl0eSA9ICggMS4wIC0gdmlzaWJpbGl0eSAvIDQuMCApO1wiLFxuXG5cdFx0XHRcdFx0XHRcdFx0XCJ2ZWM0IHRleHR1cmUgPSB0ZXh0dXJlMkQoIG1hcCwgdlVWICk7XCIsXG5cdFx0XHRcdFx0XHRcdFx0XCJ0ZXh0dXJlLmEgKj0gb3BhY2l0eSAqIHZpc2liaWxpdHk7XCIsXG5cdFx0XHRcdFx0XHRcdFx0XCJnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlO1wiLFxuXHRcdFx0XHRcdFx0XHRcdFwiZ2xfRnJhZ0NvbG9yLnJnYiAqPSBjb2xvcjtcIixcblxuXHRcdFx0XHRcdFx0XHRcIn1cIixcblxuXHRcdFx0XHRcdFx0XCJ9XCJcblxuXHRcdFx0XHRcdF0uam9pbiggXCJcXG5cIiApXG5cblx0XHRcdFx0fTtcblxuXHRcdFx0fVxuXG5cdFx0XHRwcm9ncmFtID0gY3JlYXRlUHJvZ3JhbSggc2hhZGVyICk7XG5cblx0XHRcdGF0dHJpYnV0ZXMgPSB7XG5cdFx0XHRcdHZlcnRleDogZ2wuZ2V0QXR0cmliTG9jYXRpb24gKCBwcm9ncmFtLCBcInBvc2l0aW9uXCIgKSxcblx0XHRcdFx0dXY6ICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbiAoIHByb2dyYW0sIFwidXZcIiApXG5cdFx0XHR9O1xuXG5cdFx0XHR1bmlmb3JtcyA9IHtcblx0XHRcdFx0cmVuZGVyVHlwZTogICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgXCJyZW5kZXJUeXBlXCIgKSxcblx0XHRcdFx0bWFwOiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgXCJtYXBcIiApLFxuXHRcdFx0XHRvY2NsdXNpb25NYXA6ICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCBcIm9jY2x1c2lvbk1hcFwiICksXG5cdFx0XHRcdG9wYWNpdHk6ICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sIFwib3BhY2l0eVwiICksXG5cdFx0XHRcdGNvbG9yOiAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sIFwiY29sb3JcIiApLFxuXHRcdFx0XHRzY2FsZTogICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCBcInNjYWxlXCIgKSxcblx0XHRcdFx0cm90YXRpb246ICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgXCJyb3RhdGlvblwiICksXG5cdFx0XHRcdHNjcmVlblBvc2l0aW9uOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sIFwic2NyZWVuUG9zaXRpb25cIiApXG5cdFx0XHR9O1xuXG5cdFx0fVxuXG5cdFx0Lypcblx0XHQgKiBSZW5kZXIgbGVucyBmbGFyZXNcblx0XHQgKiBNZXRob2Q6IHJlbmRlcnMgMTZ4MTYgMHhmZjAwZmYtY29sb3JlZCBwb2ludHMgc2NhdHRlcmVkIG92ZXIgdGhlIGxpZ2h0IHNvdXJjZSBhcmVhLFxuXHRcdCAqICAgICAgICAgcmVhZHMgdGhlc2UgYmFjayBhbmQgY2FsY3VsYXRlcyBvY2NsdXNpb24uXG5cdFx0ICovXG5cblx0XHR0aGlzLnJlbmRlciA9IGZ1bmN0aW9uICggc2NlbmUsIGNhbWVyYSwgdmlld3BvcnRXaWR0aCwgdmlld3BvcnRIZWlnaHQgKSB7XG5cblx0XHRcdGlmICggZmxhcmVzLmxlbmd0aCA9PT0gMCApIHJldHVybjtcblxuXHRcdFx0dmFyIHRlbXBQb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRcdHZhciBpbnZBc3BlY3QgPSB2aWV3cG9ydEhlaWdodCAvIHZpZXdwb3J0V2lkdGgsXG5cdFx0XHRcdGhhbGZWaWV3cG9ydFdpZHRoID0gdmlld3BvcnRXaWR0aCAqIDAuNSxcblx0XHRcdFx0aGFsZlZpZXdwb3J0SGVpZ2h0ID0gdmlld3BvcnRIZWlnaHQgKiAwLjU7XG5cblx0XHRcdHZhciBzaXplID0gMTYgLyB2aWV3cG9ydEhlaWdodCxcblx0XHRcdFx0c2NhbGUgPSBuZXcgVEhSRUUuVmVjdG9yMiggc2l6ZSAqIGludkFzcGVjdCwgc2l6ZSApO1xuXG5cdFx0XHR2YXIgc2NyZWVuUG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMyggMSwgMSwgMCApLFxuXHRcdFx0XHRzY3JlZW5Qb3NpdGlvblBpeGVscyA9IG5ldyBUSFJFRS5WZWN0b3IyKCAxLCAxICk7XG5cblx0XHRcdGlmICggcHJvZ3JhbSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGluaXQoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRnbC51c2VQcm9ncmFtKCBwcm9ncmFtICk7XG5cblx0XHRcdHN0YXRlLmluaXRBdHRyaWJ1dGVzKCk7XG5cdFx0XHRzdGF0ZS5lbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMudmVydGV4ICk7XG5cdFx0XHRzdGF0ZS5lbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMudXYgKTtcblx0XHRcdHN0YXRlLmRpc2FibGVVbnVzZWRBdHRyaWJ1dGVzKCk7XG5cblx0XHRcdC8vIGxvb3AgdGhyb3VnaCBhbGwgbGVucyBmbGFyZXMgdG8gdXBkYXRlIHRoZWlyIG9jY2x1c2lvbiBhbmQgcG9zaXRpb25zXG5cdFx0XHQvLyBzZXR1cCBnbCBhbmQgY29tbW9uIHVzZWQgYXR0cmlicy91bmlmb3Jtc1xuXG5cdFx0XHRnbC51bmlmb3JtMWkoIHVuaWZvcm1zLm9jY2x1c2lvbk1hcCwgMCApO1xuXHRcdFx0Z2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5tYXAsIDEgKTtcblxuXHRcdFx0Z2wuYmluZEJ1ZmZlciggZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhCdWZmZXIgKTtcblx0XHRcdGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMudmVydGV4LCAyLCBnbC5GTE9BVCwgZmFsc2UsIDIgKiA4LCAwICk7XG5cdFx0XHRnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnV2LCAyLCBnbC5GTE9BVCwgZmFsc2UsIDIgKiA4LCA4ICk7XG5cblx0XHRcdGdsLmJpbmRCdWZmZXIoIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBlbGVtZW50QnVmZmVyICk7XG5cblx0XHRcdHN0YXRlLmRpc2FibGUoIGdsLkNVTExfRkFDRSApO1xuXHRcdFx0Z2wuZGVwdGhNYXNrKCBmYWxzZSApO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBmbGFyZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRzaXplID0gMTYgLyB2aWV3cG9ydEhlaWdodDtcblx0XHRcdFx0c2NhbGUuc2V0KCBzaXplICogaW52QXNwZWN0LCBzaXplICk7XG5cblx0XHRcdFx0Ly8gY2FsYyBvYmplY3Qgc2NyZWVuIHBvc2l0aW9uXG5cblx0XHRcdFx0dmFyIGZsYXJlID0gZmxhcmVzWyBpIF07XG5cblx0XHRcdFx0dGVtcFBvc2l0aW9uLnNldCggZmxhcmUubWF0cml4V29ybGQuZWxlbWVudHNbIDEyIF0sIGZsYXJlLm1hdHJpeFdvcmxkLmVsZW1lbnRzWyAxMyBdLCBmbGFyZS5tYXRyaXhXb3JsZC5lbGVtZW50c1sgMTQgXSApO1xuXG5cdFx0XHRcdHRlbXBQb3NpdGlvbi5hcHBseU1hdHJpeDQoIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UgKTtcblx0XHRcdFx0dGVtcFBvc2l0aW9uLmFwcGx5UHJvamVjdGlvbiggY2FtZXJhLnByb2plY3Rpb25NYXRyaXggKTtcblxuXHRcdFx0XHQvLyBzZXR1cCBhcnJheXMgZm9yIGdsIHByb2dyYW1zXG5cblx0XHRcdFx0c2NyZWVuUG9zaXRpb24uY29weSggdGVtcFBvc2l0aW9uICk7XG5cblx0XHRcdFx0c2NyZWVuUG9zaXRpb25QaXhlbHMueCA9IHNjcmVlblBvc2l0aW9uLnggKiBoYWxmVmlld3BvcnRXaWR0aCArIGhhbGZWaWV3cG9ydFdpZHRoO1xuXHRcdFx0XHRzY3JlZW5Qb3NpdGlvblBpeGVscy55ID0gc2NyZWVuUG9zaXRpb24ueSAqIGhhbGZWaWV3cG9ydEhlaWdodCArIGhhbGZWaWV3cG9ydEhlaWdodDtcblxuXHRcdFx0XHQvLyBzY3JlZW4gY3VsbFxuXG5cdFx0XHRcdGlmICggaGFzVmVydGV4VGV4dHVyZSB8fCAoXG5cdFx0XHRcdFx0c2NyZWVuUG9zaXRpb25QaXhlbHMueCA+IDAgJiZcblx0XHRcdFx0XHRzY3JlZW5Qb3NpdGlvblBpeGVscy54IDwgdmlld3BvcnRXaWR0aCAmJlxuXHRcdFx0XHRcdHNjcmVlblBvc2l0aW9uUGl4ZWxzLnkgPiAwICYmXG5cdFx0XHRcdFx0c2NyZWVuUG9zaXRpb25QaXhlbHMueSA8IHZpZXdwb3J0SGVpZ2h0ICkgKSB7XG5cblx0XHRcdFx0XHQvLyBzYXZlIGN1cnJlbnQgUkdCIHRvIHRlbXAgdGV4dHVyZVxuXG5cdFx0XHRcdFx0c3RhdGUuYWN0aXZlVGV4dHVyZSggZ2wuVEVYVFVSRTAgKTtcblx0XHRcdFx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgbnVsbCApO1xuXHRcdFx0XHRcdHN0YXRlLmFjdGl2ZVRleHR1cmUoIGdsLlRFWFRVUkUxICk7XG5cdFx0XHRcdFx0c3RhdGUuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIHRlbXBUZXh0dXJlICk7XG5cdFx0XHRcdFx0Z2wuY29weVRleEltYWdlMkQoIGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQiwgc2NyZWVuUG9zaXRpb25QaXhlbHMueCAtIDgsIHNjcmVlblBvc2l0aW9uUGl4ZWxzLnkgLSA4LCAxNiwgMTYsIDAgKTtcblxuXG5cdFx0XHRcdFx0Ly8gcmVuZGVyIHBpbmsgcXVhZFxuXG5cdFx0XHRcdFx0Z2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5yZW5kZXJUeXBlLCAwICk7XG5cdFx0XHRcdFx0Z2wudW5pZm9ybTJmKCB1bmlmb3Jtcy5zY2FsZSwgc2NhbGUueCwgc2NhbGUueSApO1xuXHRcdFx0XHRcdGdsLnVuaWZvcm0zZiggdW5pZm9ybXMuc2NyZWVuUG9zaXRpb24sIHNjcmVlblBvc2l0aW9uLngsIHNjcmVlblBvc2l0aW9uLnksIHNjcmVlblBvc2l0aW9uLnogKTtcblxuXHRcdFx0XHRcdHN0YXRlLmRpc2FibGUoIGdsLkJMRU5EICk7XG5cdFx0XHRcdFx0c3RhdGUuZW5hYmxlKCBnbC5ERVBUSF9URVNUICk7XG5cblx0XHRcdFx0XHRnbC5kcmF3RWxlbWVudHMoIGdsLlRSSUFOR0xFUywgNiwgZ2wuVU5TSUdORURfU0hPUlQsIDAgKTtcblxuXG5cdFx0XHRcdFx0Ly8gY29weSByZXN1bHQgdG8gb2NjbHVzaW9uTWFwXG5cblx0XHRcdFx0XHRzdGF0ZS5hY3RpdmVUZXh0dXJlKCBnbC5URVhUVVJFMCApO1xuXHRcdFx0XHRcdHN0YXRlLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCBvY2NsdXNpb25UZXh0dXJlICk7XG5cdFx0XHRcdFx0Z2wuY29weVRleEltYWdlMkQoIGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIHNjcmVlblBvc2l0aW9uUGl4ZWxzLnggLSA4LCBzY3JlZW5Qb3NpdGlvblBpeGVscy55IC0gOCwgMTYsIDE2LCAwICk7XG5cblxuXHRcdFx0XHRcdC8vIHJlc3RvcmUgZ3JhcGhpY3NcblxuXHRcdFx0XHRcdGdsLnVuaWZvcm0xaSggdW5pZm9ybXMucmVuZGVyVHlwZSwgMSApO1xuXHRcdFx0XHRcdHN0YXRlLmRpc2FibGUoIGdsLkRFUFRIX1RFU1QgKTtcblxuXHRcdFx0XHRcdHN0YXRlLmFjdGl2ZVRleHR1cmUoIGdsLlRFWFRVUkUxICk7XG5cdFx0XHRcdFx0c3RhdGUuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIHRlbXBUZXh0dXJlICk7XG5cdFx0XHRcdFx0Z2wuZHJhd0VsZW1lbnRzKCBnbC5UUklBTkdMRVMsIDYsIGdsLlVOU0lHTkVEX1NIT1JULCAwICk7XG5cblxuXHRcdFx0XHRcdC8vIHVwZGF0ZSBvYmplY3QgcG9zaXRpb25zXG5cblx0XHRcdFx0XHRmbGFyZS5wb3NpdGlvblNjcmVlbi5jb3B5KCBzY3JlZW5Qb3NpdGlvbiApO1xuXG5cdFx0XHRcdFx0aWYgKCBmbGFyZS5jdXN0b21VcGRhdGVDYWxsYmFjayApIHtcblxuXHRcdFx0XHRcdFx0ZmxhcmUuY3VzdG9tVXBkYXRlQ2FsbGJhY2soIGZsYXJlICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRmbGFyZS51cGRhdGVMZW5zRmxhcmVzKCk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyByZW5kZXIgZmxhcmVzXG5cblx0XHRcdFx0XHRnbC51bmlmb3JtMWkoIHVuaWZvcm1zLnJlbmRlclR5cGUsIDIgKTtcblx0XHRcdFx0XHRzdGF0ZS5lbmFibGUoIGdsLkJMRU5EICk7XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gZmxhcmUubGVuc0ZsYXJlcy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHRcdFx0dmFyIHNwcml0ZSA9IGZsYXJlLmxlbnNGbGFyZXNbIGogXTtcblxuXHRcdFx0XHRcdFx0aWYgKCBzcHJpdGUub3BhY2l0eSA+IDAuMDAxICYmIHNwcml0ZS5zY2FsZSA+IDAuMDAxICkge1xuXG5cdFx0XHRcdFx0XHRcdHNjcmVlblBvc2l0aW9uLnggPSBzcHJpdGUueDtcblx0XHRcdFx0XHRcdFx0c2NyZWVuUG9zaXRpb24ueSA9IHNwcml0ZS55O1xuXHRcdFx0XHRcdFx0XHRzY3JlZW5Qb3NpdGlvbi56ID0gc3ByaXRlLno7XG5cblx0XHRcdFx0XHRcdFx0c2l6ZSA9IHNwcml0ZS5zaXplICogc3ByaXRlLnNjYWxlIC8gdmlld3BvcnRIZWlnaHQ7XG5cblx0XHRcdFx0XHRcdFx0c2NhbGUueCA9IHNpemUgKiBpbnZBc3BlY3Q7XG5cdFx0XHRcdFx0XHRcdHNjYWxlLnkgPSBzaXplO1xuXG5cdFx0XHRcdFx0XHRcdGdsLnVuaWZvcm0zZiggdW5pZm9ybXMuc2NyZWVuUG9zaXRpb24sIHNjcmVlblBvc2l0aW9uLngsIHNjcmVlblBvc2l0aW9uLnksIHNjcmVlblBvc2l0aW9uLnogKTtcblx0XHRcdFx0XHRcdFx0Z2wudW5pZm9ybTJmKCB1bmlmb3Jtcy5zY2FsZSwgc2NhbGUueCwgc2NhbGUueSApO1xuXHRcdFx0XHRcdFx0XHRnbC51bmlmb3JtMWYoIHVuaWZvcm1zLnJvdGF0aW9uLCBzcHJpdGUucm90YXRpb24gKTtcblxuXHRcdFx0XHRcdFx0XHRnbC51bmlmb3JtMWYoIHVuaWZvcm1zLm9wYWNpdHksIHNwcml0ZS5vcGFjaXR5ICk7XG5cdFx0XHRcdFx0XHRcdGdsLnVuaWZvcm0zZiggdW5pZm9ybXMuY29sb3IsIHNwcml0ZS5jb2xvci5yLCBzcHJpdGUuY29sb3IuZywgc3ByaXRlLmNvbG9yLmIgKTtcblxuXHRcdFx0XHRcdFx0XHRzdGF0ZS5zZXRCbGVuZGluZyggc3ByaXRlLmJsZW5kaW5nLCBzcHJpdGUuYmxlbmRFcXVhdGlvbiwgc3ByaXRlLmJsZW5kU3JjLCBzcHJpdGUuYmxlbmREc3QgKTtcblx0XHRcdFx0XHRcdFx0cmVuZGVyZXIuc2V0VGV4dHVyZSggc3ByaXRlLnRleHR1cmUsIDEgKTtcblxuXHRcdFx0XHRcdFx0XHRnbC5kcmF3RWxlbWVudHMoIGdsLlRSSUFOR0xFUywgNiwgZ2wuVU5TSUdORURfU0hPUlQsIDAgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyByZXN0b3JlIGdsXG5cblx0XHRcdHN0YXRlLmVuYWJsZSggZ2wuQ1VMTF9GQUNFICk7XG5cdFx0XHRzdGF0ZS5lbmFibGUoIGdsLkRFUFRIX1RFU1QgKTtcblx0XHRcdGdsLmRlcHRoTWFzayggdHJ1ZSApO1xuXG5cdFx0XHRyZW5kZXJlci5yZXNldEdMU3RhdGUoKTtcblxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBjcmVhdGVQcm9ncmFtICggc2hhZGVyICkge1xuXG5cdFx0XHR2YXIgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcblxuXHRcdFx0dmFyIGZyYWdtZW50U2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKCBnbC5GUkFHTUVOVF9TSEFERVIgKTtcblx0XHRcdHZhciB2ZXJ0ZXhTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoIGdsLlZFUlRFWF9TSEFERVIgKTtcblxuXHRcdFx0dmFyIHByZWZpeCA9IFwicHJlY2lzaW9uIFwiICsgcmVuZGVyZXIuZ2V0UHJlY2lzaW9uKCkgKyBcIiBmbG9hdDtcXG5cIjtcblxuXHRcdFx0Z2wuc2hhZGVyU291cmNlKCBmcmFnbWVudFNoYWRlciwgcHJlZml4ICsgc2hhZGVyLmZyYWdtZW50U2hhZGVyICk7XG5cdFx0XHRnbC5zaGFkZXJTb3VyY2UoIHZlcnRleFNoYWRlciwgcHJlZml4ICsgc2hhZGVyLnZlcnRleFNoYWRlciApO1xuXG5cdFx0XHRnbC5jb21waWxlU2hhZGVyKCBmcmFnbWVudFNoYWRlciApO1xuXHRcdFx0Z2wuY29tcGlsZVNoYWRlciggdmVydGV4U2hhZGVyICk7XG5cblx0XHRcdGdsLmF0dGFjaFNoYWRlciggcHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIgKTtcblx0XHRcdGdsLmF0dGFjaFNoYWRlciggcHJvZ3JhbSwgdmVydGV4U2hhZGVyICk7XG5cblx0XHRcdGdsLmxpbmtQcm9ncmFtKCBwcm9ncmFtICk7XG5cblx0XHRcdHJldHVybiBwcm9ncmFtO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0Ly8gRmlsZTpzcmMvcmVuZGVyZXJzL3dlYmdsL3BsdWdpbnMvU3ByaXRlUGx1Z2luLmpzXG5cblx0LyoqXG5cdCAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG5cdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG5cdCAqL1xuXG5cdFRIUkVFLlNwcml0ZVBsdWdpbiA9IGZ1bmN0aW9uICggcmVuZGVyZXIsIHNwcml0ZXMgKSB7XG5cblx0XHR2YXIgZ2wgPSByZW5kZXJlci5jb250ZXh0O1xuXHRcdHZhciBzdGF0ZSA9IHJlbmRlcmVyLnN0YXRlO1xuXG5cdFx0dmFyIHZlcnRleEJ1ZmZlciwgZWxlbWVudEJ1ZmZlcjtcblx0XHR2YXIgcHJvZ3JhbSwgYXR0cmlidXRlcywgdW5pZm9ybXM7XG5cblx0XHR2YXIgdGV4dHVyZTtcblxuXHRcdC8vIGRlY29tcG9zZSBtYXRyaXhXb3JsZFxuXG5cdFx0dmFyIHNwcml0ZVBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHR2YXIgc3ByaXRlUm90YXRpb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuXHRcdHZhciBzcHJpdGVTY2FsZSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRmdW5jdGlvbiBpbml0KCkge1xuXG5cdFx0XHR2YXIgdmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KCBbXG5cdFx0XHRcdC0gMC41LCAtIDAuNSwgIDAsIDAsXG5cdFx0XHRcdCAgMC41LCAtIDAuNSwgIDEsIDAsXG5cdFx0XHRcdCAgMC41LCAgIDAuNSwgIDEsIDEsXG5cdFx0XHRcdC0gMC41LCAgIDAuNSwgIDAsIDFcblx0XHRcdF0gKTtcblxuXHRcdFx0dmFyIGZhY2VzID0gbmV3IFVpbnQxNkFycmF5KCBbXG5cdFx0XHRcdDAsIDEsIDIsXG5cdFx0XHRcdDAsIDIsIDNcblx0XHRcdF0gKTtcblxuXHRcdFx0dmVydGV4QnVmZmVyICA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuXHRcdFx0ZWxlbWVudEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuXG5cdFx0XHRnbC5iaW5kQnVmZmVyKCBnbC5BUlJBWV9CVUZGRVIsIHZlcnRleEJ1ZmZlciApO1xuXHRcdFx0Z2wuYnVmZmVyRGF0YSggZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0aWNlcywgZ2wuU1RBVElDX0RSQVcgKTtcblxuXHRcdFx0Z2wuYmluZEJ1ZmZlciggZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGVsZW1lbnRCdWZmZXIgKTtcblx0XHRcdGdsLmJ1ZmZlckRhdGEoIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBmYWNlcywgZ2wuU1RBVElDX0RSQVcgKTtcblxuXHRcdFx0cHJvZ3JhbSA9IGNyZWF0ZVByb2dyYW0oKTtcblxuXHRcdFx0YXR0cmlidXRlcyA9IHtcblx0XHRcdFx0cG9zaXRpb246XHRcdFx0Z2wuZ2V0QXR0cmliTG9jYXRpb24gKCBwcm9ncmFtLCAncG9zaXRpb24nICksXG5cdFx0XHRcdHV2Olx0XHRcdFx0XHRnbC5nZXRBdHRyaWJMb2NhdGlvbiAoIHByb2dyYW0sICd1dicgKVxuXHRcdFx0fTtcblxuXHRcdFx0dW5pZm9ybXMgPSB7XG5cdFx0XHRcdHV2T2Zmc2V0Olx0XHRcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ3V2T2Zmc2V0JyApLFxuXHRcdFx0XHR1dlNjYWxlOlx0XHRcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ3V2U2NhbGUnICksXG5cblx0XHRcdFx0cm90YXRpb246XHRcdFx0Z2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAncm90YXRpb24nICksXG5cdFx0XHRcdHNjYWxlOlx0XHRcdFx0Z2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnc2NhbGUnICksXG5cblx0XHRcdFx0Y29sb3I6XHRcdFx0XHRnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdjb2xvcicgKSxcblx0XHRcdFx0bWFwOlx0XHRcdFx0Z2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnbWFwJyApLFxuXHRcdFx0XHRvcGFjaXR5Olx0XHRcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ29wYWNpdHknICksXG5cblx0XHRcdFx0bW9kZWxWaWV3TWF0cml4OiBcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ21vZGVsVmlld01hdHJpeCcgKSxcblx0XHRcdFx0cHJvamVjdGlvbk1hdHJpeDpcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ3Byb2plY3Rpb25NYXRyaXgnICksXG5cblx0XHRcdFx0Zm9nVHlwZTpcdFx0XHRnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdmb2dUeXBlJyApLFxuXHRcdFx0XHRmb2dEZW5zaXR5Olx0XHRcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2ZvZ0RlbnNpdHknICksXG5cdFx0XHRcdGZvZ05lYXI6XHRcdFx0Z2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnZm9nTmVhcicgKSxcblx0XHRcdFx0Zm9nRmFyOlx0XHRcdFx0Z2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnZm9nRmFyJyApLFxuXHRcdFx0XHRmb2dDb2xvcjpcdFx0XHRnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdmb2dDb2xvcicgKSxcblxuXHRcdFx0XHRhbHBoYVRlc3Q6XHRcdFx0Z2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnYWxwaGFUZXN0JyApXG5cdFx0XHR9O1xuXG5cdFx0XHR2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2NhbnZhcycgKTtcblx0XHRcdGNhbnZhcy53aWR0aCA9IDg7XG5cdFx0XHRjYW52YXMuaGVpZ2h0ID0gODtcblxuXHRcdFx0dmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCggJzJkJyApO1xuXHRcdFx0Y29udGV4dC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuXHRcdFx0Y29udGV4dC5maWxsUmVjdCggMCwgMCwgOCwgOCApO1xuXG5cdFx0XHR0ZXh0dXJlID0gbmV3IFRIUkVFLlRleHR1cmUoIGNhbnZhcyApO1xuXHRcdFx0dGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHR9XG5cblx0XHR0aGlzLnJlbmRlciA9IGZ1bmN0aW9uICggc2NlbmUsIGNhbWVyYSApIHtcblxuXHRcdFx0aWYgKCBzcHJpdGVzLmxlbmd0aCA9PT0gMCApIHJldHVybjtcblxuXHRcdFx0Ly8gc2V0dXAgZ2xcblxuXHRcdFx0aWYgKCBwcm9ncmFtID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0aW5pdCgpO1xuXG5cdFx0XHR9XG5cblx0XHRcdGdsLnVzZVByb2dyYW0oIHByb2dyYW0gKTtcblxuXHRcdFx0c3RhdGUuaW5pdEF0dHJpYnV0ZXMoKTtcblx0XHRcdHN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy5wb3NpdGlvbiApO1xuXHRcdFx0c3RhdGUuZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLnV2ICk7XG5cdFx0XHRzdGF0ZS5kaXNhYmxlVW51c2VkQXR0cmlidXRlcygpO1xuXG5cdFx0XHRzdGF0ZS5kaXNhYmxlKCBnbC5DVUxMX0ZBQ0UgKTtcblx0XHRcdHN0YXRlLmVuYWJsZSggZ2wuQkxFTkQgKTtcblxuXHRcdFx0Z2wuYmluZEJ1ZmZlciggZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhCdWZmZXIgKTtcblx0XHRcdGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMucG9zaXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgMiAqIDgsIDAgKTtcblx0XHRcdGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMudXYsIDIsIGdsLkZMT0FULCBmYWxzZSwgMiAqIDgsIDggKTtcblxuXHRcdFx0Z2wuYmluZEJ1ZmZlciggZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGVsZW1lbnRCdWZmZXIgKTtcblxuXHRcdFx0Z2wudW5pZm9ybU1hdHJpeDRmdiggdW5pZm9ybXMucHJvamVjdGlvbk1hdHJpeCwgZmFsc2UsIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzICk7XG5cblx0XHRcdHN0YXRlLmFjdGl2ZVRleHR1cmUoIGdsLlRFWFRVUkUwICk7XG5cdFx0XHRnbC51bmlmb3JtMWkoIHVuaWZvcm1zLm1hcCwgMCApO1xuXG5cdFx0XHR2YXIgb2xkRm9nVHlwZSA9IDA7XG5cdFx0XHR2YXIgc2NlbmVGb2dUeXBlID0gMDtcblx0XHRcdHZhciBmb2cgPSBzY2VuZS5mb2c7XG5cblx0XHRcdGlmICggZm9nICkge1xuXG5cdFx0XHRcdGdsLnVuaWZvcm0zZiggdW5pZm9ybXMuZm9nQ29sb3IsIGZvZy5jb2xvci5yLCBmb2cuY29sb3IuZywgZm9nLmNvbG9yLmIgKTtcblxuXHRcdFx0XHRpZiAoIGZvZyBpbnN0YW5jZW9mIFRIUkVFLkZvZyApIHtcblxuXHRcdFx0XHRcdGdsLnVuaWZvcm0xZiggdW5pZm9ybXMuZm9nTmVhciwgZm9nLm5lYXIgKTtcblx0XHRcdFx0XHRnbC51bmlmb3JtMWYoIHVuaWZvcm1zLmZvZ0ZhciwgZm9nLmZhciApO1xuXG5cdFx0XHRcdFx0Z2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5mb2dUeXBlLCAxICk7XG5cdFx0XHRcdFx0b2xkRm9nVHlwZSA9IDE7XG5cdFx0XHRcdFx0c2NlbmVGb2dUeXBlID0gMTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBmb2cgaW5zdGFuY2VvZiBUSFJFRS5Gb2dFeHAyICkge1xuXG5cdFx0XHRcdFx0Z2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5mb2dEZW5zaXR5LCBmb2cuZGVuc2l0eSApO1xuXG5cdFx0XHRcdFx0Z2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5mb2dUeXBlLCAyICk7XG5cdFx0XHRcdFx0b2xkRm9nVHlwZSA9IDI7XG5cdFx0XHRcdFx0c2NlbmVGb2dUeXBlID0gMjtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Z2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5mb2dUeXBlLCAwICk7XG5cdFx0XHRcdG9sZEZvZ1R5cGUgPSAwO1xuXHRcdFx0XHRzY2VuZUZvZ1R5cGUgPSAwO1xuXG5cdFx0XHR9XG5cblxuXHRcdFx0Ly8gdXBkYXRlIHBvc2l0aW9ucyBhbmQgc29ydFxuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBzcHJpdGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIHNwcml0ZSA9IHNwcml0ZXNbIGkgXTtcblxuXHRcdFx0XHRzcHJpdGUubW9kZWxWaWV3TWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UsIHNwcml0ZS5tYXRyaXhXb3JsZCApO1xuXHRcdFx0XHRzcHJpdGUueiA9IC0gc3ByaXRlLm1vZGVsVmlld01hdHJpeC5lbGVtZW50c1sgMTQgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRzcHJpdGVzLnNvcnQoIHBhaW50ZXJTb3J0U3RhYmxlICk7XG5cblx0XHRcdC8vIHJlbmRlciBhbGwgc3ByaXRlc1xuXG5cdFx0XHR2YXIgc2NhbGUgPSBbXTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gc3ByaXRlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBzcHJpdGUgPSBzcHJpdGVzWyBpIF07XG5cdFx0XHRcdHZhciBtYXRlcmlhbCA9IHNwcml0ZS5tYXRlcmlhbDtcblxuXHRcdFx0XHRnbC51bmlmb3JtMWYoIHVuaWZvcm1zLmFscGhhVGVzdCwgbWF0ZXJpYWwuYWxwaGFUZXN0ICk7XG5cdFx0XHRcdGdsLnVuaWZvcm1NYXRyaXg0ZnYoIHVuaWZvcm1zLm1vZGVsVmlld01hdHJpeCwgZmFsc2UsIHNwcml0ZS5tb2RlbFZpZXdNYXRyaXguZWxlbWVudHMgKTtcblxuXHRcdFx0XHRzcHJpdGUubWF0cml4V29ybGQuZGVjb21wb3NlKCBzcHJpdGVQb3NpdGlvbiwgc3ByaXRlUm90YXRpb24sIHNwcml0ZVNjYWxlICk7XG5cblx0XHRcdFx0c2NhbGVbIDAgXSA9IHNwcml0ZVNjYWxlLng7XG5cdFx0XHRcdHNjYWxlWyAxIF0gPSBzcHJpdGVTY2FsZS55O1xuXG5cdFx0XHRcdHZhciBmb2dUeXBlID0gMDtcblxuXHRcdFx0XHRpZiAoIHNjZW5lLmZvZyAmJiBtYXRlcmlhbC5mb2cgKSB7XG5cblx0XHRcdFx0XHRmb2dUeXBlID0gc2NlbmVGb2dUeXBlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIG9sZEZvZ1R5cGUgIT09IGZvZ1R5cGUgKSB7XG5cblx0XHRcdFx0XHRnbC51bmlmb3JtMWkoIHVuaWZvcm1zLmZvZ1R5cGUsIGZvZ1R5cGUgKTtcblx0XHRcdFx0XHRvbGRGb2dUeXBlID0gZm9nVHlwZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBtYXRlcmlhbC5tYXAgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRnbC51bmlmb3JtMmYoIHVuaWZvcm1zLnV2T2Zmc2V0LCBtYXRlcmlhbC5tYXAub2Zmc2V0LngsIG1hdGVyaWFsLm1hcC5vZmZzZXQueSApO1xuXHRcdFx0XHRcdGdsLnVuaWZvcm0yZiggdW5pZm9ybXMudXZTY2FsZSwgbWF0ZXJpYWwubWFwLnJlcGVhdC54LCBtYXRlcmlhbC5tYXAucmVwZWF0LnkgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Z2wudW5pZm9ybTJmKCB1bmlmb3Jtcy51dk9mZnNldCwgMCwgMCApO1xuXHRcdFx0XHRcdGdsLnVuaWZvcm0yZiggdW5pZm9ybXMudXZTY2FsZSwgMSwgMSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRnbC51bmlmb3JtMWYoIHVuaWZvcm1zLm9wYWNpdHksIG1hdGVyaWFsLm9wYWNpdHkgKTtcblx0XHRcdFx0Z2wudW5pZm9ybTNmKCB1bmlmb3Jtcy5jb2xvciwgbWF0ZXJpYWwuY29sb3IuciwgbWF0ZXJpYWwuY29sb3IuZywgbWF0ZXJpYWwuY29sb3IuYiApO1xuXG5cdFx0XHRcdGdsLnVuaWZvcm0xZiggdW5pZm9ybXMucm90YXRpb24sIG1hdGVyaWFsLnJvdGF0aW9uICk7XG5cdFx0XHRcdGdsLnVuaWZvcm0yZnYoIHVuaWZvcm1zLnNjYWxlLCBzY2FsZSApO1xuXG5cdFx0XHRcdHN0YXRlLnNldEJsZW5kaW5nKCBtYXRlcmlhbC5ibGVuZGluZywgbWF0ZXJpYWwuYmxlbmRFcXVhdGlvbiwgbWF0ZXJpYWwuYmxlbmRTcmMsIG1hdGVyaWFsLmJsZW5kRHN0ICk7XG5cdFx0XHRcdHN0YXRlLnNldERlcHRoVGVzdCggbWF0ZXJpYWwuZGVwdGhUZXN0ICk7XG5cdFx0XHRcdHN0YXRlLnNldERlcHRoV3JpdGUoIG1hdGVyaWFsLmRlcHRoV3JpdGUgKTtcblxuXHRcdFx0XHRpZiAoIG1hdGVyaWFsLm1hcCAmJiBtYXRlcmlhbC5tYXAuaW1hZ2UgJiYgbWF0ZXJpYWwubWFwLmltYWdlLndpZHRoICkge1xuXG5cdFx0XHRcdFx0cmVuZGVyZXIuc2V0VGV4dHVyZSggbWF0ZXJpYWwubWFwLCAwICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHJlbmRlcmVyLnNldFRleHR1cmUoIHRleHR1cmUsIDAgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Z2wuZHJhd0VsZW1lbnRzKCBnbC5UUklBTkdMRVMsIDYsIGdsLlVOU0lHTkVEX1NIT1JULCAwICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gcmVzdG9yZSBnbFxuXG5cdFx0XHRzdGF0ZS5lbmFibGUoIGdsLkNVTExfRkFDRSApO1xuXG5cdFx0XHRyZW5kZXJlci5yZXNldEdMU3RhdGUoKTtcblxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBjcmVhdGVQcm9ncmFtICgpIHtcblxuXHRcdFx0dmFyIHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG5cblx0XHRcdHZhciB2ZXJ0ZXhTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoIGdsLlZFUlRFWF9TSEFERVIgKTtcblx0XHRcdHZhciBmcmFnbWVudFNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlciggZ2wuRlJBR01FTlRfU0hBREVSICk7XG5cblx0XHRcdGdsLnNoYWRlclNvdXJjZSggdmVydGV4U2hhZGVyLCBbXG5cblx0XHRcdFx0J3ByZWNpc2lvbiAnICsgcmVuZGVyZXIuZ2V0UHJlY2lzaW9uKCkgKyAnIGZsb2F0OycsXG5cblx0XHRcdFx0J3VuaWZvcm0gbWF0NCBtb2RlbFZpZXdNYXRyaXg7Jyxcblx0XHRcdFx0J3VuaWZvcm0gbWF0NCBwcm9qZWN0aW9uTWF0cml4OycsXG5cdFx0XHRcdCd1bmlmb3JtIGZsb2F0IHJvdGF0aW9uOycsXG5cdFx0XHRcdCd1bmlmb3JtIHZlYzIgc2NhbGU7Jyxcblx0XHRcdFx0J3VuaWZvcm0gdmVjMiB1dk9mZnNldDsnLFxuXHRcdFx0XHQndW5pZm9ybSB2ZWMyIHV2U2NhbGU7JyxcblxuXHRcdFx0XHQnYXR0cmlidXRlIHZlYzIgcG9zaXRpb247Jyxcblx0XHRcdFx0J2F0dHJpYnV0ZSB2ZWMyIHV2OycsXG5cblx0XHRcdFx0J3ZhcnlpbmcgdmVjMiB2VVY7JyxcblxuXHRcdFx0XHQndm9pZCBtYWluKCkgeycsXG5cblx0XHRcdFx0XHQndlVWID0gdXZPZmZzZXQgKyB1diAqIHV2U2NhbGU7JyxcblxuXHRcdFx0XHRcdCd2ZWMyIGFsaWduZWRQb3NpdGlvbiA9IHBvc2l0aW9uICogc2NhbGU7JyxcblxuXHRcdFx0XHRcdCd2ZWMyIHJvdGF0ZWRQb3NpdGlvbjsnLFxuXHRcdFx0XHRcdCdyb3RhdGVkUG9zaXRpb24ueCA9IGNvcyggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi54IC0gc2luKCByb3RhdGlvbiApICogYWxpZ25lZFBvc2l0aW9uLnk7Jyxcblx0XHRcdFx0XHQncm90YXRlZFBvc2l0aW9uLnkgPSBzaW4oIHJvdGF0aW9uICkgKiBhbGlnbmVkUG9zaXRpb24ueCArIGNvcyggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi55OycsXG5cblx0XHRcdFx0XHQndmVjNCBmaW5hbFBvc2l0aW9uOycsXG5cblx0XHRcdFx0XHQnZmluYWxQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIDAuMCwgMC4wLCAwLjAsIDEuMCApOycsXG5cdFx0XHRcdFx0J2ZpbmFsUG9zaXRpb24ueHkgKz0gcm90YXRlZFBvc2l0aW9uOycsXG5cdFx0XHRcdFx0J2ZpbmFsUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogZmluYWxQb3NpdGlvbjsnLFxuXG5cdFx0XHRcdFx0J2dsX1Bvc2l0aW9uID0gZmluYWxQb3NpdGlvbjsnLFxuXG5cdFx0XHRcdCd9J1xuXG5cdFx0XHRdLmpvaW4oICdcXG4nICkgKTtcblxuXHRcdFx0Z2wuc2hhZGVyU291cmNlKCBmcmFnbWVudFNoYWRlciwgW1xuXG5cdFx0XHRcdCdwcmVjaXNpb24gJyArIHJlbmRlcmVyLmdldFByZWNpc2lvbigpICsgJyBmbG9hdDsnLFxuXG5cdFx0XHRcdCd1bmlmb3JtIHZlYzMgY29sb3I7Jyxcblx0XHRcdFx0J3VuaWZvcm0gc2FtcGxlcjJEIG1hcDsnLFxuXHRcdFx0XHQndW5pZm9ybSBmbG9hdCBvcGFjaXR5OycsXG5cblx0XHRcdFx0J3VuaWZvcm0gaW50IGZvZ1R5cGU7Jyxcblx0XHRcdFx0J3VuaWZvcm0gdmVjMyBmb2dDb2xvcjsnLFxuXHRcdFx0XHQndW5pZm9ybSBmbG9hdCBmb2dEZW5zaXR5OycsXG5cdFx0XHRcdCd1bmlmb3JtIGZsb2F0IGZvZ05lYXI7Jyxcblx0XHRcdFx0J3VuaWZvcm0gZmxvYXQgZm9nRmFyOycsXG5cdFx0XHRcdCd1bmlmb3JtIGZsb2F0IGFscGhhVGVzdDsnLFxuXG5cdFx0XHRcdCd2YXJ5aW5nIHZlYzIgdlVWOycsXG5cblx0XHRcdFx0J3ZvaWQgbWFpbigpIHsnLFxuXG5cdFx0XHRcdFx0J3ZlYzQgdGV4dHVyZSA9IHRleHR1cmUyRCggbWFwLCB2VVYgKTsnLFxuXG5cdFx0XHRcdFx0J2lmICggdGV4dHVyZS5hIDwgYWxwaGFUZXN0ICkgZGlzY2FyZDsnLFxuXG5cdFx0XHRcdFx0J2dsX0ZyYWdDb2xvciA9IHZlYzQoIGNvbG9yICogdGV4dHVyZS54eXosIHRleHR1cmUuYSAqIG9wYWNpdHkgKTsnLFxuXG5cdFx0XHRcdFx0J2lmICggZm9nVHlwZSA+IDAgKSB7JyxcblxuXHRcdFx0XHRcdFx0J2Zsb2F0IGRlcHRoID0gZ2xfRnJhZ0Nvb3JkLnogLyBnbF9GcmFnQ29vcmQudzsnLFxuXHRcdFx0XHRcdFx0J2Zsb2F0IGZvZ0ZhY3RvciA9IDAuMDsnLFxuXG5cdFx0XHRcdFx0XHQnaWYgKCBmb2dUeXBlID09IDEgKSB7JyxcblxuXHRcdFx0XHRcdFx0XHQnZm9nRmFjdG9yID0gc21vb3Roc3RlcCggZm9nTmVhciwgZm9nRmFyLCBkZXB0aCApOycsXG5cblx0XHRcdFx0XHRcdCd9IGVsc2UgeycsXG5cblx0XHRcdFx0XHRcdFx0J2NvbnN0IGZsb2F0IExPRzIgPSAxLjQ0MjY5NTsnLFxuXHRcdFx0XHRcdFx0XHQnZm9nRmFjdG9yID0gZXhwMiggLSBmb2dEZW5zaXR5ICogZm9nRGVuc2l0eSAqIGRlcHRoICogZGVwdGggKiBMT0cyICk7Jyxcblx0XHRcdFx0XHRcdFx0J2ZvZ0ZhY3RvciA9IDEuMCAtIGNsYW1wKCBmb2dGYWN0b3IsIDAuMCwgMS4wICk7JyxcblxuXHRcdFx0XHRcdFx0J30nLFxuXG5cdFx0XHRcdFx0XHQnZ2xfRnJhZ0NvbG9yID0gbWl4KCBnbF9GcmFnQ29sb3IsIHZlYzQoIGZvZ0NvbG9yLCBnbF9GcmFnQ29sb3IudyApLCBmb2dGYWN0b3IgKTsnLFxuXG5cdFx0XHRcdFx0J30nLFxuXG5cdFx0XHRcdCd9J1xuXG5cdFx0XHRdLmpvaW4oICdcXG4nICkgKTtcblxuXHRcdFx0Z2wuY29tcGlsZVNoYWRlciggdmVydGV4U2hhZGVyICk7XG5cdFx0XHRnbC5jb21waWxlU2hhZGVyKCBmcmFnbWVudFNoYWRlciApO1xuXG5cdFx0XHRnbC5hdHRhY2hTaGFkZXIoIHByb2dyYW0sIHZlcnRleFNoYWRlciApO1xuXHRcdFx0Z2wuYXR0YWNoU2hhZGVyKCBwcm9ncmFtLCBmcmFnbWVudFNoYWRlciApO1xuXG5cdFx0XHRnbC5saW5rUHJvZ3JhbSggcHJvZ3JhbSApO1xuXG5cdFx0XHRyZXR1cm4gcHJvZ3JhbTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhaW50ZXJTb3J0U3RhYmxlICggYSwgYiApIHtcblxuXHRcdFx0aWYgKCBhLnogIT09IGIueiApIHtcblxuXHRcdFx0XHRyZXR1cm4gYi56IC0gYS56O1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHJldHVybiBiLmlkIC0gYS5pZDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH07XG5cblx0Ly8gRmlsZTpzcmMvZXh0cmFzL0N1cnZlVXRpbHMuanNcblxuXHQvKipcblx0ICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xuXHQgKi9cblxuXHRUSFJFRS5DdXJ2ZVV0aWxzID0ge1xuXG5cdFx0dGFuZ2VudFF1YWRyYXRpY0JlemllcjogZnVuY3Rpb24gKCB0LCBwMCwgcDEsIHAyICkge1xuXG5cdFx0XHRyZXR1cm4gMiAqICggMSAtIHQgKSAqICggcDEgLSBwMCApICsgMiAqIHQgKiAoIHAyIC0gcDEgKTtcblxuXHRcdH0sXG5cblx0XHQvLyBQdWF5IEJpbmcsIHRoYW5rcyBmb3IgaGVscGluZyB3aXRoIHRoaXMgZGVyaXZhdGl2ZSFcblxuXHRcdHRhbmdlbnRDdWJpY0JlemllcjogZnVuY3Rpb24gKCB0LCBwMCwgcDEsIHAyLCBwMyApIHtcblxuXHRcdFx0cmV0dXJuIC0gMyAqIHAwICogKCAxIC0gdCApICogKCAxIC0gdCApICArXG5cdFx0XHRcdDMgKiBwMSAqICggMSAtIHQgKSAqICggMSAtIHQgKSAtIDYgKiB0ICogcDEgKiAoIDEgLSB0ICkgK1xuXHRcdFx0XHQ2ICogdCAqICBwMiAqICggMSAtIHQgKSAtIDMgKiB0ICogdCAqIHAyICtcblx0XHRcdFx0MyAqIHQgKiB0ICogcDM7XG5cblx0XHR9LFxuXG5cdFx0dGFuZ2VudFNwbGluZTogZnVuY3Rpb24gKCB0LCBwMCwgcDEsIHAyLCBwMyApIHtcblxuXHRcdFx0Ly8gVG8gY2hlY2sgaWYgbXkgZm9ybXVsYXMgYXJlIGNvcnJlY3RcblxuXHRcdFx0dmFyIGgwMCA9IDYgKiB0ICogdCAtIDYgKiB0OyBcdC8vIGRlcml2ZWQgZnJvbSAydF4zIOKIkiAzdF4yICsgMVxuXHRcdFx0dmFyIGgxMCA9IDMgKiB0ICogdCAtIDQgKiB0ICsgMTsgLy8gdF4zIOKIkiAydF4yICsgdFxuXHRcdFx0dmFyIGgwMSA9IC0gNiAqIHQgKiB0ICsgNiAqIHQ7IFx0Ly8g4oiSIDJ0MyArIDN0MlxuXHRcdFx0dmFyIGgxMSA9IDMgKiB0ICogdCAtIDIgKiB0O1x0Ly8gdDMg4oiSIHQyXG5cblx0XHRcdHJldHVybiBoMDAgKyBoMTAgKyBoMDEgKyBoMTE7XG5cblx0XHR9LFxuXG5cdFx0Ly8gQ2F0bXVsbC1Sb21cblxuXHRcdGludGVycG9sYXRlOiBmdW5jdGlvbiggcDAsIHAxLCBwMiwgcDMsIHQgKSB7XG5cblx0XHRcdHZhciB2MCA9ICggcDIgLSBwMCApICogMC41O1xuXHRcdFx0dmFyIHYxID0gKCBwMyAtIHAxICkgKiAwLjU7XG5cdFx0XHR2YXIgdDIgPSB0ICogdDtcblx0XHRcdHZhciB0MyA9IHQgKiB0Mjtcblx0XHRcdHJldHVybiAoIDIgKiBwMSAtIDIgKiBwMiArIHYwICsgdjEgKSAqIHQzICsgKCAtIDMgKiBwMSArIDMgKiBwMiAtIDIgKiB2MCAtIHYxICkgKiB0MiArIHYwICogdCArIHAxO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0Ly8gRmlsZTpzcmMvZXh0cmFzL0dlb21ldHJ5VXRpbHMuanNcblxuXHQvKipcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICovXG5cblx0VEhSRUUuR2VvbWV0cnlVdGlscyA9IHtcblxuXHRcdG1lcmdlOiBmdW5jdGlvbiAoIGdlb21ldHJ5MSwgZ2VvbWV0cnkyLCBtYXRlcmlhbEluZGV4T2Zmc2V0ICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5HZW9tZXRyeVV0aWxzOiAubWVyZ2UoKSBoYXMgYmVlbiBtb3ZlZCB0byBHZW9tZXRyeS4gVXNlIGdlb21ldHJ5Lm1lcmdlKCBnZW9tZXRyeTIsIG1hdHJpeCwgbWF0ZXJpYWxJbmRleE9mZnNldCApIGluc3RlYWQuJyApO1xuXG5cdFx0XHR2YXIgbWF0cml4O1xuXG5cdFx0XHRpZiAoIGdlb21ldHJ5MiBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggKSB7XG5cblx0XHRcdFx0Z2VvbWV0cnkyLm1hdHJpeEF1dG9VcGRhdGUgJiYgZ2VvbWV0cnkyLnVwZGF0ZU1hdHJpeCgpO1xuXG5cdFx0XHRcdG1hdHJpeCA9IGdlb21ldHJ5Mi5tYXRyaXg7XG5cdFx0XHRcdGdlb21ldHJ5MiA9IGdlb21ldHJ5Mi5nZW9tZXRyeTtcblxuXHRcdFx0fVxuXG5cdFx0XHRnZW9tZXRyeTEubWVyZ2UoIGdlb21ldHJ5MiwgbWF0cml4LCBtYXRlcmlhbEluZGV4T2Zmc2V0ICk7XG5cblx0XHR9LFxuXG5cdFx0Y2VudGVyOiBmdW5jdGlvbiAoIGdlb21ldHJ5ICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5HZW9tZXRyeVV0aWxzOiAuY2VudGVyKCkgaGFzIGJlZW4gbW92ZWQgdG8gR2VvbWV0cnkuIFVzZSBnZW9tZXRyeS5jZW50ZXIoKSBpbnN0ZWFkLicgKTtcblx0XHRcdHJldHVybiBnZW9tZXRyeS5jZW50ZXIoKTtcblxuXHRcdH1cblxuXHR9O1xuXG5cdC8vIEZpbGU6c3JjL2V4dHJhcy9JbWFnZVV0aWxzLmpzXG5cblx0LyoqXG5cdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqIEBhdXRob3IgRGFvc2hlbmcgTXUgLyBodHRwczovL2dpdGh1Yi5jb20vRGFvc2hlbmdNdS9cblx0ICovXG5cblx0VEhSRUUuSW1hZ2VVdGlscyA9IHtcblxuXHRcdGNyb3NzT3JpZ2luOiB1bmRlZmluZWQsXG5cblx0XHRsb2FkVGV4dHVyZTogZnVuY3Rpb24gKCB1cmwsIG1hcHBpbmcsIG9uTG9hZCwgb25FcnJvciApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuSW1hZ2VVdGlscy5sb2FkVGV4dHVyZSBpcyBiZWluZyBkZXByZWNhdGVkLiBVc2UgVEhSRUUuVGV4dHVyZUxvYWRlcigpIGluc3RlYWQuJyApO1xuXG5cdFx0XHR2YXIgbG9hZGVyID0gbmV3IFRIUkVFLlRleHR1cmVMb2FkZXIoKTtcblx0XHRcdGxvYWRlci5zZXRDcm9zc09yaWdpbiggdGhpcy5jcm9zc09yaWdpbiApO1xuXG5cdFx0XHR2YXIgdGV4dHVyZSA9IGxvYWRlci5sb2FkKCB1cmwsIG9uTG9hZCwgdW5kZWZpbmVkLCBvbkVycm9yICk7XG5cblx0XHRcdGlmICggbWFwcGluZyApIHRleHR1cmUubWFwcGluZyA9IG1hcHBpbmc7XG5cblx0XHRcdHJldHVybiB0ZXh0dXJlO1xuXG5cdFx0fSxcblxuXHRcdGxvYWRUZXh0dXJlQ3ViZTogZnVuY3Rpb24gKCB1cmxzLCBtYXBwaW5nLCBvbkxvYWQsIG9uRXJyb3IgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkltYWdlVXRpbHMubG9hZFRleHR1cmVDdWJlIGlzIGJlaW5nIGRlcHJlY2F0ZWQuIFVzZSBUSFJFRS5DdWJlVGV4dHVyZUxvYWRlcigpIGluc3RlYWQuJyApO1xuXG5cdFx0XHR2YXIgbG9hZGVyID0gbmV3IFRIUkVFLkN1YmVUZXh0dXJlTG9hZGVyKCk7XG5cdFx0XHRsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIHRoaXMuY3Jvc3NPcmlnaW4gKTtcblxuXHRcdFx0dmFyIHRleHR1cmUgPSBsb2FkZXIubG9hZCggdXJscywgb25Mb2FkLCB1bmRlZmluZWQsIG9uRXJyb3IgKTtcblxuXHRcdFx0aWYgKCBtYXBwaW5nICkgdGV4dHVyZS5tYXBwaW5nID0gbWFwcGluZztcblxuXHRcdFx0cmV0dXJuIHRleHR1cmU7XG5cblx0XHR9LFxuXG5cdFx0bG9hZENvbXByZXNzZWRUZXh0dXJlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5JbWFnZVV0aWxzLmxvYWRDb21wcmVzc2VkVGV4dHVyZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVEhSRUUuRERTTG9hZGVyIGluc3RlYWQuJyApXG5cblx0XHR9LFxuXG5cdFx0bG9hZENvbXByZXNzZWRUZXh0dXJlQ3ViZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuSW1hZ2VVdGlscy5sb2FkQ29tcHJlc3NlZFRleHR1cmVDdWJlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBUSFJFRS5ERFNMb2FkZXIgaW5zdGVhZC4nIClcblxuXHRcdH1cblxuXHR9O1xuXG5cdC8vIEZpbGU6c3JjL2V4dHJhcy9TY2VuZVV0aWxzLmpzXG5cblx0LyoqXG5cdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG5cdCAqL1xuXG5cdFRIUkVFLlNjZW5lVXRpbHMgPSB7XG5cblx0XHRjcmVhdGVNdWx0aU1hdGVyaWFsT2JqZWN0OiBmdW5jdGlvbiAoIGdlb21ldHJ5LCBtYXRlcmlhbHMgKSB7XG5cblx0XHRcdHZhciBncm91cCA9IG5ldyBUSFJFRS5Hcm91cCgpO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBtYXRlcmlhbHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRncm91cC5hZGQoIG5ldyBUSFJFRS5NZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWxzWyBpIF0gKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBncm91cDtcblxuXHRcdH0sXG5cblx0XHRkZXRhY2g6IGZ1bmN0aW9uICggY2hpbGQsIHBhcmVudCwgc2NlbmUgKSB7XG5cblx0XHRcdGNoaWxkLmFwcGx5TWF0cml4KCBwYXJlbnQubWF0cml4V29ybGQgKTtcblx0XHRcdHBhcmVudC5yZW1vdmUoIGNoaWxkICk7XG5cdFx0XHRzY2VuZS5hZGQoIGNoaWxkICk7XG5cblx0XHR9LFxuXG5cdFx0YXR0YWNoOiBmdW5jdGlvbiAoIGNoaWxkLCBzY2VuZSwgcGFyZW50ICkge1xuXG5cdFx0XHR2YXIgbWF0cml4V29ybGRJbnZlcnNlID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblx0XHRcdG1hdHJpeFdvcmxkSW52ZXJzZS5nZXRJbnZlcnNlKCBwYXJlbnQubWF0cml4V29ybGQgKTtcblx0XHRcdGNoaWxkLmFwcGx5TWF0cml4KCBtYXRyaXhXb3JsZEludmVyc2UgKTtcblxuXHRcdFx0c2NlbmUucmVtb3ZlKCBjaGlsZCApO1xuXHRcdFx0cGFyZW50LmFkZCggY2hpbGQgKTtcblxuXHRcdH1cblxuXHR9O1xuXG5cdC8vIEZpbGU6c3JjL2V4dHJhcy9TaGFwZVV0aWxzLmpzXG5cblx0LyoqXG5cdCAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcblx0ICovXG5cblx0VEhSRUUuU2hhcGVVdGlscyA9IHtcblxuXHRcdC8vIGNhbGN1bGF0ZSBhcmVhIG9mIHRoZSBjb250b3VyIHBvbHlnb25cblxuXHRcdGFyZWE6IGZ1bmN0aW9uICggY29udG91ciApIHtcblxuXHRcdFx0dmFyIG4gPSBjb250b3VyLmxlbmd0aDtcblx0XHRcdHZhciBhID0gMC4wO1xuXG5cdFx0XHRmb3IgKCB2YXIgcCA9IG4gLSAxLCBxID0gMDsgcSA8IG47IHAgPSBxICsrICkge1xuXG5cdFx0XHRcdGEgKz0gY29udG91clsgcCBdLnggKiBjb250b3VyWyBxIF0ueSAtIGNvbnRvdXJbIHEgXS54ICogY29udG91clsgcCBdLnk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGEgKiAwLjU7XG5cblx0XHR9LFxuXG5cdFx0dHJpYW5ndWxhdGU6ICggZnVuY3Rpb24gKCkge1xuXG5cdFx0XHQvKipcblx0XHRcdCAqIFRoaXMgY29kZSBpcyBhIHF1aWNrIHBvcnQgb2YgY29kZSB3cml0dGVuIGluIEMrKyB3aGljaCB3YXMgc3VibWl0dGVkIHRvXG5cdFx0XHQgKiBmbGlwY29kZS5jb20gYnkgSm9obiBXLiBSYXRjbGlmZiAgLy8gSnVseSAyMiwgMjAwMFxuXHRcdFx0ICogU2VlIG9yaWdpbmFsIGNvZGUgYW5kIG1vcmUgaW5mb3JtYXRpb24gaGVyZTpcblx0XHRcdCAqIGh0dHA6Ly93d3cuZmxpcGNvZGUuY29tL2FyY2hpdmVzL0VmZmljaWVudF9Qb2x5Z29uX1RyaWFuZ3VsYXRpb24uc2h0bWxcblx0XHRcdCAqXG5cdFx0XHQgKiBwb3J0ZWQgdG8gYWN0aW9uc2NyaXB0IGJ5IFpldmFuIFJvc3NlclxuXHRcdFx0ICogd3d3LmFjdGlvbnNuaXBwZXQuY29tXG5cdFx0XHQgKlxuXHRcdFx0ICogcG9ydGVkIHRvIGphdmFzY3JpcHQgYnkgSm9zaHVhIEtvb1xuXHRcdFx0ICogaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xuXHRcdFx0ICpcblx0XHRcdCAqL1xuXG5cdFx0XHRmdW5jdGlvbiBzbmlwKCBjb250b3VyLCB1LCB2LCB3LCBuLCB2ZXJ0cyApIHtcblxuXHRcdFx0XHR2YXIgcDtcblx0XHRcdFx0dmFyIGF4LCBheSwgYngsIGJ5O1xuXHRcdFx0XHR2YXIgY3gsIGN5LCBweCwgcHk7XG5cblx0XHRcdFx0YXggPSBjb250b3VyWyB2ZXJ0c1sgdSBdIF0ueDtcblx0XHRcdFx0YXkgPSBjb250b3VyWyB2ZXJ0c1sgdSBdIF0ueTtcblxuXHRcdFx0XHRieCA9IGNvbnRvdXJbIHZlcnRzWyB2IF0gXS54O1xuXHRcdFx0XHRieSA9IGNvbnRvdXJbIHZlcnRzWyB2IF0gXS55O1xuXG5cdFx0XHRcdGN4ID0gY29udG91clsgdmVydHNbIHcgXSBdLng7XG5cdFx0XHRcdGN5ID0gY29udG91clsgdmVydHNbIHcgXSBdLnk7XG5cblx0XHRcdFx0aWYgKCBOdW1iZXIuRVBTSUxPTiA+ICggKCAoIGJ4IC0gYXggKSAqICggY3kgLSBheSApICkgLSAoICggYnkgLSBheSApICogKCBjeCAtIGF4ICkgKSApICkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0XHRcdHZhciBhWCwgYVksIGJYLCBiWSwgY1gsIGNZO1xuXHRcdFx0XHR2YXIgYXB4LCBhcHksIGJweCwgYnB5LCBjcHgsIGNweTtcblx0XHRcdFx0dmFyIGNDUk9TU2FwLCBiQ1JPU1NjcCwgYUNST1NTYnA7XG5cblx0XHRcdFx0YVggPSBjeCAtIGJ4OyAgYVkgPSBjeSAtIGJ5O1xuXHRcdFx0XHRiWCA9IGF4IC0gY3g7ICBiWSA9IGF5IC0gY3k7XG5cdFx0XHRcdGNYID0gYnggLSBheDsgIGNZID0gYnkgLSBheTtcblxuXHRcdFx0XHRmb3IgKCBwID0gMDsgcCA8IG47IHAgKysgKSB7XG5cblx0XHRcdFx0XHRweCA9IGNvbnRvdXJbIHZlcnRzWyBwIF0gXS54O1xuXHRcdFx0XHRcdHB5ID0gY29udG91clsgdmVydHNbIHAgXSBdLnk7XG5cblx0XHRcdFx0XHRpZiAoICggKCBweCA9PT0gYXggKSAmJiAoIHB5ID09PSBheSApICkgfHxcblx0XHRcdFx0XHRcdCAoICggcHggPT09IGJ4ICkgJiYgKCBweSA9PT0gYnkgKSApIHx8XG5cdFx0XHRcdFx0XHQgKCAoIHB4ID09PSBjeCApICYmICggcHkgPT09IGN5ICkgKSApXHRjb250aW51ZTtcblxuXHRcdFx0XHRcdGFweCA9IHB4IC0gYXg7ICBhcHkgPSBweSAtIGF5O1xuXHRcdFx0XHRcdGJweCA9IHB4IC0gYng7ICBicHkgPSBweSAtIGJ5O1xuXHRcdFx0XHRcdGNweCA9IHB4IC0gY3g7ICBjcHkgPSBweSAtIGN5O1xuXG5cdFx0XHRcdFx0Ly8gc2VlIGlmIHAgaXMgaW5zaWRlIHRyaWFuZ2xlIGFiY1xuXG5cdFx0XHRcdFx0YUNST1NTYnAgPSBhWCAqIGJweSAtIGFZICogYnB4O1xuXHRcdFx0XHRcdGNDUk9TU2FwID0gY1ggKiBhcHkgLSBjWSAqIGFweDtcblx0XHRcdFx0XHRiQ1JPU1NjcCA9IGJYICogY3B5IC0gYlkgKiBjcHg7XG5cblx0XHRcdFx0XHRpZiAoICggYUNST1NTYnAgPj0gLSBOdW1iZXIuRVBTSUxPTiApICYmICggYkNST1NTY3AgPj0gLSBOdW1iZXIuRVBTSUxPTiApICYmICggY0NST1NTYXAgPj0gLSBOdW1iZXIuRVBTSUxPTiApICkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyB0YWtlcyBpbiBhbiBjb250b3VyIGFycmF5IGFuZCByZXR1cm5zXG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiAoIGNvbnRvdXIsIGluZGljZXMgKSB7XG5cblx0XHRcdFx0dmFyIG4gPSBjb250b3VyLmxlbmd0aDtcblxuXHRcdFx0XHRpZiAoIG4gPCAzICkgcmV0dXJuIG51bGw7XG5cblx0XHRcdFx0dmFyIHJlc3VsdCA9IFtdLFxuXHRcdFx0XHRcdHZlcnRzID0gW10sXG5cdFx0XHRcdFx0dmVydEluZGljZXMgPSBbXTtcblxuXHRcdFx0XHQvKiB3ZSB3YW50IGEgY291bnRlci1jbG9ja3dpc2UgcG9seWdvbiBpbiB2ZXJ0cyAqL1xuXG5cdFx0XHRcdHZhciB1LCB2LCB3O1xuXG5cdFx0XHRcdGlmICggVEhSRUUuU2hhcGVVdGlscy5hcmVhKCBjb250b3VyICkgPiAwLjAgKSB7XG5cblx0XHRcdFx0XHRmb3IgKCB2ID0gMDsgdiA8IG47IHYgKysgKSB2ZXJ0c1sgdiBdID0gdjtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Zm9yICggdiA9IDA7IHYgPCBuOyB2ICsrICkgdmVydHNbIHYgXSA9ICggbiAtIDEgKSAtIHY7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBudiA9IG47XG5cblx0XHRcdFx0LyogIHJlbW92ZSBudiAtIDIgdmVydGljZXMsIGNyZWF0aW5nIDEgdHJpYW5nbGUgZXZlcnkgdGltZSAqL1xuXG5cdFx0XHRcdHZhciBjb3VudCA9IDIgKiBudjsgICAvKiBlcnJvciBkZXRlY3Rpb24gKi9cblxuXHRcdFx0XHRmb3IgKCB2ID0gbnYgLSAxOyBudiA+IDI7ICkge1xuXG5cdFx0XHRcdFx0LyogaWYgd2UgbG9vcCwgaXQgaXMgcHJvYmFibHkgYSBub24tc2ltcGxlIHBvbHlnb24gKi9cblxuXHRcdFx0XHRcdGlmICggKCBjb3VudCAtLSApIDw9IDAgKSB7XG5cblx0XHRcdFx0XHRcdC8vKiogVHJpYW5ndWxhdGU6IEVSUk9SIC0gcHJvYmFibGUgYmFkIHBvbHlnb24hXG5cblx0XHRcdFx0XHRcdC8vdGhyb3cgKCBcIldhcm5pbmcsIHVuYWJsZSB0byB0cmlhbmd1bGF0ZSBwb2x5Z29uIVwiICk7XG5cdFx0XHRcdFx0XHQvL3JldHVybiBudWxsO1xuXHRcdFx0XHRcdFx0Ly8gU29tZXRpbWVzIHdhcm5pbmcgaXMgZmluZSwgZXNwZWNpYWxseSBwb2x5Z29ucyBhcmUgdHJpYW5ndWxhdGVkIGluIHJldmVyc2UuXG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5TaGFwZVV0aWxzOiBVbmFibGUgdG8gdHJpYW5ndWxhdGUgcG9seWdvbiEgaW4gdHJpYW5ndWxhdGUoKScgKTtcblxuXHRcdFx0XHRcdFx0aWYgKCBpbmRpY2VzICkgcmV0dXJuIHZlcnRJbmRpY2VzO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8qIHRocmVlIGNvbnNlY3V0aXZlIHZlcnRpY2VzIGluIGN1cnJlbnQgcG9seWdvbiwgPHUsdix3PiAqL1xuXG5cdFx0XHRcdFx0dSA9IHY7IFx0IFx0aWYgKCBudiA8PSB1ICkgdSA9IDA7ICAgICAvKiBwcmV2aW91cyAqL1xuXHRcdFx0XHRcdHYgPSB1ICsgMTsgIGlmICggbnYgPD0gdiApIHYgPSAwOyAgICAgLyogbmV3IHYgICAgKi9cblx0XHRcdFx0XHR3ID0gdiArIDE7ICBpZiAoIG52IDw9IHcgKSB3ID0gMDsgICAgIC8qIG5leHQgICAgICovXG5cblx0XHRcdFx0XHRpZiAoIHNuaXAoIGNvbnRvdXIsIHUsIHYsIHcsIG52LCB2ZXJ0cyApICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgYSwgYiwgYywgcywgdDtcblxuXHRcdFx0XHRcdFx0LyogdHJ1ZSBuYW1lcyBvZiB0aGUgdmVydGljZXMgKi9cblxuXHRcdFx0XHRcdFx0YSA9IHZlcnRzWyB1IF07XG5cdFx0XHRcdFx0XHRiID0gdmVydHNbIHYgXTtcblx0XHRcdFx0XHRcdGMgPSB2ZXJ0c1sgdyBdO1xuXG5cdFx0XHRcdFx0XHQvKiBvdXRwdXQgVHJpYW5nbGUgKi9cblxuXHRcdFx0XHRcdFx0cmVzdWx0LnB1c2goIFsgY29udG91clsgYSBdLFxuXHRcdFx0XHRcdFx0XHRjb250b3VyWyBiIF0sXG5cdFx0XHRcdFx0XHRcdGNvbnRvdXJbIGMgXSBdICk7XG5cblxuXHRcdFx0XHRcdFx0dmVydEluZGljZXMucHVzaCggWyB2ZXJ0c1sgdSBdLCB2ZXJ0c1sgdiBdLCB2ZXJ0c1sgdyBdIF0gKTtcblxuXHRcdFx0XHRcdFx0LyogcmVtb3ZlIHYgZnJvbSB0aGUgcmVtYWluaW5nIHBvbHlnb24gKi9cblxuXHRcdFx0XHRcdFx0Zm9yICggcyA9IHYsIHQgPSB2ICsgMTsgdCA8IG52OyBzICsrLCB0ICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdHZlcnRzWyBzIF0gPSB2ZXJ0c1sgdCBdO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdG52IC0tO1xuXG5cdFx0XHRcdFx0XHQvKiByZXNldCBlcnJvciBkZXRlY3Rpb24gY291bnRlciAqL1xuXG5cdFx0XHRcdFx0XHRjb3VudCA9IDIgKiBudjtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBpbmRpY2VzICkgcmV0dXJuIHZlcnRJbmRpY2VzO1xuXHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xuXG5cdFx0XHR9XG5cblx0XHR9ICkoKSxcblxuXHRcdHRyaWFuZ3VsYXRlU2hhcGU6IGZ1bmN0aW9uICggY29udG91ciwgaG9sZXMgKSB7XG5cblx0XHRcdGZ1bmN0aW9uIHBvaW50X2luX3NlZ21lbnRfMkRfY29saW4oIGluU2VnUHQxLCBpblNlZ1B0MiwgaW5PdGhlclB0ICkge1xuXG5cdFx0XHRcdC8vIGluT3RoZXJQdCBuZWVkcyB0byBiZSBjb2xsaW5lYXIgdG8gdGhlIGluU2VnbWVudFxuXHRcdFx0XHRpZiAoIGluU2VnUHQxLnggIT09IGluU2VnUHQyLnggKSB7XG5cblx0XHRcdFx0XHRpZiAoIGluU2VnUHQxLnggPCBpblNlZ1B0Mi54ICkge1xuXG5cdFx0XHRcdFx0XHRyZXR1cm5cdCggKCBpblNlZ1B0MS54IDw9IGluT3RoZXJQdC54ICkgJiYgKCBpbk90aGVyUHQueCA8PSBpblNlZ1B0Mi54ICkgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdHJldHVyblx0KCAoIGluU2VnUHQyLnggPD0gaW5PdGhlclB0LnggKSAmJiAoIGluT3RoZXJQdC54IDw9IGluU2VnUHQxLnggKSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRpZiAoIGluU2VnUHQxLnkgPCBpblNlZ1B0Mi55ICkge1xuXG5cdFx0XHRcdFx0XHRyZXR1cm5cdCggKCBpblNlZ1B0MS55IDw9IGluT3RoZXJQdC55ICkgJiYgKCBpbk90aGVyUHQueSA8PSBpblNlZ1B0Mi55ICkgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdHJldHVyblx0KCAoIGluU2VnUHQyLnkgPD0gaW5PdGhlclB0LnkgKSAmJiAoIGluT3RoZXJQdC55IDw9IGluU2VnUHQxLnkgKSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBpbnRlcnNlY3Rfc2VnbWVudHNfMkQoIGluU2VnMVB0MSwgaW5TZWcxUHQyLCBpblNlZzJQdDEsIGluU2VnMlB0MiwgaW5FeGNsdWRlQWRqYWNlbnRTZWdzICkge1xuXG5cdFx0XHRcdHZhciBzZWcxZHggPSBpblNlZzFQdDIueCAtIGluU2VnMVB0MS54LCAgIHNlZzFkeSA9IGluU2VnMVB0Mi55IC0gaW5TZWcxUHQxLnk7XG5cdFx0XHRcdHZhciBzZWcyZHggPSBpblNlZzJQdDIueCAtIGluU2VnMlB0MS54LCAgIHNlZzJkeSA9IGluU2VnMlB0Mi55IC0gaW5TZWcyUHQxLnk7XG5cblx0XHRcdFx0dmFyIHNlZzFzZWcyZHggPSBpblNlZzFQdDEueCAtIGluU2VnMlB0MS54O1xuXHRcdFx0XHR2YXIgc2VnMXNlZzJkeSA9IGluU2VnMVB0MS55IC0gaW5TZWcyUHQxLnk7XG5cblx0XHRcdFx0dmFyIGxpbWl0XHRcdD0gc2VnMWR5ICogc2VnMmR4IC0gc2VnMWR4ICogc2VnMmR5O1xuXHRcdFx0XHR2YXIgcGVycFNlZzFcdD0gc2VnMWR5ICogc2VnMXNlZzJkeCAtIHNlZzFkeCAqIHNlZzFzZWcyZHk7XG5cblx0XHRcdFx0aWYgKCBNYXRoLmFicyggbGltaXQgKSA+IE51bWJlci5FUFNJTE9OICkge1xuXG5cdFx0XHRcdFx0Ly8gbm90IHBhcmFsbGVsXG5cblx0XHRcdFx0XHR2YXIgcGVycFNlZzI7XG5cdFx0XHRcdFx0aWYgKCBsaW1pdCA+IDAgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggKCBwZXJwU2VnMSA8IDAgKSB8fCAoIHBlcnBTZWcxID4gbGltaXQgKSApIFx0XHRyZXR1cm4gW107XG5cdFx0XHRcdFx0XHRwZXJwU2VnMiA9IHNlZzJkeSAqIHNlZzFzZWcyZHggLSBzZWcyZHggKiBzZWcxc2VnMmR5O1xuXHRcdFx0XHRcdFx0aWYgKCAoIHBlcnBTZWcyIDwgMCApIHx8ICggcGVycFNlZzIgPiBsaW1pdCApICkgXHRcdHJldHVybiBbXTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdGlmICggKCBwZXJwU2VnMSA+IDAgKSB8fCAoIHBlcnBTZWcxIDwgbGltaXQgKSApIFx0XHRyZXR1cm4gW107XG5cdFx0XHRcdFx0XHRwZXJwU2VnMiA9IHNlZzJkeSAqIHNlZzFzZWcyZHggLSBzZWcyZHggKiBzZWcxc2VnMmR5O1xuXHRcdFx0XHRcdFx0aWYgKCAoIHBlcnBTZWcyID4gMCApIHx8ICggcGVycFNlZzIgPCBsaW1pdCApICkgXHRcdHJldHVybiBbXTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIGkuZS4gdG8gcmVkdWNlIHJvdW5kaW5nIGVycm9yc1xuXHRcdFx0XHRcdC8vIGludGVyc2VjdGlvbiBhdCBlbmRwb2ludCBvZiBzZWdtZW50IzE/XG5cdFx0XHRcdFx0aWYgKCBwZXJwU2VnMiA9PT0gMCApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCAoIGluRXhjbHVkZUFkamFjZW50U2VncyApICYmXG5cdFx0XHRcdFx0XHRcdCAoICggcGVycFNlZzEgPT09IDAgKSB8fCAoIHBlcnBTZWcxID09PSBsaW1pdCApICkgKVx0XHRyZXR1cm4gW107XG5cdFx0XHRcdFx0XHRyZXR1cm4gWyBpblNlZzFQdDEgXTtcblxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIHBlcnBTZWcyID09PSBsaW1pdCApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCAoIGluRXhjbHVkZUFkamFjZW50U2VncyApICYmXG5cdFx0XHRcdFx0XHRcdCAoICggcGVycFNlZzEgPT09IDAgKSB8fCAoIHBlcnBTZWcxID09PSBsaW1pdCApICkgKVx0XHRyZXR1cm4gW107XG5cdFx0XHRcdFx0XHRyZXR1cm4gWyBpblNlZzFQdDIgXTtcblxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBpbnRlcnNlY3Rpb24gYXQgZW5kcG9pbnQgb2Ygc2VnbWVudCMyP1xuXHRcdFx0XHRcdGlmICggcGVycFNlZzEgPT09IDAgKVx0XHRyZXR1cm4gWyBpblNlZzJQdDEgXTtcblx0XHRcdFx0XHRpZiAoIHBlcnBTZWcxID09PSBsaW1pdCApXHRyZXR1cm4gWyBpblNlZzJQdDIgXTtcblxuXHRcdFx0XHRcdC8vIHJldHVybiByZWFsIGludGVyc2VjdGlvbiBwb2ludFxuXHRcdFx0XHRcdHZhciBmYWN0b3JTZWcxID0gcGVycFNlZzIgLyBsaW1pdDtcblx0XHRcdFx0XHRyZXR1cm5cdFsgeyB4OiBpblNlZzFQdDEueCArIGZhY3RvclNlZzEgKiBzZWcxZHgsXG5cdFx0XHRcdFx0XHRcdFx0eTogaW5TZWcxUHQxLnkgKyBmYWN0b3JTZWcxICogc2VnMWR5IH0gXTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ly8gcGFyYWxsZWwgb3IgY29sbGluZWFyXG5cdFx0XHRcdFx0aWYgKCAoIHBlcnBTZWcxICE9PSAwICkgfHxcblx0XHRcdFx0XHRcdCAoIHNlZzJkeSAqIHNlZzFzZWcyZHggIT09IHNlZzJkeCAqIHNlZzFzZWcyZHkgKSApIFx0XHRcdHJldHVybiBbXTtcblxuXHRcdFx0XHRcdC8vIHRoZXkgYXJlIGNvbGxpbmVhciBvciBkZWdlbmVyYXRlXG5cdFx0XHRcdFx0dmFyIHNlZzFQdCA9ICggKCBzZWcxZHggPT09IDAgKSAmJiAoIHNlZzFkeSA9PT0gMCApICk7XHQvLyBzZWdtZW50MSBpcyBqdXN0IGEgcG9pbnQ/XG5cdFx0XHRcdFx0dmFyIHNlZzJQdCA9ICggKCBzZWcyZHggPT09IDAgKSAmJiAoIHNlZzJkeSA9PT0gMCApICk7XHQvLyBzZWdtZW50MiBpcyBqdXN0IGEgcG9pbnQ/XG5cdFx0XHRcdFx0Ly8gYm90aCBzZWdtZW50cyBhcmUgcG9pbnRzXG5cdFx0XHRcdFx0aWYgKCBzZWcxUHQgJiYgc2VnMlB0ICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoICggaW5TZWcxUHQxLnggIT09IGluU2VnMlB0MS54ICkgfHxcblx0XHRcdFx0XHRcdFx0ICggaW5TZWcxUHQxLnkgIT09IGluU2VnMlB0MS55ICkgKVx0XHRyZXR1cm4gW107XHQvLyB0aGV5IGFyZSBkaXN0aW5jdCAgcG9pbnRzXG5cdFx0XHRcdFx0XHRyZXR1cm4gWyBpblNlZzFQdDEgXTsgICAgICAgICAgICAgICAgIFx0XHRcdFx0XHRcdC8vIHRoZXkgYXJlIHRoZSBzYW1lIHBvaW50XG5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gc2VnbWVudCMxICBpcyBhIHNpbmdsZSBwb2ludFxuXHRcdFx0XHRcdGlmICggc2VnMVB0ICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoICEgcG9pbnRfaW5fc2VnbWVudF8yRF9jb2xpbiggaW5TZWcyUHQxLCBpblNlZzJQdDIsIGluU2VnMVB0MSApIClcdFx0cmV0dXJuIFtdO1x0XHQvLyBidXQgbm90IGluIHNlZ21lbnQjMlxuXHRcdFx0XHRcdFx0cmV0dXJuIFsgaW5TZWcxUHQxIF07XG5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gc2VnbWVudCMyICBpcyBhIHNpbmdsZSBwb2ludFxuXHRcdFx0XHRcdGlmICggc2VnMlB0ICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoICEgcG9pbnRfaW5fc2VnbWVudF8yRF9jb2xpbiggaW5TZWcxUHQxLCBpblNlZzFQdDIsIGluU2VnMlB0MSApIClcdFx0cmV0dXJuIFtdO1x0XHQvLyBidXQgbm90IGluIHNlZ21lbnQjMVxuXHRcdFx0XHRcdFx0cmV0dXJuIFsgaW5TZWcyUHQxIF07XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyB0aGV5IGFyZSBjb2xsaW5lYXIgc2VnbWVudHMsIHdoaWNoIG1pZ2h0IG92ZXJsYXBcblx0XHRcdFx0XHR2YXIgc2VnMW1pbiwgc2VnMW1heCwgc2VnMW1pblZhbCwgc2VnMW1heFZhbDtcblx0XHRcdFx0XHR2YXIgc2VnMm1pbiwgc2VnMm1heCwgc2VnMm1pblZhbCwgc2VnMm1heFZhbDtcblx0XHRcdFx0XHRpZiAoIHNlZzFkeCAhPT0gMCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gdGhlIHNlZ21lbnRzIGFyZSBOT1Qgb24gYSB2ZXJ0aWNhbCBsaW5lXG5cdFx0XHRcdFx0XHRpZiAoIGluU2VnMVB0MS54IDwgaW5TZWcxUHQyLnggKSB7XG5cblx0XHRcdFx0XHRcdFx0c2VnMW1pbiA9IGluU2VnMVB0MTsgc2VnMW1pblZhbCA9IGluU2VnMVB0MS54O1xuXHRcdFx0XHRcdFx0XHRzZWcxbWF4ID0gaW5TZWcxUHQyOyBzZWcxbWF4VmFsID0gaW5TZWcxUHQyLng7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0c2VnMW1pbiA9IGluU2VnMVB0Mjsgc2VnMW1pblZhbCA9IGluU2VnMVB0Mi54O1xuXHRcdFx0XHRcdFx0XHRzZWcxbWF4ID0gaW5TZWcxUHQxOyBzZWcxbWF4VmFsID0gaW5TZWcxUHQxLng7XG5cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICggaW5TZWcyUHQxLnggPCBpblNlZzJQdDIueCApIHtcblxuXHRcdFx0XHRcdFx0XHRzZWcybWluID0gaW5TZWcyUHQxOyBzZWcybWluVmFsID0gaW5TZWcyUHQxLng7XG5cdFx0XHRcdFx0XHRcdHNlZzJtYXggPSBpblNlZzJQdDI7IHNlZzJtYXhWYWwgPSBpblNlZzJQdDIueDtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRzZWcybWluID0gaW5TZWcyUHQyOyBzZWcybWluVmFsID0gaW5TZWcyUHQyLng7XG5cdFx0XHRcdFx0XHRcdHNlZzJtYXggPSBpblNlZzJQdDE7IHNlZzJtYXhWYWwgPSBpblNlZzJQdDEueDtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Ly8gdGhlIHNlZ21lbnRzIGFyZSBvbiBhIHZlcnRpY2FsIGxpbmVcblx0XHRcdFx0XHRcdGlmICggaW5TZWcxUHQxLnkgPCBpblNlZzFQdDIueSApIHtcblxuXHRcdFx0XHRcdFx0XHRzZWcxbWluID0gaW5TZWcxUHQxOyBzZWcxbWluVmFsID0gaW5TZWcxUHQxLnk7XG5cdFx0XHRcdFx0XHRcdHNlZzFtYXggPSBpblNlZzFQdDI7IHNlZzFtYXhWYWwgPSBpblNlZzFQdDIueTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRzZWcxbWluID0gaW5TZWcxUHQyOyBzZWcxbWluVmFsID0gaW5TZWcxUHQyLnk7XG5cdFx0XHRcdFx0XHRcdHNlZzFtYXggPSBpblNlZzFQdDE7IHNlZzFtYXhWYWwgPSBpblNlZzFQdDEueTtcblxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCBpblNlZzJQdDEueSA8IGluU2VnMlB0Mi55ICkge1xuXG5cdFx0XHRcdFx0XHRcdHNlZzJtaW4gPSBpblNlZzJQdDE7IHNlZzJtaW5WYWwgPSBpblNlZzJQdDEueTtcblx0XHRcdFx0XHRcdFx0c2VnMm1heCA9IGluU2VnMlB0Mjsgc2VnMm1heFZhbCA9IGluU2VnMlB0Mi55O1xuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdHNlZzJtaW4gPSBpblNlZzJQdDI7IHNlZzJtaW5WYWwgPSBpblNlZzJQdDIueTtcblx0XHRcdFx0XHRcdFx0c2VnMm1heCA9IGluU2VnMlB0MTsgc2VnMm1heFZhbCA9IGluU2VnMlB0MS55O1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBzZWcxbWluVmFsIDw9IHNlZzJtaW5WYWwgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggc2VnMW1heFZhbCA8ICBzZWcybWluVmFsIClcdHJldHVybiBbXTtcblx0XHRcdFx0XHRcdGlmICggc2VnMW1heFZhbCA9PT0gc2VnMm1pblZhbCApXHR7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBpbkV4Y2x1ZGVBZGphY2VudFNlZ3MgKVx0XHRyZXR1cm4gW107XG5cdFx0XHRcdFx0XHRcdHJldHVybiBbIHNlZzJtaW4gXTtcblxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCBzZWcxbWF4VmFsIDw9IHNlZzJtYXhWYWwgKVx0cmV0dXJuIFsgc2VnMm1pbiwgc2VnMW1heCBdO1xuXHRcdFx0XHRcdFx0cmV0dXJuXHRbIHNlZzJtaW4sIHNlZzJtYXggXTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdGlmICggc2VnMW1pblZhbCA+ICBzZWcybWF4VmFsIClcdHJldHVybiBbXTtcblx0XHRcdFx0XHRcdGlmICggc2VnMW1pblZhbCA9PT0gc2VnMm1heFZhbCApXHR7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBpbkV4Y2x1ZGVBZGphY2VudFNlZ3MgKVx0XHRyZXR1cm4gW107XG5cdFx0XHRcdFx0XHRcdHJldHVybiBbIHNlZzFtaW4gXTtcblxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCBzZWcxbWF4VmFsIDw9IHNlZzJtYXhWYWwgKVx0cmV0dXJuIFsgc2VnMW1pbiwgc2VnMW1heCBdO1xuXHRcdFx0XHRcdFx0cmV0dXJuXHRbIHNlZzFtaW4sIHNlZzJtYXggXTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gaXNQb2ludEluc2lkZUFuZ2xlKCBpblZlcnRleCwgaW5MZWdGcm9tUHQsIGluTGVnVG9QdCwgaW5PdGhlclB0ICkge1xuXG5cdFx0XHRcdC8vIFRoZSBvcmRlciBvZiBsZWdzIGlzIGltcG9ydGFudFxuXG5cdFx0XHRcdC8vIHRyYW5zbGF0aW9uIG9mIGFsbCBwb2ludHMsIHNvIHRoYXQgVmVydGV4IGlzIGF0ICgwLDApXG5cdFx0XHRcdHZhciBsZWdGcm9tUHRYXHQ9IGluTGVnRnJvbVB0LnggLSBpblZlcnRleC54LCAgbGVnRnJvbVB0WVx0PSBpbkxlZ0Zyb21QdC55IC0gaW5WZXJ0ZXgueTtcblx0XHRcdFx0dmFyIGxlZ1RvUHRYXHQ9IGluTGVnVG9QdC54XHQtIGluVmVydGV4LngsICBsZWdUb1B0WVx0XHQ9IGluTGVnVG9QdC55XHQtIGluVmVydGV4Lnk7XG5cdFx0XHRcdHZhciBvdGhlclB0WFx0PSBpbk90aGVyUHQueFx0LSBpblZlcnRleC54LCAgb3RoZXJQdFlcdFx0PSBpbk90aGVyUHQueVx0LSBpblZlcnRleC55O1xuXG5cdFx0XHRcdC8vIG1haW4gYW5nbGUgPjA6IDwgMTgwIGRlZy47IDA6IDE4MCBkZWcuOyA8MDogPiAxODAgZGVnLlxuXHRcdFx0XHR2YXIgZnJvbTJ0b0FuZ2xlXHQ9IGxlZ0Zyb21QdFggKiBsZWdUb1B0WSAtIGxlZ0Zyb21QdFkgKiBsZWdUb1B0WDtcblx0XHRcdFx0dmFyIGZyb20yb3RoZXJBbmdsZVx0PSBsZWdGcm9tUHRYICogb3RoZXJQdFkgLSBsZWdGcm9tUHRZICogb3RoZXJQdFg7XG5cblx0XHRcdFx0aWYgKCBNYXRoLmFicyggZnJvbTJ0b0FuZ2xlICkgPiBOdW1iZXIuRVBTSUxPTiApIHtcblxuXHRcdFx0XHRcdC8vIGFuZ2xlICE9IDE4MCBkZWcuXG5cblx0XHRcdFx0XHR2YXIgb3RoZXIydG9BbmdsZVx0XHQ9IG90aGVyUHRYICogbGVnVG9QdFkgLSBvdGhlclB0WSAqIGxlZ1RvUHRYO1xuXHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKCBcImZyb20ydG86IFwiICsgZnJvbTJ0b0FuZ2xlICsgXCIsIGZyb20yb3RoZXI6IFwiICsgZnJvbTJvdGhlckFuZ2xlICsgXCIsIG90aGVyMnRvOiBcIiArIG90aGVyMnRvQW5nbGUgKTtcblxuXHRcdFx0XHRcdGlmICggZnJvbTJ0b0FuZ2xlID4gMCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gbWFpbiBhbmdsZSA8IDE4MCBkZWcuXG5cdFx0XHRcdFx0XHRyZXR1cm5cdCggKCBmcm9tMm90aGVyQW5nbGUgPj0gMCApICYmICggb3RoZXIydG9BbmdsZSA+PSAwICkgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdC8vIG1haW4gYW5nbGUgPiAxODAgZGVnLlxuXHRcdFx0XHRcdFx0cmV0dXJuXHQoICggZnJvbTJvdGhlckFuZ2xlID49IDAgKSB8fCAoIG90aGVyMnRvQW5nbGUgPj0gMCApICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIGFuZ2xlID09IDE4MCBkZWcuXG5cdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coIFwiZnJvbTJ0bzogMTgwIGRlZy4sIGZyb20yb3RoZXI6IFwiICsgZnJvbTJvdGhlckFuZ2xlICApO1xuXHRcdFx0XHRcdHJldHVyblx0KCBmcm9tMm90aGVyQW5nbGUgPiAwICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblxuXHRcdFx0ZnVuY3Rpb24gcmVtb3ZlSG9sZXMoIGNvbnRvdXIsIGhvbGVzICkge1xuXG5cdFx0XHRcdHZhciBzaGFwZSA9IGNvbnRvdXIuY29uY2F0KCk7IC8vIHdvcmsgb24gdGhpcyBzaGFwZVxuXHRcdFx0XHR2YXIgaG9sZTtcblxuXHRcdFx0XHRmdW5jdGlvbiBpc0N1dExpbmVJbnNpZGVBbmdsZXMoIGluU2hhcGVJZHgsIGluSG9sZUlkeCApIHtcblxuXHRcdFx0XHRcdC8vIENoZWNrIGlmIGhvbGUgcG9pbnQgbGllcyB3aXRoaW4gYW5nbGUgYXJvdW5kIHNoYXBlIHBvaW50XG5cdFx0XHRcdFx0dmFyIGxhc3RTaGFwZUlkeCA9IHNoYXBlLmxlbmd0aCAtIDE7XG5cblx0XHRcdFx0XHR2YXIgcHJldlNoYXBlSWR4ID0gaW5TaGFwZUlkeCAtIDE7XG5cdFx0XHRcdFx0aWYgKCBwcmV2U2hhcGVJZHggPCAwIClcdFx0XHRwcmV2U2hhcGVJZHggPSBsYXN0U2hhcGVJZHg7XG5cblx0XHRcdFx0XHR2YXIgbmV4dFNoYXBlSWR4ID0gaW5TaGFwZUlkeCArIDE7XG5cdFx0XHRcdFx0aWYgKCBuZXh0U2hhcGVJZHggPiBsYXN0U2hhcGVJZHggKVx0bmV4dFNoYXBlSWR4ID0gMDtcblxuXHRcdFx0XHRcdHZhciBpbnNpZGVBbmdsZSA9IGlzUG9pbnRJbnNpZGVBbmdsZSggc2hhcGVbIGluU2hhcGVJZHggXSwgc2hhcGVbIHByZXZTaGFwZUlkeCBdLCBzaGFwZVsgbmV4dFNoYXBlSWR4IF0sIGhvbGVbIGluSG9sZUlkeCBdICk7XG5cdFx0XHRcdFx0aWYgKCAhIGluc2lkZUFuZ2xlICkge1xuXG5cdFx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyggXCJWZXJ0ZXggKFNoYXBlKTogXCIgKyBpblNoYXBlSWR4ICsgXCIsIFBvaW50OiBcIiArIGhvbGVbaW5Ib2xlSWR4XS54ICsgXCIvXCIgKyBob2xlW2luSG9sZUlkeF0ueSApO1xuXHRcdFx0XHRcdFx0cmV0dXJuXHRmYWxzZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIENoZWNrIGlmIHNoYXBlIHBvaW50IGxpZXMgd2l0aGluIGFuZ2xlIGFyb3VuZCBob2xlIHBvaW50XG5cdFx0XHRcdFx0dmFyIGxhc3RIb2xlSWR4ID0gaG9sZS5sZW5ndGggLSAxO1xuXG5cdFx0XHRcdFx0dmFyIHByZXZIb2xlSWR4ID0gaW5Ib2xlSWR4IC0gMTtcblx0XHRcdFx0XHRpZiAoIHByZXZIb2xlSWR4IDwgMCApXHRcdFx0cHJldkhvbGVJZHggPSBsYXN0SG9sZUlkeDtcblxuXHRcdFx0XHRcdHZhciBuZXh0SG9sZUlkeCA9IGluSG9sZUlkeCArIDE7XG5cdFx0XHRcdFx0aWYgKCBuZXh0SG9sZUlkeCA+IGxhc3RIb2xlSWR4IClcdG5leHRIb2xlSWR4ID0gMDtcblxuXHRcdFx0XHRcdGluc2lkZUFuZ2xlID0gaXNQb2ludEluc2lkZUFuZ2xlKCBob2xlWyBpbkhvbGVJZHggXSwgaG9sZVsgcHJldkhvbGVJZHggXSwgaG9sZVsgbmV4dEhvbGVJZHggXSwgc2hhcGVbIGluU2hhcGVJZHggXSApO1xuXHRcdFx0XHRcdGlmICggISBpbnNpZGVBbmdsZSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coIFwiVmVydGV4IChIb2xlKTogXCIgKyBpbkhvbGVJZHggKyBcIiwgUG9pbnQ6IFwiICsgc2hhcGVbaW5TaGFwZUlkeF0ueCArIFwiL1wiICsgc2hhcGVbaW5TaGFwZUlkeF0ueSApO1xuXHRcdFx0XHRcdFx0cmV0dXJuXHRmYWxzZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVyblx0dHJ1ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZnVuY3Rpb24gaW50ZXJzZWN0c1NoYXBlRWRnZSggaW5TaGFwZVB0LCBpbkhvbGVQdCApIHtcblxuXHRcdFx0XHRcdC8vIGNoZWNrcyBmb3IgaW50ZXJzZWN0aW9ucyB3aXRoIHNoYXBlIGVkZ2VzXG5cdFx0XHRcdFx0dmFyIHNJZHgsIG5leHRJZHgsIGludGVyc2VjdGlvbjtcblx0XHRcdFx0XHRmb3IgKCBzSWR4ID0gMDsgc0lkeCA8IHNoYXBlLmxlbmd0aDsgc0lkeCArKyApIHtcblxuXHRcdFx0XHRcdFx0bmV4dElkeCA9IHNJZHggKyAxOyBuZXh0SWR4ICU9IHNoYXBlLmxlbmd0aDtcblx0XHRcdFx0XHRcdGludGVyc2VjdGlvbiA9IGludGVyc2VjdF9zZWdtZW50c18yRCggaW5TaGFwZVB0LCBpbkhvbGVQdCwgc2hhcGVbIHNJZHggXSwgc2hhcGVbIG5leHRJZHggXSwgdHJ1ZSApO1xuXHRcdFx0XHRcdFx0aWYgKCBpbnRlcnNlY3Rpb24ubGVuZ3RoID4gMCApXHRcdHJldHVyblx0dHJ1ZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVyblx0ZmFsc2U7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBpbmRlcEhvbGVzID0gW107XG5cblx0XHRcdFx0ZnVuY3Rpb24gaW50ZXJzZWN0c0hvbGVFZGdlKCBpblNoYXBlUHQsIGluSG9sZVB0ICkge1xuXG5cdFx0XHRcdFx0Ly8gY2hlY2tzIGZvciBpbnRlcnNlY3Rpb25zIHdpdGggaG9sZSBlZGdlc1xuXHRcdFx0XHRcdHZhciBpaElkeCwgY2hrSG9sZSxcblx0XHRcdFx0XHRcdGhJZHgsIG5leHRJZHgsIGludGVyc2VjdGlvbjtcblx0XHRcdFx0XHRmb3IgKCBpaElkeCA9IDA7IGloSWR4IDwgaW5kZXBIb2xlcy5sZW5ndGg7IGloSWR4ICsrICkge1xuXG5cdFx0XHRcdFx0XHRjaGtIb2xlID0gaG9sZXNbIGluZGVwSG9sZXNbIGloSWR4IF1dO1xuXHRcdFx0XHRcdFx0Zm9yICggaElkeCA9IDA7IGhJZHggPCBjaGtIb2xlLmxlbmd0aDsgaElkeCArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRuZXh0SWR4ID0gaElkeCArIDE7IG5leHRJZHggJT0gY2hrSG9sZS5sZW5ndGg7XG5cdFx0XHRcdFx0XHRcdGludGVyc2VjdGlvbiA9IGludGVyc2VjdF9zZWdtZW50c18yRCggaW5TaGFwZVB0LCBpbkhvbGVQdCwgY2hrSG9sZVsgaElkeCBdLCBjaGtIb2xlWyBuZXh0SWR4IF0sIHRydWUgKTtcblx0XHRcdFx0XHRcdFx0aWYgKCBpbnRlcnNlY3Rpb24ubGVuZ3RoID4gMCApXHRcdHJldHVyblx0dHJ1ZTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVyblx0ZmFsc2U7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBob2xlSW5kZXgsIHNoYXBlSW5kZXgsXG5cdFx0XHRcdFx0c2hhcGVQdCwgaG9sZVB0LFxuXHRcdFx0XHRcdGhvbGVJZHgsIGN1dEtleSwgZmFpbGVkQ3V0cyA9IFtdLFxuXHRcdFx0XHRcdHRtcFNoYXBlMSwgdG1wU2hhcGUyLFxuXHRcdFx0XHRcdHRtcEhvbGUxLCB0bXBIb2xlMjtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XG5cblx0XHRcdFx0XHRpbmRlcEhvbGVzLnB1c2goIGggKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIG1pblNoYXBlSW5kZXggPSAwO1xuXHRcdFx0XHR2YXIgY291bnRlciA9IGluZGVwSG9sZXMubGVuZ3RoICogMjtcblx0XHRcdFx0d2hpbGUgKCBpbmRlcEhvbGVzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0XHRjb3VudGVyIC0tO1xuXHRcdFx0XHRcdGlmICggY291bnRlciA8IDAgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKCBcIkluZmluaXRlIExvb3AhIEhvbGVzIGxlZnQ6XCIgKyBpbmRlcEhvbGVzLmxlbmd0aCArIFwiLCBQcm9iYWJseSBIb2xlIG91dHNpZGUgU2hhcGUhXCIgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gc2VhcmNoIGZvciBzaGFwZS12ZXJ0ZXggYW5kIGhvbGUtdmVydGV4LFxuXHRcdFx0XHRcdC8vIHdoaWNoIGNhbiBiZSBjb25uZWN0ZWQgd2l0aG91dCBpbnRlcnNlY3Rpb25zXG5cdFx0XHRcdFx0Zm9yICggc2hhcGVJbmRleCA9IG1pblNoYXBlSW5kZXg7IHNoYXBlSW5kZXggPCBzaGFwZS5sZW5ndGg7IHNoYXBlSW5kZXggKysgKSB7XG5cblx0XHRcdFx0XHRcdHNoYXBlUHQgPSBzaGFwZVsgc2hhcGVJbmRleCBdO1xuXHRcdFx0XHRcdFx0aG9sZUluZGV4XHQ9IC0gMTtcblxuXHRcdFx0XHRcdFx0Ly8gc2VhcmNoIGZvciBob2xlIHdoaWNoIGNhbiBiZSByZWFjaGVkIHdpdGhvdXQgaW50ZXJzZWN0aW9uc1xuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGggPSAwOyBoIDwgaW5kZXBIb2xlcy5sZW5ndGg7IGggKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0aG9sZUlkeCA9IGluZGVwSG9sZXNbIGggXTtcblxuXHRcdFx0XHRcdFx0XHQvLyBwcmV2ZW50IG11bHRpcGxlIGNoZWNrc1xuXHRcdFx0XHRcdFx0XHRjdXRLZXkgPSBzaGFwZVB0LnggKyBcIjpcIiArIHNoYXBlUHQueSArIFwiOlwiICsgaG9sZUlkeDtcblx0XHRcdFx0XHRcdFx0aWYgKCBmYWlsZWRDdXRzWyBjdXRLZXkgXSAhPT0gdW5kZWZpbmVkIClcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHRcdFx0XHRob2xlID0gaG9sZXNbIGhvbGVJZHggXTtcblx0XHRcdFx0XHRcdFx0Zm9yICggdmFyIGgyID0gMDsgaDIgPCBob2xlLmxlbmd0aDsgaDIgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRob2xlUHQgPSBob2xlWyBoMiBdO1xuXHRcdFx0XHRcdFx0XHRcdGlmICggISBpc0N1dExpbmVJbnNpZGVBbmdsZXMoIHNoYXBlSW5kZXgsIGgyICkgKVx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGludGVyc2VjdHNTaGFwZUVkZ2UoIHNoYXBlUHQsIGhvbGVQdCApIClcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBpbnRlcnNlY3RzSG9sZUVkZ2UoIHNoYXBlUHQsIGhvbGVQdCApIClcdFx0Y29udGludWU7XG5cblx0XHRcdFx0XHRcdFx0XHRob2xlSW5kZXggPSBoMjtcblx0XHRcdFx0XHRcdFx0XHRpbmRlcEhvbGVzLnNwbGljZSggaCwgMSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0dG1wU2hhcGUxID0gc2hhcGUuc2xpY2UoIDAsIHNoYXBlSW5kZXggKyAxICk7XG5cdFx0XHRcdFx0XHRcdFx0dG1wU2hhcGUyID0gc2hhcGUuc2xpY2UoIHNoYXBlSW5kZXggKTtcblx0XHRcdFx0XHRcdFx0XHR0bXBIb2xlMSA9IGhvbGUuc2xpY2UoIGhvbGVJbmRleCApO1xuXHRcdFx0XHRcdFx0XHRcdHRtcEhvbGUyID0gaG9sZS5zbGljZSggMCwgaG9sZUluZGV4ICsgMSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0c2hhcGUgPSB0bXBTaGFwZTEuY29uY2F0KCB0bXBIb2xlMSApLmNvbmNhdCggdG1wSG9sZTIgKS5jb25jYXQoIHRtcFNoYXBlMiApO1xuXG5cdFx0XHRcdFx0XHRcdFx0bWluU2hhcGVJbmRleCA9IHNoYXBlSW5kZXg7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBEZWJ1ZyBvbmx5LCB0byBzaG93IHRoZSBzZWxlY3RlZCBjdXRzXG5cdFx0XHRcdFx0XHRcdFx0Ly8gZ2xvYl9DdXRMaW5lcy5wdXNoKCBbIHNoYXBlUHQsIGhvbGVQdCBdICk7XG5cblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmICggaG9sZUluZGV4ID49IDAgKVx0YnJlYWs7XHRcdC8vIGhvbGUtdmVydGV4IGZvdW5kXG5cblx0XHRcdFx0XHRcdFx0ZmFpbGVkQ3V0c1sgY3V0S2V5IF0gPSB0cnVlO1x0XHRcdC8vIHJlbWVtYmVyIGZhaWx1cmVcblxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCBob2xlSW5kZXggPj0gMCApXHRicmVhaztcdFx0Ly8gaG9sZS12ZXJ0ZXggZm91bmRcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHNoYXBlOyBcdFx0XHQvKiBzaGFwZSB3aXRoIG5vIGhvbGVzICovXG5cblx0XHRcdH1cblxuXG5cdFx0XHR2YXIgaSwgaWwsIGYsIGZhY2UsXG5cdFx0XHRcdGtleSwgaW5kZXgsXG5cdFx0XHRcdGFsbFBvaW50c01hcCA9IHt9O1xuXG5cdFx0XHQvLyBUbyBtYWludGFpbiByZWZlcmVuY2UgdG8gb2xkIHNoYXBlLCBvbmUgbXVzdCBtYXRjaCBjb29yZGluYXRlcywgb3Igb2Zmc2V0IHRoZSBpbmRpY2VzIGZyb20gb3JpZ2luYWwgYXJyYXlzLiBJdCdzIHByb2JhYmx5IGVhc2llciB0byBkbyB0aGUgZmlyc3QuXG5cblx0XHRcdHZhciBhbGxwb2ludHMgPSBjb250b3VyLmNvbmNhdCgpO1xuXG5cdFx0XHRmb3IgKCB2YXIgaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XG5cblx0XHRcdFx0QXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoIGFsbHBvaW50cywgaG9sZXNbIGggXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vY29uc29sZS5sb2coIFwiYWxscG9pbnRzXCIsYWxscG9pbnRzLCBhbGxwb2ludHMubGVuZ3RoICk7XG5cblx0XHRcdC8vIHByZXBhcmUgYWxsIHBvaW50cyBtYXBcblxuXHRcdFx0Zm9yICggaSA9IDAsIGlsID0gYWxscG9pbnRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdGtleSA9IGFsbHBvaW50c1sgaSBdLnggKyBcIjpcIiArIGFsbHBvaW50c1sgaSBdLnk7XG5cblx0XHRcdFx0aWYgKCBhbGxQb2ludHNNYXBbIGtleSBdICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLndhcm4oIFwiVEhSRUUuU2hhcGU6IER1cGxpY2F0ZSBwb2ludFwiLCBrZXkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0YWxsUG9pbnRzTWFwWyBrZXkgXSA9IGk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gcmVtb3ZlIGhvbGVzIGJ5IGN1dHRpbmcgcGF0aHMgdG8gaG9sZXMgYW5kIGFkZGluZyB0aGVtIHRvIHRoZSBzaGFwZVxuXHRcdFx0dmFyIHNoYXBlV2l0aG91dEhvbGVzID0gcmVtb3ZlSG9sZXMoIGNvbnRvdXIsIGhvbGVzICk7XG5cblx0XHRcdHZhciB0cmlhbmdsZXMgPSBUSFJFRS5TaGFwZVV0aWxzLnRyaWFuZ3VsYXRlKCBzaGFwZVdpdGhvdXRIb2xlcywgZmFsc2UgKTsgLy8gVHJ1ZSByZXR1cm5zIGluZGljZXMgZm9yIHBvaW50cyBvZiBzcG9vbGVkIHNoYXBlXG5cdFx0XHQvL2NvbnNvbGUubG9nKCBcInRyaWFuZ2xlc1wiLHRyaWFuZ2xlcywgdHJpYW5nbGVzLmxlbmd0aCApO1xuXG5cdFx0XHQvLyBjaGVjayBhbGwgZmFjZSB2ZXJ0aWNlcyBhZ2FpbnN0IGFsbCBwb2ludHMgbWFwXG5cblx0XHRcdGZvciAoIGkgPSAwLCBpbCA9IHRyaWFuZ2xlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRmYWNlID0gdHJpYW5nbGVzWyBpIF07XG5cblx0XHRcdFx0Zm9yICggZiA9IDA7IGYgPCAzOyBmICsrICkge1xuXG5cdFx0XHRcdFx0a2V5ID0gZmFjZVsgZiBdLnggKyBcIjpcIiArIGZhY2VbIGYgXS55O1xuXG5cdFx0XHRcdFx0aW5kZXggPSBhbGxQb2ludHNNYXBbIGtleSBdO1xuXG5cdFx0XHRcdFx0aWYgKCBpbmRleCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRmYWNlWyBmIF0gPSBpbmRleDtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRyaWFuZ2xlcy5jb25jYXQoKTtcblxuXHRcdH0sXG5cblx0XHRpc0Nsb2NrV2lzZTogZnVuY3Rpb24gKCBwdHMgKSB7XG5cblx0XHRcdHJldHVybiBUSFJFRS5TaGFwZVV0aWxzLmFyZWEoIHB0cyApIDwgMDtcblxuXHRcdH0sXG5cblx0XHQvLyBCZXppZXIgQ3VydmVzIGZvcm11bGFzIG9idGFpbmVkIGZyb21cblx0XHQvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0IlQzMlQTl6aWVyX2N1cnZlXG5cblx0XHQvLyBRdWFkIEJlemllciBGdW5jdGlvbnNcblxuXHRcdGIyOiAoIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0ZnVuY3Rpb24gYjJwMCggdCwgcCApIHtcblxuXHRcdFx0XHR2YXIgayA9IDEgLSB0O1xuXHRcdFx0XHRyZXR1cm4gayAqIGsgKiBwO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGIycDEoIHQsIHAgKSB7XG5cblx0XHRcdFx0cmV0dXJuIDIgKiAoIDEgLSB0ICkgKiB0ICogcDtcblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBiMnAyKCB0LCBwICkge1xuXG5cdFx0XHRcdHJldHVybiB0ICogdCAqIHA7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uICggdCwgcDAsIHAxLCBwMiApIHtcblxuXHRcdFx0XHRyZXR1cm4gYjJwMCggdCwgcDAgKSArIGIycDEoIHQsIHAxICkgKyBiMnAyKCB0LCBwMiApO1xuXG5cdFx0XHR9O1xuXG5cdFx0fSApKCksXG5cblx0XHQvLyBDdWJpYyBCZXppZXIgRnVuY3Rpb25zXG5cblx0XHRiMzogKCBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGZ1bmN0aW9uIGIzcDAoIHQsIHAgKSB7XG5cblx0XHRcdFx0dmFyIGsgPSAxIC0gdDtcblx0XHRcdFx0cmV0dXJuIGsgKiBrICogayAqIHA7XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gYjNwMSggdCwgcCApIHtcblxuXHRcdFx0XHR2YXIgayA9IDEgLSB0O1xuXHRcdFx0XHRyZXR1cm4gMyAqIGsgKiBrICogdCAqIHA7XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gYjNwMiggdCwgcCApIHtcblxuXHRcdFx0XHR2YXIgayA9IDEgLSB0O1xuXHRcdFx0XHRyZXR1cm4gMyAqIGsgKiB0ICogdCAqIHA7XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gYjNwMyggdCwgcCApIHtcblxuXHRcdFx0XHRyZXR1cm4gdCAqIHQgKiB0ICogcDtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKCB0LCBwMCwgcDEsIHAyLCBwMyApIHtcblxuXHRcdFx0XHRyZXR1cm4gYjNwMCggdCwgcDAgKSArIGIzcDEoIHQsIHAxICkgKyBiM3AyKCB0LCBwMiApICsgYjNwMyggdCwgcDMgKTtcblxuXHRcdFx0fTtcblxuXHRcdH0gKSgpXG5cblx0fTtcblxuXHQvLyBGaWxlOnNyYy9leHRyYXMvYXVkaW8vQXVkaW8uanNcblxuXHQvKipcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICovXG5cblx0VEhSRUUuQXVkaW8gPSBmdW5jdGlvbiAoIGxpc3RlbmVyICkge1xuXG5cdFx0VEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG5cdFx0dGhpcy50eXBlID0gJ0F1ZGlvJztcblxuXHRcdHRoaXMuY29udGV4dCA9IGxpc3RlbmVyLmNvbnRleHQ7XG5cdFx0dGhpcy5zb3VyY2UgPSB0aGlzLmNvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7XG5cdFx0dGhpcy5zb3VyY2Uub25lbmRlZCA9IHRoaXMub25FbmRlZC5iaW5kKCB0aGlzICk7XG5cblx0XHR0aGlzLmdhaW4gPSB0aGlzLmNvbnRleHQuY3JlYXRlR2FpbigpO1xuXHRcdHRoaXMuZ2Fpbi5jb25uZWN0KCB0aGlzLmNvbnRleHQuZGVzdGluYXRpb24gKTtcblxuXHRcdHRoaXMucGFubmVyID0gdGhpcy5jb250ZXh0LmNyZWF0ZVBhbm5lcigpO1xuXHRcdHRoaXMucGFubmVyLmNvbm5lY3QoIHRoaXMuZ2FpbiApO1xuXG5cdFx0dGhpcy5hdXRvcGxheSA9IGZhbHNlO1xuXG5cdFx0dGhpcy5zdGFydFRpbWUgPSAwO1xuXHRcdHRoaXMucGxheWJhY2tSYXRlID0gMTtcblx0XHR0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuXG5cdH07XG5cblx0VEhSRUUuQXVkaW8ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XG5cdFRIUkVFLkF1ZGlvLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkF1ZGlvO1xuXG5cdFRIUkVFLkF1ZGlvLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKCBmaWxlICkge1xuXG5cdFx0dmFyIHNjb3BlID0gdGhpcztcblxuXHRcdHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cdFx0cmVxdWVzdC5vcGVuKCAnR0VUJywgZmlsZSwgdHJ1ZSApO1xuXHRcdHJlcXVlc3QucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcblx0XHRyZXF1ZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uICggZSApIHtcblxuXHRcdFx0c2NvcGUuY29udGV4dC5kZWNvZGVBdWRpb0RhdGEoIHRoaXMucmVzcG9uc2UsIGZ1bmN0aW9uICggYnVmZmVyICkge1xuXG5cdFx0XHRcdHNjb3BlLnNvdXJjZS5idWZmZXIgPSBidWZmZXI7XG5cblx0XHRcdFx0aWYgKCBzY29wZS5hdXRvcGxheSApIHNjb3BlLnBsYXkoKTtcblxuXHRcdFx0fSApO1xuXG5cdFx0fTtcblx0XHRyZXF1ZXN0LnNlbmQoKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0VEhSRUUuQXVkaW8ucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRpZiAoIHRoaXMuaXNQbGF5aW5nID09PSB0cnVlICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5BdWRpbzogQXVkaW8gaXMgYWxyZWFkeSBwbGF5aW5nLicgKTtcblx0XHRcdHJldHVybjtcblxuXHRcdH1cblxuXHRcdHZhciBzb3VyY2UgPSB0aGlzLmNvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7XG5cblx0XHRzb3VyY2UuYnVmZmVyID0gdGhpcy5zb3VyY2UuYnVmZmVyO1xuXHRcdHNvdXJjZS5sb29wID0gdGhpcy5zb3VyY2UubG9vcDtcblx0XHRzb3VyY2Uub25lbmRlZCA9IHRoaXMuc291cmNlLm9uZW5kZWQ7XG5cdFx0c291cmNlLnN0YXJ0KCAwLCB0aGlzLnN0YXJ0VGltZSApO1xuXHRcdHNvdXJjZS5wbGF5YmFja1JhdGUudmFsdWUgPSB0aGlzLnBsYXliYWNrUmF0ZTtcblxuXHRcdHRoaXMuaXNQbGF5aW5nID0gdHJ1ZTtcblxuXHRcdHRoaXMuc291cmNlID0gc291cmNlO1xuXG5cdFx0dGhpcy5jb25uZWN0KCk7XG5cblx0fTtcblxuXHRUSFJFRS5BdWRpby5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLnNvdXJjZS5zdG9wKCk7XG5cdFx0dGhpcy5zdGFydFRpbWUgPSB0aGlzLmNvbnRleHQuY3VycmVudFRpbWU7XG5cblx0fTtcblxuXHRUSFJFRS5BdWRpby5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHRoaXMuc291cmNlLnN0b3AoKTtcblx0XHR0aGlzLnN0YXJ0VGltZSA9IDA7XG5cblx0fTtcblxuXHRUSFJFRS5BdWRpby5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdGlmICggdGhpcy5maWx0ZXIgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0dGhpcy5zb3VyY2UuY29ubmVjdCggdGhpcy5maWx0ZXIgKTtcblx0XHRcdHRoaXMuZmlsdGVyLmNvbm5lY3QoIHRoaXMucGFubmVyICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aGlzLnNvdXJjZS5jb25uZWN0KCB0aGlzLnBhbm5lciApO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0VEhSRUUuQXVkaW8ucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRpZiAoIHRoaXMuZmlsdGVyICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHRoaXMuc291cmNlLmRpc2Nvbm5lY3QoIHRoaXMuZmlsdGVyICk7XG5cdFx0XHR0aGlzLmZpbHRlci5kaXNjb25uZWN0KCB0aGlzLnBhbm5lciApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhpcy5zb3VyY2UuZGlzY29ubmVjdCggdGhpcy5wYW5uZXIgKTtcblxuXHRcdH1cblxuXHR9O1xuXG5cdFRIUkVFLkF1ZGlvLnByb3RvdHlwZS5zZXRGaWx0ZXIgPSBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0aWYgKCB0aGlzLmlzUGxheWluZyA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0dGhpcy5kaXNjb25uZWN0KCk7XG5cdFx0XHR0aGlzLmZpbHRlciA9IHZhbHVlO1xuXHRcdFx0dGhpcy5jb25uZWN0KCk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aGlzLmZpbHRlciA9IHZhbHVlO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0VEhSRUUuQXVkaW8ucHJvdG90eXBlLmdldEZpbHRlciA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiB0aGlzLmZpbHRlcjtcblxuXHR9O1xuXG5cdFRIUkVFLkF1ZGlvLnByb3RvdHlwZS5zZXRQbGF5YmFja1JhdGUgPSBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0dGhpcy5wbGF5YmFja1JhdGUgPSB2YWx1ZTtcblxuXHRcdGlmICggdGhpcy5pc1BsYXlpbmcgPT09IHRydWUgKSB7XG5cblx0XHRcdHRoaXMuc291cmNlLnBsYXliYWNrUmF0ZS52YWx1ZSA9IHRoaXMucGxheWJhY2tSYXRlO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0VEhSRUUuQXVkaW8ucHJvdG90eXBlLmdldFBsYXliYWNrUmF0ZSA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiB0aGlzLnBsYXliYWNrUmF0ZTtcblxuXHR9O1xuXG5cdFRIUkVFLkF1ZGlvLnByb3RvdHlwZS5vbkVuZGVkID0gZnVuY3Rpb24oKSB7XG5cblx0XHR0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuXG5cdH07XG5cblx0VEhSRUUuQXVkaW8ucHJvdG90eXBlLnNldExvb3AgPSBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0dGhpcy5zb3VyY2UubG9vcCA9IHZhbHVlO1xuXG5cdH07XG5cblx0VEhSRUUuQXVkaW8ucHJvdG90eXBlLmdldExvb3AgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5zb3VyY2UubG9vcDtcblxuXHR9O1xuXG5cdFRIUkVFLkF1ZGlvLnByb3RvdHlwZS5zZXRSZWZEaXN0YW5jZSA9IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHR0aGlzLnBhbm5lci5yZWZEaXN0YW5jZSA9IHZhbHVlO1xuXG5cdH07XG5cblx0VEhSRUUuQXVkaW8ucHJvdG90eXBlLmdldFJlZkRpc3RhbmNlID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMucGFubmVyLnJlZkRpc3RhbmNlO1xuXG5cdH07XG5cblx0VEhSRUUuQXVkaW8ucHJvdG90eXBlLnNldFJvbGxvZmZGYWN0b3IgPSBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0dGhpcy5wYW5uZXIucm9sbG9mZkZhY3RvciA9IHZhbHVlO1xuXG5cdH07XG5cblx0VEhSRUUuQXVkaW8ucHJvdG90eXBlLmdldFJvbGxvZmZGYWN0b3IgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5wYW5uZXIucm9sbG9mZkZhY3RvcjtcblxuXHR9O1xuXG5cdFRIUkVFLkF1ZGlvLnByb3RvdHlwZS5zZXRWb2x1bWUgPSBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0dGhpcy5nYWluLmdhaW4udmFsdWUgPSB2YWx1ZTtcblxuXHR9O1xuXG5cdFRIUkVFLkF1ZGlvLnByb3RvdHlwZS5nZXRWb2x1bWUgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5nYWluLmdhaW4udmFsdWU7XG5cblx0fTtcblxuXHRUSFJFRS5BdWRpby5wcm90b3R5cGUudXBkYXRlTWF0cml4V29ybGQgPSAoIGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBwb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlTWF0cml4V29ybGQoIGZvcmNlICkge1xuXG5cdFx0XHRUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUudXBkYXRlTWF0cml4V29ybGQuY2FsbCggdGhpcywgZm9yY2UgKTtcblxuXHRcdFx0cG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLm1hdHJpeFdvcmxkICk7XG5cblx0XHRcdHRoaXMucGFubmVyLnNldFBvc2l0aW9uKCBwb3NpdGlvbi54LCBwb3NpdGlvbi55LCBwb3NpdGlvbi56ICk7XG5cblx0XHR9O1xuXG5cdH0gKSgpO1xuXG5cdC8vIEZpbGU6c3JjL2V4dHJhcy9hdWRpby9BdWRpb0xpc3RlbmVyLmpzXG5cblx0LyoqXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqL1xuXG5cdFRIUkVFLkF1ZGlvTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cblx0XHR0aGlzLnR5cGUgPSAnQXVkaW9MaXN0ZW5lcic7XG5cblx0XHR0aGlzLmNvbnRleHQgPSBuZXcgKCB3aW5kb3cuQXVkaW9Db250ZXh0IHx8IHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQgKSgpO1xuXG5cdH07XG5cblx0VEhSRUUuQXVkaW9MaXN0ZW5lci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblx0VEhSRUUuQXVkaW9MaXN0ZW5lci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5BdWRpb0xpc3RlbmVyO1xuXG5cdFRIUkVFLkF1ZGlvTGlzdGVuZXIucHJvdG90eXBlLnVwZGF0ZU1hdHJpeFdvcmxkID0gKCBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgcG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdHZhciBxdWF0ZXJuaW9uID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcblx0XHR2YXIgc2NhbGUgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0dmFyIG9yaWVudGF0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiB1cGRhdGVNYXRyaXhXb3JsZCggZm9yY2UgKSB7XG5cblx0XHRcdFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS51cGRhdGVNYXRyaXhXb3JsZC5jYWxsKCB0aGlzLCBmb3JjZSApO1xuXG5cdFx0XHR2YXIgbGlzdGVuZXIgPSB0aGlzLmNvbnRleHQubGlzdGVuZXI7XG5cdFx0XHR2YXIgdXAgPSB0aGlzLnVwO1xuXG5cdFx0XHR0aGlzLm1hdHJpeFdvcmxkLmRlY29tcG9zZSggcG9zaXRpb24sIHF1YXRlcm5pb24sIHNjYWxlICk7XG5cblx0XHRcdG9yaWVudGF0aW9uLnNldCggMCwgMCwgLSAxICkuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICk7XG5cblx0XHRcdGxpc3RlbmVyLnNldFBvc2l0aW9uKCBwb3NpdGlvbi54LCBwb3NpdGlvbi55LCBwb3NpdGlvbi56ICk7XG5cdFx0XHRsaXN0ZW5lci5zZXRPcmllbnRhdGlvbiggb3JpZW50YXRpb24ueCwgb3JpZW50YXRpb24ueSwgb3JpZW50YXRpb24ueiwgdXAueCwgdXAueSwgdXAueiApO1xuXG5cdFx0fTtcblxuXHR9ICkoKTtcblxuXHQvLyBGaWxlOnNyYy9leHRyYXMvY29yZS9DdXJ2ZS5qc1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXG5cdCAqIEV4dGVuc2libGUgY3VydmUgb2JqZWN0XG5cdCAqXG5cdCAqIFNvbWUgY29tbW9uIG9mIEN1cnZlIG1ldGhvZHNcblx0ICogLmdldFBvaW50KHQpLCBnZXRUYW5nZW50KHQpXG5cdCAqIC5nZXRQb2ludEF0KHUpLCBnZXRUYWdlbnRBdCh1KVxuXHQgKiAuZ2V0UG9pbnRzKCksIC5nZXRTcGFjZWRQb2ludHMoKVxuXHQgKiAuZ2V0TGVuZ3RoKClcblx0ICogLnVwZGF0ZUFyY0xlbmd0aHMoKVxuXHQgKlxuXHQgKiBUaGlzIGZvbGxvd2luZyBjbGFzc2VzIHN1YmNsYXNzZXMgVEhSRUUuQ3VydmU6XG5cdCAqXG5cdCAqIC0tIDJkIGNsYXNzZXMgLS1cblx0ICogVEhSRUUuTGluZUN1cnZlXG5cdCAqIFRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlXG5cdCAqIFRIUkVFLkN1YmljQmV6aWVyQ3VydmVcblx0ICogVEhSRUUuU3BsaW5lQ3VydmVcblx0ICogVEhSRUUuQXJjQ3VydmVcblx0ICogVEhSRUUuRWxsaXBzZUN1cnZlXG5cdCAqXG5cdCAqIC0tIDNkIGNsYXNzZXMgLS1cblx0ICogVEhSRUUuTGluZUN1cnZlM1xuXHQgKiBUSFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZTNcblx0ICogVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZTNcblx0ICogVEhSRUUuU3BsaW5lQ3VydmUzXG5cdCAqIFRIUkVFLkNsb3NlZFNwbGluZUN1cnZlM1xuXHQgKlxuXHQgKiBBIHNlcmllcyBvZiBjdXJ2ZXMgY2FuIGJlIHJlcHJlc2VudGVkIGFzIGEgVEhSRUUuQ3VydmVQYXRoXG5cdCAqXG5cdCAqKi9cblxuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0ICpcdEFic3RyYWN0IEN1cnZlIGJhc2UgY2xhc3Ncblx0ICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFRIUkVFLkN1cnZlID0gZnVuY3Rpb24gKCkge1xuXG5cdH07XG5cblx0VEhSRUUuQ3VydmUucHJvdG90eXBlID0ge1xuXG5cdFx0Y29uc3RydWN0b3I6IFRIUkVFLkN1cnZlLFxuXG5cdFx0Ly8gVmlydHVhbCBiYXNlIGNsYXNzIG1ldGhvZCB0byBvdmVyd3JpdGUgYW5kIGltcGxlbWVudCBpbiBzdWJjbGFzc2VzXG5cdFx0Ly9cdC0gdCBbMCAuLiAxXVxuXG5cdFx0Z2V0UG9pbnQ6IGZ1bmN0aW9uICggdCApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCBcIlRIUkVFLkN1cnZlOiBXYXJuaW5nLCBnZXRQb2ludCgpIG5vdCBpbXBsZW1lbnRlZCFcIiApO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR9LFxuXG5cdFx0Ly8gR2V0IHBvaW50IGF0IHJlbGF0aXZlIHBvc2l0aW9uIGluIGN1cnZlIGFjY29yZGluZyB0byBhcmMgbGVuZ3RoXG5cdFx0Ly8gLSB1IFswIC4uIDFdXG5cblx0XHRnZXRQb2ludEF0OiBmdW5jdGlvbiAoIHUgKSB7XG5cblx0XHRcdHZhciB0ID0gdGhpcy5nZXRVdG9UbWFwcGluZyggdSApO1xuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0UG9pbnQoIHQgKTtcblxuXHRcdH0sXG5cblx0XHQvLyBHZXQgc2VxdWVuY2Ugb2YgcG9pbnRzIHVzaW5nIGdldFBvaW50KCB0IClcblxuXHRcdGdldFBvaW50czogZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XG5cblx0XHRcdGlmICggISBkaXZpc2lvbnMgKSBkaXZpc2lvbnMgPSA1O1xuXG5cdFx0XHR2YXIgZCwgcHRzID0gW107XG5cblx0XHRcdGZvciAoIGQgPSAwOyBkIDw9IGRpdmlzaW9uczsgZCArKyApIHtcblxuXHRcdFx0XHRwdHMucHVzaCggdGhpcy5nZXRQb2ludCggZCAvIGRpdmlzaW9ucyApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHB0cztcblxuXHRcdH0sXG5cblx0XHQvLyBHZXQgc2VxdWVuY2Ugb2YgcG9pbnRzIHVzaW5nIGdldFBvaW50QXQoIHUgKVxuXG5cdFx0Z2V0U3BhY2VkUG9pbnRzOiBmdW5jdGlvbiAoIGRpdmlzaW9ucyApIHtcblxuXHRcdFx0aWYgKCAhIGRpdmlzaW9ucyApIGRpdmlzaW9ucyA9IDU7XG5cblx0XHRcdHZhciBkLCBwdHMgPSBbXTtcblxuXHRcdFx0Zm9yICggZCA9IDA7IGQgPD0gZGl2aXNpb25zOyBkICsrICkge1xuXG5cdFx0XHRcdHB0cy5wdXNoKCB0aGlzLmdldFBvaW50QXQoIGQgLyBkaXZpc2lvbnMgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBwdHM7XG5cblx0XHR9LFxuXG5cdFx0Ly8gR2V0IHRvdGFsIGN1cnZlIGFyYyBsZW5ndGhcblxuXHRcdGdldExlbmd0aDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgbGVuZ3RocyA9IHRoaXMuZ2V0TGVuZ3RocygpO1xuXHRcdFx0cmV0dXJuIGxlbmd0aHNbIGxlbmd0aHMubGVuZ3RoIC0gMSBdO1xuXG5cdFx0fSxcblxuXHRcdC8vIEdldCBsaXN0IG9mIGN1bXVsYXRpdmUgc2VnbWVudCBsZW5ndGhzXG5cblx0XHRnZXRMZW5ndGhzOiBmdW5jdGlvbiAoIGRpdmlzaW9ucyApIHtcblxuXHRcdFx0aWYgKCAhIGRpdmlzaW9ucyApIGRpdmlzaW9ucyA9ICggdGhpcy5fX2FyY0xlbmd0aERpdmlzaW9ucyApID8gKCB0aGlzLl9fYXJjTGVuZ3RoRGl2aXNpb25zICkgOiAyMDA7XG5cblx0XHRcdGlmICggdGhpcy5jYWNoZUFyY0xlbmd0aHNcblx0XHRcdFx0JiYgKCB0aGlzLmNhY2hlQXJjTGVuZ3Rocy5sZW5ndGggPT09IGRpdmlzaW9ucyArIDEgKVxuXHRcdFx0XHQmJiAhIHRoaXMubmVlZHNVcGRhdGUgKSB7XG5cblx0XHRcdFx0Ly9jb25zb2xlLmxvZyggXCJjYWNoZWRcIiwgdGhpcy5jYWNoZUFyY0xlbmd0aHMgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXMuY2FjaGVBcmNMZW5ndGhzO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMubmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuXHRcdFx0dmFyIGNhY2hlID0gW107XG5cdFx0XHR2YXIgY3VycmVudCwgbGFzdCA9IHRoaXMuZ2V0UG9pbnQoIDAgKTtcblx0XHRcdHZhciBwLCBzdW0gPSAwO1xuXG5cdFx0XHRjYWNoZS5wdXNoKCAwICk7XG5cblx0XHRcdGZvciAoIHAgPSAxOyBwIDw9IGRpdmlzaW9uczsgcCArKyApIHtcblxuXHRcdFx0XHRjdXJyZW50ID0gdGhpcy5nZXRQb2ludCAoIHAgLyBkaXZpc2lvbnMgKTtcblx0XHRcdFx0c3VtICs9IGN1cnJlbnQuZGlzdGFuY2VUbyggbGFzdCApO1xuXHRcdFx0XHRjYWNoZS5wdXNoKCBzdW0gKTtcblx0XHRcdFx0bGFzdCA9IGN1cnJlbnQ7XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5jYWNoZUFyY0xlbmd0aHMgPSBjYWNoZTtcblxuXHRcdFx0cmV0dXJuIGNhY2hlOyAvLyB7IHN1bXM6IGNhY2hlLCBzdW06c3VtIH07IFN1bSBpcyBpbiB0aGUgbGFzdCBlbGVtZW50LlxuXG5cdFx0fSxcblxuXHRcdHVwZGF0ZUFyY0xlbmd0aHM6IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHR0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdHRoaXMuZ2V0TGVuZ3RocygpO1xuXG5cdFx0fSxcblxuXHRcdC8vIEdpdmVuIHUgKCAwIC4uIDEgKSwgZ2V0IGEgdCB0byBmaW5kIHAuIFRoaXMgZ2l2ZXMgeW91IHBvaW50cyB3aGljaCBhcmUgZXF1aWRpc3RhbnRcblxuXHRcdGdldFV0b1RtYXBwaW5nOiBmdW5jdGlvbiAoIHUsIGRpc3RhbmNlICkge1xuXG5cdFx0XHR2YXIgYXJjTGVuZ3RocyA9IHRoaXMuZ2V0TGVuZ3RocygpO1xuXG5cdFx0XHR2YXIgaSA9IDAsIGlsID0gYXJjTGVuZ3Rocy5sZW5ndGg7XG5cblx0XHRcdHZhciB0YXJnZXRBcmNMZW5ndGg7IC8vIFRoZSB0YXJnZXRlZCB1IGRpc3RhbmNlIHZhbHVlIHRvIGdldFxuXG5cdFx0XHRpZiAoIGRpc3RhbmNlICkge1xuXG5cdFx0XHRcdHRhcmdldEFyY0xlbmd0aCA9IGRpc3RhbmNlO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHRhcmdldEFyY0xlbmd0aCA9IHUgKiBhcmNMZW5ndGhzWyBpbCAtIDEgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvL3ZhciB0aW1lID0gRGF0ZS5ub3coKTtcblxuXHRcdFx0Ly8gYmluYXJ5IHNlYXJjaCBmb3IgdGhlIGluZGV4IHdpdGggbGFyZ2VzdCB2YWx1ZSBzbWFsbGVyIHRoYW4gdGFyZ2V0IHUgZGlzdGFuY2VcblxuXHRcdFx0dmFyIGxvdyA9IDAsIGhpZ2ggPSBpbCAtIDEsIGNvbXBhcmlzb247XG5cblx0XHRcdHdoaWxlICggbG93IDw9IGhpZ2ggKSB7XG5cblx0XHRcdFx0aSA9IE1hdGguZmxvb3IoIGxvdyArICggaGlnaCAtIGxvdyApIC8gMiApOyAvLyBsZXNzIGxpa2VseSB0byBvdmVyZmxvdywgdGhvdWdoIHByb2JhYmx5IG5vdCBpc3N1ZSBoZXJlLCBKUyBkb2Vzbid0IHJlYWxseSBoYXZlIGludGVnZXJzLCBhbGwgbnVtYmVycyBhcmUgZmxvYXRzXG5cblx0XHRcdFx0Y29tcGFyaXNvbiA9IGFyY0xlbmd0aHNbIGkgXSAtIHRhcmdldEFyY0xlbmd0aDtcblxuXHRcdFx0XHRpZiAoIGNvbXBhcmlzb24gPCAwICkge1xuXG5cdFx0XHRcdFx0bG93ID0gaSArIDE7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggY29tcGFyaXNvbiA+IDAgKSB7XG5cblx0XHRcdFx0XHRoaWdoID0gaSAtIDE7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGhpZ2ggPSBpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Ly8gRE9ORVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpID0gaGlnaDtcblxuXHRcdFx0Ly9jb25zb2xlLmxvZygnYicgLCBpLCBsb3csIGhpZ2gsIERhdGUubm93KCktIHRpbWUpO1xuXG5cdFx0XHRpZiAoIGFyY0xlbmd0aHNbIGkgXSA9PT0gdGFyZ2V0QXJjTGVuZ3RoICkge1xuXG5cdFx0XHRcdHZhciB0ID0gaSAvICggaWwgLSAxICk7XG5cdFx0XHRcdHJldHVybiB0O1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHdlIGNvdWxkIGdldCBmaW5lciBncmFpbiBhdCBsZW5ndGhzLCBvciB1c2Ugc2ltcGxlIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gcG9pbnRzXG5cblx0XHRcdHZhciBsZW5ndGhCZWZvcmUgPSBhcmNMZW5ndGhzWyBpIF07XG5cdFx0XHR2YXIgbGVuZ3RoQWZ0ZXIgPSBhcmNMZW5ndGhzWyBpICsgMSBdO1xuXG5cdFx0XHR2YXIgc2VnbWVudExlbmd0aCA9IGxlbmd0aEFmdGVyIC0gbGVuZ3RoQmVmb3JlO1xuXG5cdFx0XHQvLyBkZXRlcm1pbmUgd2hlcmUgd2UgYXJlIGJldHdlZW4gdGhlICdiZWZvcmUnIGFuZCAnYWZ0ZXInIHBvaW50c1xuXG5cdFx0XHR2YXIgc2VnbWVudEZyYWN0aW9uID0gKCB0YXJnZXRBcmNMZW5ndGggLSBsZW5ndGhCZWZvcmUgKSAvIHNlZ21lbnRMZW5ndGg7XG5cblx0XHRcdC8vIGFkZCB0aGF0IGZyYWN0aW9uYWwgYW1vdW50IHRvIHRcblxuXHRcdFx0dmFyIHQgPSAoIGkgKyBzZWdtZW50RnJhY3Rpb24gKSAvICggaWwgLSAxICk7XG5cblx0XHRcdHJldHVybiB0O1xuXG5cdFx0fSxcblxuXHRcdC8vIFJldHVybnMgYSB1bml0IHZlY3RvciB0YW5nZW50IGF0IHRcblx0XHQvLyBJbiBjYXNlIGFueSBzdWIgY3VydmUgZG9lcyBub3QgaW1wbGVtZW50IGl0cyB0YW5nZW50IGRlcml2YXRpb24sXG5cdFx0Ly8gMiBwb2ludHMgYSBzbWFsbCBkZWx0YSBhcGFydCB3aWxsIGJlIHVzZWQgdG8gZmluZCBpdHMgZ3JhZGllbnRcblx0XHQvLyB3aGljaCBzZWVtcyB0byBnaXZlIGEgcmVhc29uYWJsZSBhcHByb3hpbWF0aW9uXG5cblx0XHRnZXRUYW5nZW50OiBmdW5jdGlvbiggdCApIHtcblxuXHRcdFx0dmFyIGRlbHRhID0gMC4wMDAxO1xuXHRcdFx0dmFyIHQxID0gdCAtIGRlbHRhO1xuXHRcdFx0dmFyIHQyID0gdCArIGRlbHRhO1xuXG5cdFx0XHQvLyBDYXBwaW5nIGluIGNhc2Ugb2YgZGFuZ2VyXG5cblx0XHRcdGlmICggdDEgPCAwICkgdDEgPSAwO1xuXHRcdFx0aWYgKCB0MiA+IDEgKSB0MiA9IDE7XG5cblx0XHRcdHZhciBwdDEgPSB0aGlzLmdldFBvaW50KCB0MSApO1xuXHRcdFx0dmFyIHB0MiA9IHRoaXMuZ2V0UG9pbnQoIHQyICk7XG5cblx0XHRcdHZhciB2ZWMgPSBwdDIuY2xvbmUoKS5zdWIoIHB0MSApO1xuXHRcdFx0cmV0dXJuIHZlYy5ub3JtYWxpemUoKTtcblxuXHRcdH0sXG5cblx0XHRnZXRUYW5nZW50QXQ6IGZ1bmN0aW9uICggdSApIHtcblxuXHRcdFx0dmFyIHQgPSB0aGlzLmdldFV0b1RtYXBwaW5nKCB1ICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRUYW5nZW50KCB0ICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdFRIUkVFLkN1cnZlLlV0aWxzID0gVEhSRUUuQ3VydmVVdGlsczsgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblxuXHQvLyBUT0RPOiBUcmFuc2Zvcm1hdGlvbiBmb3IgQ3VydmVzP1xuXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHQgKlx0M0QgQ3VydmVzXG5cdCAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXHQvLyBBIEZhY3RvcnkgbWV0aG9kIGZvciBjcmVhdGluZyBuZXcgY3VydmUgc3ViY2xhc3Nlc1xuXG5cdFRIUkVFLkN1cnZlLmNyZWF0ZSA9IGZ1bmN0aW9uICggY29uc3RydWN0b3IsIGdldFBvaW50RnVuYyApIHtcblxuXHRcdGNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkN1cnZlLnByb3RvdHlwZSApO1xuXHRcdGNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGNvbnN0cnVjdG9yO1xuXHRcdGNvbnN0cnVjdG9yLnByb3RvdHlwZS5nZXRQb2ludCA9IGdldFBvaW50RnVuYztcblxuXHRcdHJldHVybiBjb25zdHJ1Y3RvcjtcblxuXHR9O1xuXG5cdC8vIEZpbGU6c3JjL2V4dHJhcy9jb3JlL0N1cnZlUGF0aC5qc1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXG5cdCAqXG5cdCAqKi9cblxuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0ICpcdEN1cnZlZCBQYXRoIC0gYSBjdXJ2ZSBwYXRoIGlzIHNpbXBseSBhIGFycmF5IG9mIGNvbm5lY3RlZFxuXHQgKiAgY3VydmVzLCBidXQgcmV0YWlucyB0aGUgYXBpIG9mIGEgY3VydmVcblx0ICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFRIUkVFLkN1cnZlUGF0aCA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHRoaXMuY3VydmVzID0gW107XG5cblx0XHR0aGlzLmF1dG9DbG9zZSA9IGZhbHNlOyAvLyBBdXRvbWF0aWNhbGx5IGNsb3NlcyB0aGUgcGF0aFxuXG5cdH07XG5cblx0VEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkN1cnZlLnByb3RvdHlwZSApO1xuXHRUSFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQ3VydmVQYXRoO1xuXG5cdFRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKCBjdXJ2ZSApIHtcblxuXHRcdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XG5cblx0fTtcblxuXHQvKlxuXHRUSFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmNoZWNrQ29ubmVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuXHRcdC8vIFRPRE9cblx0XHQvLyBJZiB0aGUgZW5kaW5nIG9mIGN1cnZlIGlzIG5vdCBjb25uZWN0ZWQgdG8gdGhlIHN0YXJ0aW5nXG5cdFx0Ly8gb3IgdGhlIG5leHQgY3VydmUsIHRoZW4sIHRoaXMgaXMgbm90IGEgcmVhbCBwYXRoXG5cdH07XG5cdCovXG5cblx0VEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5jbG9zZVBhdGggPSBmdW5jdGlvbigpIHtcblxuXHRcdC8vIFRPRE8gVGVzdFxuXHRcdC8vIGFuZCB2ZXJpZnkgZm9yIHZlY3RvcjMgKG5lZWRzIHRvIGltcGxlbWVudCBlcXVhbHMpXG5cdFx0Ly8gQWRkIGEgbGluZSBjdXJ2ZSBpZiBzdGFydCBhbmQgZW5kIG9mIGxpbmVzIGFyZSBub3QgY29ubmVjdGVkXG5cdFx0dmFyIHN0YXJ0UG9pbnQgPSB0aGlzLmN1cnZlc1sgMCBdLmdldFBvaW50KCAwICk7XG5cdFx0dmFyIGVuZFBvaW50ID0gdGhpcy5jdXJ2ZXNbIHRoaXMuY3VydmVzLmxlbmd0aCAtIDEgXS5nZXRQb2ludCggMSApO1xuXG5cdFx0aWYgKCAhIHN0YXJ0UG9pbnQuZXF1YWxzKCBlbmRQb2ludCApICkge1xuXG5cdFx0XHR0aGlzLmN1cnZlcy5wdXNoKCBuZXcgVEhSRUUuTGluZUN1cnZlKCBlbmRQb2ludCwgc3RhcnRQb2ludCApICk7XG5cblx0XHR9XG5cblx0fTtcblxuXHQvLyBUbyBnZXQgYWNjdXJhdGUgcG9pbnQgd2l0aCByZWZlcmVuY2UgdG9cblx0Ly8gZW50aXJlIHBhdGggZGlzdGFuY2UgYXQgdGltZSB0LFxuXHQvLyBmb2xsb3dpbmcgaGFzIHRvIGJlIGRvbmU6XG5cblx0Ly8gMS4gTGVuZ3RoIG9mIGVhY2ggc3ViIHBhdGggaGF2ZSB0byBiZSBrbm93blxuXHQvLyAyLiBMb2NhdGUgYW5kIGlkZW50aWZ5IHR5cGUgb2YgY3VydmVcblx0Ly8gMy4gR2V0IHQgZm9yIHRoZSBjdXJ2ZVxuXHQvLyA0LiBSZXR1cm4gY3VydmUuZ2V0UG9pbnRBdCh0JylcblxuXHRUSFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24oIHQgKSB7XG5cblx0XHR2YXIgZCA9IHQgKiB0aGlzLmdldExlbmd0aCgpO1xuXHRcdHZhciBjdXJ2ZUxlbmd0aHMgPSB0aGlzLmdldEN1cnZlTGVuZ3RocygpO1xuXHRcdHZhciBpID0gMDtcblxuXHRcdC8vIFRvIHRoaW5rIGFib3V0IGJvdW5kYXJpZXMgcG9pbnRzLlxuXG5cdFx0d2hpbGUgKCBpIDwgY3VydmVMZW5ndGhzLmxlbmd0aCApIHtcblxuXHRcdFx0aWYgKCBjdXJ2ZUxlbmd0aHNbIGkgXSA+PSBkICkge1xuXG5cdFx0XHRcdHZhciBkaWZmID0gY3VydmVMZW5ndGhzWyBpIF0gLSBkO1xuXHRcdFx0XHR2YXIgY3VydmUgPSB0aGlzLmN1cnZlc1sgaSBdO1xuXG5cdFx0XHRcdHZhciB1ID0gMSAtIGRpZmYgLyBjdXJ2ZS5nZXRMZW5ndGgoKTtcblxuXHRcdFx0XHRyZXR1cm4gY3VydmUuZ2V0UG9pbnRBdCggdSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGkgKys7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdC8vIGxvb3Agd2hlcmUgc3VtICE9IDAsIHN1bSA+IGQgLCBzdW0rMSA8ZFxuXG5cdH07XG5cblx0Lypcblx0VEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5nZXRUYW5nZW50ID0gZnVuY3Rpb24oIHQgKSB7XG5cdH07XG5cdCovXG5cblx0Ly8gV2UgY2Fubm90IHVzZSB0aGUgZGVmYXVsdCBUSFJFRS5DdXJ2ZSBnZXRQb2ludCgpIHdpdGggZ2V0TGVuZ3RoKCkgYmVjYXVzZSBpblxuXHQvLyBUSFJFRS5DdXJ2ZSwgZ2V0TGVuZ3RoKCkgZGVwZW5kcyBvbiBnZXRQb2ludCgpIGJ1dCBpbiBUSFJFRS5DdXJ2ZVBhdGhcblx0Ly8gZ2V0UG9pbnQoKSBkZXBlbmRzIG9uIGdldExlbmd0aFxuXG5cdFRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuZ2V0TGVuZ3RoID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgbGVucyA9IHRoaXMuZ2V0Q3VydmVMZW5ndGhzKCk7XG5cdFx0cmV0dXJuIGxlbnNbIGxlbnMubGVuZ3RoIC0gMSBdO1xuXG5cdH07XG5cblx0Ly8gQ29tcHV0ZSBsZW5ndGhzIGFuZCBjYWNoZSB0aGVtXG5cdC8vIFdlIGNhbm5vdCBvdmVyd3JpdGUgZ2V0TGVuZ3RocygpIGJlY2F1c2UgVXRvVCBtYXBwaW5nIHVzZXMgaXQuXG5cblx0VEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5nZXRDdXJ2ZUxlbmd0aHMgPSBmdW5jdGlvbigpIHtcblxuXHRcdC8vIFdlIHVzZSBjYWNoZSB2YWx1ZXMgaWYgY3VydmVzIGFuZCBjYWNoZSBhcnJheSBhcmUgc2FtZSBsZW5ndGhcblxuXHRcdGlmICggdGhpcy5jYWNoZUxlbmd0aHMgJiYgdGhpcy5jYWNoZUxlbmd0aHMubGVuZ3RoID09PSB0aGlzLmN1cnZlcy5sZW5ndGggKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLmNhY2hlTGVuZ3RocztcblxuXHRcdH1cblxuXHRcdC8vIEdldCBsZW5ndGggb2Ygc3ViLWN1cnZlXG5cdFx0Ly8gUHVzaCBzdW1zIGludG8gY2FjaGVkIGFycmF5XG5cblx0XHR2YXIgbGVuZ3RocyA9IFtdLCBzdW1zID0gMDtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdHN1bXMgKz0gdGhpcy5jdXJ2ZXNbIGkgXS5nZXRMZW5ndGgoKTtcblx0XHRcdGxlbmd0aHMucHVzaCggc3VtcyApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5jYWNoZUxlbmd0aHMgPSBsZW5ndGhzO1xuXG5cdFx0cmV0dXJuIGxlbmd0aHM7XG5cblx0fTtcblxuXG5cblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdCAqXHRDcmVhdGUgR2VvbWV0cmllcyBIZWxwZXJzXG5cdCAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXHQvLy8gR2VuZXJhdGUgZ2VvbWV0cnkgZnJvbSBwYXRoIHBvaW50cyAoZm9yIExpbmUgb3IgUG9pbnRzIG9iamVjdHMpXG5cblx0VEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5jcmVhdGVQb2ludHNHZW9tZXRyeSA9IGZ1bmN0aW9uKCBkaXZpc2lvbnMgKSB7XG5cblx0XHR2YXIgcHRzID0gdGhpcy5nZXRQb2ludHMoIGRpdmlzaW9ucywgdHJ1ZSApO1xuXHRcdHJldHVybiB0aGlzLmNyZWF0ZUdlb21ldHJ5KCBwdHMgKTtcblxuXHR9O1xuXG5cdC8vIEdlbmVyYXRlIGdlb21ldHJ5IGZyb20gZXF1aWRpc3RhbnQgc2FtcGxpbmcgYWxvbmcgdGhlIHBhdGhcblxuXHRUSFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmNyZWF0ZVNwYWNlZFBvaW50c0dlb21ldHJ5ID0gZnVuY3Rpb24oIGRpdmlzaW9ucyApIHtcblxuXHRcdHZhciBwdHMgPSB0aGlzLmdldFNwYWNlZFBvaW50cyggZGl2aXNpb25zLCB0cnVlICk7XG5cdFx0cmV0dXJuIHRoaXMuY3JlYXRlR2VvbWV0cnkoIHB0cyApO1xuXG5cdH07XG5cblx0VEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5jcmVhdGVHZW9tZXRyeSA9IGZ1bmN0aW9uKCBwb2ludHMgKSB7XG5cblx0XHR2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHR2YXIgcG9pbnQgPSBwb2ludHNbIGkgXTtcblx0XHRcdGdlb21ldHJ5LnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCBwb2ludC54LCBwb2ludC55LCBwb2ludC56IHx8IDAgKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGdlb21ldHJ5O1xuXG5cdH07XG5cblx0Ly8gRmlsZTpzcmMvZXh0cmFzL2NvcmUvUGF0aC5qc1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXG5cdCAqIENyZWF0ZXMgZnJlZSBmb3JtIDJkIHBhdGggdXNpbmcgc2VyaWVzIG9mIHBvaW50cywgbGluZXMgb3IgY3VydmVzLlxuXHQgKlxuXHQgKiovXG5cblx0VEhSRUUuUGF0aCA9IGZ1bmN0aW9uICggcG9pbnRzICkge1xuXG5cdFx0VEhSRUUuQ3VydmVQYXRoLmNhbGwoIHRoaXMgKTtcblxuXHRcdHRoaXMuYWN0aW9ucyA9IFtdO1xuXG5cdFx0aWYgKCBwb2ludHMgKSB7XG5cblx0XHRcdHRoaXMuZnJvbVBvaW50cyggcG9pbnRzICk7XG5cblx0XHR9XG5cblx0fTtcblxuXHRUSFJFRS5QYXRoLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUgKTtcblx0VEhSRUUuUGF0aC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5QYXRoO1xuXG5cdC8vIFRPRE8gQ2xlYW4gdXAgUEFUSCBBUElcblxuXHQvLyBDcmVhdGUgcGF0aCB1c2luZyBzdHJhaWdodCBsaW5lcyB0byBjb25uZWN0IGFsbCBwb2ludHNcblx0Ly8gLSB2ZWN0b3JzOiBhcnJheSBvZiBWZWN0b3IyXG5cblx0VEhSRUUuUGF0aC5wcm90b3R5cGUuZnJvbVBvaW50cyA9IGZ1bmN0aW9uICggdmVjdG9ycyApIHtcblxuXHRcdHRoaXMubW92ZVRvKCB2ZWN0b3JzWyAwIF0ueCwgdmVjdG9yc1sgMCBdLnkgKTtcblxuXHRcdGZvciAoIHZhciBpID0gMSwgbCA9IHZlY3RvcnMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0dGhpcy5saW5lVG8oIHZlY3RvcnNbIGkgXS54LCB2ZWN0b3JzWyBpIF0ueSApO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0Ly8gc3RhcnRQYXRoKCkgZW5kUGF0aCgpP1xuXG5cdFRIUkVFLlBhdGgucHJvdG90eXBlLm1vdmVUbyA9IGZ1bmN0aW9uICggeCwgeSApIHtcblxuXHRcdHRoaXMuYWN0aW9ucy5wdXNoKCB7IGFjdGlvbjogJ21vdmVUbycsIGFyZ3M6IFsgeCwgeSBdIH0gKTtcblxuXHR9O1xuXG5cdFRIUkVFLlBhdGgucHJvdG90eXBlLmxpbmVUbyA9IGZ1bmN0aW9uICggeCwgeSApIHtcblxuXHRcdHZhciBsYXN0YXJncyA9IHRoaXMuYWN0aW9uc1sgdGhpcy5hY3Rpb25zLmxlbmd0aCAtIDEgXS5hcmdzO1xuXG5cdFx0dmFyIHgwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDIgXTtcblx0XHR2YXIgeTAgPSBsYXN0YXJnc1sgbGFzdGFyZ3MubGVuZ3RoIC0gMSBdO1xuXG5cdFx0dmFyIGN1cnZlID0gbmV3IFRIUkVFLkxpbmVDdXJ2ZSggbmV3IFRIUkVFLlZlY3RvcjIoIHgwLCB5MCApLCBuZXcgVEhSRUUuVmVjdG9yMiggeCwgeSApICk7XG5cdFx0dGhpcy5jdXJ2ZXMucHVzaCggY3VydmUgKTtcblxuXHRcdHRoaXMuYWN0aW9ucy5wdXNoKCB7IGFjdGlvbjogJ2xpbmVUbycsIGFyZ3M6IFsgeCwgeSBdIH0gKTtcblxuXHR9O1xuXG5cdFRIUkVFLlBhdGgucHJvdG90eXBlLnF1YWRyYXRpY0N1cnZlVG8gPSBmdW5jdGlvbiggYUNQeCwgYUNQeSwgYVgsIGFZICkge1xuXG5cdFx0dmFyIGxhc3RhcmdzID0gdGhpcy5hY3Rpb25zWyB0aGlzLmFjdGlvbnMubGVuZ3RoIC0gMSBdLmFyZ3M7XG5cblx0XHR2YXIgeDAgPSBsYXN0YXJnc1sgbGFzdGFyZ3MubGVuZ3RoIC0gMiBdO1xuXHRcdHZhciB5MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAxIF07XG5cblx0XHR2YXIgY3VydmUgPSBuZXcgVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmUoXG5cdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggeDAsIHkwICksXG5cdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggYUNQeCwgYUNQeSApLFxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIGFYLCBhWSApXG5cdFx0KTtcblxuXHRcdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XG5cblx0XHR0aGlzLmFjdGlvbnMucHVzaCggeyBhY3Rpb246ICdxdWFkcmF0aWNDdXJ2ZVRvJywgYXJnczogWyBhQ1B4LCBhQ1B5LCBhWCwgYVkgXSB9ICk7XG5cblx0fTtcblxuXHRUSFJFRS5QYXRoLnByb3RvdHlwZS5iZXppZXJDdXJ2ZVRvID0gZnVuY3Rpb24oIGFDUDF4LCBhQ1AxeSwgYUNQMngsIGFDUDJ5LCBhWCwgYVkgKSB7XG5cblx0XHR2YXIgbGFzdGFyZ3MgPSB0aGlzLmFjdGlvbnNbIHRoaXMuYWN0aW9ucy5sZW5ndGggLSAxIF0uYXJncztcblxuXHRcdHZhciB4MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAyIF07XG5cdFx0dmFyIHkwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDEgXTtcblxuXHRcdHZhciBjdXJ2ZSA9IG5ldyBUSFJFRS5DdWJpY0JlemllckN1cnZlKFxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIHgwLCB5MCApLFxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIGFDUDF4LCBhQ1AxeSApLFxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIGFDUDJ4LCBhQ1AyeSApLFxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIGFYLCBhWSApXG5cdFx0KTtcblxuXHRcdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XG5cblx0XHR0aGlzLmFjdGlvbnMucHVzaCggeyBhY3Rpb246ICdiZXppZXJDdXJ2ZVRvJywgYXJnczogWyBhQ1AxeCwgYUNQMXksIGFDUDJ4LCBhQ1AyeSwgYVgsIGFZIF0gfSApO1xuXG5cdH07XG5cblx0VEhSRUUuUGF0aC5wcm90b3R5cGUuc3BsaW5lVGhydSA9IGZ1bmN0aW9uKCBwdHMgLypBcnJheSBvZiBWZWN0b3IqLyApIHtcblxuXHRcdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGFyZ3VtZW50cyApO1xuXG5cdFx0dmFyIGxhc3RhcmdzID0gdGhpcy5hY3Rpb25zWyB0aGlzLmFjdGlvbnMubGVuZ3RoIC0gMSBdLmFyZ3M7XG5cblx0XHR2YXIgeDAgPSBsYXN0YXJnc1sgbGFzdGFyZ3MubGVuZ3RoIC0gMiBdO1xuXHRcdHZhciB5MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAxIF07XG5cblx0XHR2YXIgbnB0cyA9IFsgbmV3IFRIUkVFLlZlY3RvcjIoIHgwLCB5MCApIF07XG5cdFx0QXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoIG5wdHMsIHB0cyApO1xuXG5cdFx0dmFyIGN1cnZlID0gbmV3IFRIUkVFLlNwbGluZUN1cnZlKCBucHRzICk7XG5cdFx0dGhpcy5jdXJ2ZXMucHVzaCggY3VydmUgKTtcblxuXHRcdHRoaXMuYWN0aW9ucy5wdXNoKCB7IGFjdGlvbjogJ3NwbGluZVRocnUnLCBhcmdzOiBhcmdzIH0gKTtcblxuXHR9O1xuXG5cdC8vIEZVVFVSRTogQ2hhbmdlIHRoZSBBUEkgb3IgZm9sbG93IGNhbnZhcyBBUEk/XG5cblx0VEhSRUUuUGF0aC5wcm90b3R5cGUuYXJjID0gZnVuY3Rpb24gKCBhWCwgYVksIGFSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKSB7XG5cblx0XHR2YXIgbGFzdGFyZ3MgPSB0aGlzLmFjdGlvbnNbIHRoaXMuYWN0aW9ucy5sZW5ndGggLSAxIF0uYXJncztcblx0XHR2YXIgeDAgPSBsYXN0YXJnc1sgbGFzdGFyZ3MubGVuZ3RoIC0gMiBdO1xuXHRcdHZhciB5MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAxIF07XG5cblx0XHR0aGlzLmFic2FyYyggYVggKyB4MCwgYVkgKyB5MCwgYVJhZGl1cyxcblx0XHRcdGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKTtcblxuXHQgfTtcblxuXHQgVEhSRUUuUGF0aC5wcm90b3R5cGUuYWJzYXJjID0gZnVuY3Rpb24gKCBhWCwgYVksIGFSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKSB7XG5cblx0XHR0aGlzLmFic2VsbGlwc2UoIGFYLCBhWSwgYVJhZGl1cywgYVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApO1xuXG5cdCB9O1xuXG5cdFRIUkVFLlBhdGgucHJvdG90eXBlLmVsbGlwc2UgPSBmdW5jdGlvbiAoIGFYLCBhWSwgeFJhZGl1cywgeVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSwgYVJvdGF0aW9uICkge1xuXG5cdFx0dmFyIGxhc3RhcmdzID0gdGhpcy5hY3Rpb25zWyB0aGlzLmFjdGlvbnMubGVuZ3RoIC0gMSBdLmFyZ3M7XG5cdFx0dmFyIHgwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDIgXTtcblx0XHR2YXIgeTAgPSBsYXN0YXJnc1sgbGFzdGFyZ3MubGVuZ3RoIC0gMSBdO1xuXG5cdFx0dGhpcy5hYnNlbGxpcHNlKCBhWCArIHgwLCBhWSArIHkwLCB4UmFkaXVzLCB5UmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlLCBhUm90YXRpb24gKTtcblxuXHQgfTtcblxuXG5cdFRIUkVFLlBhdGgucHJvdG90eXBlLmFic2VsbGlwc2UgPSBmdW5jdGlvbiAoIGFYLCBhWSwgeFJhZGl1cywgeVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSwgYVJvdGF0aW9uICkge1xuXG5cdFx0dmFyIGFyZ3MgPSBbXG5cdFx0XHRhWCwgYVksXG5cdFx0XHR4UmFkaXVzLCB5UmFkaXVzLFxuXHRcdFx0YVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSxcblx0XHRcdGFDbG9ja3dpc2UsXG5cdFx0XHRhUm90YXRpb24gfHwgMCAvLyBhUm90YXRpb24gaXMgb3B0aW9uYWwuXG5cdFx0XTtcblxuXHRcdHZhciBjdXJ2ZSA9IG5ldyBUSFJFRS5FbGxpcHNlQ3VydmUoIGFYLCBhWSwgeFJhZGl1cywgeVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSwgYVJvdGF0aW9uICk7XG5cdFx0dGhpcy5jdXJ2ZXMucHVzaCggY3VydmUgKTtcblxuXHRcdHZhciBsYXN0UG9pbnQgPSBjdXJ2ZS5nZXRQb2ludCggMSApO1xuXHRcdGFyZ3MucHVzaCggbGFzdFBvaW50LnggKTtcblx0XHRhcmdzLnB1c2goIGxhc3RQb2ludC55ICk7XG5cblx0XHR0aGlzLmFjdGlvbnMucHVzaCggeyBhY3Rpb246ICdlbGxpcHNlJywgYXJnczogYXJncyB9ICk7XG5cblx0IH07XG5cblx0VEhSRUUuUGF0aC5wcm90b3R5cGUuZ2V0U3BhY2VkUG9pbnRzID0gZnVuY3Rpb24gKCBkaXZpc2lvbnMsIGNsb3NlZFBhdGggKSB7XG5cblx0XHRpZiAoICEgZGl2aXNpb25zICkgZGl2aXNpb25zID0gNDA7XG5cblx0XHR2YXIgcG9pbnRzID0gW107XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBkaXZpc2lvbnM7IGkgKysgKSB7XG5cblx0XHRcdHBvaW50cy5wdXNoKCB0aGlzLmdldFBvaW50KCBpIC8gZGl2aXNpb25zICkgKTtcblxuXHRcdFx0Ly9pZiAoICF0aGlzLmdldFBvaW50KCBpIC8gZGl2aXNpb25zICkgKSB0aHJvdyBcIkRJRVwiO1xuXG5cdFx0fVxuXG5cdFx0Ly8gaWYgKCBjbG9zZWRQYXRoICkge1xuXHRcdC8vXG5cdFx0Ly8gXHRwb2ludHMucHVzaCggcG9pbnRzWyAwIF0gKTtcblx0XHQvL1xuXHRcdC8vIH1cblxuXHRcdHJldHVybiBwb2ludHM7XG5cblx0fTtcblxuXHQvKiBSZXR1cm4gYW4gYXJyYXkgb2YgdmVjdG9ycyBiYXNlZCBvbiBjb250b3VyIG9mIHRoZSBwYXRoICovXG5cblx0VEhSRUUuUGF0aC5wcm90b3R5cGUuZ2V0UG9pbnRzID0gZnVuY3Rpb24oIGRpdmlzaW9ucywgY2xvc2VkUGF0aCApIHtcblxuXHRcdGRpdmlzaW9ucyA9IGRpdmlzaW9ucyB8fCAxMjtcblxuXHRcdHZhciBiMiA9IFRIUkVFLlNoYXBlVXRpbHMuYjI7XG5cdFx0dmFyIGIzID0gVEhSRUUuU2hhcGVVdGlscy5iMztcblxuXHRcdHZhciBwb2ludHMgPSBbXTtcblxuXHRcdHZhciBjcHgsIGNweSwgY3B4MiwgY3B5MiwgY3B4MSwgY3B5MSwgY3B4MCwgY3B5MCxcblx0XHRcdGxhc3RlLCB0eCwgdHk7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLmFjdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0dmFyIGl0ZW0gPSB0aGlzLmFjdGlvbnNbIGkgXTtcblxuXHRcdFx0dmFyIGFjdGlvbiA9IGl0ZW0uYWN0aW9uO1xuXHRcdFx0dmFyIGFyZ3MgPSBpdGVtLmFyZ3M7XG5cblx0XHRcdHN3aXRjaCAoIGFjdGlvbiApIHtcblxuXHRcdFx0Y2FzZSAnbW92ZVRvJzpcblxuXHRcdFx0XHRwb2ludHMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoIGFyZ3NbIDAgXSwgYXJnc1sgMSBdICkgKTtcblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnbGluZVRvJzpcblxuXHRcdFx0XHRwb2ludHMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoIGFyZ3NbIDAgXSwgYXJnc1sgMSBdICkgKTtcblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAncXVhZHJhdGljQ3VydmVUbyc6XG5cblx0XHRcdFx0Y3B4ICA9IGFyZ3NbIDIgXTtcblx0XHRcdFx0Y3B5ICA9IGFyZ3NbIDMgXTtcblxuXHRcdFx0XHRjcHgxID0gYXJnc1sgMCBdO1xuXHRcdFx0XHRjcHkxID0gYXJnc1sgMSBdO1xuXG5cdFx0XHRcdGlmICggcG9pbnRzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0XHRsYXN0ZSA9IHBvaW50c1sgcG9pbnRzLmxlbmd0aCAtIDEgXTtcblxuXHRcdFx0XHRcdGNweDAgPSBsYXN0ZS54O1xuXHRcdFx0XHRcdGNweTAgPSBsYXN0ZS55O1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRsYXN0ZSA9IHRoaXMuYWN0aW9uc1sgaSAtIDEgXS5hcmdzO1xuXG5cdFx0XHRcdFx0Y3B4MCA9IGxhc3RlWyBsYXN0ZS5sZW5ndGggLSAyIF07XG5cdFx0XHRcdFx0Y3B5MCA9IGxhc3RlWyBsYXN0ZS5sZW5ndGggLSAxIF07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZvciAoIHZhciBqID0gMTsgaiA8PSBkaXZpc2lvbnM7IGogKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgdCA9IGogLyBkaXZpc2lvbnM7XG5cblx0XHRcdFx0XHR0eCA9IGIyKCB0LCBjcHgwLCBjcHgxLCBjcHggKTtcblx0XHRcdFx0XHR0eSA9IGIyKCB0LCBjcHkwLCBjcHkxLCBjcHkgKTtcblxuXHRcdFx0XHRcdHBvaW50cy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggdHgsIHR5ICkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ2JlemllckN1cnZlVG8nOlxuXG5cdFx0XHRcdGNweCAgPSBhcmdzWyA0IF07XG5cdFx0XHRcdGNweSAgPSBhcmdzWyA1IF07XG5cblx0XHRcdFx0Y3B4MSA9IGFyZ3NbIDAgXTtcblx0XHRcdFx0Y3B5MSA9IGFyZ3NbIDEgXTtcblxuXHRcdFx0XHRjcHgyID0gYXJnc1sgMiBdO1xuXHRcdFx0XHRjcHkyID0gYXJnc1sgMyBdO1xuXG5cdFx0XHRcdGlmICggcG9pbnRzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0XHRsYXN0ZSA9IHBvaW50c1sgcG9pbnRzLmxlbmd0aCAtIDEgXTtcblxuXHRcdFx0XHRcdGNweDAgPSBsYXN0ZS54O1xuXHRcdFx0XHRcdGNweTAgPSBsYXN0ZS55O1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRsYXN0ZSA9IHRoaXMuYWN0aW9uc1sgaSAtIDEgXS5hcmdzO1xuXG5cdFx0XHRcdFx0Y3B4MCA9IGxhc3RlWyBsYXN0ZS5sZW5ndGggLSAyIF07XG5cdFx0XHRcdFx0Y3B5MCA9IGxhc3RlWyBsYXN0ZS5sZW5ndGggLSAxIF07XG5cblx0XHRcdFx0fVxuXG5cblx0XHRcdFx0Zm9yICggdmFyIGogPSAxOyBqIDw9IGRpdmlzaW9uczsgaiArKyApIHtcblxuXHRcdFx0XHRcdHZhciB0ID0gaiAvIGRpdmlzaW9ucztcblxuXHRcdFx0XHRcdHR4ID0gYjMoIHQsIGNweDAsIGNweDEsIGNweDIsIGNweCApO1xuXHRcdFx0XHRcdHR5ID0gYjMoIHQsIGNweTAsIGNweTEsIGNweTIsIGNweSApO1xuXG5cdFx0XHRcdFx0cG9pbnRzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCB0eCwgdHkgKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnc3BsaW5lVGhydSc6XG5cblx0XHRcdFx0bGFzdGUgPSB0aGlzLmFjdGlvbnNbIGkgLSAxIF0uYXJncztcblxuXHRcdFx0XHR2YXIgbGFzdCA9IG5ldyBUSFJFRS5WZWN0b3IyKCBsYXN0ZVsgbGFzdGUubGVuZ3RoIC0gMiBdLCBsYXN0ZVsgbGFzdGUubGVuZ3RoIC0gMSBdICk7XG5cdFx0XHRcdHZhciBzcHRzID0gWyBsYXN0IF07XG5cblx0XHRcdFx0dmFyIG4gPSBkaXZpc2lvbnMgKiBhcmdzWyAwIF0ubGVuZ3RoO1xuXG5cdFx0XHRcdHNwdHMgPSBzcHRzLmNvbmNhdCggYXJnc1sgMCBdICk7XG5cblx0XHRcdFx0dmFyIHNwbGluZSA9IG5ldyBUSFJFRS5TcGxpbmVDdXJ2ZSggc3B0cyApO1xuXG5cdFx0XHRcdGZvciAoIHZhciBqID0gMTsgaiA8PSBuOyBqICsrICkge1xuXG5cdFx0XHRcdFx0cG9pbnRzLnB1c2goIHNwbGluZS5nZXRQb2ludEF0KCBqIC8gbiApICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdhcmMnOlxuXG5cdFx0XHRcdHZhciBhWCA9IGFyZ3NbIDAgXSwgYVkgPSBhcmdzWyAxIF0sXG5cdFx0XHRcdFx0YVJhZGl1cyA9IGFyZ3NbIDIgXSxcblx0XHRcdFx0XHRhU3RhcnRBbmdsZSA9IGFyZ3NbIDMgXSwgYUVuZEFuZ2xlID0gYXJnc1sgNCBdLFxuXHRcdFx0XHRcdGFDbG9ja3dpc2UgPSAhISBhcmdzWyA1IF07XG5cblx0XHRcdFx0dmFyIGRlbHRhQW5nbGUgPSBhRW5kQW5nbGUgLSBhU3RhcnRBbmdsZTtcblx0XHRcdFx0dmFyIGFuZ2xlO1xuXHRcdFx0XHR2YXIgdGRpdmlzaW9ucyA9IGRpdmlzaW9ucyAqIDI7XG5cblx0XHRcdFx0Zm9yICggdmFyIGogPSAxOyBqIDw9IHRkaXZpc2lvbnM7IGogKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgdCA9IGogLyB0ZGl2aXNpb25zO1xuXG5cdFx0XHRcdFx0aWYgKCAhIGFDbG9ja3dpc2UgKSB7XG5cblx0XHRcdFx0XHRcdHQgPSAxIC0gdDtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGFuZ2xlID0gYVN0YXJ0QW5nbGUgKyB0ICogZGVsdGFBbmdsZTtcblxuXHRcdFx0XHRcdHR4ID0gYVggKyBhUmFkaXVzICogTWF0aC5jb3MoIGFuZ2xlICk7XG5cdFx0XHRcdFx0dHkgPSBhWSArIGFSYWRpdXMgKiBNYXRoLnNpbiggYW5nbGUgKTtcblxuXHRcdFx0XHRcdC8vY29uc29sZS5sb2coJ3QnLCB0LCAnYW5nbGUnLCBhbmdsZSwgJ3R4JywgdHgsICd0eScsIHR5KTtcblxuXHRcdFx0XHRcdHBvaW50cy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggdHgsIHR5ICkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly9jb25zb2xlLmxvZyhwb2ludHMpO1xuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdlbGxpcHNlJzpcblxuXHRcdFx0XHR2YXIgYVggPSBhcmdzWyAwIF0sIGFZID0gYXJnc1sgMSBdLFxuXHRcdFx0XHRcdHhSYWRpdXMgPSBhcmdzWyAyIF0sXG5cdFx0XHRcdFx0eVJhZGl1cyA9IGFyZ3NbIDMgXSxcblx0XHRcdFx0XHRhU3RhcnRBbmdsZSA9IGFyZ3NbIDQgXSwgYUVuZEFuZ2xlID0gYXJnc1sgNSBdLFxuXHRcdFx0XHRcdGFDbG9ja3dpc2UgPSAhISBhcmdzWyA2IF0sXG5cdFx0XHRcdFx0YVJvdGF0aW9uID0gYXJnc1sgNyBdO1xuXG5cblx0XHRcdFx0dmFyIGRlbHRhQW5nbGUgPSBhRW5kQW5nbGUgLSBhU3RhcnRBbmdsZTtcblx0XHRcdFx0dmFyIGFuZ2xlO1xuXHRcdFx0XHR2YXIgdGRpdmlzaW9ucyA9IGRpdmlzaW9ucyAqIDI7XG5cblx0XHRcdFx0dmFyIGNvcywgc2luO1xuXHRcdFx0XHRpZiAoIGFSb3RhdGlvbiAhPT0gMCApIHtcblxuXHRcdFx0XHRcdGNvcyA9IE1hdGguY29zKCBhUm90YXRpb24gKTtcblx0XHRcdFx0XHRzaW4gPSBNYXRoLnNpbiggYVJvdGF0aW9uICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZvciAoIHZhciBqID0gMTsgaiA8PSB0ZGl2aXNpb25zOyBqICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIHQgPSBqIC8gdGRpdmlzaW9ucztcblxuXHRcdFx0XHRcdGlmICggISBhQ2xvY2t3aXNlICkge1xuXG5cdFx0XHRcdFx0XHR0ID0gMSAtIHQ7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRhbmdsZSA9IGFTdGFydEFuZ2xlICsgdCAqIGRlbHRhQW5nbGU7XG5cblx0XHRcdFx0XHR0eCA9IGFYICsgeFJhZGl1cyAqIE1hdGguY29zKCBhbmdsZSApO1xuXHRcdFx0XHRcdHR5ID0gYVkgKyB5UmFkaXVzICogTWF0aC5zaW4oIGFuZ2xlICk7XG5cblx0XHRcdFx0XHRpZiAoIGFSb3RhdGlvbiAhPT0gMCApIHtcblxuXHRcdFx0XHRcdFx0dmFyIHggPSB0eCwgeSA9IHR5O1xuXG5cdFx0XHRcdFx0XHQvLyBSb3RhdGUgdGhlIHBvaW50IGFib3V0IHRoZSBjZW50ZXIgb2YgdGhlIGVsbGlwc2UuXG5cdFx0XHRcdFx0XHR0eCA9ICggeCAtIGFYICkgKiBjb3MgLSAoIHkgLSBhWSApICogc2luICsgYVg7XG5cdFx0XHRcdFx0XHR0eSA9ICggeCAtIGFYICkgKiBzaW4gKyAoIHkgLSBhWSApICogY29zICsgYVk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvL2NvbnNvbGUubG9nKCd0JywgdCwgJ2FuZ2xlJywgYW5nbGUsICd0eCcsIHR4LCAndHknLCB0eSk7XG5cblx0XHRcdFx0XHRwb2ludHMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoIHR4LCB0eSApICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vY29uc29sZS5sb2cocG9pbnRzKTtcblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0fSAvLyBlbmQgc3dpdGNoXG5cblx0XHR9XG5cblxuXG5cdFx0Ly8gTm9ybWFsaXplIHRvIHJlbW92ZSB0aGUgY2xvc2luZyBwb2ludCBieSBkZWZhdWx0LlxuXHRcdHZhciBsYXN0UG9pbnQgPSBwb2ludHNbIHBvaW50cy5sZW5ndGggLSAxIF07XG5cdFx0aWYgKCBNYXRoLmFicyggbGFzdFBvaW50LnggLSBwb2ludHNbIDAgXS54ICkgPCBOdW1iZXIuRVBTSUxPTiAmJlxuXHRcdFx0XHQgTWF0aC5hYnMoIGxhc3RQb2ludC55IC0gcG9pbnRzWyAwIF0ueSApIDwgTnVtYmVyLkVQU0lMT04gKVxuXHRcdFx0cG9pbnRzLnNwbGljZSggcG9pbnRzLmxlbmd0aCAtIDEsIDEgKTtcblx0XHRpZiAoIGNsb3NlZFBhdGggKSB7XG5cblx0XHRcdHBvaW50cy5wdXNoKCBwb2ludHNbIDAgXSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHBvaW50cztcblxuXHR9O1xuXG5cdC8vXG5cdC8vIEJyZWFrcyBwYXRoIGludG8gc2hhcGVzXG5cdC8vXG5cdC8vXHRBc3N1bXB0aW9ucyAoaWYgcGFyYW1ldGVyIGlzQ0NXPT10cnVlIHRoZSBvcHBvc2l0ZSBob2xkcyk6XG5cdC8vXHQtIHNvbGlkIHNoYXBlcyBhcmUgZGVmaW5lZCBjbG9ja3dpc2UgKENXKVxuXHQvL1x0LSBob2xlcyBhcmUgZGVmaW5lZCBjb3VudGVyY2xvY2t3aXNlIChDQ1cpXG5cdC8vXG5cdC8vXHRJZiBwYXJhbWV0ZXIgbm9Ib2xlcz09dHJ1ZTpcblx0Ly8gIC0gYWxsIHN1YlBhdGhzIGFyZSByZWdhcmRlZCBhcyBzb2xpZCBzaGFwZXNcblx0Ly8gIC0gZGVmaW5pdGlvbiBvcmRlciBDVy9DQ1cgaGFzIG5vIHJlbGV2YW5jZVxuXHQvL1xuXG5cdFRIUkVFLlBhdGgucHJvdG90eXBlLnRvU2hhcGVzID0gZnVuY3Rpb24oIGlzQ0NXLCBub0hvbGVzICkge1xuXG5cdFx0ZnVuY3Rpb24gZXh0cmFjdFN1YnBhdGhzKCBpbkFjdGlvbnMgKSB7XG5cblx0XHRcdHZhciBzdWJQYXRocyA9IFtdLCBsYXN0UGF0aCA9IG5ldyBUSFJFRS5QYXRoKCk7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGluQWN0aW9ucy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBpdGVtID0gaW5BY3Rpb25zWyBpIF07XG5cblx0XHRcdFx0dmFyIGFyZ3MgPSBpdGVtLmFyZ3M7XG5cdFx0XHRcdHZhciBhY3Rpb24gPSBpdGVtLmFjdGlvbjtcblxuXHRcdFx0XHRpZiAoIGFjdGlvbiA9PT0gJ21vdmVUbycgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGxhc3RQYXRoLmFjdGlvbnMubGVuZ3RoICE9PSAwICkge1xuXG5cdFx0XHRcdFx0XHRzdWJQYXRocy5wdXNoKCBsYXN0UGF0aCApO1xuXHRcdFx0XHRcdFx0bGFzdFBhdGggPSBuZXcgVEhSRUUuUGF0aCgpO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRsYXN0UGF0aFsgYWN0aW9uIF0uYXBwbHkoIGxhc3RQYXRoLCBhcmdzICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBsYXN0UGF0aC5hY3Rpb25zLmxlbmd0aCAhPT0gMCApIHtcblxuXHRcdFx0XHRzdWJQYXRocy5wdXNoKCBsYXN0UGF0aCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGNvbnNvbGUubG9nKHN1YlBhdGhzKTtcblxuXHRcdFx0cmV0dXJuXHRzdWJQYXRocztcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHRvU2hhcGVzTm9Ib2xlcyggaW5TdWJwYXRocyApIHtcblxuXHRcdFx0dmFyIHNoYXBlcyA9IFtdO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBpblN1YnBhdGhzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIHRtcFBhdGggPSBpblN1YnBhdGhzWyBpIF07XG5cblx0XHRcdFx0dmFyIHRtcFNoYXBlID0gbmV3IFRIUkVFLlNoYXBlKCk7XG5cdFx0XHRcdHRtcFNoYXBlLmFjdGlvbnMgPSB0bXBQYXRoLmFjdGlvbnM7XG5cdFx0XHRcdHRtcFNoYXBlLmN1cnZlcyA9IHRtcFBhdGguY3VydmVzO1xuXG5cdFx0XHRcdHNoYXBlcy5wdXNoKCB0bXBTaGFwZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vY29uc29sZS5sb2coXCJzaGFwZVwiLCBzaGFwZXMpO1xuXG5cdFx0XHRyZXR1cm4gc2hhcGVzO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaXNQb2ludEluc2lkZVBvbHlnb24oIGluUHQsIGluUG9seWdvbiApIHtcblxuXHRcdFx0dmFyIHBvbHlMZW4gPSBpblBvbHlnb24ubGVuZ3RoO1xuXG5cdFx0XHQvLyBpblB0IG9uIHBvbHlnb24gY29udG91ciA9PiBpbW1lZGlhdGUgc3VjY2VzcyAgICBvclxuXHRcdFx0Ly8gdG9nZ2xpbmcgb2YgaW5zaWRlL291dHNpZGUgYXQgZXZlcnkgc2luZ2xlISBpbnRlcnNlY3Rpb24gcG9pbnQgb2YgYW4gZWRnZVxuXHRcdFx0Ly8gIHdpdGggdGhlIGhvcml6b250YWwgbGluZSB0aHJvdWdoIGluUHQsIGxlZnQgb2YgaW5QdFxuXHRcdFx0Ly8gIG5vdCBjb3VudGluZyBsb3dlclkgZW5kcG9pbnRzIG9mIGVkZ2VzIGFuZCB3aG9sZSBlZGdlcyBvbiB0aGF0IGxpbmVcblx0XHRcdHZhciBpbnNpZGUgPSBmYWxzZTtcblx0XHRcdGZvciAoIHZhciBwID0gcG9seUxlbiAtIDEsIHEgPSAwOyBxIDwgcG9seUxlbjsgcCA9IHEgKysgKSB7XG5cblx0XHRcdFx0dmFyIGVkZ2VMb3dQdCAgPSBpblBvbHlnb25bIHAgXTtcblx0XHRcdFx0dmFyIGVkZ2VIaWdoUHQgPSBpblBvbHlnb25bIHEgXTtcblxuXHRcdFx0XHR2YXIgZWRnZUR4ID0gZWRnZUhpZ2hQdC54IC0gZWRnZUxvd1B0Lng7XG5cdFx0XHRcdHZhciBlZGdlRHkgPSBlZGdlSGlnaFB0LnkgLSBlZGdlTG93UHQueTtcblxuXHRcdFx0XHRpZiAoIE1hdGguYWJzKCBlZGdlRHkgKSA+IE51bWJlci5FUFNJTE9OICkge1xuXG5cdFx0XHRcdFx0Ly8gbm90IHBhcmFsbGVsXG5cdFx0XHRcdFx0aWYgKCBlZGdlRHkgPCAwICkge1xuXG5cdFx0XHRcdFx0XHRlZGdlTG93UHQgID0gaW5Qb2x5Z29uWyBxIF07IGVkZ2VEeCA9IC0gZWRnZUR4O1xuXHRcdFx0XHRcdFx0ZWRnZUhpZ2hQdCA9IGluUG9seWdvblsgcCBdOyBlZGdlRHkgPSAtIGVkZ2VEeTtcblxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoICggaW5QdC55IDwgZWRnZUxvd1B0LnkgKSB8fCAoIGluUHQueSA+IGVkZ2VIaWdoUHQueSApICkgXHRcdGNvbnRpbnVlO1xuXG5cdFx0XHRcdFx0aWYgKCBpblB0LnkgPT09IGVkZ2VMb3dQdC55ICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIGluUHQueCA9PT0gZWRnZUxvd1B0LnggKVx0XHRyZXR1cm5cdHRydWU7XHRcdC8vIGluUHQgaXMgb24gY29udG91ciA/XG5cdFx0XHRcdFx0XHQvLyBjb250aW51ZTtcdFx0XHRcdC8vIG5vIGludGVyc2VjdGlvbiBvciBlZGdlTG93UHQgPT4gZG9lc24ndCBjb3VudCAhISFcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdHZhciBwZXJwRWRnZSA9IGVkZ2VEeSAqICggaW5QdC54IC0gZWRnZUxvd1B0LnggKSAtIGVkZ2VEeCAqICggaW5QdC55IC0gZWRnZUxvd1B0LnkgKTtcblx0XHRcdFx0XHRcdGlmICggcGVycEVkZ2UgPT09IDAgKVx0XHRcdFx0cmV0dXJuXHR0cnVlO1x0XHQvLyBpblB0IGlzIG9uIGNvbnRvdXIgP1xuXHRcdFx0XHRcdFx0aWYgKCBwZXJwRWRnZSA8IDAgKSBcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0aW5zaWRlID0gISBpbnNpZGU7XHRcdC8vIHRydWUgaW50ZXJzZWN0aW9uIGxlZnQgb2YgaW5QdFxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyBwYXJhbGxlbCBvciBjb2xsaW5lYXJcblx0XHRcdFx0XHRpZiAoIGluUHQueSAhPT0gZWRnZUxvd1B0LnkgKSBcdFx0Y29udGludWU7XHRcdFx0Ly8gcGFyYWxsZWxcblx0XHRcdFx0XHQvLyBlZGdlIGxpZXMgb24gdGhlIHNhbWUgaG9yaXpvbnRhbCBsaW5lIGFzIGluUHRcblx0XHRcdFx0XHRpZiAoICggKCBlZGdlSGlnaFB0LnggPD0gaW5QdC54ICkgJiYgKCBpblB0LnggPD0gZWRnZUxvd1B0LnggKSApIHx8XG5cdFx0XHRcdFx0XHQgKCAoIGVkZ2VMb3dQdC54IDw9IGluUHQueCApICYmICggaW5QdC54IDw9IGVkZ2VIaWdoUHQueCApICkgKVx0XHRyZXR1cm5cdHRydWU7XHQvLyBpblB0OiBQb2ludCBvbiBjb250b3VyICFcblx0XHRcdFx0XHQvLyBjb250aW51ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuXHRpbnNpZGU7XG5cblx0XHR9XG5cblx0XHR2YXIgaXNDbG9ja1dpc2UgPSBUSFJFRS5TaGFwZVV0aWxzLmlzQ2xvY2tXaXNlO1xuXG5cdFx0dmFyIHN1YlBhdGhzID0gZXh0cmFjdFN1YnBhdGhzKCB0aGlzLmFjdGlvbnMgKTtcblx0XHRpZiAoIHN1YlBhdGhzLmxlbmd0aCA9PT0gMCApIHJldHVybiBbXTtcblxuXHRcdGlmICggbm9Ib2xlcyA9PT0gdHJ1ZSApXHRyZXR1cm5cdHRvU2hhcGVzTm9Ib2xlcyggc3ViUGF0aHMgKTtcblxuXG5cdFx0dmFyIHNvbGlkLCB0bXBQYXRoLCB0bXBTaGFwZSwgc2hhcGVzID0gW107XG5cblx0XHRpZiAoIHN1YlBhdGhzLmxlbmd0aCA9PT0gMSApIHtcblxuXHRcdFx0dG1wUGF0aCA9IHN1YlBhdGhzWyAwIF07XG5cdFx0XHR0bXBTaGFwZSA9IG5ldyBUSFJFRS5TaGFwZSgpO1xuXHRcdFx0dG1wU2hhcGUuYWN0aW9ucyA9IHRtcFBhdGguYWN0aW9ucztcblx0XHRcdHRtcFNoYXBlLmN1cnZlcyA9IHRtcFBhdGguY3VydmVzO1xuXHRcdFx0c2hhcGVzLnB1c2goIHRtcFNoYXBlICk7XG5cdFx0XHRyZXR1cm4gc2hhcGVzO1xuXG5cdFx0fVxuXG5cdFx0dmFyIGhvbGVzRmlyc3QgPSAhIGlzQ2xvY2tXaXNlKCBzdWJQYXRoc1sgMCBdLmdldFBvaW50cygpICk7XG5cdFx0aG9sZXNGaXJzdCA9IGlzQ0NXID8gISBob2xlc0ZpcnN0IDogaG9sZXNGaXJzdDtcblxuXHRcdC8vIGNvbnNvbGUubG9nKFwiSG9sZXMgZmlyc3RcIiwgaG9sZXNGaXJzdCk7XG5cblx0XHR2YXIgYmV0dGVyU2hhcGVIb2xlcyA9IFtdO1xuXHRcdHZhciBuZXdTaGFwZXMgPSBbXTtcblx0XHR2YXIgbmV3U2hhcGVIb2xlcyA9IFtdO1xuXHRcdHZhciBtYWluSWR4ID0gMDtcblx0XHR2YXIgdG1wUG9pbnRzO1xuXG5cdFx0bmV3U2hhcGVzWyBtYWluSWR4IF0gPSB1bmRlZmluZWQ7XG5cdFx0bmV3U2hhcGVIb2xlc1sgbWFpbklkeCBdID0gW107XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBzdWJQYXRocy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHR0bXBQYXRoID0gc3ViUGF0aHNbIGkgXTtcblx0XHRcdHRtcFBvaW50cyA9IHRtcFBhdGguZ2V0UG9pbnRzKCk7XG5cdFx0XHRzb2xpZCA9IGlzQ2xvY2tXaXNlKCB0bXBQb2ludHMgKTtcblx0XHRcdHNvbGlkID0gaXNDQ1cgPyAhIHNvbGlkIDogc29saWQ7XG5cblx0XHRcdGlmICggc29saWQgKSB7XG5cblx0XHRcdFx0aWYgKCAoICEgaG9sZXNGaXJzdCApICYmICggbmV3U2hhcGVzWyBtYWluSWR4IF0gKSApXHRtYWluSWR4ICsrO1xuXG5cdFx0XHRcdG5ld1NoYXBlc1sgbWFpbklkeCBdID0geyBzOiBuZXcgVEhSRUUuU2hhcGUoKSwgcDogdG1wUG9pbnRzIH07XG5cdFx0XHRcdG5ld1NoYXBlc1sgbWFpbklkeCBdLnMuYWN0aW9ucyA9IHRtcFBhdGguYWN0aW9ucztcblx0XHRcdFx0bmV3U2hhcGVzWyBtYWluSWR4IF0ucy5jdXJ2ZXMgPSB0bXBQYXRoLmN1cnZlcztcblxuXHRcdFx0XHRpZiAoIGhvbGVzRmlyc3QgKVx0bWFpbklkeCArKztcblx0XHRcdFx0bmV3U2hhcGVIb2xlc1sgbWFpbklkeCBdID0gW107XG5cblx0XHRcdFx0Ly9jb25zb2xlLmxvZygnY3cnLCBpKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRuZXdTaGFwZUhvbGVzWyBtYWluSWR4IF0ucHVzaCggeyBoOiB0bXBQYXRoLCBwOiB0bXBQb2ludHNbIDAgXSB9ICk7XG5cblx0XHRcdFx0Ly9jb25zb2xlLmxvZygnY2N3JywgaSk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIG9ubHkgSG9sZXM/IC0+IHByb2JhYmx5IGFsbCBTaGFwZXMgd2l0aCB3cm9uZyBvcmllbnRhdGlvblxuXHRcdGlmICggISBuZXdTaGFwZXNbIDAgXSApXHRyZXR1cm5cdHRvU2hhcGVzTm9Ib2xlcyggc3ViUGF0aHMgKTtcblxuXG5cdFx0aWYgKCBuZXdTaGFwZXMubGVuZ3RoID4gMSApIHtcblxuXHRcdFx0dmFyIGFtYmlndW91cyA9IGZhbHNlO1xuXHRcdFx0dmFyIHRvQ2hhbmdlID0gW107XG5cblx0XHRcdGZvciAoIHZhciBzSWR4ID0gMCwgc0xlbiA9IG5ld1NoYXBlcy5sZW5ndGg7IHNJZHggPCBzTGVuOyBzSWR4ICsrICkge1xuXG5cdFx0XHRcdGJldHRlclNoYXBlSG9sZXNbIHNJZHggXSA9IFtdO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIHZhciBzSWR4ID0gMCwgc0xlbiA9IG5ld1NoYXBlcy5sZW5ndGg7IHNJZHggPCBzTGVuOyBzSWR4ICsrICkge1xuXG5cdFx0XHRcdHZhciBzaG8gPSBuZXdTaGFwZUhvbGVzWyBzSWR4IF07XG5cblx0XHRcdFx0Zm9yICggdmFyIGhJZHggPSAwOyBoSWR4IDwgc2hvLmxlbmd0aDsgaElkeCArKyApIHtcblxuXHRcdFx0XHRcdHZhciBobyA9IHNob1sgaElkeCBdO1xuXHRcdFx0XHRcdHZhciBob2xlX3VuYXNzaWduZWQgPSB0cnVlO1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIHMySWR4ID0gMDsgczJJZHggPCBuZXdTaGFwZXMubGVuZ3RoOyBzMklkeCArKyApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBpc1BvaW50SW5zaWRlUG9seWdvbiggaG8ucCwgbmV3U2hhcGVzWyBzMklkeCBdLnAgKSApIHtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHNJZHggIT09IHMySWR4IClcdHRvQ2hhbmdlLnB1c2goIHsgZnJvbXM6IHNJZHgsIHRvczogczJJZHgsIGhvbGU6IGhJZHggfSApO1xuXHRcdFx0XHRcdFx0XHRpZiAoIGhvbGVfdW5hc3NpZ25lZCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGhvbGVfdW5hc3NpZ25lZCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdGJldHRlclNoYXBlSG9sZXNbIHMySWR4IF0ucHVzaCggaG8gKTtcblxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0YW1iaWd1b3VzID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIGhvbGVfdW5hc3NpZ25lZCApIHtcblxuXHRcdFx0XHRcdFx0YmV0dGVyU2hhcGVIb2xlc1sgc0lkeCBdLnB1c2goIGhvICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cdFx0XHQvLyBjb25zb2xlLmxvZyhcImFtYmlndW91czogXCIsIGFtYmlndW91cyk7XG5cdFx0XHRpZiAoIHRvQ2hhbmdlLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0Ly8gY29uc29sZS5sb2coXCJ0byBjaGFuZ2U6IFwiLCB0b0NoYW5nZSk7XG5cdFx0XHRcdGlmICggISBhbWJpZ3VvdXMgKVx0bmV3U2hhcGVIb2xlcyA9IGJldHRlclNoYXBlSG9sZXM7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHZhciB0bXBIb2xlcztcblxuXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBuZXdTaGFwZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdHRtcFNoYXBlID0gbmV3U2hhcGVzWyBpIF0ucztcblx0XHRcdHNoYXBlcy5wdXNoKCB0bXBTaGFwZSApO1xuXHRcdFx0dG1wSG9sZXMgPSBuZXdTaGFwZUhvbGVzWyBpIF07XG5cblx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSB0bXBIb2xlcy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHR0bXBTaGFwZS5ob2xlcy5wdXNoKCB0bXBIb2xlc1sgaiBdLmggKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly9jb25zb2xlLmxvZyhcInNoYXBlXCIsIHNoYXBlcyk7XG5cblx0XHRyZXR1cm4gc2hhcGVzO1xuXG5cdH07XG5cblx0Ly8gRmlsZTpzcmMvZXh0cmFzL2NvcmUvU2hhcGUuanNcblxuXHQvKipcblx0ICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xuXHQgKiBEZWZpbmVzIGEgMmQgc2hhcGUgcGxhbmUgdXNpbmcgcGF0aHMuXG5cdCAqKi9cblxuXHQvLyBTVEVQIDEgQ3JlYXRlIGEgcGF0aC5cblx0Ly8gU1RFUCAyIFR1cm4gcGF0aCBpbnRvIHNoYXBlLlxuXHQvLyBTVEVQIDMgRXh0cnVkZUdlb21ldHJ5IHRha2VzIGluIFNoYXBlL1NoYXBlc1xuXHQvLyBTVEVQIDNhIC0gRXh0cmFjdCBwb2ludHMgZnJvbSBlYWNoIHNoYXBlLCB0dXJuIHRvIHZlcnRpY2VzXG5cdC8vIFNURVAgM2IgLSBUcmlhbmd1bGF0ZSBlYWNoIHNoYXBlLCBhZGQgZmFjZXMuXG5cblx0VEhSRUUuU2hhcGUgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRUSFJFRS5QYXRoLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblxuXHRcdHRoaXMuaG9sZXMgPSBbXTtcblxuXHR9O1xuXG5cdFRIUkVFLlNoYXBlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLlBhdGgucHJvdG90eXBlICk7XG5cdFRIUkVFLlNoYXBlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlNoYXBlO1xuXG5cdC8vIENvbnZlbmllbmNlIG1ldGhvZCB0byByZXR1cm4gRXh0cnVkZUdlb21ldHJ5XG5cblx0VEhSRUUuU2hhcGUucHJvdG90eXBlLmV4dHJ1ZGUgPSBmdW5jdGlvbiAoIG9wdGlvbnMgKSB7XG5cblx0XHRyZXR1cm4gbmV3IFRIUkVFLkV4dHJ1ZGVHZW9tZXRyeSggdGhpcywgb3B0aW9ucyApO1xuXG5cdH07XG5cblx0Ly8gQ29udmVuaWVuY2UgbWV0aG9kIHRvIHJldHVybiBTaGFwZUdlb21ldHJ5XG5cblx0VEhSRUUuU2hhcGUucHJvdG90eXBlLm1ha2VHZW9tZXRyeSA9IGZ1bmN0aW9uICggb3B0aW9ucyApIHtcblxuXHRcdHJldHVybiBuZXcgVEhSRUUuU2hhcGVHZW9tZXRyeSggdGhpcywgb3B0aW9ucyApO1xuXG5cdH07XG5cblx0Ly8gR2V0IHBvaW50cyBvZiBob2xlc1xuXG5cdFRIUkVFLlNoYXBlLnByb3RvdHlwZS5nZXRQb2ludHNIb2xlcyA9IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xuXG5cdFx0dmFyIGhvbGVzUHRzID0gW107XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLmhvbGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGhvbGVzUHRzWyBpIF0gPSB0aGlzLmhvbGVzWyBpIF0uZ2V0UG9pbnRzKCBkaXZpc2lvbnMgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBob2xlc1B0cztcblxuXHR9O1xuXG5cblx0Ly8gR2V0IHBvaW50cyBvZiBzaGFwZSBhbmQgaG9sZXMgKGtleXBvaW50cyBiYXNlZCBvbiBzZWdtZW50cyBwYXJhbWV0ZXIpXG5cblx0VEhSRUUuU2hhcGUucHJvdG90eXBlLmV4dHJhY3RBbGxQb2ludHMgPSBmdW5jdGlvbiAoIGRpdmlzaW9ucyApIHtcblxuXHRcdHJldHVybiB7XG5cblx0XHRcdHNoYXBlOiB0aGlzLmdldFBvaW50cyggZGl2aXNpb25zICksXG5cdFx0XHRob2xlczogdGhpcy5nZXRQb2ludHNIb2xlcyggZGl2aXNpb25zIClcblxuXHRcdH07XG5cblx0fTtcblxuXHRUSFJFRS5TaGFwZS5wcm90b3R5cGUuZXh0cmFjdFBvaW50cyA9IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZXh0cmFjdEFsbFBvaW50cyggZGl2aXNpb25zICk7XG5cblx0fTtcblxuXHRUSFJFRS5TaGFwZS5VdGlscyA9IFRIUkVFLlNoYXBlVXRpbHM7IC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cblx0Ly8gRmlsZTpzcmMvZXh0cmFzL2N1cnZlcy9MaW5lQ3VydmUuanNcblxuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0ICpcdExpbmVcblx0ICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFRIUkVFLkxpbmVDdXJ2ZSA9IGZ1bmN0aW9uICggdjEsIHYyICkge1xuXG5cdFx0dGhpcy52MSA9IHYxO1xuXHRcdHRoaXMudjIgPSB2MjtcblxuXHR9O1xuXG5cdFRIUkVFLkxpbmVDdXJ2ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5DdXJ2ZS5wcm90b3R5cGUgKTtcblx0VEhSRUUuTGluZUN1cnZlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkxpbmVDdXJ2ZTtcblxuXHRUSFJFRS5MaW5lQ3VydmUucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24gKCB0ICkge1xuXG5cdFx0dmFyIHBvaW50ID0gdGhpcy52Mi5jbG9uZSgpLnN1YiggdGhpcy52MSApO1xuXHRcdHBvaW50Lm11bHRpcGx5U2NhbGFyKCB0ICkuYWRkKCB0aGlzLnYxICk7XG5cblx0XHRyZXR1cm4gcG9pbnQ7XG5cblx0fTtcblxuXHQvLyBMaW5lIGN1cnZlIGlzIGxpbmVhciwgc28gd2UgY2FuIG92ZXJ3cml0ZSBkZWZhdWx0IGdldFBvaW50QXRcblxuXHRUSFJFRS5MaW5lQ3VydmUucHJvdG90eXBlLmdldFBvaW50QXQgPSBmdW5jdGlvbiAoIHUgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5nZXRQb2ludCggdSApO1xuXG5cdH07XG5cblx0VEhSRUUuTGluZUN1cnZlLnByb3RvdHlwZS5nZXRUYW5nZW50ID0gZnVuY3Rpb24oIHQgKSB7XG5cblx0XHR2YXIgdGFuZ2VudCA9IHRoaXMudjIuY2xvbmUoKS5zdWIoIHRoaXMudjEgKTtcblxuXHRcdHJldHVybiB0YW5nZW50Lm5vcm1hbGl6ZSgpO1xuXG5cdH07XG5cblx0Ly8gRmlsZTpzcmMvZXh0cmFzL2N1cnZlcy9RdWFkcmF0aWNCZXppZXJDdXJ2ZS5qc1xuXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHQgKlx0UXVhZHJhdGljIEJlemllciBjdXJ2ZVxuXHQgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxuXHRUSFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZSA9IGZ1bmN0aW9uICggdjAsIHYxLCB2MiApIHtcblxuXHRcdHRoaXMudjAgPSB2MDtcblx0XHR0aGlzLnYxID0gdjE7XG5cdFx0dGhpcy52MiA9IHYyO1xuXG5cdH07XG5cblx0VEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQ3VydmUucHJvdG90eXBlICk7XG5cdFRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlO1xuXG5cblx0VEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmUucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24gKCB0ICkge1xuXG5cdFx0dmFyIGIyID0gVEhSRUUuU2hhcGVVdGlscy5iMjtcblxuXHRcdHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMihcblx0XHRcdGIyKCB0LCB0aGlzLnYwLngsIHRoaXMudjEueCwgdGhpcy52Mi54ICksXG5cdFx0XHRiMiggdCwgdGhpcy52MC55LCB0aGlzLnYxLnksIHRoaXMudjIueSApXG5cdFx0KTtcblxuXHR9O1xuXG5cblx0VEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmUucHJvdG90eXBlLmdldFRhbmdlbnQgPSBmdW5jdGlvbiggdCApIHtcblxuXHRcdHZhciB0YW5nZW50UXVhZHJhdGljQmV6aWVyID0gVEhSRUUuQ3VydmVVdGlscy50YW5nZW50UXVhZHJhdGljQmV6aWVyO1xuXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IyKFxuXHRcdFx0dGFuZ2VudFF1YWRyYXRpY0JlemllciggdCwgdGhpcy52MC54LCB0aGlzLnYxLngsIHRoaXMudjIueCApLFxuXHRcdFx0dGFuZ2VudFF1YWRyYXRpY0JlemllciggdCwgdGhpcy52MC55LCB0aGlzLnYxLnksIHRoaXMudjIueSApXG5cdFx0KS5ub3JtYWxpemUoKTtcblxuXHR9O1xuXG5cdC8vIEZpbGU6c3JjL2V4dHJhcy9jdXJ2ZXMvQ3ViaWNCZXppZXJDdXJ2ZS5qc1xuXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHQgKlx0Q3ViaWMgQmV6aWVyIGN1cnZlXG5cdCAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXHRUSFJFRS5DdWJpY0JlemllckN1cnZlID0gZnVuY3Rpb24gKCB2MCwgdjEsIHYyLCB2MyApIHtcblxuXHRcdHRoaXMudjAgPSB2MDtcblx0XHR0aGlzLnYxID0gdjE7XG5cdFx0dGhpcy52MiA9IHYyO1xuXHRcdHRoaXMudjMgPSB2MztcblxuXHR9O1xuXG5cdFRIUkVFLkN1YmljQmV6aWVyQ3VydmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQ3VydmUucHJvdG90eXBlICk7XG5cdFRIUkVFLkN1YmljQmV6aWVyQ3VydmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZTtcblxuXHRUSFJFRS5DdWJpY0JlemllckN1cnZlLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uICggdCApIHtcblxuXHRcdHZhciBiMyA9IFRIUkVFLlNoYXBlVXRpbHMuYjM7XG5cblx0XHRyZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjIoIFxuXHRcdFx0YjMoIHQsIHRoaXMudjAueCwgdGhpcy52MS54LCB0aGlzLnYyLngsIHRoaXMudjMueCApLFxuXHRcdFx0YjMoIHQsIHRoaXMudjAueSwgdGhpcy52MS55LCB0aGlzLnYyLnksIHRoaXMudjMueSApXG5cdFx0KTtcblxuXHR9O1xuXG5cdFRIUkVFLkN1YmljQmV6aWVyQ3VydmUucHJvdG90eXBlLmdldFRhbmdlbnQgPSBmdW5jdGlvbiggdCApIHtcblxuXHRcdHZhciB0YW5nZW50Q3ViaWNCZXppZXIgPSBUSFJFRS5DdXJ2ZVV0aWxzLnRhbmdlbnRDdWJpY0JlemllcjtcblxuXHRcdHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMiggXG5cdFx0XHR0YW5nZW50Q3ViaWNCZXppZXIoIHQsIHRoaXMudjAueCwgdGhpcy52MS54LCB0aGlzLnYyLngsIHRoaXMudjMueCApLFxuXHRcdFx0dGFuZ2VudEN1YmljQmV6aWVyKCB0LCB0aGlzLnYwLnksIHRoaXMudjEueSwgdGhpcy52Mi55LCB0aGlzLnYzLnkgKVxuXHRcdCkubm9ybWFsaXplKCk7XG5cblx0fTtcblxuXHQvLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL1NwbGluZUN1cnZlLmpzXG5cblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdCAqXHRTcGxpbmUgY3VydmVcblx0ICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFRIUkVFLlNwbGluZUN1cnZlID0gZnVuY3Rpb24gKCBwb2ludHMgLyogYXJyYXkgb2YgVmVjdG9yMiAqLyApIHtcblxuXHRcdHRoaXMucG9pbnRzID0gKCBwb2ludHMgPT0gdW5kZWZpbmVkICkgPyBbXSA6IHBvaW50cztcblxuXHR9O1xuXG5cdFRIUkVFLlNwbGluZUN1cnZlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkN1cnZlLnByb3RvdHlwZSApO1xuXHRUSFJFRS5TcGxpbmVDdXJ2ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5TcGxpbmVDdXJ2ZTtcblxuXHRUSFJFRS5TcGxpbmVDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoIHQgKSB7XG5cblx0XHR2YXIgcG9pbnRzID0gdGhpcy5wb2ludHM7XG5cdFx0dmFyIHBvaW50ID0gKCBwb2ludHMubGVuZ3RoIC0gMSApICogdDtcblxuXHRcdHZhciBpbnRQb2ludCA9IE1hdGguZmxvb3IoIHBvaW50ICk7XG5cdFx0dmFyIHdlaWdodCA9IHBvaW50IC0gaW50UG9pbnQ7XG5cblx0XHR2YXIgcG9pbnQwID0gcG9pbnRzWyBpbnRQb2ludCA9PT0gMCA/IGludFBvaW50IDogaW50UG9pbnQgLSAxIF07XG5cdFx0dmFyIHBvaW50MSA9IHBvaW50c1sgaW50UG9pbnQgXTtcblx0XHR2YXIgcG9pbnQyID0gcG9pbnRzWyBpbnRQb2ludCA+IHBvaW50cy5sZW5ndGggLSAyID8gcG9pbnRzLmxlbmd0aCAtIDEgOiBpbnRQb2ludCArIDEgXTtcblx0XHR2YXIgcG9pbnQzID0gcG9pbnRzWyBpbnRQb2ludCA+IHBvaW50cy5sZW5ndGggLSAzID8gcG9pbnRzLmxlbmd0aCAtIDEgOiBpbnRQb2ludCArIDIgXTtcblxuXHRcdHZhciBpbnRlcnBvbGF0ZSA9IFRIUkVFLkN1cnZlVXRpbHMuaW50ZXJwb2xhdGU7XG5cblx0XHRyZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjIoXG5cdFx0XHRpbnRlcnBvbGF0ZSggcG9pbnQwLngsIHBvaW50MS54LCBwb2ludDIueCwgcG9pbnQzLngsIHdlaWdodCApLFxuXHRcdFx0aW50ZXJwb2xhdGUoIHBvaW50MC55LCBwb2ludDEueSwgcG9pbnQyLnksIHBvaW50My55LCB3ZWlnaHQgKVxuXHRcdCk7XG5cblx0fTtcblxuXHQvLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL0VsbGlwc2VDdXJ2ZS5qc1xuXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHQgKlx0RWxsaXBzZSBjdXJ2ZVxuXHQgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblx0VEhSRUUuRWxsaXBzZUN1cnZlID0gZnVuY3Rpb24gKCBhWCwgYVksIHhSYWRpdXMsIHlSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UsIGFSb3RhdGlvbiApIHtcblxuXHRcdHRoaXMuYVggPSBhWDtcblx0XHR0aGlzLmFZID0gYVk7XG5cblx0XHR0aGlzLnhSYWRpdXMgPSB4UmFkaXVzO1xuXHRcdHRoaXMueVJhZGl1cyA9IHlSYWRpdXM7XG5cblx0XHR0aGlzLmFTdGFydEFuZ2xlID0gYVN0YXJ0QW5nbGU7XG5cdFx0dGhpcy5hRW5kQW5nbGUgPSBhRW5kQW5nbGU7XG5cblx0XHR0aGlzLmFDbG9ja3dpc2UgPSBhQ2xvY2t3aXNlO1xuXHRcdFxuXHRcdHRoaXMuYVJvdGF0aW9uID0gYVJvdGF0aW9uIHx8IDA7XG5cblx0fTtcblxuXHRUSFJFRS5FbGxpcHNlQ3VydmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQ3VydmUucHJvdG90eXBlICk7XG5cdFRIUkVFLkVsbGlwc2VDdXJ2ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5FbGxpcHNlQ3VydmU7XG5cblx0VEhSRUUuRWxsaXBzZUN1cnZlLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uICggdCApIHtcblxuXHRcdHZhciBkZWx0YUFuZ2xlID0gdGhpcy5hRW5kQW5nbGUgLSB0aGlzLmFTdGFydEFuZ2xlO1xuXG5cdFx0aWYgKCBkZWx0YUFuZ2xlIDwgMCApIGRlbHRhQW5nbGUgKz0gTWF0aC5QSSAqIDI7XG5cdFx0aWYgKCBkZWx0YUFuZ2xlID4gTWF0aC5QSSAqIDIgKSBkZWx0YUFuZ2xlIC09IE1hdGguUEkgKiAyO1xuXG5cdFx0dmFyIGFuZ2xlO1xuXG5cdFx0aWYgKCB0aGlzLmFDbG9ja3dpc2UgPT09IHRydWUgKSB7XG5cblx0XHRcdGFuZ2xlID0gdGhpcy5hRW5kQW5nbGUgKyAoIDEgLSB0ICkgKiAoIE1hdGguUEkgKiAyIC0gZGVsdGFBbmdsZSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0YW5nbGUgPSB0aGlzLmFTdGFydEFuZ2xlICsgdCAqIGRlbHRhQW5nbGU7XG5cblx0XHR9XG5cdFx0XG5cdFx0dmFyIHggPSB0aGlzLmFYICsgdGhpcy54UmFkaXVzICogTWF0aC5jb3MoIGFuZ2xlICk7XG5cdFx0dmFyIHkgPSB0aGlzLmFZICsgdGhpcy55UmFkaXVzICogTWF0aC5zaW4oIGFuZ2xlICk7XG5cblx0XHRpZiAoIHRoaXMuYVJvdGF0aW9uICE9PSAwICkge1xuXG5cdFx0XHR2YXIgY29zID0gTWF0aC5jb3MoIHRoaXMuYVJvdGF0aW9uICk7XG5cdFx0XHR2YXIgc2luID0gTWF0aC5zaW4oIHRoaXMuYVJvdGF0aW9uICk7XG5cblx0XHRcdHZhciB0eCA9IHgsIHR5ID0geTtcblxuXHRcdFx0Ly8gUm90YXRlIHRoZSBwb2ludCBhYm91dCB0aGUgY2VudGVyIG9mIHRoZSBlbGxpcHNlLlxuXHRcdFx0eCA9ICggdHggLSB0aGlzLmFYICkgKiBjb3MgLSAoIHR5IC0gdGhpcy5hWSApICogc2luICsgdGhpcy5hWDtcblx0XHRcdHkgPSAoIHR4IC0gdGhpcy5hWCApICogc2luICsgKCB0eSAtIHRoaXMuYVkgKSAqIGNvcyArIHRoaXMuYVk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjIoIHgsIHkgKTtcblxuXHR9O1xuXG5cdC8vIEZpbGU6c3JjL2V4dHJhcy9jdXJ2ZXMvQXJjQ3VydmUuanNcblxuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0ICpcdEFyYyBjdXJ2ZVxuXHQgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblx0VEhSRUUuQXJjQ3VydmUgPSBmdW5jdGlvbiAoIGFYLCBhWSwgYVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApIHtcblxuXHRcdFRIUkVFLkVsbGlwc2VDdXJ2ZS5jYWxsKCB0aGlzLCBhWCwgYVksIGFSYWRpdXMsIGFSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKTtcblxuXHR9O1xuXG5cdFRIUkVFLkFyY0N1cnZlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkVsbGlwc2VDdXJ2ZS5wcm90b3R5cGUgKTtcblx0VEhSRUUuQXJjQ3VydmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQXJjQ3VydmU7XG5cblx0Ly8gRmlsZTpzcmMvZXh0cmFzL2N1cnZlcy9MaW5lQ3VydmUzLmpzXG5cblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdCAqXHRMaW5lM0Rcblx0ICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFRIUkVFLkxpbmVDdXJ2ZTMgPSBUSFJFRS5DdXJ2ZS5jcmVhdGUoXG5cblx0XHRmdW5jdGlvbiAoIHYxLCB2MiApIHtcblxuXHRcdFx0dGhpcy52MSA9IHYxO1xuXHRcdFx0dGhpcy52MiA9IHYyO1xuXG5cdFx0fSxcblxuXHRcdGZ1bmN0aW9uICggdCApIHtcblxuXHRcdFx0dmFyIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRcdHZlY3Rvci5zdWJWZWN0b3JzKCB0aGlzLnYyLCB0aGlzLnYxICk7IC8vIGRpZmZcblx0XHRcdHZlY3Rvci5tdWx0aXBseVNjYWxhciggdCApO1xuXHRcdFx0dmVjdG9yLmFkZCggdGhpcy52MSApO1xuXG5cdFx0XHRyZXR1cm4gdmVjdG9yO1xuXG5cdFx0fVxuXG5cdCk7XG5cblx0Ly8gRmlsZTpzcmMvZXh0cmFzL2N1cnZlcy9RdWFkcmF0aWNCZXppZXJDdXJ2ZTMuanNcblxuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0ICpcdFF1YWRyYXRpYyBCZXppZXIgM0QgY3VydmVcblx0ICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlMyA9IFRIUkVFLkN1cnZlLmNyZWF0ZShcblxuXHRcdGZ1bmN0aW9uICggdjAsIHYxLCB2MiApIHtcblxuXHRcdFx0dGhpcy52MCA9IHYwO1xuXHRcdFx0dGhpcy52MSA9IHYxO1xuXHRcdFx0dGhpcy52MiA9IHYyO1xuXG5cdFx0fSxcblxuXHRcdGZ1bmN0aW9uICggdCApIHtcblxuXHRcdFx0dmFyIGIyID0gVEhSRUUuU2hhcGVVdGlscy5iMjtcdFx0XG5cblx0XHRcdHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMyhcblx0XHRcdFx0YjIoIHQsIHRoaXMudjAueCwgdGhpcy52MS54LCB0aGlzLnYyLnggKSxcblx0XHRcdFx0YjIoIHQsIHRoaXMudjAueSwgdGhpcy52MS55LCB0aGlzLnYyLnkgKSxcblx0XHRcdFx0YjIoIHQsIHRoaXMudjAueiwgdGhpcy52MS56LCB0aGlzLnYyLnogKVxuXHRcdFx0KTtcblxuXHRcdH1cblxuXHQpO1xuXG5cdC8vIEZpbGU6c3JjL2V4dHJhcy9jdXJ2ZXMvQ3ViaWNCZXppZXJDdXJ2ZTMuanNcblxuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0ICpcdEN1YmljIEJlemllciAzRCBjdXJ2ZVxuXHQgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblx0VEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZTMgPSBUSFJFRS5DdXJ2ZS5jcmVhdGUoXG5cblx0XHRmdW5jdGlvbiAoIHYwLCB2MSwgdjIsIHYzICkge1xuXG5cdFx0XHR0aGlzLnYwID0gdjA7XG5cdFx0XHR0aGlzLnYxID0gdjE7XG5cdFx0XHR0aGlzLnYyID0gdjI7XG5cdFx0XHR0aGlzLnYzID0gdjM7XG5cblx0XHR9LFxuXG5cdFx0ZnVuY3Rpb24gKCB0ICkge1xuXG5cdFx0XHR2YXIgYjMgPSBUSFJFRS5TaGFwZVV0aWxzLmIzO1xuXG5cdFx0XHRyZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjMoXG5cdFx0XHRcdGIzKCB0LCB0aGlzLnYwLngsIHRoaXMudjEueCwgdGhpcy52Mi54LCB0aGlzLnYzLnggKSxcblx0XHRcdFx0YjMoIHQsIHRoaXMudjAueSwgdGhpcy52MS55LCB0aGlzLnYyLnksIHRoaXMudjMueSApLFxuXHRcdFx0XHRiMyggdCwgdGhpcy52MC56LCB0aGlzLnYxLnosIHRoaXMudjIueiwgdGhpcy52My56IClcblx0XHRcdCk7XG5cblx0XHR9XG5cblx0KTtcblxuXHQvLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL1NwbGluZUN1cnZlMy5qc1xuXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHQgKlx0U3BsaW5lIDNEIGN1cnZlXG5cdCAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG5cdFRIUkVFLlNwbGluZUN1cnZlMyA9IFRIUkVFLkN1cnZlLmNyZWF0ZShcblxuXHRcdGZ1bmN0aW9uICggcG9pbnRzIC8qIGFycmF5IG9mIFZlY3RvcjMgKi8gKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlNwbGluZUN1cnZlMyB3aWxsIGJlIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgVEhSRUUuQ2F0bXVsbFJvbUN1cnZlMycgKTtcblx0XHRcdHRoaXMucG9pbnRzID0gKCBwb2ludHMgPT0gdW5kZWZpbmVkICkgPyBbXSA6IHBvaW50cztcblxuXHRcdH0sXG5cblx0XHRmdW5jdGlvbiAoIHQgKSB7XG5cblx0XHRcdHZhciBwb2ludHMgPSB0aGlzLnBvaW50cztcblx0XHRcdHZhciBwb2ludCA9ICggcG9pbnRzLmxlbmd0aCAtIDEgKSAqIHQ7XG5cblx0XHRcdHZhciBpbnRQb2ludCA9IE1hdGguZmxvb3IoIHBvaW50ICk7XG5cdFx0XHR2YXIgd2VpZ2h0ID0gcG9pbnQgLSBpbnRQb2ludDtcblxuXHRcdFx0dmFyIHBvaW50MCA9IHBvaW50c1sgaW50UG9pbnQgPT0gMCA/IGludFBvaW50IDogaW50UG9pbnQgLSAxIF07XG5cdFx0XHR2YXIgcG9pbnQxID0gcG9pbnRzWyBpbnRQb2ludCBdO1xuXHRcdFx0dmFyIHBvaW50MiA9IHBvaW50c1sgaW50UG9pbnQgPiBwb2ludHMubGVuZ3RoIC0gMiA/IHBvaW50cy5sZW5ndGggLSAxIDogaW50UG9pbnQgKyAxIF07XG5cdFx0XHR2YXIgcG9pbnQzID0gcG9pbnRzWyBpbnRQb2ludCA+IHBvaW50cy5sZW5ndGggLSAzID8gcG9pbnRzLmxlbmd0aCAtIDEgOiBpbnRQb2ludCArIDIgXTtcblxuXHRcdFx0dmFyIGludGVycG9sYXRlID0gVEhSRUUuQ3VydmVVdGlscy5pbnRlcnBvbGF0ZTtcblxuXHRcdFx0cmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IzKFxuXHRcdFx0XHRpbnRlcnBvbGF0ZSggcG9pbnQwLngsIHBvaW50MS54LCBwb2ludDIueCwgcG9pbnQzLngsIHdlaWdodCApLFxuXHRcdFx0XHRpbnRlcnBvbGF0ZSggcG9pbnQwLnksIHBvaW50MS55LCBwb2ludDIueSwgcG9pbnQzLnksIHdlaWdodCApLFxuXHRcdFx0XHRpbnRlcnBvbGF0ZSggcG9pbnQwLnosIHBvaW50MS56LCBwb2ludDIueiwgcG9pbnQzLnosIHdlaWdodCApXG5cdFx0XHQpO1xuXG5cdFx0fVxuXG5cdCk7XG5cblx0Ly8gRmlsZTpzcmMvZXh0cmFzL2N1cnZlcy9DYXRtdWxsUm9tQ3VydmUzLmpzXG5cblx0LyoqXG5cdCAqIEBhdXRob3Igeno4NSBodHRwczovL2dpdGh1Yi5jb20veno4NVxuXHQgKlxuXHQgKiBDZW50cmlwZXRhbCBDYXRtdWxsUm9tIEN1cnZlIC0gd2hpY2ggaXMgdXNlZnVsIGZvciBhdm9pZGluZ1xuXHQgKiBjdXNwcyBhbmQgc2VsZi1pbnRlcnNlY3Rpb25zIGluIG5vbi11bmlmb3JtIGNhdG11bGwgcm9tIGN1cnZlcy5cblx0ICogaHR0cDovL3d3dy5jZW15dWtzZWwuY29tL3Jlc2VhcmNoL2NhdG11bGxyb21fcGFyYW0vY2F0bXVsbHJvbS5wZGZcblx0ICpcblx0ICogY3VydmUudHlwZSBhY2NlcHRzIGNlbnRyaXBldGFsKGRlZmF1bHQpLCBjaG9yZGFsIGFuZCBjYXRtdWxscm9tXG5cdCAqIGN1cnZlLnRlbnNpb24gaXMgdXNlZCBmb3IgY2F0bXVsbHJvbSB3aGljaCBkZWZhdWx0cyB0byAwLjVcblx0ICovXG5cblx0VEhSRUUuQ2F0bXVsbFJvbUN1cnZlMyA9ICggZnVuY3Rpb24oKSB7XG5cblx0XHR2YXJcblx0XHRcdHRtcCA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG5cdFx0XHRweCA9IG5ldyBDdWJpY1BvbHkoKSxcblx0XHRcdHB5ID0gbmV3IEN1YmljUG9seSgpLFxuXHRcdFx0cHogPSBuZXcgQ3ViaWNQb2x5KCk7XG5cblx0XHQvKlxuXHRcdEJhc2VkIG9uIGFuIG9wdGltaXplZCBjKysgc29sdXRpb24gaW5cblx0XHQgLSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzk0ODk3MzYvY2F0bXVsbC1yb20tY3VydmUtd2l0aC1uby1jdXNwcy1hbmQtbm8tc2VsZi1pbnRlcnNlY3Rpb25zL1xuXHRcdCAtIGh0dHA6Ly9pZGVvbmUuY29tL05vRWJWTVxuXG5cdFx0VGhpcyBDdWJpY1BvbHkgY2xhc3MgY291bGQgYmUgdXNlZCBmb3IgcmV1c2luZyBzb21lIHZhcmlhYmxlcyBhbmQgY2FsY3VsYXRpb25zLFxuXHRcdGJ1dCBmb3IgdGhyZWUuanMgY3VydmUgdXNlLCBpdCBjb3VsZCBiZSBwb3NzaWJsZSBpbmxpbmVkIGFuZCBmbGF0dGVuIGludG8gYSBzaW5nbGUgZnVuY3Rpb24gY2FsbFxuXHRcdHdoaWNoIGNhbiBiZSBwbGFjZWQgaW4gQ3VydmVVdGlscy5cblx0XHQqL1xuXG5cdFx0ZnVuY3Rpb24gQ3ViaWNQb2x5KCkge1xuXG5cdFx0fVxuXG5cdFx0Lypcblx0XHQgKiBDb21wdXRlIGNvZWZmaWNpZW50cyBmb3IgYSBjdWJpYyBwb2x5bm9taWFsXG5cdFx0ICogICBwKHMpID0gYzAgKyBjMSpzICsgYzIqc14yICsgYzMqc14zXG5cdFx0ICogc3VjaCB0aGF0XG5cdFx0ICogICBwKDApID0geDAsIHAoMSkgPSB4MVxuXHRcdCAqICBhbmRcblx0XHQgKiAgIHAnKDApID0gdDAsIHAnKDEpID0gdDEuXG5cdFx0ICovXG5cdFx0Q3ViaWNQb2x5LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oIHgwLCB4MSwgdDAsIHQxICkge1xuXG5cdFx0XHR0aGlzLmMwID0geDA7XG5cdFx0XHR0aGlzLmMxID0gdDA7XG5cdFx0XHR0aGlzLmMyID0gLSAzICogeDAgKyAzICogeDEgLSAyICogdDAgLSB0MTtcblx0XHRcdHRoaXMuYzMgPSAyICogeDAgLSAyICogeDEgKyB0MCArIHQxO1xuXG5cdFx0fTtcblxuXHRcdEN1YmljUG9seS5wcm90b3R5cGUuaW5pdE5vbnVuaWZvcm1DYXRtdWxsUm9tID0gZnVuY3Rpb24oIHgwLCB4MSwgeDIsIHgzLCBkdDAsIGR0MSwgZHQyICkge1xuXG5cdFx0XHQvLyBjb21wdXRlIHRhbmdlbnRzIHdoZW4gcGFyYW1ldGVyaXplZCBpbiBbdDEsdDJdXG5cdFx0XHR2YXIgdDEgPSAoIHgxIC0geDAgKSAvIGR0MCAtICggeDIgLSB4MCApIC8gKCBkdDAgKyBkdDEgKSArICggeDIgLSB4MSApIC8gZHQxO1xuXHRcdFx0dmFyIHQyID0gKCB4MiAtIHgxICkgLyBkdDEgLSAoIHgzIC0geDEgKSAvICggZHQxICsgZHQyICkgKyAoIHgzIC0geDIgKSAvIGR0MjtcblxuXHRcdFx0Ly8gcmVzY2FsZSB0YW5nZW50cyBmb3IgcGFyYW1ldHJpemF0aW9uIGluIFswLDFdXG5cdFx0XHR0MSAqPSBkdDE7XG5cdFx0XHR0MiAqPSBkdDE7XG5cblx0XHRcdC8vIGluaXRDdWJpY1BvbHlcblx0XHRcdHRoaXMuaW5pdCggeDEsIHgyLCB0MSwgdDIgKTtcblxuXHRcdH07XG5cblx0XHQvLyBzdGFuZGFyZCBDYXRtdWxsLVJvbSBzcGxpbmU6IGludGVycG9sYXRlIGJldHdlZW4geDEgYW5kIHgyIHdpdGggcHJldmlvdXMvZm9sbG93aW5nIHBvaW50cyB4MS94NFxuXHRcdEN1YmljUG9seS5wcm90b3R5cGUuaW5pdENhdG11bGxSb20gPSBmdW5jdGlvbiggeDAsIHgxLCB4MiwgeDMsIHRlbnNpb24gKSB7XG5cblx0XHRcdHRoaXMuaW5pdCggeDEsIHgyLCB0ZW5zaW9uICogKCB4MiAtIHgwICksIHRlbnNpb24gKiAoIHgzIC0geDEgKSApO1xuXG5cdFx0fTtcblxuXHRcdEN1YmljUG9seS5wcm90b3R5cGUuY2FsYyA9IGZ1bmN0aW9uKCB0ICkge1xuXG5cdFx0XHR2YXIgdDIgPSB0ICogdDtcblx0XHRcdHZhciB0MyA9IHQyICogdDtcblx0XHRcdHJldHVybiB0aGlzLmMwICsgdGhpcy5jMSAqIHQgKyB0aGlzLmMyICogdDIgKyB0aGlzLmMzICogdDM7XG5cblx0XHR9O1xuXG5cdFx0Ly8gU3ViY2xhc3MgVGhyZWUuanMgY3VydmVcblx0XHRyZXR1cm4gVEhSRUUuQ3VydmUuY3JlYXRlKFxuXG5cdFx0XHRmdW5jdGlvbiAoIHAgLyogYXJyYXkgb2YgVmVjdG9yMyAqLyApIHtcblxuXHRcdFx0XHR0aGlzLnBvaW50cyA9IHAgfHwgW107XG5cblx0XHRcdH0sXG5cblx0XHRcdGZ1bmN0aW9uICggdCApIHtcblxuXHRcdFx0XHR2YXIgcG9pbnRzID0gdGhpcy5wb2ludHMsXG5cdFx0XHRcdFx0cG9pbnQsIGludFBvaW50LCB3ZWlnaHQsIGw7XG5cblx0XHRcdFx0bCA9IHBvaW50cy5sZW5ndGg7XG5cblx0XHRcdFx0aWYgKCBsIDwgMiApIGNvbnNvbGUubG9nKCAnZHVoLCB5b3UgbmVlZCBhdCBsZWFzdCAyIHBvaW50cycgKTtcblxuXHRcdFx0XHRwb2ludCA9ICggbCAtIDEgKSAqIHQ7XG5cdFx0XHRcdGludFBvaW50ID0gTWF0aC5mbG9vciggcG9pbnQgKTtcblx0XHRcdFx0d2VpZ2h0ID0gcG9pbnQgLSBpbnRQb2ludDtcblxuXHRcdFx0XHRpZiAoIHdlaWdodCA9PT0gMCAmJiBpbnRQb2ludCA9PT0gbCAtIDEgKSB7XG5cblx0XHRcdFx0XHRpbnRQb2ludCA9IGwgLSAyO1xuXHRcdFx0XHRcdHdlaWdodCA9IDE7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBwMCwgcDEsIHAyLCBwMztcblxuXHRcdFx0XHRpZiAoIGludFBvaW50ID09PSAwICkge1xuXG5cdFx0XHRcdFx0Ly8gZXh0cmFwb2xhdGUgZmlyc3QgcG9pbnRcblx0XHRcdFx0XHR0bXAuc3ViVmVjdG9ycyggcG9pbnRzWyAwIF0sIHBvaW50c1sgMSBdICkuYWRkKCBwb2ludHNbIDAgXSApO1xuXHRcdFx0XHRcdHAwID0gdG1wO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRwMCA9IHBvaW50c1sgaW50UG9pbnQgLSAxIF07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHAxID0gcG9pbnRzWyBpbnRQb2ludCBdO1xuXHRcdFx0XHRwMiA9IHBvaW50c1sgaW50UG9pbnQgKyAxIF07XG5cblx0XHRcdFx0aWYgKCBpbnRQb2ludCArIDIgPCBsICkge1xuXG5cdFx0XHRcdFx0cDMgPSBwb2ludHNbIGludFBvaW50ICsgMiBdXG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIGV4dHJhcG9sYXRlIGxhc3QgcG9pbnRcblx0XHRcdFx0XHR0bXAuc3ViVmVjdG9ycyggcG9pbnRzWyBsIC0gMSBdLCBwb2ludHNbIGwgLSAyIF0gKS5hZGQoIHBvaW50c1sgbCAtIDIgXSApO1xuXHRcdFx0XHRcdHAzID0gdG1wO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHRoaXMudHlwZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMudHlwZSA9PT0gJ2NlbnRyaXBldGFsJyB8fCB0aGlzLnR5cGUgPT09ICdjaG9yZGFsJyApIHtcblxuXHRcdFx0XHRcdC8vIGluaXQgQ2VudHJpcGV0YWwgLyBDaG9yZGFsIENhdG11bGwtUm9tXG5cdFx0XHRcdFx0dmFyIHBvdyA9IHRoaXMudHlwZSA9PT0gJ2Nob3JkYWwnID8gMC41IDogMC4yNTtcblx0XHRcdFx0XHR2YXIgZHQwID0gTWF0aC5wb3coIHAwLmRpc3RhbmNlVG9TcXVhcmVkKCBwMSApLCBwb3cgKTtcblx0XHRcdFx0XHR2YXIgZHQxID0gTWF0aC5wb3coIHAxLmRpc3RhbmNlVG9TcXVhcmVkKCBwMiApLCBwb3cgKTtcblx0XHRcdFx0XHR2YXIgZHQyID0gTWF0aC5wb3coIHAyLmRpc3RhbmNlVG9TcXVhcmVkKCBwMyApLCBwb3cgKTtcblxuXHRcdFx0XHRcdC8vIHNhZmV0eSBjaGVjayBmb3IgcmVwZWF0ZWQgcG9pbnRzXG5cdFx0XHRcdFx0aWYgKCBkdDEgPCAxZS00ICkgZHQxID0gMS4wO1xuXHRcdFx0XHRcdGlmICggZHQwIDwgMWUtNCApIGR0MCA9IGR0MTtcblx0XHRcdFx0XHRpZiAoIGR0MiA8IDFlLTQgKSBkdDIgPSBkdDE7XG5cblx0XHRcdFx0XHRweC5pbml0Tm9udW5pZm9ybUNhdG11bGxSb20oIHAwLngsIHAxLngsIHAyLngsIHAzLngsIGR0MCwgZHQxLCBkdDIgKTtcblx0XHRcdFx0XHRweS5pbml0Tm9udW5pZm9ybUNhdG11bGxSb20oIHAwLnksIHAxLnksIHAyLnksIHAzLnksIGR0MCwgZHQxLCBkdDIgKTtcblx0XHRcdFx0XHRwei5pbml0Tm9udW5pZm9ybUNhdG11bGxSb20oIHAwLnosIHAxLnosIHAyLnosIHAzLnosIGR0MCwgZHQxLCBkdDIgKTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCB0aGlzLnR5cGUgPT09ICdjYXRtdWxscm9tJyApIHtcblxuXHRcdFx0XHRcdHZhciB0ZW5zaW9uID0gdGhpcy50ZW5zaW9uICE9PSB1bmRlZmluZWQgPyB0aGlzLnRlbnNpb24gOiAwLjU7XG5cdFx0XHRcdFx0cHguaW5pdENhdG11bGxSb20oIHAwLngsIHAxLngsIHAyLngsIHAzLngsIHRlbnNpb24gKTtcblx0XHRcdFx0XHRweS5pbml0Q2F0bXVsbFJvbSggcDAueSwgcDEueSwgcDIueSwgcDMueSwgdGVuc2lvbiApO1xuXHRcdFx0XHRcdHB6LmluaXRDYXRtdWxsUm9tKCBwMC56LCBwMS56LCBwMi56LCBwMy56LCB0ZW5zaW9uICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciB2ID0gbmV3IFRIUkVFLlZlY3RvcjMoXG5cdFx0XHRcdFx0cHguY2FsYyggd2VpZ2h0ICksXG5cdFx0XHRcdFx0cHkuY2FsYyggd2VpZ2h0ICksXG5cdFx0XHRcdFx0cHouY2FsYyggd2VpZ2h0IClcblx0XHRcdFx0KTtcblxuXHRcdFx0XHRyZXR1cm4gdjtcblxuXHRcdFx0fVxuXG5cdFx0KTtcblxuXHR9ICkoKTtcblxuXHQvLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL0Nsb3NlZFNwbGluZUN1cnZlMy5qc1xuXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHQgKlx0Q2xvc2VkIFNwbGluZSAzRCBjdXJ2ZVxuXHQgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxuXHRUSFJFRS5DbG9zZWRTcGxpbmVDdXJ2ZTMgPSBUSFJFRS5DdXJ2ZS5jcmVhdGUoXG5cblx0XHRmdW5jdGlvbiAoIHBvaW50cyAvKiBhcnJheSBvZiBWZWN0b3IzICovICkge1xuXG5cdFx0XHR0aGlzLnBvaW50cyA9ICggcG9pbnRzID09IHVuZGVmaW5lZCApID8gW10gOiBwb2ludHM7XG5cblx0XHR9LFxuXG5cdFx0ZnVuY3Rpb24gKCB0ICkge1xuXG5cdFx0XHR2YXIgcG9pbnRzID0gdGhpcy5wb2ludHM7XG5cdFx0XHR2YXIgcG9pbnQgPSAoIHBvaW50cy5sZW5ndGggLSAwICkgKiB0OyAvLyBUaGlzIG5lZWRzIHRvIGJlIGZyb20gMC1sZW5ndGggKzFcblxuXHRcdFx0dmFyIGludFBvaW50ID0gTWF0aC5mbG9vciggcG9pbnQgKTtcblx0XHRcdHZhciB3ZWlnaHQgPSBwb2ludCAtIGludFBvaW50O1xuXG5cdFx0XHRpbnRQb2ludCArPSBpbnRQb2ludCA+IDAgPyAwIDogKCBNYXRoLmZsb29yKCBNYXRoLmFicyggaW50UG9pbnQgKSAvIHBvaW50cy5sZW5ndGggKSArIDEgKSAqIHBvaW50cy5sZW5ndGg7XG5cblx0XHRcdHZhciBwb2ludDAgPSBwb2ludHNbICggaW50UG9pbnQgLSAxICkgJSBwb2ludHMubGVuZ3RoIF07XG5cdFx0XHR2YXIgcG9pbnQxID0gcG9pbnRzWyAoIGludFBvaW50ICAgICApICUgcG9pbnRzLmxlbmd0aCBdO1xuXHRcdFx0dmFyIHBvaW50MiA9IHBvaW50c1sgKCBpbnRQb2ludCArIDEgKSAlIHBvaW50cy5sZW5ndGggXTtcblx0XHRcdHZhciBwb2ludDMgPSBwb2ludHNbICggaW50UG9pbnQgKyAyICkgJSBwb2ludHMubGVuZ3RoIF07XG5cblx0XHRcdHZhciBpbnRlcnBvbGF0ZSA9IFRIUkVFLkN1cnZlVXRpbHMuaW50ZXJwb2xhdGU7XG5cblx0XHRcdHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMyhcblx0XHRcdFx0aW50ZXJwb2xhdGUoIHBvaW50MC54LCBwb2ludDEueCwgcG9pbnQyLngsIHBvaW50My54LCB3ZWlnaHQgKSxcblx0XHRcdFx0aW50ZXJwb2xhdGUoIHBvaW50MC55LCBwb2ludDEueSwgcG9pbnQyLnksIHBvaW50My55LCB3ZWlnaHQgKSxcblx0XHRcdFx0aW50ZXJwb2xhdGUoIHBvaW50MC56LCBwb2ludDEueiwgcG9pbnQyLnosIHBvaW50My56LCB3ZWlnaHQgKVxuXHRcdFx0KTtcblxuXHRcdH1cblxuXHQpO1xuXG5cdC8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL0JveEdlb21ldHJ5LmpzXG5cblx0LyoqXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqIGJhc2VkIG9uIGh0dHA6Ly9wYXBlcnZpc2lvbjNkLmdvb2dsZWNvZGUuY29tL3N2bi90cnVuay9hczMvdHJ1bmsvc3JjL29yZy9wYXBlcnZpc2lvbjNkL29iamVjdHMvcHJpbWl0aXZlcy9DdWJlLmFzXG5cdCAqL1xuXG5cdFRIUkVFLkJveEdlb21ldHJ5ID0gZnVuY3Rpb24gKCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCwgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIGRlcHRoU2VnbWVudHMgKSB7XG5cblx0XHRUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cblx0XHR0aGlzLnR5cGUgPSAnQm94R2VvbWV0cnknO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0d2lkdGg6IHdpZHRoLFxuXHRcdFx0aGVpZ2h0OiBoZWlnaHQsXG5cdFx0XHRkZXB0aDogZGVwdGgsXG5cdFx0XHR3aWR0aFNlZ21lbnRzOiB3aWR0aFNlZ21lbnRzLFxuXHRcdFx0aGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzLFxuXHRcdFx0ZGVwdGhTZWdtZW50czogZGVwdGhTZWdtZW50c1xuXHRcdH07XG5cblx0XHR0aGlzLndpZHRoU2VnbWVudHMgPSB3aWR0aFNlZ21lbnRzIHx8IDE7XG5cdFx0dGhpcy5oZWlnaHRTZWdtZW50cyA9IGhlaWdodFNlZ21lbnRzIHx8IDE7XG5cdFx0dGhpcy5kZXB0aFNlZ21lbnRzID0gZGVwdGhTZWdtZW50cyB8fCAxO1xuXG5cdFx0dmFyIHNjb3BlID0gdGhpcztcblxuXHRcdHZhciB3aWR0aF9oYWxmID0gd2lkdGggLyAyO1xuXHRcdHZhciBoZWlnaHRfaGFsZiA9IGhlaWdodCAvIDI7XG5cdFx0dmFyIGRlcHRoX2hhbGYgPSBkZXB0aCAvIDI7XG5cblx0XHRidWlsZFBsYW5lKCAneicsICd5JywgLSAxLCAtIDEsIGRlcHRoLCBoZWlnaHQsIHdpZHRoX2hhbGYsIDAgKTsgLy8gcHhcblx0XHRidWlsZFBsYW5lKCAneicsICd5JywgICAxLCAtIDEsIGRlcHRoLCBoZWlnaHQsIC0gd2lkdGhfaGFsZiwgMSApOyAvLyBueFxuXHRcdGJ1aWxkUGxhbmUoICd4JywgJ3onLCAgIDEsICAgMSwgd2lkdGgsIGRlcHRoLCBoZWlnaHRfaGFsZiwgMiApOyAvLyBweVxuXHRcdGJ1aWxkUGxhbmUoICd4JywgJ3onLCAgIDEsIC0gMSwgd2lkdGgsIGRlcHRoLCAtIGhlaWdodF9oYWxmLCAzICk7IC8vIG55XG5cdFx0YnVpbGRQbGFuZSggJ3gnLCAneScsICAgMSwgLSAxLCB3aWR0aCwgaGVpZ2h0LCBkZXB0aF9oYWxmLCA0ICk7IC8vIHB6XG5cdFx0YnVpbGRQbGFuZSggJ3gnLCAneScsIC0gMSwgLSAxLCB3aWR0aCwgaGVpZ2h0LCAtIGRlcHRoX2hhbGYsIDUgKTsgLy8gbnpcblxuXHRcdGZ1bmN0aW9uIGJ1aWxkUGxhbmUoIHUsIHYsIHVkaXIsIHZkaXIsIHdpZHRoLCBoZWlnaHQsIGRlcHRoLCBtYXRlcmlhbEluZGV4ICkge1xuXG5cdFx0XHR2YXIgdywgaXgsIGl5LFxuXHRcdFx0Z3JpZFggPSBzY29wZS53aWR0aFNlZ21lbnRzLFxuXHRcdFx0Z3JpZFkgPSBzY29wZS5oZWlnaHRTZWdtZW50cyxcblx0XHRcdHdpZHRoX2hhbGYgPSB3aWR0aCAvIDIsXG5cdFx0XHRoZWlnaHRfaGFsZiA9IGhlaWdodCAvIDIsXG5cdFx0XHRvZmZzZXQgPSBzY29wZS52ZXJ0aWNlcy5sZW5ndGg7XG5cblx0XHRcdGlmICggKCB1ID09PSAneCcgJiYgdiA9PT0gJ3knICkgfHwgKCB1ID09PSAneScgJiYgdiA9PT0gJ3gnICkgKSB7XG5cblx0XHRcdFx0dyA9ICd6JztcblxuXHRcdFx0fSBlbHNlIGlmICggKCB1ID09PSAneCcgJiYgdiA9PT0gJ3onICkgfHwgKCB1ID09PSAneicgJiYgdiA9PT0gJ3gnICkgKSB7XG5cblx0XHRcdFx0dyA9ICd5Jztcblx0XHRcdFx0Z3JpZFkgPSBzY29wZS5kZXB0aFNlZ21lbnRzO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCAoIHUgPT09ICd6JyAmJiB2ID09PSAneScgKSB8fCAoIHUgPT09ICd5JyAmJiB2ID09PSAneicgKSApIHtcblxuXHRcdFx0XHR3ID0gJ3gnO1xuXHRcdFx0XHRncmlkWCA9IHNjb3BlLmRlcHRoU2VnbWVudHM7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIGdyaWRYMSA9IGdyaWRYICsgMSxcblx0XHRcdGdyaWRZMSA9IGdyaWRZICsgMSxcblx0XHRcdHNlZ21lbnRfd2lkdGggPSB3aWR0aCAvIGdyaWRYLFxuXHRcdFx0c2VnbWVudF9oZWlnaHQgPSBoZWlnaHQgLyBncmlkWSxcblx0XHRcdG5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRcdG5vcm1hbFsgdyBdID0gZGVwdGggPiAwID8gMSA6IC0gMTtcblxuXHRcdFx0Zm9yICggaXkgPSAwOyBpeSA8IGdyaWRZMTsgaXkgKysgKSB7XG5cblx0XHRcdFx0Zm9yICggaXggPSAwOyBpeCA8IGdyaWRYMTsgaXggKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHRcdFx0XHR2ZWN0b3JbIHUgXSA9ICggaXggKiBzZWdtZW50X3dpZHRoIC0gd2lkdGhfaGFsZiApICogdWRpcjtcblx0XHRcdFx0XHR2ZWN0b3JbIHYgXSA9ICggaXkgKiBzZWdtZW50X2hlaWdodCAtIGhlaWdodF9oYWxmICkgKiB2ZGlyO1xuXHRcdFx0XHRcdHZlY3RvclsgdyBdID0gZGVwdGg7XG5cblx0XHRcdFx0XHRzY29wZS52ZXJ0aWNlcy5wdXNoKCB2ZWN0b3IgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggaXkgPSAwOyBpeSA8IGdyaWRZOyBpeSArKyApIHtcblxuXHRcdFx0XHRmb3IgKCBpeCA9IDA7IGl4IDwgZ3JpZFg7IGl4ICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIGEgPSBpeCArIGdyaWRYMSAqIGl5O1xuXHRcdFx0XHRcdHZhciBiID0gaXggKyBncmlkWDEgKiAoIGl5ICsgMSApO1xuXHRcdFx0XHRcdHZhciBjID0gKCBpeCArIDEgKSArIGdyaWRYMSAqICggaXkgKyAxICk7XG5cdFx0XHRcdFx0dmFyIGQgPSAoIGl4ICsgMSApICsgZ3JpZFgxICogaXk7XG5cblx0XHRcdFx0XHR2YXIgdXZhID0gbmV3IFRIUkVFLlZlY3RvcjIoIGl4IC8gZ3JpZFgsIDEgLSBpeSAvIGdyaWRZICk7XG5cdFx0XHRcdFx0dmFyIHV2YiA9IG5ldyBUSFJFRS5WZWN0b3IyKCBpeCAvIGdyaWRYLCAxIC0gKCBpeSArIDEgKSAvIGdyaWRZICk7XG5cdFx0XHRcdFx0dmFyIHV2YyA9IG5ldyBUSFJFRS5WZWN0b3IyKCAoIGl4ICsgMSApIC8gZ3JpZFgsIDEgLSAoIGl5ICsgMSApIC8gZ3JpZFkgKTtcblx0XHRcdFx0XHR2YXIgdXZkID0gbmV3IFRIUkVFLlZlY3RvcjIoICggaXggKyAxICkgLyBncmlkWCwgMSAtIGl5IC8gZ3JpZFkgKTtcblxuXHRcdFx0XHRcdHZhciBmYWNlID0gbmV3IFRIUkVFLkZhY2UzKCBhICsgb2Zmc2V0LCBiICsgb2Zmc2V0LCBkICsgb2Zmc2V0ICk7XG5cdFx0XHRcdFx0ZmFjZS5ub3JtYWwuY29weSggbm9ybWFsICk7XG5cdFx0XHRcdFx0ZmFjZS52ZXJ0ZXhOb3JtYWxzLnB1c2goIG5vcm1hbC5jbG9uZSgpLCBub3JtYWwuY2xvbmUoKSwgbm9ybWFsLmNsb25lKCkgKTtcblx0XHRcdFx0XHRmYWNlLm1hdGVyaWFsSW5kZXggPSBtYXRlcmlhbEluZGV4O1xuXG5cdFx0XHRcdFx0c2NvcGUuZmFjZXMucHVzaCggZmFjZSApO1xuXHRcdFx0XHRcdHNjb3BlLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2YSwgdXZiLCB1dmQgXSApO1xuXG5cdFx0XHRcdFx0ZmFjZSA9IG5ldyBUSFJFRS5GYWNlMyggYiArIG9mZnNldCwgYyArIG9mZnNldCwgZCArIG9mZnNldCApO1xuXHRcdFx0XHRcdGZhY2Uubm9ybWFsLmNvcHkoIG5vcm1hbCApO1xuXHRcdFx0XHRcdGZhY2UudmVydGV4Tm9ybWFscy5wdXNoKCBub3JtYWwuY2xvbmUoKSwgbm9ybWFsLmNsb25lKCksIG5vcm1hbC5jbG9uZSgpICk7XG5cdFx0XHRcdFx0ZmFjZS5tYXRlcmlhbEluZGV4ID0gbWF0ZXJpYWxJbmRleDtcblxuXHRcdFx0XHRcdHNjb3BlLmZhY2VzLnB1c2goIGZhY2UgKTtcblx0XHRcdFx0XHRzY29wZS5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1dmIuY2xvbmUoKSwgdXZjLCB1dmQuY2xvbmUoKSBdICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHR0aGlzLm1lcmdlVmVydGljZXMoKTtcblxuXHR9O1xuXG5cdFRIUkVFLkJveEdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xuXHRUSFJFRS5Cb3hHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Cb3hHZW9tZXRyeTtcblxuXHRUSFJFRS5Cb3hHZW9tZXRyeS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgcGFyYW1ldGVycyA9IHRoaXMucGFyYW1ldGVycztcblxuXHRcdHJldHVybiBuZXcgVEhSRUUuQm94R2VvbWV0cnkoXG5cdFx0XHRwYXJhbWV0ZXJzLndpZHRoLFxuXHRcdFx0cGFyYW1ldGVycy5oZWlnaHQsXG5cdFx0XHRwYXJhbWV0ZXJzLmRlcHRoLFxuXHRcdFx0cGFyYW1ldGVycy53aWR0aFNlZ21lbnRzLFxuXHRcdFx0cGFyYW1ldGVycy5oZWlnaHRTZWdtZW50cyxcblx0XHRcdHBhcmFtZXRlcnMuZGVwdGhTZWdtZW50c1xuXHRcdCk7XG5cblx0fTtcblxuXHRUSFJFRS5DdWJlR2VvbWV0cnkgPSBUSFJFRS5Cb3hHZW9tZXRyeTsgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblxuXHQvLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9DaXJjbGVHZW9tZXRyeS5qc1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIGh1Z2hlc1xuXHQgKi9cblxuXHRUSFJFRS5DaXJjbGVHZW9tZXRyeSA9IGZ1bmN0aW9uICggcmFkaXVzLCBzZWdtZW50cywgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSB7XG5cblx0XHRUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cblx0XHR0aGlzLnR5cGUgPSAnQ2lyY2xlR2VvbWV0cnknO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0XHRzZWdtZW50czogc2VnbWVudHMsXG5cdFx0XHR0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxuXHRcdFx0dGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXG5cdFx0fTtcblxuXHRcdHRoaXMuZnJvbUJ1ZmZlckdlb21ldHJ5KCBuZXcgVEhSRUUuQ2lyY2xlQnVmZmVyR2VvbWV0cnkoIHJhZGl1cywgc2VnbWVudHMsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkgKTtcblxuXHR9O1xuXG5cdFRIUkVFLkNpcmNsZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xuXHRUSFJFRS5DaXJjbGVHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5DaXJjbGVHZW9tZXRyeTtcblxuXHRUSFJFRS5DaXJjbGVHZW9tZXRyeS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgcGFyYW1ldGVycyA9IHRoaXMucGFyYW1ldGVycztcblxuXHRcdHJldHVybiBuZXcgVEhSRUUuQ2lyY2xlR2VvbWV0cnkoXG5cdFx0XHRwYXJhbWV0ZXJzLnJhZGl1cyxcblx0XHRcdHBhcmFtZXRlcnMuc2VnbWVudHMsXG5cdFx0XHRwYXJhbWV0ZXJzLnRoZXRhU3RhcnQsXG5cdFx0XHRwYXJhbWV0ZXJzLnRoZXRhTGVuZ3RoXG5cdFx0KTtcblxuXHR9O1xuXG5cdC8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL0NpcmNsZUJ1ZmZlckdlb21ldHJ5LmpzXG5cblx0LyoqXG5cdCAqIEBhdXRob3IgYmVuYWFkYW1zIC8gaHR0cHM6Ly90d2l0dGVyLmNvbS9iZW5fYV9hZGFtc1xuXHQgKi9cblxuXHRUSFJFRS5DaXJjbGVCdWZmZXJHZW9tZXRyeSA9IGZ1bmN0aW9uICggcmFkaXVzLCBzZWdtZW50cywgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSB7XG5cblx0XHRUSFJFRS5CdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cblx0XHR0aGlzLnR5cGUgPSAnQ2lyY2xlQnVmZmVyR2VvbWV0cnknO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0XHRzZWdtZW50czogc2VnbWVudHMsXG5cdFx0XHR0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxuXHRcdFx0dGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXG5cdFx0fTtcblxuXHRcdHJhZGl1cyA9IHJhZGl1cyB8fCA1MDtcblx0XHRzZWdtZW50cyA9IHNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBNYXRoLm1heCggMywgc2VnbWVudHMgKSA6IDg7XG5cblx0XHR0aGV0YVN0YXJ0ID0gdGhldGFTdGFydCAhPT0gdW5kZWZpbmVkID8gdGhldGFTdGFydCA6IDA7XG5cdFx0dGhldGFMZW5ndGggPSB0aGV0YUxlbmd0aCAhPT0gdW5kZWZpbmVkID8gdGhldGFMZW5ndGggOiBNYXRoLlBJICogMjtcblxuXHRcdHZhciB2ZXJ0aWNlcyA9IHNlZ21lbnRzICsgMjtcblxuXHRcdHZhciBwb3NpdGlvbnMgPSBuZXcgRmxvYXQzMkFycmF5KCB2ZXJ0aWNlcyAqIDMgKTtcblx0XHR2YXIgbm9ybWFscyA9IG5ldyBGbG9hdDMyQXJyYXkoIHZlcnRpY2VzICogMyApO1xuXHRcdHZhciB1dnMgPSBuZXcgRmxvYXQzMkFycmF5KCB2ZXJ0aWNlcyAqIDIgKTtcblxuXHRcdC8vIGNlbnRlciBkYXRhIGlzIGFscmVhZHkgemVybywgYnV0IG5lZWQgdG8gc2V0IGEgZmV3IGV4dHJhc1xuXHRcdG5vcm1hbHNbIDIgXSA9IDEuMDtcblx0XHR1dnNbIDAgXSA9IDAuNTtcblx0XHR1dnNbIDEgXSA9IDAuNTtcblxuXHRcdGZvciAoIHZhciBzID0gMCwgaSA9IDMsIGlpID0gMiA7IHMgPD0gc2VnbWVudHM7IHMgKyssIGkgKz0gMywgaWkgKz0gMiApIHtcblxuXHRcdFx0dmFyIHNlZ21lbnQgPSB0aGV0YVN0YXJ0ICsgcyAvIHNlZ21lbnRzICogdGhldGFMZW5ndGg7XG5cblx0XHRcdHBvc2l0aW9uc1sgaSBdID0gcmFkaXVzICogTWF0aC5jb3MoIHNlZ21lbnQgKTtcblx0XHRcdHBvc2l0aW9uc1sgaSArIDEgXSA9IHJhZGl1cyAqIE1hdGguc2luKCBzZWdtZW50ICk7XG5cblx0XHRcdG5vcm1hbHNbIGkgKyAyIF0gPSAxOyAvLyBub3JtYWwgelxuXG5cdFx0XHR1dnNbIGlpIF0gPSAoIHBvc2l0aW9uc1sgaSBdIC8gcmFkaXVzICsgMSApIC8gMjtcblx0XHRcdHV2c1sgaWkgKyAxIF0gPSAoIHBvc2l0aW9uc1sgaSArIDEgXSAvIHJhZGl1cyArIDEgKSAvIDI7XG5cblx0XHR9XG5cblx0XHR2YXIgaW5kaWNlcyA9IFtdO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAxOyBpIDw9IHNlZ21lbnRzOyBpICsrICkge1xuXG5cdFx0XHRpbmRpY2VzLnB1c2goIGksIGkgKyAxLCAwICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLnNldEluZGV4KCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgVWludDE2QXJyYXkoIGluZGljZXMgKSwgMSApICk7XG5cdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9ucywgMyApICk7XG5cdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkgKTtcblx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3V2JywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcblxuXHRcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgVEhSRUUuU3BoZXJlKCBuZXcgVEhSRUUuVmVjdG9yMygpLCByYWRpdXMgKTtcblxuXHR9O1xuXG5cdFRIUkVFLkNpcmNsZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xuXHRUSFJFRS5DaXJjbGVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5DaXJjbGVCdWZmZXJHZW9tZXRyeTtcblxuXHRUSFJFRS5DaXJjbGVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgcGFyYW1ldGVycyA9IHRoaXMucGFyYW1ldGVycztcblxuXHRcdHJldHVybiBuZXcgVEhSRUUuQ2lyY2xlQnVmZmVyR2VvbWV0cnkoXG5cdFx0XHRwYXJhbWV0ZXJzLnJhZGl1cyxcblx0XHRcdHBhcmFtZXRlcnMuc2VnbWVudHMsXG5cdFx0XHRwYXJhbWV0ZXJzLnRoZXRhU3RhcnQsXG5cdFx0XHRwYXJhbWV0ZXJzLnRoZXRhTGVuZ3RoXG5cdFx0KTtcblxuXHR9O1xuXG5cdC8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL0N5bGluZGVyR2VvbWV0cnkuanNcblxuXHQvKipcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICovXG5cblx0VEhSRUUuQ3lsaW5kZXJHZW9tZXRyeSA9IGZ1bmN0aW9uICggcmFkaXVzVG9wLCByYWRpdXNCb3R0b20sIGhlaWdodCwgcmFkaWFsU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCBvcGVuRW5kZWQsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkge1xuXG5cdFx0VEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG5cdFx0dGhpcy50eXBlID0gJ0N5bGluZGVyR2VvbWV0cnknO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0cmFkaXVzVG9wOiByYWRpdXNUb3AsXG5cdFx0XHRyYWRpdXNCb3R0b206IHJhZGl1c0JvdHRvbSxcblx0XHRcdGhlaWdodDogaGVpZ2h0LFxuXHRcdFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxuXHRcdFx0aGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzLFxuXHRcdFx0b3BlbkVuZGVkOiBvcGVuRW5kZWQsXG5cdFx0XHR0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxuXHRcdFx0dGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXG5cdFx0fTtcblxuXHRcdHJhZGl1c1RvcCA9IHJhZGl1c1RvcCAhPT0gdW5kZWZpbmVkID8gcmFkaXVzVG9wIDogMjA7XG5cdFx0cmFkaXVzQm90dG9tID0gcmFkaXVzQm90dG9tICE9PSB1bmRlZmluZWQgPyByYWRpdXNCb3R0b20gOiAyMDtcblx0XHRoZWlnaHQgPSBoZWlnaHQgIT09IHVuZGVmaW5lZCA/IGhlaWdodCA6IDEwMDtcblxuXHRcdHJhZGlhbFNlZ21lbnRzID0gcmFkaWFsU2VnbWVudHMgfHwgODtcblx0XHRoZWlnaHRTZWdtZW50cyA9IGhlaWdodFNlZ21lbnRzIHx8IDE7XG5cblx0XHRvcGVuRW5kZWQgPSBvcGVuRW5kZWQgIT09IHVuZGVmaW5lZCA/IG9wZW5FbmRlZCA6IGZhbHNlO1xuXHRcdHRoZXRhU3RhcnQgPSB0aGV0YVN0YXJ0ICE9PSB1bmRlZmluZWQgPyB0aGV0YVN0YXJ0IDogMDtcblx0XHR0aGV0YUxlbmd0aCA9IHRoZXRhTGVuZ3RoICE9PSB1bmRlZmluZWQgPyB0aGV0YUxlbmd0aCA6IDIgKiBNYXRoLlBJO1xuXG5cdFx0dmFyIGhlaWdodEhhbGYgPSBoZWlnaHQgLyAyO1xuXG5cdFx0dmFyIHgsIHksIHZlcnRpY2VzID0gW10sIHV2cyA9IFtdO1xuXG5cdFx0Zm9yICggeSA9IDA7IHkgPD0gaGVpZ2h0U2VnbWVudHM7IHkgKysgKSB7XG5cblx0XHRcdHZhciB2ZXJ0aWNlc1JvdyA9IFtdO1xuXHRcdFx0dmFyIHV2c1JvdyA9IFtdO1xuXG5cdFx0XHR2YXIgdiA9IHkgLyBoZWlnaHRTZWdtZW50cztcblx0XHRcdHZhciByYWRpdXMgPSB2ICogKCByYWRpdXNCb3R0b20gLSByYWRpdXNUb3AgKSArIHJhZGl1c1RvcDtcblxuXHRcdFx0Zm9yICggeCA9IDA7IHggPD0gcmFkaWFsU2VnbWVudHM7IHggKysgKSB7XG5cblx0XHRcdFx0dmFyIHUgPSB4IC8gcmFkaWFsU2VnbWVudHM7XG5cblx0XHRcdFx0dmFyIHZlcnRleCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0XHRcdHZlcnRleC54ID0gcmFkaXVzICogTWF0aC5zaW4oIHUgKiB0aGV0YUxlbmd0aCArIHRoZXRhU3RhcnQgKTtcblx0XHRcdFx0dmVydGV4LnkgPSAtIHYgKiBoZWlnaHQgKyBoZWlnaHRIYWxmO1xuXHRcdFx0XHR2ZXJ0ZXgueiA9IHJhZGl1cyAqIE1hdGguY29zKCB1ICogdGhldGFMZW5ndGggKyB0aGV0YVN0YXJ0ICk7XG5cblx0XHRcdFx0dGhpcy52ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXggKTtcblxuXHRcdFx0XHR2ZXJ0aWNlc1Jvdy5wdXNoKCB0aGlzLnZlcnRpY2VzLmxlbmd0aCAtIDEgKTtcblx0XHRcdFx0dXZzUm93LnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCB1LCAxIC0gdiApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dmVydGljZXMucHVzaCggdmVydGljZXNSb3cgKTtcblx0XHRcdHV2cy5wdXNoKCB1dnNSb3cgKTtcblxuXHRcdH1cblxuXHRcdHZhciB0YW5UaGV0YSA9ICggcmFkaXVzQm90dG9tIC0gcmFkaXVzVG9wICkgLyBoZWlnaHQ7XG5cdFx0dmFyIG5hLCBuYjtcblxuXHRcdGZvciAoIHggPSAwOyB4IDwgcmFkaWFsU2VnbWVudHM7IHggKysgKSB7XG5cblx0XHRcdGlmICggcmFkaXVzVG9wICE9PSAwICkge1xuXG5cdFx0XHRcdG5hID0gdGhpcy52ZXJ0aWNlc1sgdmVydGljZXNbIDAgXVsgeCBdIF0uY2xvbmUoKTtcblx0XHRcdFx0bmIgPSB0aGlzLnZlcnRpY2VzWyB2ZXJ0aWNlc1sgMCBdWyB4ICsgMSBdIF0uY2xvbmUoKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRuYSA9IHRoaXMudmVydGljZXNbIHZlcnRpY2VzWyAxIF1bIHggXSBdLmNsb25lKCk7XG5cdFx0XHRcdG5iID0gdGhpcy52ZXJ0aWNlc1sgdmVydGljZXNbIDEgXVsgeCArIDEgXSBdLmNsb25lKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0bmEuc2V0WSggTWF0aC5zcXJ0KCBuYS54ICogbmEueCArIG5hLnogKiBuYS56ICkgKiB0YW5UaGV0YSApLm5vcm1hbGl6ZSgpO1xuXHRcdFx0bmIuc2V0WSggTWF0aC5zcXJ0KCBuYi54ICogbmIueCArIG5iLnogKiBuYi56ICkgKiB0YW5UaGV0YSApLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHRmb3IgKCB5ID0gMDsgeSA8IGhlaWdodFNlZ21lbnRzOyB5ICsrICkge1xuXG5cdFx0XHRcdHZhciB2MSA9IHZlcnRpY2VzWyB5IF1bIHggXTtcblx0XHRcdFx0dmFyIHYyID0gdmVydGljZXNbIHkgKyAxIF1bIHggXTtcblx0XHRcdFx0dmFyIHYzID0gdmVydGljZXNbIHkgKyAxIF1bIHggKyAxIF07XG5cdFx0XHRcdHZhciB2NCA9IHZlcnRpY2VzWyB5IF1bIHggKyAxIF07XG5cblx0XHRcdFx0dmFyIG4xID0gbmEuY2xvbmUoKTtcblx0XHRcdFx0dmFyIG4yID0gbmEuY2xvbmUoKTtcblx0XHRcdFx0dmFyIG4zID0gbmIuY2xvbmUoKTtcblx0XHRcdFx0dmFyIG40ID0gbmIuY2xvbmUoKTtcblxuXHRcdFx0XHR2YXIgdXYxID0gdXZzWyB5IF1bIHggXS5jbG9uZSgpO1xuXHRcdFx0XHR2YXIgdXYyID0gdXZzWyB5ICsgMSBdWyB4IF0uY2xvbmUoKTtcblx0XHRcdFx0dmFyIHV2MyA9IHV2c1sgeSArIDEgXVsgeCArIDEgXS5jbG9uZSgpO1xuXHRcdFx0XHR2YXIgdXY0ID0gdXZzWyB5IF1bIHggKyAxIF0uY2xvbmUoKTtcblxuXHRcdFx0XHR0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggdjEsIHYyLCB2NCwgWyBuMSwgbjIsIG40IF0gKSApO1xuXHRcdFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2MSwgdXYyLCB1djQgXSApO1xuXG5cdFx0XHRcdHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCB2MiwgdjMsIHY0LCBbIG4yLmNsb25lKCksIG4zLCBuNC5jbG9uZSgpIF0gKSApO1xuXHRcdFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2Mi5jbG9uZSgpLCB1djMsIHV2NC5jbG9uZSgpIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gdG9wIGNhcFxuXG5cdFx0aWYgKCBvcGVuRW5kZWQgPT09IGZhbHNlICYmIHJhZGl1c1RvcCA+IDAgKSB7XG5cblx0XHRcdHRoaXMudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoIDAsIGhlaWdodEhhbGYsIDAgKSApO1xuXG5cdFx0XHRmb3IgKCB4ID0gMDsgeCA8IHJhZGlhbFNlZ21lbnRzOyB4ICsrICkge1xuXG5cdFx0XHRcdHZhciB2MSA9IHZlcnRpY2VzWyAwIF1bIHggXTtcblx0XHRcdFx0dmFyIHYyID0gdmVydGljZXNbIDAgXVsgeCArIDEgXTtcblx0XHRcdFx0dmFyIHYzID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGggLSAxO1xuXG5cdFx0XHRcdHZhciBuMSA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICk7XG5cdFx0XHRcdHZhciBuMiA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICk7XG5cdFx0XHRcdHZhciBuMyA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICk7XG5cblx0XHRcdFx0dmFyIHV2MSA9IHV2c1sgMCBdWyB4IF0uY2xvbmUoKTtcblx0XHRcdFx0dmFyIHV2MiA9IHV2c1sgMCBdWyB4ICsgMSBdLmNsb25lKCk7XG5cdFx0XHRcdHZhciB1djMgPSBuZXcgVEhSRUUuVmVjdG9yMiggdXYyLngsIDAgKTtcblxuXHRcdFx0XHR0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggdjEsIHYyLCB2MywgWyBuMSwgbjIsIG4zIF0sIHVuZGVmaW5lZCwgMSApICk7XG5cdFx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXYxLCB1djIsIHV2MyBdICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIGJvdHRvbSBjYXBcblxuXHRcdGlmICggb3BlbkVuZGVkID09PSBmYWxzZSAmJiByYWRpdXNCb3R0b20gPiAwICkge1xuXG5cdFx0XHR0aGlzLnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAtIGhlaWdodEhhbGYsIDAgKSApO1xuXG5cdFx0XHRmb3IgKCB4ID0gMDsgeCA8IHJhZGlhbFNlZ21lbnRzOyB4ICsrICkge1xuXG5cdFx0XHRcdHZhciB2MSA9IHZlcnRpY2VzWyBoZWlnaHRTZWdtZW50cyBdWyB4ICsgMSBdO1xuXHRcdFx0XHR2YXIgdjIgPSB2ZXJ0aWNlc1sgaGVpZ2h0U2VnbWVudHMgXVsgeCBdO1xuXHRcdFx0XHR2YXIgdjMgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aCAtIDE7XG5cblx0XHRcdFx0dmFyIG4xID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIC0gMSwgMCApO1xuXHRcdFx0XHR2YXIgbjIgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgLSAxLCAwICk7XG5cdFx0XHRcdHZhciBuMyA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAtIDEsIDAgKTtcblxuXHRcdFx0XHR2YXIgdXYxID0gdXZzWyBoZWlnaHRTZWdtZW50cyBdWyB4ICsgMSBdLmNsb25lKCk7XG5cdFx0XHRcdHZhciB1djIgPSB1dnNbIGhlaWdodFNlZ21lbnRzIF1bIHggXS5jbG9uZSgpO1xuXHRcdFx0XHR2YXIgdXYzID0gbmV3IFRIUkVFLlZlY3RvcjIoIHV2Mi54LCAxICk7XG5cblx0XHRcdFx0dGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIHYxLCB2MiwgdjMsIFsgbjEsIG4yLCBuMyBdLCB1bmRlZmluZWQsIDIgKSApO1xuXHRcdFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2MSwgdXYyLCB1djMgXSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHR0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xuXG5cdH07XG5cblx0VEhSRUUuQ3lsaW5kZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcblx0VEhSRUUuQ3lsaW5kZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5DeWxpbmRlckdlb21ldHJ5O1xuXG5cdFRIUkVFLkN5bGluZGVyR2VvbWV0cnkucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHBhcmFtZXRlcnMgPSB0aGlzLnBhcmFtZXRlcnM7XG5cblx0XHRyZXR1cm4gbmV3IFRIUkVFLkN5bGluZGVyR2VvbWV0cnkoXG5cdFx0XHRwYXJhbWV0ZXJzLnJhZGl1c1RvcCxcblx0XHRcdHBhcmFtZXRlcnMucmFkaXVzQm90dG9tLFxuXHRcdFx0cGFyYW1ldGVycy5oZWlnaHQsXG5cdFx0XHRwYXJhbWV0ZXJzLnJhZGlhbFNlZ21lbnRzLFxuXHRcdFx0cGFyYW1ldGVycy5oZWlnaHRTZWdtZW50cyxcblx0XHRcdHBhcmFtZXRlcnMub3BlbkVuZGVkLFxuXHRcdFx0cGFyYW1ldGVycy50aGV0YVN0YXJ0LFxuXHRcdFx0cGFyYW1ldGVycy50aGV0YUxlbmd0aFxuXHRcdCk7XG5cblx0fTtcblxuXHQvLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9FZGdlc0dlb21ldHJ5LmpzXG5cblx0LyoqXG5cdCAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuXHQgKi9cblxuXHRUSFJFRS5FZGdlc0dlb21ldHJ5ID0gZnVuY3Rpb24gKCBnZW9tZXRyeSwgdGhyZXNob2xkQW5nbGUgKSB7XG5cblx0XHRUSFJFRS5CdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cblx0XHR0aHJlc2hvbGRBbmdsZSA9ICggdGhyZXNob2xkQW5nbGUgIT09IHVuZGVmaW5lZCApID8gdGhyZXNob2xkQW5nbGUgOiAxO1xuXG5cdFx0dmFyIHRocmVzaG9sZERvdCA9IE1hdGguY29zKCBUSFJFRS5NYXRoLmRlZ1RvUmFkKCB0aHJlc2hvbGRBbmdsZSApICk7XG5cblx0XHR2YXIgZWRnZSA9IFsgMCwgMCBdLCBoYXNoID0ge307XG5cblx0XHRmdW5jdGlvbiBzb3J0RnVuY3Rpb24oIGEsIGIgKSB7XG5cblx0XHRcdHJldHVybiBhIC0gYjtcblxuXHRcdH1cblxuXHRcdHZhciBrZXlzID0gWyAnYScsICdiJywgJ2MnIF07XG5cblx0XHR2YXIgZ2VvbWV0cnkyO1xuXG5cdFx0aWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5ICkge1xuXG5cdFx0XHRnZW9tZXRyeTIgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcblx0XHRcdGdlb21ldHJ5Mi5mcm9tQnVmZmVyR2VvbWV0cnkoIGdlb21ldHJ5ICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRnZW9tZXRyeTIgPSBnZW9tZXRyeS5jbG9uZSgpO1xuXG5cdFx0fVxuXG5cdFx0Z2VvbWV0cnkyLm1lcmdlVmVydGljZXMoKTtcblx0XHRnZW9tZXRyeTIuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG5cblx0XHR2YXIgdmVydGljZXMgPSBnZW9tZXRyeTIudmVydGljZXM7XG5cdFx0dmFyIGZhY2VzID0gZ2VvbWV0cnkyLmZhY2VzO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gZmFjZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0dmFyIGZhY2UgPSBmYWNlc1sgaSBdO1xuXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCAzOyBqICsrICkge1xuXG5cdFx0XHRcdGVkZ2VbIDAgXSA9IGZhY2VbIGtleXNbIGogXSBdO1xuXHRcdFx0XHRlZGdlWyAxIF0gPSBmYWNlWyBrZXlzWyAoIGogKyAxICkgJSAzIF0gXTtcblx0XHRcdFx0ZWRnZS5zb3J0KCBzb3J0RnVuY3Rpb24gKTtcblxuXHRcdFx0XHR2YXIga2V5ID0gZWRnZS50b1N0cmluZygpO1xuXG5cdFx0XHRcdGlmICggaGFzaFsga2V5IF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGhhc2hbIGtleSBdID0geyB2ZXJ0MTogZWRnZVsgMCBdLCB2ZXJ0MjogZWRnZVsgMSBdLCBmYWNlMTogaSwgZmFjZTI6IHVuZGVmaW5lZCB9O1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRoYXNoWyBrZXkgXS5mYWNlMiA9IGk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHR2YXIgY29vcmRzID0gW107XG5cblx0XHRmb3IgKCB2YXIga2V5IGluIGhhc2ggKSB7XG5cblx0XHRcdHZhciBoID0gaGFzaFsga2V5IF07XG5cblx0XHRcdGlmICggaC5mYWNlMiA9PT0gdW5kZWZpbmVkIHx8IGZhY2VzWyBoLmZhY2UxIF0ubm9ybWFsLmRvdCggZmFjZXNbIGguZmFjZTIgXS5ub3JtYWwgKSA8PSB0aHJlc2hvbGREb3QgKSB7XG5cblx0XHRcdFx0dmFyIHZlcnRleCA9IHZlcnRpY2VzWyBoLnZlcnQxIF07XG5cdFx0XHRcdGNvb3Jkcy5wdXNoKCB2ZXJ0ZXgueCApO1xuXHRcdFx0XHRjb29yZHMucHVzaCggdmVydGV4LnkgKTtcblx0XHRcdFx0Y29vcmRzLnB1c2goIHZlcnRleC56ICk7XG5cblx0XHRcdFx0dmVydGV4ID0gdmVydGljZXNbIGgudmVydDIgXTtcblx0XHRcdFx0Y29vcmRzLnB1c2goIHZlcnRleC54ICk7XG5cdFx0XHRcdGNvb3Jkcy5wdXNoKCB2ZXJ0ZXgueSApO1xuXHRcdFx0XHRjb29yZHMucHVzaCggdmVydGV4LnogKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBGbG9hdDMyQXJyYXkoIGNvb3JkcyApLCAzICkgKTtcblxuXHR9O1xuXG5cdFRIUkVFLkVkZ2VzR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XG5cdFRIUkVFLkVkZ2VzR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuRWRnZXNHZW9tZXRyeTtcblxuXHQvLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9FeHRydWRlR2VvbWV0cnkuanNcblxuXHQvKipcblx0ICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xuXHQgKlxuXHQgKiBDcmVhdGVzIGV4dHJ1ZGVkIGdlb21ldHJ5IGZyb20gYSBwYXRoIHNoYXBlLlxuXHQgKlxuXHQgKiBwYXJhbWV0ZXJzID0ge1xuXHQgKlxuXHQgKiAgY3VydmVTZWdtZW50czogPGludD4sIC8vIG51bWJlciBvZiBwb2ludHMgb24gdGhlIGN1cnZlc1xuXHQgKiAgc3RlcHM6IDxpbnQ+LCAvLyBudW1iZXIgb2YgcG9pbnRzIGZvciB6LXNpZGUgZXh0cnVzaW9ucyAvIHVzZWQgZm9yIHN1YmRpdmlkaW5nIHNlZ21lbnRzIG9mIGV4dHJ1ZGUgc3BsaW5lIHRvb1xuXHQgKiAgYW1vdW50OiA8aW50PiwgLy8gRGVwdGggdG8gZXh0cnVkZSB0aGUgc2hhcGVcblx0ICpcblx0ICogIGJldmVsRW5hYmxlZDogPGJvb2w+LCAvLyB0dXJuIG9uIGJldmVsXG5cdCAqICBiZXZlbFRoaWNrbmVzczogPGZsb2F0PiwgLy8gaG93IGRlZXAgaW50byB0aGUgb3JpZ2luYWwgc2hhcGUgYmV2ZWwgZ29lc1xuXHQgKiAgYmV2ZWxTaXplOiA8ZmxvYXQ+LCAvLyBob3cgZmFyIGZyb20gc2hhcGUgb3V0bGluZSBpcyBiZXZlbFxuXHQgKiAgYmV2ZWxTZWdtZW50czogPGludD4sIC8vIG51bWJlciBvZiBiZXZlbCBsYXllcnNcblx0ICpcblx0ICogIGV4dHJ1ZGVQYXRoOiA8VEhSRUUuQ3VydmVQYXRoPiAvLyAzZCBzcGxpbmUgcGF0aCB0byBleHRydWRlIHNoYXBlIGFsb25nLiAoY3JlYXRlcyBGcmFtZXMgaWYgLmZyYW1lcyBhcmVuJ3QgZGVmaW5lZClcblx0ICogIGZyYW1lczogPFRIUkVFLlR1YmVHZW9tZXRyeS5GcmVuZXRGcmFtZXM+IC8vIGNvbnRhaW5pbmcgYXJyYXlzIG9mIHRhbmdlbnRzLCBub3JtYWxzLCBiaW5vcm1hbHNcblx0ICpcblx0ICogIHV2R2VuZXJhdG9yOiA8T2JqZWN0PiAvLyBvYmplY3QgdGhhdCBwcm92aWRlcyBVViBnZW5lcmF0b3IgZnVuY3Rpb25zXG5cdCAqXG5cdCAqIH1cblx0ICoqL1xuXG5cdFRIUkVFLkV4dHJ1ZGVHZW9tZXRyeSA9IGZ1bmN0aW9uICggc2hhcGVzLCBvcHRpb25zICkge1xuXG5cdFx0aWYgKCB0eXBlb2YoIHNoYXBlcyApID09PSBcInVuZGVmaW5lZFwiICkge1xuXG5cdFx0XHRzaGFwZXMgPSBbXTtcblx0XHRcdHJldHVybjtcblxuXHRcdH1cblxuXHRcdFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuXHRcdHRoaXMudHlwZSA9ICdFeHRydWRlR2VvbWV0cnknO1xuXG5cdFx0c2hhcGVzID0gQXJyYXkuaXNBcnJheSggc2hhcGVzICkgPyBzaGFwZXMgOiBbIHNoYXBlcyBdO1xuXG5cdFx0dGhpcy5hZGRTaGFwZUxpc3QoIHNoYXBlcywgb3B0aW9ucyApO1xuXG5cdFx0dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcblxuXHRcdC8vIGNhbid0IHJlYWxseSB1c2UgYXV0b21hdGljIHZlcnRleCBub3JtYWxzXG5cdFx0Ly8gYXMgdGhlbiBmcm9udCBhbmQgYmFjayBzaWRlcyBnZXQgc21vb3RoZWQgdG9vXG5cdFx0Ly8gc2hvdWxkIGRvIHNlcGFyYXRlIHNtb290aGluZyBqdXN0IGZvciBzaWRlc1xuXG5cdFx0Ly90aGlzLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XG5cblx0XHQvL2NvbnNvbGUubG9nKCBcInRvb2tcIiwgKCBEYXRlLm5vdygpIC0gc3RhcnRUaW1lICkgKTtcblxuXHR9O1xuXG5cdFRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcblx0VEhSRUUuRXh0cnVkZUdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkV4dHJ1ZGVHZW9tZXRyeTtcblxuXHRUSFJFRS5FeHRydWRlR2VvbWV0cnkucHJvdG90eXBlLmFkZFNoYXBlTGlzdCA9IGZ1bmN0aW9uICggc2hhcGVzLCBvcHRpb25zICkge1xuXG5cdFx0dmFyIHNsID0gc2hhcGVzLmxlbmd0aDtcblxuXHRcdGZvciAoIHZhciBzID0gMDsgcyA8IHNsOyBzICsrICkge1xuXG5cdFx0XHR2YXIgc2hhcGUgPSBzaGFwZXNbIHMgXTtcblx0XHRcdHRoaXMuYWRkU2hhcGUoIHNoYXBlLCBvcHRpb25zICk7XG5cblx0XHR9XG5cblx0fTtcblxuXHRUSFJFRS5FeHRydWRlR2VvbWV0cnkucHJvdG90eXBlLmFkZFNoYXBlID0gZnVuY3Rpb24gKCBzaGFwZSwgb3B0aW9ucyApIHtcblxuXHRcdHZhciBhbW91bnQgPSBvcHRpb25zLmFtb3VudCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5hbW91bnQgOiAxMDA7XG5cblx0XHR2YXIgYmV2ZWxUaGlja25lc3MgPSBvcHRpb25zLmJldmVsVGhpY2tuZXNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmJldmVsVGhpY2tuZXNzIDogNjsgLy8gMTBcblx0XHR2YXIgYmV2ZWxTaXplID0gb3B0aW9ucy5iZXZlbFNpemUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYmV2ZWxTaXplIDogYmV2ZWxUaGlja25lc3MgLSAyOyAvLyA4XG5cdFx0dmFyIGJldmVsU2VnbWVudHMgPSBvcHRpb25zLmJldmVsU2VnbWVudHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYmV2ZWxTZWdtZW50cyA6IDM7XG5cblx0XHR2YXIgYmV2ZWxFbmFibGVkID0gb3B0aW9ucy5iZXZlbEVuYWJsZWQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYmV2ZWxFbmFibGVkIDogdHJ1ZTsgLy8gZmFsc2VcblxuXHRcdHZhciBjdXJ2ZVNlZ21lbnRzID0gb3B0aW9ucy5jdXJ2ZVNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmN1cnZlU2VnbWVudHMgOiAxMjtcblxuXHRcdHZhciBzdGVwcyA9IG9wdGlvbnMuc3RlcHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc3RlcHMgOiAxO1xuXG5cdFx0dmFyIGV4dHJ1ZGVQYXRoID0gb3B0aW9ucy5leHRydWRlUGF0aDtcblx0XHR2YXIgZXh0cnVkZVB0cywgZXh0cnVkZUJ5UGF0aCA9IGZhbHNlO1xuXG5cdFx0Ly8gVXNlIGRlZmF1bHQgV29ybGRVVkdlbmVyYXRvciBpZiBubyBVViBnZW5lcmF0b3JzIGFyZSBzcGVjaWZpZWQuXG5cdFx0dmFyIHV2Z2VuID0gb3B0aW9ucy5VVkdlbmVyYXRvciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5VVkdlbmVyYXRvciA6IFRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5Xb3JsZFVWR2VuZXJhdG9yO1xuXG5cdFx0dmFyIHNwbGluZVR1YmUsIGJpbm9ybWFsLCBub3JtYWwsIHBvc2l0aW9uMjtcblx0XHRpZiAoIGV4dHJ1ZGVQYXRoICkge1xuXG5cdFx0XHRleHRydWRlUHRzID0gZXh0cnVkZVBhdGguZ2V0U3BhY2VkUG9pbnRzKCBzdGVwcyApO1xuXG5cdFx0XHRleHRydWRlQnlQYXRoID0gdHJ1ZTtcblx0XHRcdGJldmVsRW5hYmxlZCA9IGZhbHNlOyAvLyBiZXZlbHMgbm90IHN1cHBvcnRlZCBmb3IgcGF0aCBleHRydXNpb25cblxuXHRcdFx0Ly8gU0VUVVAgVE5CIHZhcmlhYmxlc1xuXG5cdFx0XHQvLyBSZXVzZSBUTkIgZnJvbSBUdWJlR2VvbXRyeSBmb3Igbm93LlxuXHRcdFx0Ly8gVE9ETzEgLSBoYXZlIGEgLmlzQ2xvc2VkIGluIHNwbGluZT9cblxuXHRcdFx0c3BsaW5lVHViZSA9IG9wdGlvbnMuZnJhbWVzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmZyYW1lcyA6IG5ldyBUSFJFRS5UdWJlR2VvbWV0cnkuRnJlbmV0RnJhbWVzKCBleHRydWRlUGF0aCwgc3RlcHMsIGZhbHNlICk7XG5cblx0XHRcdC8vIGNvbnNvbGUubG9nKHNwbGluZVR1YmUsICdzcGxpbmVUdWJlJywgc3BsaW5lVHViZS5ub3JtYWxzLmxlbmd0aCwgJ3N0ZXBzJywgc3RlcHMsICdleHRydWRlUHRzJywgZXh0cnVkZVB0cy5sZW5ndGgpO1xuXG5cdFx0XHRiaW5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0XHRub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdFx0cG9zaXRpb24yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdH1cblxuXHRcdC8vIFNhZmVndWFyZHMgaWYgYmV2ZWxzIGFyZSBub3QgZW5hYmxlZFxuXG5cdFx0aWYgKCAhIGJldmVsRW5hYmxlZCApIHtcblxuXHRcdFx0YmV2ZWxTZWdtZW50cyA9IDA7XG5cdFx0XHRiZXZlbFRoaWNrbmVzcyA9IDA7XG5cdFx0XHRiZXZlbFNpemUgPSAwO1xuXG5cdFx0fVxuXG5cdFx0Ly8gVmFyaWFibGVzIGluaXRpYWxpemF0aW9uXG5cblx0XHR2YXIgYWhvbGUsIGgsIGhsOyAvLyBsb29waW5nIG9mIGhvbGVzXG5cdFx0dmFyIHNjb3BlID0gdGhpcztcblxuXHRcdHZhciBzaGFwZXNPZmZzZXQgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDtcblxuXHRcdHZhciBzaGFwZVBvaW50cyA9IHNoYXBlLmV4dHJhY3RQb2ludHMoIGN1cnZlU2VnbWVudHMgKTtcblxuXHRcdHZhciB2ZXJ0aWNlcyA9IHNoYXBlUG9pbnRzLnNoYXBlO1xuXHRcdHZhciBob2xlcyA9IHNoYXBlUG9pbnRzLmhvbGVzO1xuXG5cdFx0dmFyIHJldmVyc2UgPSAhIFRIUkVFLlNoYXBlVXRpbHMuaXNDbG9ja1dpc2UoIHZlcnRpY2VzICk7XG5cblx0XHRpZiAoIHJldmVyc2UgKSB7XG5cblx0XHRcdHZlcnRpY2VzID0gdmVydGljZXMucmV2ZXJzZSgpO1xuXG5cdFx0XHQvLyBNYXliZSB3ZSBzaG91bGQgYWxzbyBjaGVjayBpZiBob2xlcyBhcmUgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvbiwganVzdCB0byBiZSBzYWZlIC4uLlxuXG5cdFx0XHRmb3IgKCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcblxuXHRcdFx0XHRhaG9sZSA9IGhvbGVzWyBoIF07XG5cblx0XHRcdFx0aWYgKCBUSFJFRS5TaGFwZVV0aWxzLmlzQ2xvY2tXaXNlKCBhaG9sZSApICkge1xuXG5cdFx0XHRcdFx0aG9sZXNbIGggXSA9IGFob2xlLnJldmVyc2UoKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV2ZXJzZSA9IGZhbHNlOyAvLyBJZiB2ZXJ0aWNlcyBhcmUgaW4gb3JkZXIgbm93LCB3ZSBzaG91bGRuJ3QgbmVlZCB0byB3b3JyeSBhYm91dCB0aGVtIGFnYWluIChob3BlZnVsbHkpIVxuXG5cdFx0fVxuXG5cblx0XHR2YXIgZmFjZXMgPSBUSFJFRS5TaGFwZVV0aWxzLnRyaWFuZ3VsYXRlU2hhcGUoIHZlcnRpY2VzLCBob2xlcyApO1xuXG5cdFx0LyogVmVydGljZXMgKi9cblxuXHRcdHZhciBjb250b3VyID0gdmVydGljZXM7IC8vIHZlcnRpY2VzIGhhcyBhbGwgcG9pbnRzIGJ1dCBjb250b3VyIGhhcyBvbmx5IHBvaW50cyBvZiBjaXJjdW1mZXJlbmNlXG5cblx0XHRmb3IgKCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcblxuXHRcdFx0YWhvbGUgPSBob2xlc1sgaCBdO1xuXG5cdFx0XHR2ZXJ0aWNlcyA9IHZlcnRpY2VzLmNvbmNhdCggYWhvbGUgKTtcblxuXHRcdH1cblxuXG5cdFx0ZnVuY3Rpb24gc2NhbGVQdDIgKCBwdCwgdmVjLCBzaXplICkge1xuXG5cdFx0XHRpZiAoICEgdmVjICkgY29uc29sZS5lcnJvciggXCJUSFJFRS5FeHRydWRlR2VvbWV0cnk6IHZlYyBkb2VzIG5vdCBleGlzdFwiICk7XG5cblx0XHRcdHJldHVybiB2ZWMuY2xvbmUoKS5tdWx0aXBseVNjYWxhciggc2l6ZSApLmFkZCggcHQgKTtcblxuXHRcdH1cblxuXHRcdHZhciBiLCBicywgdCwgeixcblx0XHRcdHZlcnQsIHZsZW4gPSB2ZXJ0aWNlcy5sZW5ndGgsXG5cdFx0XHRmYWNlLCBmbGVuID0gZmFjZXMubGVuZ3RoO1xuXG5cblx0XHQvLyBGaW5kIGRpcmVjdGlvbnMgZm9yIHBvaW50IG1vdmVtZW50XG5cblxuXHRcdGZ1bmN0aW9uIGdldEJldmVsVmVjKCBpblB0LCBpblByZXYsIGluTmV4dCApIHtcblxuXHRcdFx0Ly8gY29tcHV0ZXMgZm9yIGluUHQgdGhlIGNvcnJlc3BvbmRpbmcgcG9pbnQgaW5QdCcgb24gYSBuZXcgY29udG91clxuXHRcdFx0Ly8gICBzaGlmdGVkIGJ5IDEgdW5pdCAobGVuZ3RoIG9mIG5vcm1hbGl6ZWQgdmVjdG9yKSB0byB0aGUgbGVmdFxuXHRcdFx0Ly8gaWYgd2Ugd2FsayBhbG9uZyBjb250b3VyIGNsb2Nrd2lzZSwgdGhpcyBuZXcgY29udG91ciBpcyBvdXRzaWRlIHRoZSBvbGQgb25lXG5cdFx0XHQvL1xuXHRcdFx0Ly8gaW5QdCcgaXMgdGhlIGludGVyc2VjdGlvbiBvZiB0aGUgdHdvIGxpbmVzIHBhcmFsbGVsIHRvIHRoZSB0d29cblx0XHRcdC8vICBhZGphY2VudCBlZGdlcyBvZiBpblB0IGF0IGEgZGlzdGFuY2Ugb2YgMSB1bml0IG9uIHRoZSBsZWZ0IHNpZGUuXG5cblx0XHRcdHZhciB2X3RyYW5zX3gsIHZfdHJhbnNfeSwgc2hyaW5rX2J5ID0gMTtcdFx0Ly8gcmVzdWx0aW5nIHRyYW5zbGF0aW9uIHZlY3RvciBmb3IgaW5QdFxuXG5cdFx0XHQvLyBnb29kIHJlYWRpbmcgZm9yIGdlb21ldHJ5IGFsZ29yaXRobXMgKGhlcmU6IGxpbmUtbGluZSBpbnRlcnNlY3Rpb24pXG5cdFx0XHQvLyBodHRwOi8vZ2VvbWFsZ29yaXRobXMuY29tL2EwNS1faW50ZXJzZWN0LTEuaHRtbFxuXG5cdFx0XHR2YXIgdl9wcmV2X3ggPSBpblB0LnggLSBpblByZXYueCwgdl9wcmV2X3kgPSBpblB0LnkgLSBpblByZXYueTtcblx0XHRcdHZhciB2X25leHRfeCA9IGluTmV4dC54IC0gaW5QdC54LCB2X25leHRfeSA9IGluTmV4dC55IC0gaW5QdC55O1xuXG5cdFx0XHR2YXIgdl9wcmV2X2xlbnNxID0gKCB2X3ByZXZfeCAqIHZfcHJldl94ICsgdl9wcmV2X3kgKiB2X3ByZXZfeSApO1xuXG5cdFx0XHQvLyBjaGVjayBmb3IgY29sbGluZWFyIGVkZ2VzXG5cdFx0XHR2YXIgY29sbGluZWFyMCA9ICggdl9wcmV2X3ggKiB2X25leHRfeSAtIHZfcHJldl95ICogdl9uZXh0X3ggKTtcblxuXHRcdFx0aWYgKCBNYXRoLmFicyggY29sbGluZWFyMCApID4gTnVtYmVyLkVQU0lMT04gKSB7XG5cblx0XHRcdFx0Ly8gbm90IGNvbGxpbmVhclxuXG5cdFx0XHRcdC8vIGxlbmd0aCBvZiB2ZWN0b3JzIGZvciBub3JtYWxpemluZ1xuXG5cdFx0XHRcdHZhciB2X3ByZXZfbGVuID0gTWF0aC5zcXJ0KCB2X3ByZXZfbGVuc3EgKTtcblx0XHRcdFx0dmFyIHZfbmV4dF9sZW4gPSBNYXRoLnNxcnQoIHZfbmV4dF94ICogdl9uZXh0X3ggKyB2X25leHRfeSAqIHZfbmV4dF95ICk7XG5cblx0XHRcdFx0Ly8gc2hpZnQgYWRqYWNlbnQgcG9pbnRzIGJ5IHVuaXQgdmVjdG9ycyB0byB0aGUgbGVmdFxuXG5cdFx0XHRcdHZhciBwdFByZXZTaGlmdF94ID0gKCBpblByZXYueCAtIHZfcHJldl95IC8gdl9wcmV2X2xlbiApO1xuXHRcdFx0XHR2YXIgcHRQcmV2U2hpZnRfeSA9ICggaW5QcmV2LnkgKyB2X3ByZXZfeCAvIHZfcHJldl9sZW4gKTtcblxuXHRcdFx0XHR2YXIgcHROZXh0U2hpZnRfeCA9ICggaW5OZXh0LnggLSB2X25leHRfeSAvIHZfbmV4dF9sZW4gKTtcblx0XHRcdFx0dmFyIHB0TmV4dFNoaWZ0X3kgPSAoIGluTmV4dC55ICsgdl9uZXh0X3ggLyB2X25leHRfbGVuICk7XG5cblx0XHRcdFx0Ly8gc2NhbGluZyBmYWN0b3IgZm9yIHZfcHJldiB0byBpbnRlcnNlY3Rpb24gcG9pbnRcblxuXHRcdFx0XHR2YXIgc2YgPSAoICAoIHB0TmV4dFNoaWZ0X3ggLSBwdFByZXZTaGlmdF94ICkgKiB2X25leHRfeSAtXG5cdFx0XHRcdFx0XHRcdCggcHROZXh0U2hpZnRfeSAtIHB0UHJldlNoaWZ0X3kgKSAqIHZfbmV4dF94ICAgICkgL1xuXHRcdFx0XHRcdFx0ICAoIHZfcHJldl94ICogdl9uZXh0X3kgLSB2X3ByZXZfeSAqIHZfbmV4dF94ICk7XG5cblx0XHRcdFx0Ly8gdmVjdG9yIGZyb20gaW5QdCB0byBpbnRlcnNlY3Rpb24gcG9pbnRcblxuXHRcdFx0XHR2X3RyYW5zX3ggPSAoIHB0UHJldlNoaWZ0X3ggKyB2X3ByZXZfeCAqIHNmIC0gaW5QdC54ICk7XG5cdFx0XHRcdHZfdHJhbnNfeSA9ICggcHRQcmV2U2hpZnRfeSArIHZfcHJldl95ICogc2YgLSBpblB0LnkgKTtcblxuXHRcdFx0XHQvLyBEb24ndCBub3JtYWxpemUhLCBvdGhlcndpc2Ugc2hhcnAgY29ybmVycyBiZWNvbWUgdWdseVxuXHRcdFx0XHQvLyAgYnV0IHByZXZlbnQgY3Jhenkgc3Bpa2VzXG5cdFx0XHRcdHZhciB2X3RyYW5zX2xlbnNxID0gKCB2X3RyYW5zX3ggKiB2X3RyYW5zX3ggKyB2X3RyYW5zX3kgKiB2X3RyYW5zX3kgKTtcblx0XHRcdFx0aWYgKCB2X3RyYW5zX2xlbnNxIDw9IDIgKSB7XG5cblx0XHRcdFx0XHRyZXR1cm5cdG5ldyBUSFJFRS5WZWN0b3IyKCB2X3RyYW5zX3gsIHZfdHJhbnNfeSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRzaHJpbmtfYnkgPSBNYXRoLnNxcnQoIHZfdHJhbnNfbGVuc3EgLyAyICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIGhhbmRsZSBzcGVjaWFsIGNhc2Ugb2YgY29sbGluZWFyIGVkZ2VzXG5cblx0XHRcdFx0dmFyIGRpcmVjdGlvbl9lcSA9IGZhbHNlO1x0XHQvLyBhc3N1bWVzOiBvcHBvc2l0ZVxuXHRcdFx0XHRpZiAoIHZfcHJldl94ID4gTnVtYmVyLkVQU0lMT04gKSB7XG5cblx0XHRcdFx0XHRpZiAoIHZfbmV4dF94ID4gTnVtYmVyLkVQU0lMT04gKSB7XG5cblx0XHRcdFx0XHRcdGRpcmVjdGlvbl9lcSA9IHRydWU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGlmICggdl9wcmV2X3ggPCAtIE51bWJlci5FUFNJTE9OICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIHZfbmV4dF94IDwgLSBOdW1iZXIuRVBTSUxPTiApIHtcblxuXHRcdFx0XHRcdFx0XHRkaXJlY3Rpb25fZXEgPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRpZiAoIE1hdGguc2lnbiggdl9wcmV2X3kgKSA9PT0gTWF0aC5zaWduKCB2X25leHRfeSApICkge1xuXG5cdFx0XHRcdFx0XHRcdGRpcmVjdGlvbl9lcSA9IHRydWU7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBkaXJlY3Rpb25fZXEgKSB7XG5cblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyhcIldhcm5pbmc6IGxpbmVzIGFyZSBhIHN0cmFpZ2h0IHNlcXVlbmNlXCIpO1xuXHRcdFx0XHRcdHZfdHJhbnNfeCA9IC0gdl9wcmV2X3k7XG5cdFx0XHRcdFx0dl90cmFuc195ID0gIHZfcHJldl94O1xuXHRcdFx0XHRcdHNocmlua19ieSA9IE1hdGguc3FydCggdl9wcmV2X2xlbnNxICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKFwiV2FybmluZzogbGluZXMgYXJlIGEgc3RyYWlnaHQgc3Bpa2VcIik7XG5cdFx0XHRcdFx0dl90cmFuc194ID0gdl9wcmV2X3g7XG5cdFx0XHRcdFx0dl90cmFuc195ID0gdl9wcmV2X3k7XG5cdFx0XHRcdFx0c2hyaW5rX2J5ID0gTWF0aC5zcXJ0KCB2X3ByZXZfbGVuc3EgLyAyICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVyblx0bmV3IFRIUkVFLlZlY3RvcjIoIHZfdHJhbnNfeCAvIHNocmlua19ieSwgdl90cmFuc195IC8gc2hyaW5rX2J5ICk7XG5cblx0XHR9XG5cblxuXHRcdHZhciBjb250b3VyTW92ZW1lbnRzID0gW107XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gY29udG91ci5sZW5ndGgsIGogPSBpbCAtIDEsIGsgPSBpICsgMTsgaSA8IGlsOyBpICsrLCBqICsrLCBrICsrICkge1xuXG5cdFx0XHRpZiAoIGogPT09IGlsICkgaiA9IDA7XG5cdFx0XHRpZiAoIGsgPT09IGlsICkgayA9IDA7XG5cblx0XHRcdC8vICAoaiktLS0oaSktLS0oaylcblx0XHRcdC8vIGNvbnNvbGUubG9nKCdpLGosaycsIGksIGogLCBrKVxuXG5cdFx0XHRjb250b3VyTW92ZW1lbnRzWyBpIF0gPSBnZXRCZXZlbFZlYyggY29udG91clsgaSBdLCBjb250b3VyWyBqIF0sIGNvbnRvdXJbIGsgXSApO1xuXG5cdFx0fVxuXG5cdFx0dmFyIGhvbGVzTW92ZW1lbnRzID0gW10sIG9uZUhvbGVNb3ZlbWVudHMsIHZlcnRpY2VzTW92ZW1lbnRzID0gY29udG91ck1vdmVtZW50cy5jb25jYXQoKTtcblxuXHRcdGZvciAoIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xuXG5cdFx0XHRhaG9sZSA9IGhvbGVzWyBoIF07XG5cblx0XHRcdG9uZUhvbGVNb3ZlbWVudHMgPSBbXTtcblxuXHRcdFx0Zm9yICggaSA9IDAsIGlsID0gYWhvbGUubGVuZ3RoLCBqID0gaWwgLSAxLCBrID0gaSArIDE7IGkgPCBpbDsgaSArKywgaiArKywgayArKyApIHtcblxuXHRcdFx0XHRpZiAoIGogPT09IGlsICkgaiA9IDA7XG5cdFx0XHRcdGlmICggayA9PT0gaWwgKSBrID0gMDtcblxuXHRcdFx0XHQvLyAgKGopLS0tKGkpLS0tKGspXG5cdFx0XHRcdG9uZUhvbGVNb3ZlbWVudHNbIGkgXSA9IGdldEJldmVsVmVjKCBhaG9sZVsgaSBdLCBhaG9sZVsgaiBdLCBhaG9sZVsgayBdICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aG9sZXNNb3ZlbWVudHMucHVzaCggb25lSG9sZU1vdmVtZW50cyApO1xuXHRcdFx0dmVydGljZXNNb3ZlbWVudHMgPSB2ZXJ0aWNlc01vdmVtZW50cy5jb25jYXQoIG9uZUhvbGVNb3ZlbWVudHMgKTtcblxuXHRcdH1cblxuXG5cdFx0Ly8gTG9vcCBiZXZlbFNlZ21lbnRzLCAxIGZvciB0aGUgZnJvbnQsIDEgZm9yIHRoZSBiYWNrXG5cblx0XHRmb3IgKCBiID0gMDsgYiA8IGJldmVsU2VnbWVudHM7IGIgKysgKSB7XG5cblx0XHRcdC8vZm9yICggYiA9IGJldmVsU2VnbWVudHM7IGIgPiAwOyBiIC0tICkge1xuXG5cdFx0XHR0ID0gYiAvIGJldmVsU2VnbWVudHM7XG5cdFx0XHR6ID0gYmV2ZWxUaGlja25lc3MgKiAoIDEgLSB0ICk7XG5cblx0XHRcdC8veiA9IGJldmVsVGhpY2tuZXNzICogdDtcblx0XHRcdGJzID0gYmV2ZWxTaXplICogKCBNYXRoLnNpbiAoIHQgKiBNYXRoLlBJIC8gMiApICk7IC8vIGN1cnZlZFxuXHRcdFx0Ly9icyA9IGJldmVsU2l6ZSAqIHQ7IC8vIGxpbmVhclxuXG5cdFx0XHQvLyBjb250cmFjdCBzaGFwZVxuXG5cdFx0XHRmb3IgKCBpID0gMCwgaWwgPSBjb250b3VyLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdHZlcnQgPSBzY2FsZVB0MiggY29udG91clsgaSBdLCBjb250b3VyTW92ZW1lbnRzWyBpIF0sIGJzICk7XG5cblx0XHRcdFx0diggdmVydC54LCB2ZXJ0LnksICAtIHogKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBleHBhbmQgaG9sZXNcblxuXHRcdFx0Zm9yICggaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XG5cblx0XHRcdFx0YWhvbGUgPSBob2xlc1sgaCBdO1xuXHRcdFx0XHRvbmVIb2xlTW92ZW1lbnRzID0gaG9sZXNNb3ZlbWVudHNbIGggXTtcblxuXHRcdFx0XHRmb3IgKCBpID0gMCwgaWwgPSBhaG9sZS5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHZlcnQgPSBzY2FsZVB0MiggYWhvbGVbIGkgXSwgb25lSG9sZU1vdmVtZW50c1sgaSBdLCBicyApO1xuXG5cdFx0XHRcdFx0diggdmVydC54LCB2ZXJ0LnksICAtIHogKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGJzID0gYmV2ZWxTaXplO1xuXG5cdFx0Ly8gQmFjayBmYWNpbmcgdmVydGljZXNcblxuXHRcdGZvciAoIGkgPSAwOyBpIDwgdmxlbjsgaSArKyApIHtcblxuXHRcdFx0dmVydCA9IGJldmVsRW5hYmxlZCA/IHNjYWxlUHQyKCB2ZXJ0aWNlc1sgaSBdLCB2ZXJ0aWNlc01vdmVtZW50c1sgaSBdLCBicyApIDogdmVydGljZXNbIGkgXTtcblxuXHRcdFx0aWYgKCAhIGV4dHJ1ZGVCeVBhdGggKSB7XG5cblx0XHRcdFx0diggdmVydC54LCB2ZXJ0LnksIDAgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyB2KCB2ZXJ0LngsIHZlcnQueSArIGV4dHJ1ZGVQdHNbIDAgXS55LCBleHRydWRlUHRzWyAwIF0ueCApO1xuXG5cdFx0XHRcdG5vcm1hbC5jb3B5KCBzcGxpbmVUdWJlLm5vcm1hbHNbIDAgXSApLm11bHRpcGx5U2NhbGFyKCB2ZXJ0LnggKTtcblx0XHRcdFx0Ymlub3JtYWwuY29weSggc3BsaW5lVHViZS5iaW5vcm1hbHNbIDAgXSApLm11bHRpcGx5U2NhbGFyKCB2ZXJ0LnkgKTtcblxuXHRcdFx0XHRwb3NpdGlvbjIuY29weSggZXh0cnVkZVB0c1sgMCBdICkuYWRkKCBub3JtYWwgKS5hZGQoIGJpbm9ybWFsICk7XG5cblx0XHRcdFx0diggcG9zaXRpb24yLngsIHBvc2l0aW9uMi55LCBwb3NpdGlvbjIueiApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBBZGQgc3RlcHBlZCB2ZXJ0aWNlcy4uLlxuXHRcdC8vIEluY2x1ZGluZyBmcm9udCBmYWNpbmcgdmVydGljZXNcblxuXHRcdHZhciBzO1xuXG5cdFx0Zm9yICggcyA9IDE7IHMgPD0gc3RlcHM7IHMgKysgKSB7XG5cblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgdmxlbjsgaSArKyApIHtcblxuXHRcdFx0XHR2ZXJ0ID0gYmV2ZWxFbmFibGVkID8gc2NhbGVQdDIoIHZlcnRpY2VzWyBpIF0sIHZlcnRpY2VzTW92ZW1lbnRzWyBpIF0sIGJzICkgOiB2ZXJ0aWNlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggISBleHRydWRlQnlQYXRoICkge1xuXG5cdFx0XHRcdFx0diggdmVydC54LCB2ZXJ0LnksIGFtb3VudCAvIHN0ZXBzICogcyApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyB2KCB2ZXJ0LngsIHZlcnQueSArIGV4dHJ1ZGVQdHNbIHMgLSAxIF0ueSwgZXh0cnVkZVB0c1sgcyAtIDEgXS54ICk7XG5cblx0XHRcdFx0XHRub3JtYWwuY29weSggc3BsaW5lVHViZS5ub3JtYWxzWyBzIF0gKS5tdWx0aXBseVNjYWxhciggdmVydC54ICk7XG5cdFx0XHRcdFx0Ymlub3JtYWwuY29weSggc3BsaW5lVHViZS5iaW5vcm1hbHNbIHMgXSApLm11bHRpcGx5U2NhbGFyKCB2ZXJ0LnkgKTtcblxuXHRcdFx0XHRcdHBvc2l0aW9uMi5jb3B5KCBleHRydWRlUHRzWyBzIF0gKS5hZGQoIG5vcm1hbCApLmFkZCggYmlub3JtYWwgKTtcblxuXHRcdFx0XHRcdHYoIHBvc2l0aW9uMi54LCBwb3NpdGlvbjIueSwgcG9zaXRpb24yLnogKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXG5cdFx0Ly8gQWRkIGJldmVsIHNlZ21lbnRzIHBsYW5lc1xuXG5cdFx0Ly9mb3IgKCBiID0gMTsgYiA8PSBiZXZlbFNlZ21lbnRzOyBiICsrICkge1xuXHRcdGZvciAoIGIgPSBiZXZlbFNlZ21lbnRzIC0gMTsgYiA+PSAwOyBiIC0tICkge1xuXG5cdFx0XHR0ID0gYiAvIGJldmVsU2VnbWVudHM7XG5cdFx0XHR6ID0gYmV2ZWxUaGlja25lc3MgKiAoIDEgLSB0ICk7XG5cdFx0XHQvL2JzID0gYmV2ZWxTaXplICogKCAxLU1hdGguc2luICggKCAxIC0gdCApICogTWF0aC5QSS8yICkgKTtcblx0XHRcdGJzID0gYmV2ZWxTaXplICogTWF0aC5zaW4gKCB0ICogTWF0aC5QSSAvIDIgKTtcblxuXHRcdFx0Ly8gY29udHJhY3Qgc2hhcGVcblxuXHRcdFx0Zm9yICggaSA9IDAsIGlsID0gY29udG91ci5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHR2ZXJ0ID0gc2NhbGVQdDIoIGNvbnRvdXJbIGkgXSwgY29udG91ck1vdmVtZW50c1sgaSBdLCBicyApO1xuXHRcdFx0XHR2KCB2ZXJ0LngsIHZlcnQueSwgIGFtb3VudCArIHogKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBleHBhbmQgaG9sZXNcblxuXHRcdFx0Zm9yICggaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XG5cblx0XHRcdFx0YWhvbGUgPSBob2xlc1sgaCBdO1xuXHRcdFx0XHRvbmVIb2xlTW92ZW1lbnRzID0gaG9sZXNNb3ZlbWVudHNbIGggXTtcblxuXHRcdFx0XHRmb3IgKCBpID0gMCwgaWwgPSBhaG9sZS5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHZlcnQgPSBzY2FsZVB0MiggYWhvbGVbIGkgXSwgb25lSG9sZU1vdmVtZW50c1sgaSBdLCBicyApO1xuXG5cdFx0XHRcdFx0aWYgKCAhIGV4dHJ1ZGVCeVBhdGggKSB7XG5cblx0XHRcdFx0XHRcdHYoIHZlcnQueCwgdmVydC55LCAgYW1vdW50ICsgeiApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0diggdmVydC54LCB2ZXJ0LnkgKyBleHRydWRlUHRzWyBzdGVwcyAtIDEgXS55LCBleHRydWRlUHRzWyBzdGVwcyAtIDEgXS54ICsgeiApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0LyogRmFjZXMgKi9cblxuXHRcdC8vIFRvcCBhbmQgYm90dG9tIGZhY2VzXG5cblx0XHRidWlsZExpZEZhY2VzKCk7XG5cblx0XHQvLyBTaWRlcyBmYWNlc1xuXG5cdFx0YnVpbGRTaWRlRmFjZXMoKTtcblxuXG5cdFx0Ly8vLy8gIEludGVybmFsIGZ1bmN0aW9uc1xuXG5cdFx0ZnVuY3Rpb24gYnVpbGRMaWRGYWNlcygpIHtcblxuXHRcdFx0aWYgKCBiZXZlbEVuYWJsZWQgKSB7XG5cblx0XHRcdFx0dmFyIGxheWVyID0gMDsgLy8gc3RlcHMgKyAxXG5cdFx0XHRcdHZhciBvZmZzZXQgPSB2bGVuICogbGF5ZXI7XG5cblx0XHRcdFx0Ly8gQm90dG9tIGZhY2VzXG5cblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBmbGVuOyBpICsrICkge1xuXG5cdFx0XHRcdFx0ZmFjZSA9IGZhY2VzWyBpIF07XG5cdFx0XHRcdFx0ZjMoIGZhY2VbIDIgXSArIG9mZnNldCwgZmFjZVsgMSBdICsgb2Zmc2V0LCBmYWNlWyAwIF0gKyBvZmZzZXQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0bGF5ZXIgPSBzdGVwcyArIGJldmVsU2VnbWVudHMgKiAyO1xuXHRcdFx0XHRvZmZzZXQgPSB2bGVuICogbGF5ZXI7XG5cblx0XHRcdFx0Ly8gVG9wIGZhY2VzXG5cblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBmbGVuOyBpICsrICkge1xuXG5cdFx0XHRcdFx0ZmFjZSA9IGZhY2VzWyBpIF07XG5cdFx0XHRcdFx0ZjMoIGZhY2VbIDAgXSArIG9mZnNldCwgZmFjZVsgMSBdICsgb2Zmc2V0LCBmYWNlWyAyIF0gKyBvZmZzZXQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gQm90dG9tIGZhY2VzXG5cblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBmbGVuOyBpICsrICkge1xuXG5cdFx0XHRcdFx0ZmFjZSA9IGZhY2VzWyBpIF07XG5cdFx0XHRcdFx0ZjMoIGZhY2VbIDIgXSwgZmFjZVsgMSBdLCBmYWNlWyAwIF0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVG9wIGZhY2VzXG5cblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBmbGVuOyBpICsrICkge1xuXG5cdFx0XHRcdFx0ZmFjZSA9IGZhY2VzWyBpIF07XG5cdFx0XHRcdFx0ZjMoIGZhY2VbIDAgXSArIHZsZW4gKiBzdGVwcywgZmFjZVsgMSBdICsgdmxlbiAqIHN0ZXBzLCBmYWNlWyAyIF0gKyB2bGVuICogc3RlcHMgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIENyZWF0ZSBmYWNlcyBmb3IgdGhlIHotc2lkZXMgb2YgdGhlIHNoYXBlXG5cblx0XHRmdW5jdGlvbiBidWlsZFNpZGVGYWNlcygpIHtcblxuXHRcdFx0dmFyIGxheWVyb2Zmc2V0ID0gMDtcblx0XHRcdHNpZGV3YWxscyggY29udG91ciwgbGF5ZXJvZmZzZXQgKTtcblx0XHRcdGxheWVyb2Zmc2V0ICs9IGNvbnRvdXIubGVuZ3RoO1xuXG5cdFx0XHRmb3IgKCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcblxuXHRcdFx0XHRhaG9sZSA9IGhvbGVzWyBoIF07XG5cdFx0XHRcdHNpZGV3YWxscyggYWhvbGUsIGxheWVyb2Zmc2V0ICk7XG5cblx0XHRcdFx0Ly8sIHRydWVcblx0XHRcdFx0bGF5ZXJvZmZzZXQgKz0gYWhvbGUubGVuZ3RoO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBzaWRld2FsbHMoIGNvbnRvdXIsIGxheWVyb2Zmc2V0ICkge1xuXG5cdFx0XHR2YXIgaiwgaztcblx0XHRcdGkgPSBjb250b3VyLmxlbmd0aDtcblxuXHRcdFx0d2hpbGUgKCAtLSBpID49IDAgKSB7XG5cblx0XHRcdFx0aiA9IGk7XG5cdFx0XHRcdGsgPSBpIC0gMTtcblx0XHRcdFx0aWYgKCBrIDwgMCApIGsgPSBjb250b3VyLmxlbmd0aCAtIDE7XG5cblx0XHRcdFx0Ly9jb25zb2xlLmxvZygnYicsIGksaiwgaS0xLCBrLHZlcnRpY2VzLmxlbmd0aCk7XG5cblx0XHRcdFx0dmFyIHMgPSAwLCBzbCA9IHN0ZXBzICArIGJldmVsU2VnbWVudHMgKiAyO1xuXG5cdFx0XHRcdGZvciAoIHMgPSAwOyBzIDwgc2w7IHMgKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgc2xlbjEgPSB2bGVuICogcztcblx0XHRcdFx0XHR2YXIgc2xlbjIgPSB2bGVuICogKCBzICsgMSApO1xuXG5cdFx0XHRcdFx0dmFyIGEgPSBsYXllcm9mZnNldCArIGogKyBzbGVuMSxcblx0XHRcdFx0XHRcdGIgPSBsYXllcm9mZnNldCArIGsgKyBzbGVuMSxcblx0XHRcdFx0XHRcdGMgPSBsYXllcm9mZnNldCArIGsgKyBzbGVuMixcblx0XHRcdFx0XHRcdGQgPSBsYXllcm9mZnNldCArIGogKyBzbGVuMjtcblxuXHRcdFx0XHRcdGY0KCBhLCBiLCBjLCBkLCBjb250b3VyLCBzLCBzbCwgaiwgayApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cblx0XHRmdW5jdGlvbiB2KCB4LCB5LCB6ICkge1xuXG5cdFx0XHRzY29wZS52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMyggeCwgeSwgeiApICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBmMyggYSwgYiwgYyApIHtcblxuXHRcdFx0YSArPSBzaGFwZXNPZmZzZXQ7XG5cdFx0XHRiICs9IHNoYXBlc09mZnNldDtcblx0XHRcdGMgKz0gc2hhcGVzT2Zmc2V0O1xuXG5cdFx0XHRzY29wZS5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGEsIGIsIGMsIG51bGwsIG51bGwsIDAgKSApO1xuXG5cdFx0XHR2YXIgdXZzID0gdXZnZW4uZ2VuZXJhdGVUb3BVViggc2NvcGUsIGEsIGIsIGMgKTtcblxuXHRcdFx0c2NvcGUuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIHV2cyApO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZjQoIGEsIGIsIGMsIGQsIHdhbGxDb250b3VyLCBzdGVwSW5kZXgsIHN0ZXBzTGVuZ3RoLCBjb250b3VySW5kZXgxLCBjb250b3VySW5kZXgyICkge1xuXG5cdFx0XHRhICs9IHNoYXBlc09mZnNldDtcblx0XHRcdGIgKz0gc2hhcGVzT2Zmc2V0O1xuXHRcdFx0YyArPSBzaGFwZXNPZmZzZXQ7XG5cdFx0XHRkICs9IHNoYXBlc09mZnNldDtcblxuXHRcdFx0c2NvcGUuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBhLCBiLCBkLCBudWxsLCBudWxsLCAxICkgKTtcblx0XHRcdHNjb3BlLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYiwgYywgZCwgbnVsbCwgbnVsbCwgMSApICk7XG5cblx0XHRcdHZhciB1dnMgPSB1dmdlbi5nZW5lcmF0ZVNpZGVXYWxsVVYoIHNjb3BlLCBhLCBiLCBjLCBkICk7XG5cblx0XHRcdHNjb3BlLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2c1sgMCBdLCB1dnNbIDEgXSwgdXZzWyAzIF0gXSApO1xuXHRcdFx0c2NvcGUuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZzWyAxIF0sIHV2c1sgMiBdLCB1dnNbIDMgXSBdICk7XG5cblx0XHR9XG5cblx0fTtcblxuXHRUSFJFRS5FeHRydWRlR2VvbWV0cnkuV29ybGRVVkdlbmVyYXRvciA9IHtcblxuXHRcdGdlbmVyYXRlVG9wVVY6IGZ1bmN0aW9uICggZ2VvbWV0cnksIGluZGV4QSwgaW5kZXhCLCBpbmRleEMgKSB7XG5cblx0XHRcdHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzO1xuXG5cdFx0XHR2YXIgYSA9IHZlcnRpY2VzWyBpbmRleEEgXTtcblx0XHRcdHZhciBiID0gdmVydGljZXNbIGluZGV4QiBdO1xuXHRcdFx0dmFyIGMgPSB2ZXJ0aWNlc1sgaW5kZXhDIF07XG5cblx0XHRcdHJldHVybiBbXG5cdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCBhLngsIGEueSApLFxuXHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggYi54LCBiLnkgKSxcblx0XHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIGMueCwgYy55IClcblx0XHRcdF07XG5cblx0XHR9LFxuXG5cdFx0Z2VuZXJhdGVTaWRlV2FsbFVWOiBmdW5jdGlvbiAoIGdlb21ldHJ5LCBpbmRleEEsIGluZGV4QiwgaW5kZXhDLCBpbmRleEQgKSB7XG5cblx0XHRcdHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzO1xuXG5cdFx0XHR2YXIgYSA9IHZlcnRpY2VzWyBpbmRleEEgXTtcblx0XHRcdHZhciBiID0gdmVydGljZXNbIGluZGV4QiBdO1xuXHRcdFx0dmFyIGMgPSB2ZXJ0aWNlc1sgaW5kZXhDIF07XG5cdFx0XHR2YXIgZCA9IHZlcnRpY2VzWyBpbmRleEQgXTtcblxuXHRcdFx0aWYgKCBNYXRoLmFicyggYS55IC0gYi55ICkgPCAwLjAxICkge1xuXG5cdFx0XHRcdHJldHVybiBbXG5cdFx0XHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIGEueCwgMSAtIGEueiApLFxuXHRcdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCBiLngsIDEgLSBiLnogKSxcblx0XHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggYy54LCAxIC0gYy56ICksXG5cdFx0XHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIGQueCwgMSAtIGQueiApXG5cdFx0XHRcdF07XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggYS55LCAxIC0gYS56ICksXG5cdFx0XHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIGIueSwgMSAtIGIueiApLFxuXHRcdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCBjLnksIDEgLSBjLnogKSxcblx0XHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggZC55LCAxIC0gZC56IClcblx0XHRcdFx0XTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXHR9O1xuXG5cdC8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL1NoYXBlR2VvbWV0cnkuanNcblxuXHQvKipcblx0ICogQGF1dGhvciBqb25vYnIxIC8gaHR0cDovL2pvbm9icjEuY29tXG5cdCAqXG5cdCAqIENyZWF0ZXMgYSBvbmUtc2lkZWQgcG9seWdvbmFsIGdlb21ldHJ5IGZyb20gYSBwYXRoIHNoYXBlLiBTaW1pbGFyIHRvXG5cdCAqIEV4dHJ1ZGVHZW9tZXRyeS5cblx0ICpcblx0ICogcGFyYW1ldGVycyA9IHtcblx0ICpcblx0ICpcdGN1cnZlU2VnbWVudHM6IDxpbnQ+LCAvLyBudW1iZXIgb2YgcG9pbnRzIG9uIHRoZSBjdXJ2ZXMuIE5PVCBVU0VEIEFUIFRIRSBNT01FTlQuXG5cdCAqXG5cdCAqXHRtYXRlcmlhbDogPGludD4gLy8gbWF0ZXJpYWwgaW5kZXggZm9yIGZyb250IGFuZCBiYWNrIGZhY2VzXG5cdCAqXHR1dkdlbmVyYXRvcjogPE9iamVjdD4gLy8gb2JqZWN0IHRoYXQgcHJvdmlkZXMgVVYgZ2VuZXJhdG9yIGZ1bmN0aW9uc1xuXHQgKlxuXHQgKiB9XG5cdCAqKi9cblxuXHRUSFJFRS5TaGFwZUdlb21ldHJ5ID0gZnVuY3Rpb24gKCBzaGFwZXMsIG9wdGlvbnMgKSB7XG5cblx0XHRUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cblx0XHR0aGlzLnR5cGUgPSAnU2hhcGVHZW9tZXRyeSc7XG5cblx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHNoYXBlcyApID09PSBmYWxzZSApIHNoYXBlcyA9IFsgc2hhcGVzIF07XG5cblx0XHR0aGlzLmFkZFNoYXBlTGlzdCggc2hhcGVzLCBvcHRpb25zICk7XG5cblx0XHR0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xuXG5cdH07XG5cblx0VEhSRUUuU2hhcGVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcblx0VEhSRUUuU2hhcGVHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5TaGFwZUdlb21ldHJ5O1xuXG5cdC8qKlxuXHQgKiBBZGQgYW4gYXJyYXkgb2Ygc2hhcGVzIHRvIFRIUkVFLlNoYXBlR2VvbWV0cnkuXG5cdCAqL1xuXHRUSFJFRS5TaGFwZUdlb21ldHJ5LnByb3RvdHlwZS5hZGRTaGFwZUxpc3QgPSBmdW5jdGlvbiAoIHNoYXBlcywgb3B0aW9ucyApIHtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHNoYXBlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHR0aGlzLmFkZFNoYXBlKCBzaGFwZXNbIGkgXSwgb3B0aW9ucyApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHQvKipcblx0ICogQWRkcyBhIHNoYXBlIHRvIFRIUkVFLlNoYXBlR2VvbWV0cnksIGJhc2VkIG9uIFRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5cblx0ICovXG5cdFRIUkVFLlNoYXBlR2VvbWV0cnkucHJvdG90eXBlLmFkZFNoYXBlID0gZnVuY3Rpb24gKCBzaGFwZSwgb3B0aW9ucyApIHtcblxuXHRcdGlmICggb3B0aW9ucyA9PT0gdW5kZWZpbmVkICkgb3B0aW9ucyA9IHt9O1xuXHRcdHZhciBjdXJ2ZVNlZ21lbnRzID0gb3B0aW9ucy5jdXJ2ZVNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmN1cnZlU2VnbWVudHMgOiAxMjtcblxuXHRcdHZhciBtYXRlcmlhbCA9IG9wdGlvbnMubWF0ZXJpYWw7XG5cdFx0dmFyIHV2Z2VuID0gb3B0aW9ucy5VVkdlbmVyYXRvciA9PT0gdW5kZWZpbmVkID8gVEhSRUUuRXh0cnVkZUdlb21ldHJ5LldvcmxkVVZHZW5lcmF0b3IgOiBvcHRpb25zLlVWR2VuZXJhdG9yO1xuXG5cdFx0Ly9cblxuXHRcdHZhciBpLCBsLCBob2xlO1xuXG5cdFx0dmFyIHNoYXBlc09mZnNldCA9IHRoaXMudmVydGljZXMubGVuZ3RoO1xuXHRcdHZhciBzaGFwZVBvaW50cyA9IHNoYXBlLmV4dHJhY3RQb2ludHMoIGN1cnZlU2VnbWVudHMgKTtcblxuXHRcdHZhciB2ZXJ0aWNlcyA9IHNoYXBlUG9pbnRzLnNoYXBlO1xuXHRcdHZhciBob2xlcyA9IHNoYXBlUG9pbnRzLmhvbGVzO1xuXG5cdFx0dmFyIHJldmVyc2UgPSAhIFRIUkVFLlNoYXBlVXRpbHMuaXNDbG9ja1dpc2UoIHZlcnRpY2VzICk7XG5cblx0XHRpZiAoIHJldmVyc2UgKSB7XG5cblx0XHRcdHZlcnRpY2VzID0gdmVydGljZXMucmV2ZXJzZSgpO1xuXG5cdFx0XHQvLyBNYXliZSB3ZSBzaG91bGQgYWxzbyBjaGVjayBpZiBob2xlcyBhcmUgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvbiwganVzdCB0byBiZSBzYWZlLi4uXG5cblx0XHRcdGZvciAoIGkgPSAwLCBsID0gaG9sZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRob2xlID0gaG9sZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIFRIUkVFLlNoYXBlVXRpbHMuaXNDbG9ja1dpc2UoIGhvbGUgKSApIHtcblxuXHRcdFx0XHRcdGhvbGVzWyBpIF0gPSBob2xlLnJldmVyc2UoKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV2ZXJzZSA9IGZhbHNlO1xuXG5cdFx0fVxuXG5cdFx0dmFyIGZhY2VzID0gVEhSRUUuU2hhcGVVdGlscy50cmlhbmd1bGF0ZVNoYXBlKCB2ZXJ0aWNlcywgaG9sZXMgKTtcblxuXHRcdC8vIFZlcnRpY2VzXG5cblx0XHRmb3IgKCBpID0gMCwgbCA9IGhvbGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGhvbGUgPSBob2xlc1sgaSBdO1xuXHRcdFx0dmVydGljZXMgPSB2ZXJ0aWNlcy5jb25jYXQoIGhvbGUgKTtcblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHR2YXIgdmVydCwgdmxlbiA9IHZlcnRpY2VzLmxlbmd0aDtcblx0XHR2YXIgZmFjZSwgZmxlbiA9IGZhY2VzLmxlbmd0aDtcblxuXHRcdGZvciAoIGkgPSAwOyBpIDwgdmxlbjsgaSArKyApIHtcblxuXHRcdFx0dmVydCA9IHZlcnRpY2VzWyBpIF07XG5cblx0XHRcdHRoaXMudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoIHZlcnQueCwgdmVydC55LCAwICkgKTtcblxuXHRcdH1cblxuXHRcdGZvciAoIGkgPSAwOyBpIDwgZmxlbjsgaSArKyApIHtcblxuXHRcdFx0ZmFjZSA9IGZhY2VzWyBpIF07XG5cblx0XHRcdHZhciBhID0gZmFjZVsgMCBdICsgc2hhcGVzT2Zmc2V0O1xuXHRcdFx0dmFyIGIgPSBmYWNlWyAxIF0gKyBzaGFwZXNPZmZzZXQ7XG5cdFx0XHR2YXIgYyA9IGZhY2VbIDIgXSArIHNoYXBlc09mZnNldDtcblxuXHRcdFx0dGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGEsIGIsIGMsIG51bGwsIG51bGwsIG1hdGVyaWFsICkgKTtcblx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIHV2Z2VuLmdlbmVyYXRlVG9wVVYoIHRoaXMsIGEsIGIsIGMgKSApO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0Ly8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvTGF0aGVHZW9tZXRyeS5qc1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIGFzdHJvZHVkIC8gaHR0cDovL2FzdHJvZHVkLmlzZ3JlYXQub3JnL1xuXHQgKiBAYXV0aG9yIHp6ODUgLyBodHRwczovL2dpdGh1Yi5jb20veno4NVxuXHQgKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXG5cdCAqL1xuXG5cdC8vIHBvaW50cyAtIHRvIGNyZWF0ZSBhIGNsb3NlZCB0b3J1cywgb25lIG11c3QgdXNlIGEgc2V0IG9mIHBvaW50cyBcblx0Ly8gICAgbGlrZSBzbzogWyBhLCBiLCBjLCBkLCBhIF0sIHNlZSBmaXJzdCBpcyB0aGUgc2FtZSBhcyBsYXN0LlxuXHQvLyBzZWdtZW50cyAtIHRoZSBudW1iZXIgb2YgY2lyY3VtZmVyZW5jZSBzZWdtZW50cyB0byBjcmVhdGVcblx0Ly8gcGhpU3RhcnQgLSB0aGUgc3RhcnRpbmcgcmFkaWFuXG5cdC8vIHBoaUxlbmd0aCAtIHRoZSByYWRpYW4gKDAgdG8gMipQSSkgcmFuZ2Ugb2YgdGhlIGxhdGhlZCBzZWN0aW9uXG5cdC8vICAgIDIqcGkgaXMgYSBjbG9zZWQgbGF0aGUsIGxlc3MgdGhhbiAyUEkgaXMgYSBwb3J0aW9uLlxuXG5cdFRIUkVFLkxhdGhlR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHBvaW50cywgc2VnbWVudHMsIHBoaVN0YXJ0LCBwaGlMZW5ndGggKSB7XG5cblx0XHRUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cblx0XHR0aGlzLnR5cGUgPSAnTGF0aGVHZW9tZXRyeSc7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHRwb2ludHM6IHBvaW50cyxcblx0XHRcdHNlZ21lbnRzOiBzZWdtZW50cyxcblx0XHRcdHBoaVN0YXJ0OiBwaGlTdGFydCxcblx0XHRcdHBoaUxlbmd0aDogcGhpTGVuZ3RoXG5cdFx0fTtcblxuXHRcdHNlZ21lbnRzID0gc2VnbWVudHMgfHwgMTI7XG5cdFx0cGhpU3RhcnQgPSBwaGlTdGFydCB8fCAwO1xuXHRcdHBoaUxlbmd0aCA9IHBoaUxlbmd0aCB8fCAyICogTWF0aC5QSTtcblxuXHRcdHZhciBpbnZlcnNlUG9pbnRMZW5ndGggPSAxLjAgLyAoIHBvaW50cy5sZW5ndGggLSAxICk7XG5cdFx0dmFyIGludmVyc2VTZWdtZW50cyA9IDEuMCAvIHNlZ21lbnRzO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHNlZ21lbnRzOyBpIDw9IGlsOyBpICsrICkge1xuXG5cdFx0XHR2YXIgcGhpID0gcGhpU3RhcnQgKyBpICogaW52ZXJzZVNlZ21lbnRzICogcGhpTGVuZ3RoO1xuXG5cdFx0XHR2YXIgYyA9IE1hdGguY29zKCBwaGkgKSxcblx0XHRcdFx0cyA9IE1hdGguc2luKCBwaGkgKTtcblxuXHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IHBvaW50cy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHR2YXIgcHQgPSBwb2ludHNbIGogXTtcblxuXHRcdFx0XHR2YXIgdmVydGV4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdFx0XHR2ZXJ0ZXgueCA9IGMgKiBwdC54IC0gcyAqIHB0Lnk7XG5cdFx0XHRcdHZlcnRleC55ID0gcyAqIHB0LnggKyBjICogcHQueTtcblx0XHRcdFx0dmVydGV4LnogPSBwdC56O1xuXG5cdFx0XHRcdHRoaXMudmVydGljZXMucHVzaCggdmVydGV4ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHZhciBucCA9IHBvaW50cy5sZW5ndGg7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gc2VnbWVudHM7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IHBvaW50cy5sZW5ndGggLSAxOyBqIDwgamw7IGogKysgKSB7XG5cblx0XHRcdFx0dmFyIGJhc2UgPSBqICsgbnAgKiBpO1xuXHRcdFx0XHR2YXIgYSA9IGJhc2U7XG5cdFx0XHRcdHZhciBiID0gYmFzZSArIG5wO1xuXHRcdFx0XHR2YXIgYyA9IGJhc2UgKyAxICsgbnA7XG5cdFx0XHRcdHZhciBkID0gYmFzZSArIDE7XG5cblx0XHRcdFx0dmFyIHUwID0gaSAqIGludmVyc2VTZWdtZW50cztcblx0XHRcdFx0dmFyIHYwID0gaiAqIGludmVyc2VQb2ludExlbmd0aDtcblx0XHRcdFx0dmFyIHUxID0gdTAgKyBpbnZlcnNlU2VnbWVudHM7XG5cdFx0XHRcdHZhciB2MSA9IHYwICsgaW52ZXJzZVBvaW50TGVuZ3RoO1xuXG5cdFx0XHRcdHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBhLCBiLCBkICkgKTtcblxuXHRcdFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbXG5cblx0XHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggdTAsIHYwICksXG5cdFx0XHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIHUxLCB2MCApLFxuXHRcdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCB1MCwgdjEgKVxuXG5cdFx0XHRcdF0gKTtcblxuXHRcdFx0XHR0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYiwgYywgZCApICk7XG5cblx0XHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggW1xuXG5cdFx0XHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIHUxLCB2MCApLFxuXHRcdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCB1MSwgdjEgKSxcblx0XHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggdTAsIHYxIClcblxuXHRcdFx0XHRdICk7XG5cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0dGhpcy5tZXJnZVZlcnRpY2VzKCk7XG5cdFx0dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcblx0XHR0aGlzLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XG5cblx0fTtcblxuXHRUSFJFRS5MYXRoZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xuXHRUSFJFRS5MYXRoZUdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkxhdGhlR2VvbWV0cnk7XG5cblx0Ly8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvUGxhbmVHZW9tZXRyeS5qc1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuXHQgKiBiYXNlZCBvbiBodHRwOi8vcGFwZXJ2aXNpb24zZC5nb29nbGVjb2RlLmNvbS9zdm4vdHJ1bmsvYXMzL3RydW5rL3NyYy9vcmcvcGFwZXJ2aXNpb24zZC9vYmplY3RzL3ByaW1pdGl2ZXMvUGxhbmUuYXNcblx0ICovXG5cblx0VEhSRUUuUGxhbmVHZW9tZXRyeSA9IGZ1bmN0aW9uICggd2lkdGgsIGhlaWdodCwgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMgKSB7XG5cblx0XHRUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cblx0XHR0aGlzLnR5cGUgPSAnUGxhbmVHZW9tZXRyeSc7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHR3aWR0aDogd2lkdGgsXG5cdFx0XHRoZWlnaHQ6IGhlaWdodCxcblx0XHRcdHdpZHRoU2VnbWVudHM6IHdpZHRoU2VnbWVudHMsXG5cdFx0XHRoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHNcblx0XHR9O1xuXG5cdFx0dGhpcy5mcm9tQnVmZmVyR2VvbWV0cnkoIG5ldyBUSFJFRS5QbGFuZUJ1ZmZlckdlb21ldHJ5KCB3aWR0aCwgaGVpZ2h0LCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cyApICk7XG5cblx0fTtcblxuXHRUSFJFRS5QbGFuZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xuXHRUSFJFRS5QbGFuZUdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlBsYW5lR2VvbWV0cnk7XG5cblx0VEhSRUUuUGxhbmVHZW9tZXRyeS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgcGFyYW1ldGVycyA9IHRoaXMucGFyYW1ldGVycztcblxuXHRcdHJldHVybiBuZXcgVEhSRUUuUGxhbmVHZW9tZXRyeShcblx0XHRcdHBhcmFtZXRlcnMud2lkdGgsXG5cdFx0XHRwYXJhbWV0ZXJzLmhlaWdodCxcblx0XHRcdHBhcmFtZXRlcnMud2lkdGhTZWdtZW50cyxcblx0XHRcdHBhcmFtZXRlcnMuaGVpZ2h0U2VnbWVudHNcblx0XHQpO1xuXG5cdH07XG5cblx0Ly8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvUGxhbmVCdWZmZXJHZW9tZXRyeS5qc1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuXHQgKiBiYXNlZCBvbiBodHRwOi8vcGFwZXJ2aXNpb24zZC5nb29nbGVjb2RlLmNvbS9zdm4vdHJ1bmsvYXMzL3RydW5rL3NyYy9vcmcvcGFwZXJ2aXNpb24zZC9vYmplY3RzL3ByaW1pdGl2ZXMvUGxhbmUuYXNcblx0ICovXG5cblx0VEhSRUUuUGxhbmVCdWZmZXJHZW9tZXRyeSA9IGZ1bmN0aW9uICggd2lkdGgsIGhlaWdodCwgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMgKSB7XG5cblx0XHRUSFJFRS5CdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cblx0XHR0aGlzLnR5cGUgPSAnUGxhbmVCdWZmZXJHZW9tZXRyeSc7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHR3aWR0aDogd2lkdGgsXG5cdFx0XHRoZWlnaHQ6IGhlaWdodCxcblx0XHRcdHdpZHRoU2VnbWVudHM6IHdpZHRoU2VnbWVudHMsXG5cdFx0XHRoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHNcblx0XHR9O1xuXG5cdFx0dmFyIHdpZHRoX2hhbGYgPSB3aWR0aCAvIDI7XG5cdFx0dmFyIGhlaWdodF9oYWxmID0gaGVpZ2h0IC8gMjtcblxuXHRcdHZhciBncmlkWCA9IE1hdGguZmxvb3IoIHdpZHRoU2VnbWVudHMgKSB8fCAxO1xuXHRcdHZhciBncmlkWSA9IE1hdGguZmxvb3IoIGhlaWdodFNlZ21lbnRzICkgfHwgMTtcblxuXHRcdHZhciBncmlkWDEgPSBncmlkWCArIDE7XG5cdFx0dmFyIGdyaWRZMSA9IGdyaWRZICsgMTtcblxuXHRcdHZhciBzZWdtZW50X3dpZHRoID0gd2lkdGggLyBncmlkWDtcblx0XHR2YXIgc2VnbWVudF9oZWlnaHQgPSBoZWlnaHQgLyBncmlkWTtcblxuXHRcdHZhciB2ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIGdyaWRYMSAqIGdyaWRZMSAqIDMgKTtcblx0XHR2YXIgbm9ybWFscyA9IG5ldyBGbG9hdDMyQXJyYXkoIGdyaWRYMSAqIGdyaWRZMSAqIDMgKTtcblx0XHR2YXIgdXZzID0gbmV3IEZsb2F0MzJBcnJheSggZ3JpZFgxICogZ3JpZFkxICogMiApO1xuXG5cdFx0dmFyIG9mZnNldCA9IDA7XG5cdFx0dmFyIG9mZnNldDIgPSAwO1xuXG5cdFx0Zm9yICggdmFyIGl5ID0gMDsgaXkgPCBncmlkWTE7IGl5ICsrICkge1xuXG5cdFx0XHR2YXIgeSA9IGl5ICogc2VnbWVudF9oZWlnaHQgLSBoZWlnaHRfaGFsZjtcblxuXHRcdFx0Zm9yICggdmFyIGl4ID0gMDsgaXggPCBncmlkWDE7IGl4ICsrICkge1xuXG5cdFx0XHRcdHZhciB4ID0gaXggKiBzZWdtZW50X3dpZHRoIC0gd2lkdGhfaGFsZjtcblxuXHRcdFx0XHR2ZXJ0aWNlc1sgb2Zmc2V0IF0gPSB4O1xuXHRcdFx0XHR2ZXJ0aWNlc1sgb2Zmc2V0ICsgMSBdID0gLSB5O1xuXG5cdFx0XHRcdG5vcm1hbHNbIG9mZnNldCArIDIgXSA9IDE7XG5cblx0XHRcdFx0dXZzWyBvZmZzZXQyIF0gPSBpeCAvIGdyaWRYO1xuXHRcdFx0XHR1dnNbIG9mZnNldDIgKyAxIF0gPSAxIC0gKCBpeSAvIGdyaWRZICk7XG5cblx0XHRcdFx0b2Zmc2V0ICs9IDM7XG5cdFx0XHRcdG9mZnNldDIgKz0gMjtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0b2Zmc2V0ID0gMDtcblxuXHRcdHZhciBpbmRpY2VzID0gbmV3ICggKCB2ZXJ0aWNlcy5sZW5ndGggLyAzICkgPiA2NTUzNSA/IFVpbnQzMkFycmF5IDogVWludDE2QXJyYXkgKSggZ3JpZFggKiBncmlkWSAqIDYgKTtcblxuXHRcdGZvciAoIHZhciBpeSA9IDA7IGl5IDwgZ3JpZFk7IGl5ICsrICkge1xuXG5cdFx0XHRmb3IgKCB2YXIgaXggPSAwOyBpeCA8IGdyaWRYOyBpeCArKyApIHtcblxuXHRcdFx0XHR2YXIgYSA9IGl4ICsgZ3JpZFgxICogaXk7XG5cdFx0XHRcdHZhciBiID0gaXggKyBncmlkWDEgKiAoIGl5ICsgMSApO1xuXHRcdFx0XHR2YXIgYyA9ICggaXggKyAxICkgKyBncmlkWDEgKiAoIGl5ICsgMSApO1xuXHRcdFx0XHR2YXIgZCA9ICggaXggKyAxICkgKyBncmlkWDEgKiBpeTtcblxuXHRcdFx0XHRpbmRpY2VzWyBvZmZzZXQgXSA9IGE7XG5cdFx0XHRcdGluZGljZXNbIG9mZnNldCArIDEgXSA9IGI7XG5cdFx0XHRcdGluZGljZXNbIG9mZnNldCArIDIgXSA9IGQ7XG5cblx0XHRcdFx0aW5kaWNlc1sgb2Zmc2V0ICsgMyBdID0gYjtcblx0XHRcdFx0aW5kaWNlc1sgb2Zmc2V0ICsgNCBdID0gYztcblx0XHRcdFx0aW5kaWNlc1sgb2Zmc2V0ICsgNSBdID0gZDtcblxuXHRcdFx0XHRvZmZzZXQgKz0gNjtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0dGhpcy5zZXRJbmRleCggbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggaW5kaWNlcywgMSApICk7XG5cdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcblx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKSApO1xuXHRcdHRoaXMuYWRkQXR0cmlidXRlKCAndXYnLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKSApO1xuXG5cdH07XG5cblx0VEhSRUUuUGxhbmVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcblx0VEhSRUUuUGxhbmVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5QbGFuZUJ1ZmZlckdlb21ldHJ5O1xuXG5cdFRIUkVFLlBsYW5lQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHBhcmFtZXRlcnMgPSB0aGlzLnBhcmFtZXRlcnM7XG5cblx0XHRyZXR1cm4gbmV3IFRIUkVFLlBsYW5lQnVmZmVyR2VvbWV0cnkoXG5cdFx0XHRwYXJhbWV0ZXJzLndpZHRoLFxuXHRcdFx0cGFyYW1ldGVycy5oZWlnaHQsXG5cdFx0XHRwYXJhbWV0ZXJzLndpZHRoU2VnbWVudHMsXG5cdFx0XHRwYXJhbWV0ZXJzLmhlaWdodFNlZ21lbnRzXG5cdFx0KTtcblxuXHR9O1xuXG5cdC8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL1JpbmdHZW9tZXRyeS5qc1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIEthbGViIE11cnBoeVxuXHQgKi9cblxuXHRUSFJFRS5SaW5nR2VvbWV0cnkgPSBmdW5jdGlvbiAoIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cywgdGhldGFTZWdtZW50cywgcGhpU2VnbWVudHMsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkge1xuXG5cdFx0VEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG5cdFx0dGhpcy50eXBlID0gJ1JpbmdHZW9tZXRyeSc7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHRpbm5lclJhZGl1czogaW5uZXJSYWRpdXMsXG5cdFx0XHRvdXRlclJhZGl1czogb3V0ZXJSYWRpdXMsXG5cdFx0XHR0aGV0YVNlZ21lbnRzOiB0aGV0YVNlZ21lbnRzLFxuXHRcdFx0cGhpU2VnbWVudHM6IHBoaVNlZ21lbnRzLFxuXHRcdFx0dGhldGFTdGFydDogdGhldGFTdGFydCxcblx0XHRcdHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxuXHRcdH07XG5cblx0XHRpbm5lclJhZGl1cyA9IGlubmVyUmFkaXVzIHx8IDA7XG5cdFx0b3V0ZXJSYWRpdXMgPSBvdXRlclJhZGl1cyB8fCA1MDtcblxuXHRcdHRoZXRhU3RhcnQgPSB0aGV0YVN0YXJ0ICE9PSB1bmRlZmluZWQgPyB0aGV0YVN0YXJ0IDogMDtcblx0XHR0aGV0YUxlbmd0aCA9IHRoZXRhTGVuZ3RoICE9PSB1bmRlZmluZWQgPyB0aGV0YUxlbmd0aCA6IE1hdGguUEkgKiAyO1xuXG5cdFx0dGhldGFTZWdtZW50cyA9IHRoZXRhU2VnbWVudHMgIT09IHVuZGVmaW5lZCA/IE1hdGgubWF4KCAzLCB0aGV0YVNlZ21lbnRzICkgOiA4O1xuXHRcdHBoaVNlZ21lbnRzID0gcGhpU2VnbWVudHMgIT09IHVuZGVmaW5lZCA/IE1hdGgubWF4KCAxLCBwaGlTZWdtZW50cyApIDogODtcblxuXHRcdHZhciBpLCBvLCB1dnMgPSBbXSwgcmFkaXVzID0gaW5uZXJSYWRpdXMsIHJhZGl1c1N0ZXAgPSAoICggb3V0ZXJSYWRpdXMgLSBpbm5lclJhZGl1cyApIC8gcGhpU2VnbWVudHMgKTtcblxuXHRcdGZvciAoIGkgPSAwOyBpIDwgcGhpU2VnbWVudHMgKyAxOyBpICsrICkge1xuXG5cdFx0XHQvLyBjb25jZW50cmljIGNpcmNsZXMgaW5zaWRlIHJpbmdcblxuXHRcdFx0Zm9yICggbyA9IDA7IG8gPCB0aGV0YVNlZ21lbnRzICsgMTsgbyArKyApIHtcblxuXHRcdFx0XHQvLyBudW1iZXIgb2Ygc2VnbWVudHMgcGVyIGNpcmNsZVxuXG5cdFx0XHRcdHZhciB2ZXJ0ZXggPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdFx0XHR2YXIgc2VnbWVudCA9IHRoZXRhU3RhcnQgKyBvIC8gdGhldGFTZWdtZW50cyAqIHRoZXRhTGVuZ3RoO1xuXHRcdFx0XHR2ZXJ0ZXgueCA9IHJhZGl1cyAqIE1hdGguY29zKCBzZWdtZW50ICk7XG5cdFx0XHRcdHZlcnRleC55ID0gcmFkaXVzICogTWF0aC5zaW4oIHNlZ21lbnQgKTtcblxuXHRcdFx0XHR0aGlzLnZlcnRpY2VzLnB1c2goIHZlcnRleCApO1xuXHRcdFx0XHR1dnMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoICggdmVydGV4LnggLyBvdXRlclJhZGl1cyArIDEgKSAvIDIsICggdmVydGV4LnkgLyBvdXRlclJhZGl1cyArIDEgKSAvIDIgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJhZGl1cyArPSByYWRpdXNTdGVwO1xuXG5cdFx0fVxuXG5cdFx0dmFyIG4gPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMCwgMSApO1xuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBwaGlTZWdtZW50czsgaSArKyApIHtcblxuXHRcdFx0Ly8gY29uY2VudHJpYyBjaXJjbGVzIGluc2lkZSByaW5nXG5cblx0XHRcdHZhciB0aGV0YVNlZ21lbnQgPSBpICogKCB0aGV0YVNlZ21lbnRzICsgMSApO1xuXG5cdFx0XHRmb3IgKCBvID0gMDsgbyA8IHRoZXRhU2VnbWVudHMgOyBvICsrICkge1xuXG5cdFx0XHRcdC8vIG51bWJlciBvZiBzZWdtZW50cyBwZXIgY2lyY2xlXG5cblx0XHRcdFx0dmFyIHNlZ21lbnQgPSBvICsgdGhldGFTZWdtZW50O1xuXG5cdFx0XHRcdHZhciB2MSA9IHNlZ21lbnQ7XG5cdFx0XHRcdHZhciB2MiA9IHNlZ21lbnQgKyB0aGV0YVNlZ21lbnRzICsgMTtcblx0XHRcdFx0dmFyIHYzID0gc2VnbWVudCArIHRoZXRhU2VnbWVudHMgKyAyO1xuXG5cdFx0XHRcdHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCB2MSwgdjIsIHYzLCBbIG4uY2xvbmUoKSwgbi5jbG9uZSgpLCBuLmNsb25lKCkgXSApICk7XG5cdFx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZzWyB2MSBdLmNsb25lKCksIHV2c1sgdjIgXS5jbG9uZSgpLCB1dnNbIHYzIF0uY2xvbmUoKSBdICk7XG5cblx0XHRcdFx0djEgPSBzZWdtZW50O1xuXHRcdFx0XHR2MiA9IHNlZ21lbnQgKyB0aGV0YVNlZ21lbnRzICsgMjtcblx0XHRcdFx0djMgPSBzZWdtZW50ICsgMTtcblxuXHRcdFx0XHR0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggdjEsIHYyLCB2MywgWyBuLmNsb25lKCksIG4uY2xvbmUoKSwgbi5jbG9uZSgpIF0gKSApO1xuXHRcdFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2c1sgdjEgXS5jbG9uZSgpLCB1dnNbIHYyIF0uY2xvbmUoKSwgdXZzWyB2MyBdLmNsb25lKCkgXSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHR0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xuXG5cdFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG5ldyBUSFJFRS5TcGhlcmUoIG5ldyBUSFJFRS5WZWN0b3IzKCksIHJhZGl1cyApO1xuXG5cdH07XG5cblx0VEhSRUUuUmluZ0dlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xuXHRUSFJFRS5SaW5nR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuUmluZ0dlb21ldHJ5O1xuXG5cdFRIUkVFLlJpbmdHZW9tZXRyeS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgcGFyYW1ldGVycyA9IHRoaXMucGFyYW1ldGVycztcblxuXHRcdHJldHVybiBuZXcgVEhSRUUuUmluZ0dlb21ldHJ5KFxuXHRcdFx0cGFyYW1ldGVycy5pbm5lclJhZGl1cyxcblx0XHRcdHBhcmFtZXRlcnMub3V0ZXJSYWRpdXMsXG5cdFx0XHRwYXJhbWV0ZXJzLnRoZXRhU2VnbWVudHMsXG5cdFx0XHRwYXJhbWV0ZXJzLnBoaVNlZ21lbnRzLFxuXHRcdFx0cGFyYW1ldGVycy50aGV0YVN0YXJ0LFxuXHRcdFx0cGFyYW1ldGVycy50aGV0YUxlbmd0aFxuXHRcdCk7XG5cblx0fTtcblxuXHQvLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9TcGhlcmVHZW9tZXRyeS5qc1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuXHQgKi9cblxuXHRUSFJFRS5TcGhlcmVHZW9tZXRyeSA9IGZ1bmN0aW9uICggcmFkaXVzLCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgcGhpU3RhcnQsIHBoaUxlbmd0aCwgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSB7XG5cblx0XHRUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cblx0XHR0aGlzLnR5cGUgPSAnU3BoZXJlR2VvbWV0cnknO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0XHR3aWR0aFNlZ21lbnRzOiB3aWR0aFNlZ21lbnRzLFxuXHRcdFx0aGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzLFxuXHRcdFx0cGhpU3RhcnQ6IHBoaVN0YXJ0LFxuXHRcdFx0cGhpTGVuZ3RoOiBwaGlMZW5ndGgsXG5cdFx0XHR0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxuXHRcdFx0dGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXG5cdFx0fTtcblxuXHRcdHRoaXMuZnJvbUJ1ZmZlckdlb21ldHJ5KCBuZXcgVEhSRUUuU3BoZXJlQnVmZmVyR2VvbWV0cnkoIHJhZGl1cywgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIHBoaVN0YXJ0LCBwaGlMZW5ndGgsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkgKTtcblxuXHR9O1xuXG5cdFRIUkVFLlNwaGVyZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xuXHRUSFJFRS5TcGhlcmVHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5TcGhlcmVHZW9tZXRyeTtcblxuXHRUSFJFRS5TcGhlcmVHZW9tZXRyeS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgcGFyYW1ldGVycyA9IHRoaXMucGFyYW1ldGVycztcblxuXHRcdHJldHVybiBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoXG5cdFx0XHRwYXJhbWV0ZXJzLnJhZGl1cyxcblx0XHRcdHBhcmFtZXRlcnMud2lkdGhTZWdtZW50cyxcblx0XHRcdHBhcmFtZXRlcnMuaGVpZ2h0U2VnbWVudHMsXG5cdFx0XHRwYXJhbWV0ZXJzLnBoaVN0YXJ0LFxuXHRcdFx0cGFyYW1ldGVycy5waGlMZW5ndGgsXG5cdFx0XHRwYXJhbWV0ZXJzLnRoZXRhU3RhcnQsXG5cdFx0XHRwYXJhbWV0ZXJzLnRoZXRhTGVuZ3RoXG5cdFx0KTtcblxuXHR9O1xuXG5cdC8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL1NwaGVyZUJ1ZmZlckdlb21ldHJ5LmpzXG5cblx0LyoqXG5cdCAqIEBhdXRob3IgYmVuYWFkYW1zIC8gaHR0cHM6Ly90d2l0dGVyLmNvbS9iZW5fYV9hZGFtc1xuXHQgKiBiYXNlZCBvbiBUSFJFRS5TcGhlcmVHZW9tZXRyeVxuXHQgKi9cblxuXHRUSFJFRS5TcGhlcmVCdWZmZXJHZW9tZXRyeSA9IGZ1bmN0aW9uICggcmFkaXVzLCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgcGhpU3RhcnQsIHBoaUxlbmd0aCwgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSB7XG5cblx0XHRUSFJFRS5CdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cblx0XHR0aGlzLnR5cGUgPSAnU3BoZXJlQnVmZmVyR2VvbWV0cnknO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0XHR3aWR0aFNlZ21lbnRzOiB3aWR0aFNlZ21lbnRzLFxuXHRcdFx0aGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzLFxuXHRcdFx0cGhpU3RhcnQ6IHBoaVN0YXJ0LFxuXHRcdFx0cGhpTGVuZ3RoOiBwaGlMZW5ndGgsXG5cdFx0XHR0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxuXHRcdFx0dGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXG5cdFx0fTtcblxuXHRcdHJhZGl1cyA9IHJhZGl1cyB8fCA1MDtcblxuXHRcdHdpZHRoU2VnbWVudHMgPSBNYXRoLm1heCggMywgTWF0aC5mbG9vciggd2lkdGhTZWdtZW50cyApIHx8IDggKTtcblx0XHRoZWlnaHRTZWdtZW50cyA9IE1hdGgubWF4KCAyLCBNYXRoLmZsb29yKCBoZWlnaHRTZWdtZW50cyApIHx8IDYgKTtcblxuXHRcdHBoaVN0YXJ0ID0gcGhpU3RhcnQgIT09IHVuZGVmaW5lZCA/IHBoaVN0YXJ0IDogMDtcblx0XHRwaGlMZW5ndGggPSBwaGlMZW5ndGggIT09IHVuZGVmaW5lZCA/IHBoaUxlbmd0aCA6IE1hdGguUEkgKiAyO1xuXG5cdFx0dGhldGFTdGFydCA9IHRoZXRhU3RhcnQgIT09IHVuZGVmaW5lZCA/IHRoZXRhU3RhcnQgOiAwO1xuXHRcdHRoZXRhTGVuZ3RoID0gdGhldGFMZW5ndGggIT09IHVuZGVmaW5lZCA/IHRoZXRhTGVuZ3RoIDogTWF0aC5QSTtcblxuXHRcdHZhciB0aGV0YUVuZCA9IHRoZXRhU3RhcnQgKyB0aGV0YUxlbmd0aDtcblxuXHRcdHZhciB2ZXJ0ZXhDb3VudCA9ICggKCB3aWR0aFNlZ21lbnRzICsgMSApICogKCBoZWlnaHRTZWdtZW50cyArIDEgKSApO1xuXG5cdFx0dmFyIHBvc2l0aW9ucyA9IG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBGbG9hdDMyQXJyYXkoIHZlcnRleENvdW50ICogMyApLCAzICk7XG5cdFx0dmFyIG5vcm1hbHMgPSBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCB2ZXJ0ZXhDb3VudCAqIDMgKSwgMyApO1xuXHRcdHZhciB1dnMgPSBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCB2ZXJ0ZXhDb3VudCAqIDIgKSwgMiApO1xuXG5cdFx0dmFyIGluZGV4ID0gMCwgdmVydGljZXMgPSBbXSwgbm9ybWFsID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdGZvciAoIHZhciB5ID0gMDsgeSA8PSBoZWlnaHRTZWdtZW50czsgeSArKyApIHtcblxuXHRcdFx0dmFyIHZlcnRpY2VzUm93ID0gW107XG5cblx0XHRcdHZhciB2ID0geSAvIGhlaWdodFNlZ21lbnRzO1xuXG5cdFx0XHRmb3IgKCB2YXIgeCA9IDA7IHggPD0gd2lkdGhTZWdtZW50czsgeCArKyApIHtcblxuXHRcdFx0XHR2YXIgdSA9IHggLyB3aWR0aFNlZ21lbnRzO1xuXG5cdFx0XHRcdHZhciBweCA9IC0gcmFkaXVzICogTWF0aC5jb3MoIHBoaVN0YXJ0ICsgdSAqIHBoaUxlbmd0aCApICogTWF0aC5zaW4oIHRoZXRhU3RhcnQgKyB2ICogdGhldGFMZW5ndGggKTtcblx0XHRcdFx0dmFyIHB5ID0gcmFkaXVzICogTWF0aC5jb3MoIHRoZXRhU3RhcnQgKyB2ICogdGhldGFMZW5ndGggKTtcblx0XHRcdFx0dmFyIHB6ID0gcmFkaXVzICogTWF0aC5zaW4oIHBoaVN0YXJ0ICsgdSAqIHBoaUxlbmd0aCApICogTWF0aC5zaW4oIHRoZXRhU3RhcnQgKyB2ICogdGhldGFMZW5ndGggKTtcblxuXHRcdFx0XHRub3JtYWwuc2V0KCBweCwgcHksIHB6ICkubm9ybWFsaXplKCk7XG5cblx0XHRcdFx0cG9zaXRpb25zLnNldFhZWiggaW5kZXgsIHB4LCBweSwgcHogKTtcblx0XHRcdFx0bm9ybWFscy5zZXRYWVooIGluZGV4LCBub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56ICk7XG5cdFx0XHRcdHV2cy5zZXRYWSggaW5kZXgsIHUsIDEgLSB2ICk7XG5cblx0XHRcdFx0dmVydGljZXNSb3cucHVzaCggaW5kZXggKTtcblxuXHRcdFx0XHRpbmRleCArKztcblxuXHRcdFx0fVxuXG5cdFx0XHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0aWNlc1JvdyApO1xuXG5cdFx0fVxuXG5cdFx0dmFyIGluZGljZXMgPSBbXTtcblxuXHRcdGZvciAoIHZhciB5ID0gMDsgeSA8IGhlaWdodFNlZ21lbnRzOyB5ICsrICkge1xuXG5cdFx0XHRmb3IgKCB2YXIgeCA9IDA7IHggPCB3aWR0aFNlZ21lbnRzOyB4ICsrICkge1xuXG5cdFx0XHRcdHZhciB2MSA9IHZlcnRpY2VzWyB5IF1bIHggKyAxIF07XG5cdFx0XHRcdHZhciB2MiA9IHZlcnRpY2VzWyB5IF1bIHggXTtcblx0XHRcdFx0dmFyIHYzID0gdmVydGljZXNbIHkgKyAxIF1bIHggXTtcblx0XHRcdFx0dmFyIHY0ID0gdmVydGljZXNbIHkgKyAxIF1bIHggKyAxIF07XG5cblx0XHRcdFx0aWYgKCB5ICE9PSAwIHx8IHRoZXRhU3RhcnQgPiAwICkgaW5kaWNlcy5wdXNoKCB2MSwgdjIsIHY0ICk7XG5cdFx0XHRcdGlmICggeSAhPT0gaGVpZ2h0U2VnbWVudHMgLSAxIHx8IHRoZXRhRW5kIDwgTWF0aC5QSSApIGluZGljZXMucHVzaCggdjIsIHYzLCB2NCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHR0aGlzLnNldEluZGV4KCBuZXcgKCBwb3NpdGlvbnMuY291bnQgPiA2NTUzNSA/IFRIUkVFLlVpbnQzMkF0dHJpYnV0ZSA6IFRIUkVFLlVpbnQxNkF0dHJpYnV0ZSApKCBpbmRpY2VzLCAxICkgKTtcblx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgcG9zaXRpb25zICk7XG5cdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdub3JtYWwnLCBub3JtYWxzICk7XG5cdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICd1dicsIHV2cyApO1xuXG5cdFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG5ldyBUSFJFRS5TcGhlcmUoIG5ldyBUSFJFRS5WZWN0b3IzKCksIHJhZGl1cyApO1xuXG5cdH07XG5cblx0VEhSRUUuU3BoZXJlQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XG5cdFRIUkVFLlNwaGVyZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlNwaGVyZUJ1ZmZlckdlb21ldHJ5O1xuXG5cdFRIUkVFLlNwaGVyZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBwYXJhbWV0ZXJzID0gdGhpcy5wYXJhbWV0ZXJzO1xuXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5TcGhlcmVCdWZmZXJHZW9tZXRyeShcblx0XHRcdHBhcmFtZXRlcnMucmFkaXVzLFxuXHRcdFx0cGFyYW1ldGVycy53aWR0aFNlZ21lbnRzLFxuXHRcdFx0cGFyYW1ldGVycy5oZWlnaHRTZWdtZW50cyxcblx0XHRcdHBhcmFtZXRlcnMucGhpU3RhcnQsXG5cdFx0XHRwYXJhbWV0ZXJzLnBoaUxlbmd0aCxcblx0XHRcdHBhcmFtZXRlcnMudGhldGFTdGFydCxcblx0XHRcdHBhcmFtZXRlcnMudGhldGFMZW5ndGhcblx0XHQpO1xuXG5cdH07XG5cblx0Ly8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvVG9ydXNHZW9tZXRyeS5qc1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIG9vc21veGllY29kZVxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuXHQgKiBiYXNlZCBvbiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvYXdheTNkL3NvdXJjZS9icm93c2UvdHJ1bmsvZnAxMC9Bd2F5M0RMaXRlL3NyYy9hd2F5M2RsaXRlL3ByaW1pdGl2ZXMvVG9ydXMuYXM/cj0yODg4XG5cdCAqL1xuXG5cdFRIUkVFLlRvcnVzR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHJhZGl1cywgdHViZSwgcmFkaWFsU2VnbWVudHMsIHR1YnVsYXJTZWdtZW50cywgYXJjICkge1xuXG5cdFx0VEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG5cdFx0dGhpcy50eXBlID0gJ1RvcnVzR2VvbWV0cnknO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0XHR0dWJlOiB0dWJlLFxuXHRcdFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxuXHRcdFx0dHVidWxhclNlZ21lbnRzOiB0dWJ1bGFyU2VnbWVudHMsXG5cdFx0XHRhcmM6IGFyY1xuXHRcdH07XG5cblx0XHRyYWRpdXMgPSByYWRpdXMgfHwgMTAwO1xuXHRcdHR1YmUgPSB0dWJlIHx8IDQwO1xuXHRcdHJhZGlhbFNlZ21lbnRzID0gcmFkaWFsU2VnbWVudHMgfHwgODtcblx0XHR0dWJ1bGFyU2VnbWVudHMgPSB0dWJ1bGFyU2VnbWVudHMgfHwgNjtcblx0XHRhcmMgPSBhcmMgfHwgTWF0aC5QSSAqIDI7XG5cblx0XHR2YXIgY2VudGVyID0gbmV3IFRIUkVFLlZlY3RvcjMoKSwgdXZzID0gW10sIG5vcm1hbHMgPSBbXTtcblxuXHRcdGZvciAoIHZhciBqID0gMDsgaiA8PSByYWRpYWxTZWdtZW50czsgaiArKyApIHtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDw9IHR1YnVsYXJTZWdtZW50czsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgdSA9IGkgLyB0dWJ1bGFyU2VnbWVudHMgKiBhcmM7XG5cdFx0XHRcdHZhciB2ID0gaiAvIHJhZGlhbFNlZ21lbnRzICogTWF0aC5QSSAqIDI7XG5cblx0XHRcdFx0Y2VudGVyLnggPSByYWRpdXMgKiBNYXRoLmNvcyggdSApO1xuXHRcdFx0XHRjZW50ZXIueSA9IHJhZGl1cyAqIE1hdGguc2luKCB1ICk7XG5cblx0XHRcdFx0dmFyIHZlcnRleCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0XHRcdHZlcnRleC54ID0gKCByYWRpdXMgKyB0dWJlICogTWF0aC5jb3MoIHYgKSApICogTWF0aC5jb3MoIHUgKTtcblx0XHRcdFx0dmVydGV4LnkgPSAoIHJhZGl1cyArIHR1YmUgKiBNYXRoLmNvcyggdiApICkgKiBNYXRoLnNpbiggdSApO1xuXHRcdFx0XHR2ZXJ0ZXgueiA9IHR1YmUgKiBNYXRoLnNpbiggdiApO1xuXG5cdFx0XHRcdHRoaXMudmVydGljZXMucHVzaCggdmVydGV4ICk7XG5cblx0XHRcdFx0dXZzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCBpIC8gdHVidWxhclNlZ21lbnRzLCBqIC8gcmFkaWFsU2VnbWVudHMgKSApO1xuXHRcdFx0XHRub3JtYWxzLnB1c2goIHZlcnRleC5jbG9uZSgpLnN1YiggY2VudGVyICkubm9ybWFsaXplKCkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Zm9yICggdmFyIGogPSAxOyBqIDw9IHJhZGlhbFNlZ21lbnRzOyBqICsrICkge1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDE7IGkgPD0gdHVidWxhclNlZ21lbnRzOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBhID0gKCB0dWJ1bGFyU2VnbWVudHMgKyAxICkgKiBqICsgaSAtIDE7XG5cdFx0XHRcdHZhciBiID0gKCB0dWJ1bGFyU2VnbWVudHMgKyAxICkgKiAoIGogLSAxICkgKyBpIC0gMTtcblx0XHRcdFx0dmFyIGMgPSAoIHR1YnVsYXJTZWdtZW50cyArIDEgKSAqICggaiAtIDEgKSArIGk7XG5cdFx0XHRcdHZhciBkID0gKCB0dWJ1bGFyU2VnbWVudHMgKyAxICkgKiBqICsgaTtcblxuXHRcdFx0XHR2YXIgZmFjZSA9IG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgZCwgWyBub3JtYWxzWyBhIF0uY2xvbmUoKSwgbm9ybWFsc1sgYiBdLmNsb25lKCksIG5vcm1hbHNbIGQgXS5jbG9uZSgpIF0gKTtcblx0XHRcdFx0dGhpcy5mYWNlcy5wdXNoKCBmYWNlICk7XG5cdFx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZzWyBhIF0uY2xvbmUoKSwgdXZzWyBiIF0uY2xvbmUoKSwgdXZzWyBkIF0uY2xvbmUoKSBdICk7XG5cblx0XHRcdFx0ZmFjZSA9IG5ldyBUSFJFRS5GYWNlMyggYiwgYywgZCwgWyBub3JtYWxzWyBiIF0uY2xvbmUoKSwgbm9ybWFsc1sgYyBdLmNsb25lKCksIG5vcm1hbHNbIGQgXS5jbG9uZSgpIF0gKTtcblx0XHRcdFx0dGhpcy5mYWNlcy5wdXNoKCBmYWNlICk7XG5cdFx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZzWyBiIF0uY2xvbmUoKSwgdXZzWyBjIF0uY2xvbmUoKSwgdXZzWyBkIF0uY2xvbmUoKSBdICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG5cblx0fTtcblxuXHRUSFJFRS5Ub3J1c0dlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xuXHRUSFJFRS5Ub3J1c0dlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlRvcnVzR2VvbWV0cnk7XG5cblx0VEhSRUUuVG9ydXNHZW9tZXRyeS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgcGFyYW1ldGVycyA9IHRoaXMucGFyYW1ldGVycztcblxuXHRcdHJldHVybiBuZXcgVEhSRUUuVG9ydXNHZW9tZXRyeShcblx0XHRcdHBhcmFtZXRlcnMucmFkaXVzLFxuXHRcdFx0cGFyYW1ldGVycy50dWJlLFxuXHRcdFx0cGFyYW1ldGVycy5yYWRpYWxTZWdtZW50cyxcblx0XHRcdHBhcmFtZXRlcnMudHVidWxhclNlZ21lbnRzLFxuXHRcdFx0cGFyYW1ldGVycy5hcmNcblx0XHQpO1xuXG5cdH07XG5cblx0Ly8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvVG9ydXNLbm90R2VvbWV0cnkuanNcblxuXHQvKipcblx0ICogQGF1dGhvciBvb3Ntb3hpZWNvZGVcblx0ICogYmFzZWQgb24gaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2F3YXkzZC9zb3VyY2UvYnJvd3NlL3RydW5rL2ZwMTAvQXdheTNEL3NyYy9hd2F5M2QvcHJpbWl0aXZlcy9Ub3J1c0tub3QuYXM/c3BlYz1zdm4yNDczJnI9MjQ3M1xuXHQgKi9cblxuXHRUSFJFRS5Ub3J1c0tub3RHZW9tZXRyeSA9IGZ1bmN0aW9uICggcmFkaXVzLCB0dWJlLCByYWRpYWxTZWdtZW50cywgdHVidWxhclNlZ21lbnRzLCBwLCBxLCBoZWlnaHRTY2FsZSApIHtcblxuXHRcdFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuXHRcdHRoaXMudHlwZSA9ICdUb3J1c0tub3RHZW9tZXRyeSc7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHRyYWRpdXM6IHJhZGl1cyxcblx0XHRcdHR1YmU6IHR1YmUsXG5cdFx0XHRyYWRpYWxTZWdtZW50czogcmFkaWFsU2VnbWVudHMsXG5cdFx0XHR0dWJ1bGFyU2VnbWVudHM6IHR1YnVsYXJTZWdtZW50cyxcblx0XHRcdHA6IHAsXG5cdFx0XHRxOiBxLFxuXHRcdFx0aGVpZ2h0U2NhbGU6IGhlaWdodFNjYWxlXG5cdFx0fTtcblxuXHRcdHJhZGl1cyA9IHJhZGl1cyB8fCAxMDA7XG5cdFx0dHViZSA9IHR1YmUgfHwgNDA7XG5cdFx0cmFkaWFsU2VnbWVudHMgPSByYWRpYWxTZWdtZW50cyB8fCA2NDtcblx0XHR0dWJ1bGFyU2VnbWVudHMgPSB0dWJ1bGFyU2VnbWVudHMgfHwgODtcblx0XHRwID0gcCB8fCAyO1xuXHRcdHEgPSBxIHx8IDM7XG5cdFx0aGVpZ2h0U2NhbGUgPSBoZWlnaHRTY2FsZSB8fCAxO1xuXG5cdFx0dmFyIGdyaWQgPSBuZXcgQXJyYXkoIHJhZGlhbFNlZ21lbnRzICk7XG5cdFx0dmFyIHRhbmcgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdHZhciBuID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHR2YXIgYml0YW4gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgcmFkaWFsU2VnbWVudHM7ICsrIGkgKSB7XG5cblx0XHRcdGdyaWRbIGkgXSA9IG5ldyBBcnJheSggdHVidWxhclNlZ21lbnRzICk7XG5cdFx0XHR2YXIgdSA9IGkgLyByYWRpYWxTZWdtZW50cyAqIDIgKiBwICogTWF0aC5QSTtcblx0XHRcdHZhciBwMSA9IGdldFBvcyggdSwgcSwgcCwgcmFkaXVzLCBoZWlnaHRTY2FsZSApO1xuXHRcdFx0dmFyIHAyID0gZ2V0UG9zKCB1ICsgMC4wMSwgcSwgcCwgcmFkaXVzLCBoZWlnaHRTY2FsZSApO1xuXHRcdFx0dGFuZy5zdWJWZWN0b3JzKCBwMiwgcDEgKTtcblx0XHRcdG4uYWRkVmVjdG9ycyggcDIsIHAxICk7XG5cblx0XHRcdGJpdGFuLmNyb3NzVmVjdG9ycyggdGFuZywgbiApO1xuXHRcdFx0bi5jcm9zc1ZlY3RvcnMoIGJpdGFuLCB0YW5nICk7XG5cdFx0XHRiaXRhbi5ub3JtYWxpemUoKTtcblx0XHRcdG4ubm9ybWFsaXplKCk7XG5cblx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8IHR1YnVsYXJTZWdtZW50czsgKysgaiApIHtcblxuXHRcdFx0XHR2YXIgdiA9IGogLyB0dWJ1bGFyU2VnbWVudHMgKiAyICogTWF0aC5QSTtcblx0XHRcdFx0dmFyIGN4ID0gLSB0dWJlICogTWF0aC5jb3MoIHYgKTsgLy8gVE9ETzogSGFjazogTmVnYXRpbmcgaXQgc28gaXQgZmFjZXMgb3V0c2lkZS5cblx0XHRcdFx0dmFyIGN5ID0gdHViZSAqIE1hdGguc2luKCB2ICk7XG5cblx0XHRcdFx0dmFyIHBvcyA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0XHRcdHBvcy54ID0gcDEueCArIGN4ICogbi54ICsgY3kgKiBiaXRhbi54O1xuXHRcdFx0XHRwb3MueSA9IHAxLnkgKyBjeCAqIG4ueSArIGN5ICogYml0YW4ueTtcblx0XHRcdFx0cG9zLnogPSBwMS56ICsgY3ggKiBuLnogKyBjeSAqIGJpdGFuLno7XG5cblx0XHRcdFx0Z3JpZFsgaSBdWyBqIF0gPSB0aGlzLnZlcnRpY2VzLnB1c2goIHBvcyApIC0gMTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgcmFkaWFsU2VnbWVudHM7ICsrIGkgKSB7XG5cblx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8IHR1YnVsYXJTZWdtZW50czsgKysgaiApIHtcblxuXHRcdFx0XHR2YXIgaXAgPSAoIGkgKyAxICkgJSByYWRpYWxTZWdtZW50cztcblx0XHRcdFx0dmFyIGpwID0gKCBqICsgMSApICUgdHVidWxhclNlZ21lbnRzO1xuXG5cdFx0XHRcdHZhciBhID0gZ3JpZFsgaSBdWyBqIF07XG5cdFx0XHRcdHZhciBiID0gZ3JpZFsgaXAgXVsgaiBdO1xuXHRcdFx0XHR2YXIgYyA9IGdyaWRbIGlwIF1bIGpwIF07XG5cdFx0XHRcdHZhciBkID0gZ3JpZFsgaSBdWyBqcCBdO1xuXG5cdFx0XHRcdHZhciB1dmEgPSBuZXcgVEhSRUUuVmVjdG9yMiggaSAvIHJhZGlhbFNlZ21lbnRzLCBqIC8gdHVidWxhclNlZ21lbnRzICk7XG5cdFx0XHRcdHZhciB1dmIgPSBuZXcgVEhSRUUuVmVjdG9yMiggKCBpICsgMSApIC8gcmFkaWFsU2VnbWVudHMsIGogLyB0dWJ1bGFyU2VnbWVudHMgKTtcblx0XHRcdFx0dmFyIHV2YyA9IG5ldyBUSFJFRS5WZWN0b3IyKCAoIGkgKyAxICkgLyByYWRpYWxTZWdtZW50cywgKCBqICsgMSApIC8gdHVidWxhclNlZ21lbnRzICk7XG5cdFx0XHRcdHZhciB1dmQgPSBuZXcgVEhSRUUuVmVjdG9yMiggaSAvIHJhZGlhbFNlZ21lbnRzLCAoIGogKyAxICkgLyB0dWJ1bGFyU2VnbWVudHMgKTtcblxuXHRcdFx0XHR0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgZCApICk7XG5cdFx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZhLCB1dmIsIHV2ZCBdICk7XG5cblx0XHRcdFx0dGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGIsIGMsIGQgKSApO1xuXHRcdFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2Yi5jbG9uZSgpLCB1dmMsIHV2ZC5jbG9uZSgpIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcblx0XHR0aGlzLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XG5cblx0XHRmdW5jdGlvbiBnZXRQb3MoIHUsIGluX3EsIGluX3AsIHJhZGl1cywgaGVpZ2h0U2NhbGUgKSB7XG5cblx0XHRcdHZhciBjdSA9IE1hdGguY29zKCB1ICk7XG5cdFx0XHR2YXIgc3UgPSBNYXRoLnNpbiggdSApO1xuXHRcdFx0dmFyIHF1T3ZlclAgPSBpbl9xIC8gaW5fcCAqIHU7XG5cdFx0XHR2YXIgY3MgPSBNYXRoLmNvcyggcXVPdmVyUCApO1xuXG5cdFx0XHR2YXIgdHggPSByYWRpdXMgKiAoIDIgKyBjcyApICogMC41ICogY3U7XG5cdFx0XHR2YXIgdHkgPSByYWRpdXMgKiAoIDIgKyBjcyApICogc3UgKiAwLjU7XG5cdFx0XHR2YXIgdHogPSBoZWlnaHRTY2FsZSAqIHJhZGl1cyAqIE1hdGguc2luKCBxdU92ZXJQICkgKiAwLjU7XG5cblx0XHRcdHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMyggdHgsIHR5LCB0eiApO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0VEhSRUUuVG9ydXNLbm90R2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XG5cdFRIUkVFLlRvcnVzS25vdEdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlRvcnVzS25vdEdlb21ldHJ5O1xuXG5cdFRIUkVFLlRvcnVzS25vdEdlb21ldHJ5LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBwYXJhbWV0ZXJzID0gdGhpcy5wYXJhbWV0ZXJzO1xuXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5Ub3J1c0tub3RHZW9tZXRyeShcblx0XHRcdHBhcmFtZXRlcnMucmFkaXVzLFxuXHRcdFx0cGFyYW1ldGVycy50dWJlLFxuXHRcdFx0cGFyYW1ldGVycy5yYWRpYWxTZWdtZW50cyxcblx0XHRcdHBhcmFtZXRlcnMudHVidWxhclNlZ21lbnRzLFxuXHRcdFx0cGFyYW1ldGVycy5wLFxuXHRcdFx0cGFyYW1ldGVycy5xLFxuXHRcdFx0cGFyYW1ldGVycy5oZWlnaHRTY2FsZVxuXHRcdCk7XG5cblx0fTtcblxuXHQvLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9UdWJlR2VvbWV0cnkuanNcblxuXHQvKipcblx0ICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHBzOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuXHQgKiBAYXV0aG9yIHp6ODUgLyBodHRwczovL2dpdGh1Yi5jb20veno4NVxuXHQgKiBAYXV0aG9yIG1pbmluZ29sZCAvIGh0dHBzOi8vZ2l0aHViLmNvbS9taW5pbmdvbGRcblx0ICogQGF1dGhvciBqb25vYnIxIC8gaHR0cHM6Ly9naXRodWIuY29tL2pvbm9icjFcblx0ICpcblx0ICogTW9kaWZpZWQgZnJvbSB0aGUgVG9ydXNLbm90R2VvbWV0cnkgYnkgQG9vc21veGllY29kZVxuXHQgKlxuXHQgKiBDcmVhdGVzIGEgdHViZSB3aGljaCBleHRydWRlcyBhbG9uZyBhIDNkIHNwbGluZVxuXHQgKlxuXHQgKiBVc2VzIHBhcmFsbGVsIHRyYW5zcG9ydCBmcmFtZXMgYXMgZGVzY3JpYmVkIGluXG5cdCAqIGh0dHA6Ly93d3cuY3MuaW5kaWFuYS5lZHUvcHViL3RlY2hyZXBvcnRzL1RSNDI1LnBkZlxuXHQgKi9cblxuXHRUSFJFRS5UdWJlR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHBhdGgsIHNlZ21lbnRzLCByYWRpdXMsIHJhZGlhbFNlZ21lbnRzLCBjbG9zZWQsIHRhcGVyICkge1xuXG5cdFx0VEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG5cdFx0dGhpcy50eXBlID0gJ1R1YmVHZW9tZXRyeSc7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHRwYXRoOiBwYXRoLFxuXHRcdFx0c2VnbWVudHM6IHNlZ21lbnRzLFxuXHRcdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0XHRyYWRpYWxTZWdtZW50czogcmFkaWFsU2VnbWVudHMsXG5cdFx0XHRjbG9zZWQ6IGNsb3NlZCxcblx0XHRcdHRhcGVyOiB0YXBlclxuXHRcdH07XG5cblx0XHRzZWdtZW50cyA9IHNlZ21lbnRzIHx8IDY0O1xuXHRcdHJhZGl1cyA9IHJhZGl1cyB8fCAxO1xuXHRcdHJhZGlhbFNlZ21lbnRzID0gcmFkaWFsU2VnbWVudHMgfHwgODtcblx0XHRjbG9zZWQgPSBjbG9zZWQgfHwgZmFsc2U7XG5cdFx0dGFwZXIgPSB0YXBlciB8fCBUSFJFRS5UdWJlR2VvbWV0cnkuTm9UYXBlcjtcblxuXHRcdHZhciBncmlkID0gW107XG5cblx0XHR2YXIgc2NvcGUgPSB0aGlzLFxuXG5cdFx0XHR0YW5nZW50LFxuXHRcdFx0bm9ybWFsLFxuXHRcdFx0Ymlub3JtYWwsXG5cblx0XHRcdG51bXBvaW50cyA9IHNlZ21lbnRzICsgMSxcblxuXHRcdFx0dSwgdiwgcixcblxuXHRcdFx0Y3gsIGN5LFxuXHRcdFx0cG9zLCBwb3MyID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcblx0XHRcdGksIGosXG5cdFx0XHRpcCwganAsXG5cdFx0XHRhLCBiLCBjLCBkLFxuXHRcdFx0dXZhLCB1dmIsIHV2YywgdXZkO1xuXG5cdFx0dmFyIGZyYW1lcyA9IG5ldyBUSFJFRS5UdWJlR2VvbWV0cnkuRnJlbmV0RnJhbWVzKCBwYXRoLCBzZWdtZW50cywgY2xvc2VkICksXG5cdFx0XHR0YW5nZW50cyA9IGZyYW1lcy50YW5nZW50cyxcblx0XHRcdG5vcm1hbHMgPSBmcmFtZXMubm9ybWFscyxcblx0XHRcdGJpbm9ybWFscyA9IGZyYW1lcy5iaW5vcm1hbHM7XG5cblx0XHQvLyBwcm94eSBpbnRlcm5hbHNcblx0XHR0aGlzLnRhbmdlbnRzID0gdGFuZ2VudHM7XG5cdFx0dGhpcy5ub3JtYWxzID0gbm9ybWFscztcblx0XHR0aGlzLmJpbm9ybWFscyA9IGJpbm9ybWFscztcblxuXHRcdGZ1bmN0aW9uIHZlcnQoIHgsIHksIHogKSB7XG5cblx0XHRcdHJldHVybiBzY29wZS52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMyggeCwgeSwgeiApICkgLSAxO1xuXG5cdFx0fVxuXG5cdFx0Ly8gY29uc3RydWN0IHRoZSBncmlkXG5cblx0XHRmb3IgKCBpID0gMDsgaSA8IG51bXBvaW50czsgaSArKyApIHtcblxuXHRcdFx0Z3JpZFsgaSBdID0gW107XG5cblx0XHRcdHUgPSBpIC8gKCBudW1wb2ludHMgLSAxICk7XG5cblx0XHRcdHBvcyA9IHBhdGguZ2V0UG9pbnRBdCggdSApO1xuXG5cdFx0XHR0YW5nZW50ID0gdGFuZ2VudHNbIGkgXTtcblx0XHRcdG5vcm1hbCA9IG5vcm1hbHNbIGkgXTtcblx0XHRcdGJpbm9ybWFsID0gYmlub3JtYWxzWyBpIF07XG5cblx0XHRcdHIgPSByYWRpdXMgKiB0YXBlciggdSApO1xuXG5cdFx0XHRmb3IgKCBqID0gMDsgaiA8IHJhZGlhbFNlZ21lbnRzOyBqICsrICkge1xuXG5cdFx0XHRcdHYgPSBqIC8gcmFkaWFsU2VnbWVudHMgKiAyICogTWF0aC5QSTtcblxuXHRcdFx0XHRjeCA9IC0gciAqIE1hdGguY29zKCB2ICk7IC8vIFRPRE86IEhhY2s6IE5lZ2F0aW5nIGl0IHNvIGl0IGZhY2VzIG91dHNpZGUuXG5cdFx0XHRcdGN5ID0gciAqIE1hdGguc2luKCB2ICk7XG5cblx0XHRcdFx0cG9zMi5jb3B5KCBwb3MgKTtcblx0XHRcdFx0cG9zMi54ICs9IGN4ICogbm9ybWFsLnggKyBjeSAqIGJpbm9ybWFsLng7XG5cdFx0XHRcdHBvczIueSArPSBjeCAqIG5vcm1hbC55ICsgY3kgKiBiaW5vcm1hbC55O1xuXHRcdFx0XHRwb3MyLnogKz0gY3ggKiBub3JtYWwueiArIGN5ICogYmlub3JtYWwuejtcblxuXHRcdFx0XHRncmlkWyBpIF1bIGogXSA9IHZlcnQoIHBvczIueCwgcG9zMi55LCBwb3MyLnogKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cblx0XHQvLyBjb25zdHJ1Y3QgdGhlIG1lc2hcblxuXHRcdGZvciAoIGkgPSAwOyBpIDwgc2VnbWVudHM7IGkgKysgKSB7XG5cblx0XHRcdGZvciAoIGogPSAwOyBqIDwgcmFkaWFsU2VnbWVudHM7IGogKysgKSB7XG5cblx0XHRcdFx0aXAgPSAoIGNsb3NlZCApID8gKCBpICsgMSApICUgc2VnbWVudHMgOiBpICsgMTtcblx0XHRcdFx0anAgPSAoIGogKyAxICkgJSByYWRpYWxTZWdtZW50cztcblxuXHRcdFx0XHRhID0gZ3JpZFsgaSBdWyBqIF07XHRcdC8vICoqKiBOT1QgTkVDRVNTQVJJTFkgUExBTkFSICEgKioqXG5cdFx0XHRcdGIgPSBncmlkWyBpcCBdWyBqIF07XG5cdFx0XHRcdGMgPSBncmlkWyBpcCBdWyBqcCBdO1xuXHRcdFx0XHRkID0gZ3JpZFsgaSBdWyBqcCBdO1xuXG5cdFx0XHRcdHV2YSA9IG5ldyBUSFJFRS5WZWN0b3IyKCBpIC8gc2VnbWVudHMsIGogLyByYWRpYWxTZWdtZW50cyApO1xuXHRcdFx0XHR1dmIgPSBuZXcgVEhSRUUuVmVjdG9yMiggKCBpICsgMSApIC8gc2VnbWVudHMsIGogLyByYWRpYWxTZWdtZW50cyApO1xuXHRcdFx0XHR1dmMgPSBuZXcgVEhSRUUuVmVjdG9yMiggKCBpICsgMSApIC8gc2VnbWVudHMsICggaiArIDEgKSAvIHJhZGlhbFNlZ21lbnRzICk7XG5cdFx0XHRcdHV2ZCA9IG5ldyBUSFJFRS5WZWN0b3IyKCBpIC8gc2VnbWVudHMsICggaiArIDEgKSAvIHJhZGlhbFNlZ21lbnRzICk7XG5cblx0XHRcdFx0dGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGEsIGIsIGQgKSApO1xuXHRcdFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2YSwgdXZiLCB1dmQgXSApO1xuXG5cdFx0XHRcdHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBiLCBjLCBkICkgKTtcblx0XHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1dmIuY2xvbmUoKSwgdXZjLCB1dmQuY2xvbmUoKSBdICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG5cdFx0dGhpcy5jb21wdXRlVmVydGV4Tm9ybWFscygpO1xuXG5cdH07XG5cblx0VEhSRUUuVHViZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xuXHRUSFJFRS5UdWJlR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuVHViZUdlb21ldHJ5O1xuXHRUSFJFRS5UdWJlR2VvbWV0cnkucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMucGFyYW1ldGVycy5wYXRoLFxuXHRcdFx0dGhpcy5wYXJhbWV0ZXJzLnNlZ21lbnRzLCB0aGlzLnBhcmFtZXRlcnMucmFkaXVzLCB0aGlzLnBhcmFtZXRlcnMucmFkaWFsU2VnbWVudHMsXG5cdFx0XHR0aGlzLnBhcmFtZXRlcnMuY2xvc2VkLCB0aGlzLnBhcmFtZXRlcnMudGFwZXJcblx0XHQpO1xuXG5cdH07XG5cblx0VEhSRUUuVHViZUdlb21ldHJ5Lk5vVGFwZXIgPSBmdW5jdGlvbiAoIHUgKSB7XG5cblx0XHRyZXR1cm4gMTtcblxuXHR9O1xuXG5cdFRIUkVFLlR1YmVHZW9tZXRyeS5TaW51c29pZGFsVGFwZXIgPSBmdW5jdGlvbiAoIHUgKSB7XG5cblx0XHRyZXR1cm4gTWF0aC5zaW4oIE1hdGguUEkgKiB1ICk7XG5cblx0fTtcblxuXHQvLyBGb3IgY29tcHV0aW5nIG9mIEZyZW5ldCBmcmFtZXMsIGV4cG9zaW5nIHRoZSB0YW5nZW50cywgbm9ybWFscyBhbmQgYmlub3JtYWxzIHRoZSBzcGxpbmVcblx0VEhSRUUuVHViZUdlb21ldHJ5LkZyZW5ldEZyYW1lcyA9IGZ1bmN0aW9uICggcGF0aCwgc2VnbWVudHMsIGNsb3NlZCApIHtcblxuXHRcdHZhclx0bm9ybWFsID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcblxuXHRcdFx0dGFuZ2VudHMgPSBbXSxcblx0XHRcdG5vcm1hbHMgPSBbXSxcblx0XHRcdGJpbm9ybWFscyA9IFtdLFxuXG5cdFx0XHR2ZWMgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuXHRcdFx0bWF0ID0gbmV3IFRIUkVFLk1hdHJpeDQoKSxcblxuXHRcdFx0bnVtcG9pbnRzID0gc2VnbWVudHMgKyAxLFxuXHRcdFx0dGhldGEsXG5cdFx0XHRzbWFsbGVzdCxcblxuXHRcdFx0dHgsIHR5LCB0eixcblx0XHRcdGksIHU7XG5cblxuXHRcdC8vIGV4cG9zZSBpbnRlcm5hbHNcblx0XHR0aGlzLnRhbmdlbnRzID0gdGFuZ2VudHM7XG5cdFx0dGhpcy5ub3JtYWxzID0gbm9ybWFscztcblx0XHR0aGlzLmJpbm9ybWFscyA9IGJpbm9ybWFscztcblxuXHRcdC8vIGNvbXB1dGUgdGhlIHRhbmdlbnQgdmVjdG9ycyBmb3IgZWFjaCBzZWdtZW50IG9uIHRoZSBwYXRoXG5cblx0XHRmb3IgKCBpID0gMDsgaSA8IG51bXBvaW50czsgaSArKyApIHtcblxuXHRcdFx0dSA9IGkgLyAoIG51bXBvaW50cyAtIDEgKTtcblxuXHRcdFx0dGFuZ2VudHNbIGkgXSA9IHBhdGguZ2V0VGFuZ2VudEF0KCB1ICk7XG5cdFx0XHR0YW5nZW50c1sgaSBdLm5vcm1hbGl6ZSgpO1xuXG5cdFx0fVxuXG5cdFx0aW5pdGlhbE5vcm1hbDMoKTtcblxuXHRcdC8qXG5cdFx0ZnVuY3Rpb24gaW5pdGlhbE5vcm1hbDEobGFzdEJpbm9ybWFsKSB7XG5cdFx0XHQvLyBmaXhlZCBzdGFydCBiaW5vcm1hbC4gSGFzIGRhbmdlcnMgb2YgMCB2ZWN0b3JzXG5cdFx0XHRub3JtYWxzWyAwIF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdFx0Ymlub3JtYWxzWyAwIF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdFx0aWYgKGxhc3RCaW5vcm1hbD09PXVuZGVmaW5lZCkgbGFzdEJpbm9ybWFsID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIDEgKTtcblx0XHRcdG5vcm1hbHNbIDAgXS5jcm9zc1ZlY3RvcnMoIGxhc3RCaW5vcm1hbCwgdGFuZ2VudHNbIDAgXSApLm5vcm1hbGl6ZSgpO1xuXHRcdFx0Ymlub3JtYWxzWyAwIF0uY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgMCBdLCBub3JtYWxzWyAwIF0gKS5ub3JtYWxpemUoKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpbml0aWFsTm9ybWFsMigpIHtcblxuXHRcdFx0Ly8gVGhpcyB1c2VzIHRoZSBGcmVuZXQtU2VycmV0IGZvcm11bGEgZm9yIGRlcml2aW5nIGJpbm9ybWFsXG5cdFx0XHR2YXIgdDIgPSBwYXRoLmdldFRhbmdlbnRBdCggZXBzaWxvbiApO1xuXG5cdFx0XHRub3JtYWxzWyAwIF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpLnN1YlZlY3RvcnMoIHQyLCB0YW5nZW50c1sgMCBdICkubm9ybWFsaXplKCk7XG5cdFx0XHRiaW5vcm1hbHNbIDAgXSA9IG5ldyBUSFJFRS5WZWN0b3IzKCkuY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgMCBdLCBub3JtYWxzWyAwIF0gKTtcblxuXHRcdFx0bm9ybWFsc1sgMCBdLmNyb3NzVmVjdG9ycyggYmlub3JtYWxzWyAwIF0sIHRhbmdlbnRzWyAwIF0gKS5ub3JtYWxpemUoKTsgLy8gbGFzdCBiaW5vcm1hbCB4IHRhbmdlbnRcblx0XHRcdGJpbm9ybWFsc1sgMCBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIDAgXSwgbm9ybWFsc1sgMCBdICkubm9ybWFsaXplKCk7XG5cblx0XHR9XG5cdFx0Ki9cblxuXHRcdGZ1bmN0aW9uIGluaXRpYWxOb3JtYWwzKCkge1xuXG5cdFx0XHQvLyBzZWxlY3QgYW4gaW5pdGlhbCBub3JtYWwgdmVjdG9yIHBlcnBlbmRpY3VsYXIgdG8gdGhlIGZpcnN0IHRhbmdlbnQgdmVjdG9yLFxuXHRcdFx0Ly8gYW5kIGluIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHNtYWxsZXN0IHRhbmdlbnQgeHl6IGNvbXBvbmVudFxuXG5cdFx0XHRub3JtYWxzWyAwIF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdFx0Ymlub3JtYWxzWyAwIF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdFx0c21hbGxlc3QgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuXHRcdFx0dHggPSBNYXRoLmFicyggdGFuZ2VudHNbIDAgXS54ICk7XG5cdFx0XHR0eSA9IE1hdGguYWJzKCB0YW5nZW50c1sgMCBdLnkgKTtcblx0XHRcdHR6ID0gTWF0aC5hYnMoIHRhbmdlbnRzWyAwIF0ueiApO1xuXG5cdFx0XHRpZiAoIHR4IDw9IHNtYWxsZXN0ICkge1xuXG5cdFx0XHRcdHNtYWxsZXN0ID0gdHg7XG5cdFx0XHRcdG5vcm1hbC5zZXQoIDEsIDAsIDAgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHR5IDw9IHNtYWxsZXN0ICkge1xuXG5cdFx0XHRcdHNtYWxsZXN0ID0gdHk7XG5cdFx0XHRcdG5vcm1hbC5zZXQoIDAsIDEsIDAgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHR6IDw9IHNtYWxsZXN0ICkge1xuXG5cdFx0XHRcdG5vcm1hbC5zZXQoIDAsIDAsIDEgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2ZWMuY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgMCBdLCBub3JtYWwgKS5ub3JtYWxpemUoKTtcblxuXHRcdFx0bm9ybWFsc1sgMCBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIDAgXSwgdmVjICk7XG5cdFx0XHRiaW5vcm1hbHNbIDAgXS5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyAwIF0sIG5vcm1hbHNbIDAgXSApO1xuXG5cdFx0fVxuXG5cblx0XHQvLyBjb21wdXRlIHRoZSBzbG93bHktdmFyeWluZyBub3JtYWwgYW5kIGJpbm9ybWFsIHZlY3RvcnMgZm9yIGVhY2ggc2VnbWVudCBvbiB0aGUgcGF0aFxuXG5cdFx0Zm9yICggaSA9IDE7IGkgPCBudW1wb2ludHM7IGkgKysgKSB7XG5cblx0XHRcdG5vcm1hbHNbIGkgXSA9IG5vcm1hbHNbIGkgLSAxIF0uY2xvbmUoKTtcblxuXHRcdFx0Ymlub3JtYWxzWyBpIF0gPSBiaW5vcm1hbHNbIGkgLSAxIF0uY2xvbmUoKTtcblxuXHRcdFx0dmVjLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIGkgLSAxIF0sIHRhbmdlbnRzWyBpIF0gKTtcblxuXHRcdFx0aWYgKCB2ZWMubGVuZ3RoKCkgPiBOdW1iZXIuRVBTSUxPTiApIHtcblxuXHRcdFx0XHR2ZWMubm9ybWFsaXplKCk7XG5cblx0XHRcdFx0dGhldGEgPSBNYXRoLmFjb3MoIFRIUkVFLk1hdGguY2xhbXAoIHRhbmdlbnRzWyBpIC0gMSBdLmRvdCggdGFuZ2VudHNbIGkgXSApLCAtIDEsIDEgKSApOyAvLyBjbGFtcCBmb3IgZmxvYXRpbmcgcHQgZXJyb3JzXG5cblx0XHRcdFx0bm9ybWFsc1sgaSBdLmFwcGx5TWF0cml4NCggbWF0Lm1ha2VSb3RhdGlvbkF4aXMoIHZlYywgdGhldGEgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGJpbm9ybWFsc1sgaSBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIGkgXSwgbm9ybWFsc1sgaSBdICk7XG5cblx0XHR9XG5cblxuXHRcdC8vIGlmIHRoZSBjdXJ2ZSBpcyBjbG9zZWQsIHBvc3Rwcm9jZXNzIHRoZSB2ZWN0b3JzIHNvIHRoZSBmaXJzdCBhbmQgbGFzdCBub3JtYWwgdmVjdG9ycyBhcmUgdGhlIHNhbWVcblxuXHRcdGlmICggY2xvc2VkICkge1xuXG5cdFx0XHR0aGV0YSA9IE1hdGguYWNvcyggVEhSRUUuTWF0aC5jbGFtcCggbm9ybWFsc1sgMCBdLmRvdCggbm9ybWFsc1sgbnVtcG9pbnRzIC0gMSBdICksIC0gMSwgMSApICk7XG5cdFx0XHR0aGV0YSAvPSAoIG51bXBvaW50cyAtIDEgKTtcblxuXHRcdFx0aWYgKCB0YW5nZW50c1sgMCBdLmRvdCggdmVjLmNyb3NzVmVjdG9ycyggbm9ybWFsc1sgMCBdLCBub3JtYWxzWyBudW1wb2ludHMgLSAxIF0gKSApID4gMCApIHtcblxuXHRcdFx0XHR0aGV0YSA9IC0gdGhldGE7XG5cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggaSA9IDE7IGkgPCBudW1wb2ludHM7IGkgKysgKSB7XG5cblx0XHRcdFx0Ly8gdHdpc3QgYSBsaXR0bGUuLi5cblx0XHRcdFx0bm9ybWFsc1sgaSBdLmFwcGx5TWF0cml4NCggbWF0Lm1ha2VSb3RhdGlvbkF4aXMoIHRhbmdlbnRzWyBpIF0sIHRoZXRhICogaSApICk7XG5cdFx0XHRcdGJpbm9ybWFsc1sgaSBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIGkgXSwgbm9ybWFsc1sgaSBdICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9O1xuXG5cdC8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL1BvbHloZWRyb25HZW9tZXRyeS5qc1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIGNsb2Nrd29ya2dlZWsgLyBodHRwczovL2dpdGh1Yi5jb20vY2xvY2t3b3JrZ2Vla1xuXHQgKiBAYXV0aG9yIHRpbW90aHlwcmF0bGV5IC8gaHR0cHM6Ly9naXRodWIuY29tL3RpbW90aHlwcmF0bGV5XG5cdCAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuXHQqL1xuXG5cdFRIUkVFLlBvbHloZWRyb25HZW9tZXRyeSA9IGZ1bmN0aW9uICggdmVydGljZXMsIGluZGljZXMsIHJhZGl1cywgZGV0YWlsICkge1xuXG5cdFx0VEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG5cdFx0dGhpcy50eXBlID0gJ1BvbHloZWRyb25HZW9tZXRyeSc7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHR2ZXJ0aWNlczogdmVydGljZXMsXG5cdFx0XHRpbmRpY2VzOiBpbmRpY2VzLFxuXHRcdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0XHRkZXRhaWw6IGRldGFpbFxuXHRcdH07XG5cblx0XHRyYWRpdXMgPSByYWRpdXMgfHwgMTtcblx0XHRkZXRhaWwgPSBkZXRhaWwgfHwgMDtcblxuXHRcdHZhciB0aGF0ID0gdGhpcztcblxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHZlcnRpY2VzLmxlbmd0aDsgaSA8IGw7IGkgKz0gMyApIHtcblxuXHRcdFx0cHJlcGFyZSggbmV3IFRIUkVFLlZlY3RvcjMoIHZlcnRpY2VzWyBpIF0sIHZlcnRpY2VzWyBpICsgMSBdLCB2ZXJ0aWNlc1sgaSArIDIgXSApICk7XG5cblx0XHR9XG5cblx0XHR2YXIgcCA9IHRoaXMudmVydGljZXM7XG5cblx0XHR2YXIgZmFjZXMgPSBbXTtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgaiA9IDAsIGwgPSBpbmRpY2VzLmxlbmd0aDsgaSA8IGw7IGkgKz0gMywgaiArKyApIHtcblxuXHRcdFx0dmFyIHYxID0gcFsgaW5kaWNlc1sgaSBdIF07XG5cdFx0XHR2YXIgdjIgPSBwWyBpbmRpY2VzWyBpICsgMSBdIF07XG5cdFx0XHR2YXIgdjMgPSBwWyBpbmRpY2VzWyBpICsgMiBdIF07XG5cblx0XHRcdGZhY2VzWyBqIF0gPSBuZXcgVEhSRUUuRmFjZTMoIHYxLmluZGV4LCB2Mi5pbmRleCwgdjMuaW5kZXgsIFsgdjEuY2xvbmUoKSwgdjIuY2xvbmUoKSwgdjMuY2xvbmUoKSBdLCB1bmRlZmluZWQsIGogKTtcblxuXHRcdH1cblxuXHRcdHZhciBjZW50cm9pZCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBmYWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRzdWJkaXZpZGUoIGZhY2VzWyBpIF0sIGRldGFpbCApO1xuXG5cdFx0fVxuXG5cblx0XHQvLyBIYW5kbGUgY2FzZSB3aGVuIGZhY2Ugc3RyYWRkbGVzIHRoZSBzZWFtXG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHR2YXIgdXZzID0gdGhpcy5mYWNlVmVydGV4VXZzWyAwIF1bIGkgXTtcblxuXHRcdFx0dmFyIHgwID0gdXZzWyAwIF0ueDtcblx0XHRcdHZhciB4MSA9IHV2c1sgMSBdLng7XG5cdFx0XHR2YXIgeDIgPSB1dnNbIDIgXS54O1xuXG5cdFx0XHR2YXIgbWF4ID0gTWF0aC5tYXgoIHgwLCB4MSwgeDIgKTtcblx0XHRcdHZhciBtaW4gPSBNYXRoLm1pbiggeDAsIHgxLCB4MiApO1xuXG5cdFx0XHRpZiAoIG1heCA+IDAuOSAmJiBtaW4gPCAwLjEgKSB7XG5cblx0XHRcdFx0Ly8gMC45IGlzIHNvbWV3aGF0IGFyYml0cmFyeVxuXG5cdFx0XHRcdGlmICggeDAgPCAwLjIgKSB1dnNbIDAgXS54ICs9IDE7XG5cdFx0XHRcdGlmICggeDEgPCAwLjIgKSB1dnNbIDEgXS54ICs9IDE7XG5cdFx0XHRcdGlmICggeDIgPCAwLjIgKSB1dnNbIDIgXS54ICs9IDE7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXG5cdFx0Ly8gQXBwbHkgcmFkaXVzXG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdHRoaXMudmVydGljZXNbIGkgXS5tdWx0aXBseVNjYWxhciggcmFkaXVzICk7XG5cblx0XHR9XG5cblxuXHRcdC8vIE1lcmdlIHZlcnRpY2VzXG5cblx0XHR0aGlzLm1lcmdlVmVydGljZXMoKTtcblxuXHRcdHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG5cblx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbmV3IFRIUkVFLlNwaGVyZSggbmV3IFRIUkVFLlZlY3RvcjMoKSwgcmFkaXVzICk7XG5cblxuXHRcdC8vIFByb2plY3QgdmVjdG9yIG9udG8gc3BoZXJlJ3Mgc3VyZmFjZVxuXG5cdFx0ZnVuY3Rpb24gcHJlcGFyZSggdmVjdG9yICkge1xuXG5cdFx0XHR2YXIgdmVydGV4ID0gdmVjdG9yLm5vcm1hbGl6ZSgpLmNsb25lKCk7XG5cdFx0XHR2ZXJ0ZXguaW5kZXggPSB0aGF0LnZlcnRpY2VzLnB1c2goIHZlcnRleCApIC0gMTtcblxuXHRcdFx0Ly8gVGV4dHVyZSBjb29yZHMgYXJlIGVxdWl2YWxlbnQgdG8gbWFwIGNvb3JkcywgY2FsY3VsYXRlIGFuZ2xlIGFuZCBjb252ZXJ0IHRvIGZyYWN0aW9uIG9mIGEgY2lyY2xlLlxuXG5cdFx0XHR2YXIgdSA9IGF6aW11dGgoIHZlY3RvciApIC8gMiAvIE1hdGguUEkgKyAwLjU7XG5cdFx0XHR2YXIgdiA9IGluY2xpbmF0aW9uKCB2ZWN0b3IgKSAvIE1hdGguUEkgKyAwLjU7XG5cdFx0XHR2ZXJ0ZXgudXYgPSBuZXcgVEhSRUUuVmVjdG9yMiggdSwgMSAtIHYgKTtcblxuXHRcdFx0cmV0dXJuIHZlcnRleDtcblxuXHRcdH1cblxuXG5cdFx0Ly8gQXBwcm94aW1hdGUgYSBjdXJ2ZWQgZmFjZSB3aXRoIHJlY3Vyc2l2ZWx5IHN1Yi1kaXZpZGVkIHRyaWFuZ2xlcy5cblxuXHRcdGZ1bmN0aW9uIG1ha2UoIHYxLCB2MiwgdjMsIG1hdGVyaWFsSW5kZXggKSB7XG5cblx0XHRcdHZhciBmYWNlID0gbmV3IFRIUkVFLkZhY2UzKCB2MS5pbmRleCwgdjIuaW5kZXgsIHYzLmluZGV4LCBbIHYxLmNsb25lKCksIHYyLmNsb25lKCksIHYzLmNsb25lKCkgXSwgdW5kZWZpbmVkLCBtYXRlcmlhbEluZGV4ICk7XG5cdFx0XHR0aGF0LmZhY2VzLnB1c2goIGZhY2UgKTtcblxuXHRcdFx0Y2VudHJvaWQuY29weSggdjEgKS5hZGQoIHYyICkuYWRkKCB2MyApLmRpdmlkZVNjYWxhciggMyApO1xuXG5cdFx0XHR2YXIgYXppID0gYXppbXV0aCggY2VudHJvaWQgKTtcblxuXHRcdFx0dGhhdC5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggW1xuXHRcdFx0XHRjb3JyZWN0VVYoIHYxLnV2LCB2MSwgYXppICksXG5cdFx0XHRcdGNvcnJlY3RVViggdjIudXYsIHYyLCBhemkgKSxcblx0XHRcdFx0Y29ycmVjdFVWKCB2My51diwgdjMsIGF6aSApXG5cdFx0XHRdICk7XG5cblx0XHR9XG5cblxuXHRcdC8vIEFuYWx5dGljYWxseSBzdWJkaXZpZGUgYSBmYWNlIHRvIHRoZSByZXF1aXJlZCBkZXRhaWwgbGV2ZWwuXG5cblx0XHRmdW5jdGlvbiBzdWJkaXZpZGUoIGZhY2UsIGRldGFpbCApIHtcblxuXHRcdFx0dmFyIGNvbHMgPSBNYXRoLnBvdyggMiwgZGV0YWlsICk7XG5cdFx0XHR2YXIgYSA9IHByZXBhcmUoIHRoYXQudmVydGljZXNbIGZhY2UuYSBdICk7XG5cdFx0XHR2YXIgYiA9IHByZXBhcmUoIHRoYXQudmVydGljZXNbIGZhY2UuYiBdICk7XG5cdFx0XHR2YXIgYyA9IHByZXBhcmUoIHRoYXQudmVydGljZXNbIGZhY2UuYyBdICk7XG5cdFx0XHR2YXIgdiA9IFtdO1xuXG5cdFx0XHR2YXIgbWF0ZXJpYWxJbmRleCA9IGZhY2UubWF0ZXJpYWxJbmRleDtcblxuXHRcdFx0Ly8gQ29uc3RydWN0IGFsbCBvZiB0aGUgdmVydGljZXMgZm9yIHRoaXMgc3ViZGl2aXNpb24uXG5cblx0XHRcdGZvciAoIHZhciBpID0gMCA7IGkgPD0gY29sczsgaSArKyApIHtcblxuXHRcdFx0XHR2WyBpIF0gPSBbXTtcblxuXHRcdFx0XHR2YXIgYWogPSBwcmVwYXJlKCBhLmNsb25lKCkubGVycCggYywgaSAvIGNvbHMgKSApO1xuXHRcdFx0XHR2YXIgYmogPSBwcmVwYXJlKCBiLmNsb25lKCkubGVycCggYywgaSAvIGNvbHMgKSApO1xuXHRcdFx0XHR2YXIgcm93cyA9IGNvbHMgLSBpO1xuXG5cdFx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8PSByb3dzOyBqICsrICkge1xuXG5cdFx0XHRcdFx0aWYgKCBqID09PSAwICYmIGkgPT09IGNvbHMgKSB7XG5cblx0XHRcdFx0XHRcdHZbIGkgXVsgaiBdID0gYWo7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHR2WyBpIF1bIGogXSA9IHByZXBhcmUoIGFqLmNsb25lKCkubGVycCggYmosIGogLyByb3dzICkgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29uc3RydWN0IGFsbCBvZiB0aGUgZmFjZXMuXG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGNvbHMgOyBpICsrICkge1xuXG5cdFx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8IDIgKiAoIGNvbHMgLSBpICkgLSAxOyBqICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIGsgPSBNYXRoLmZsb29yKCBqIC8gMiApO1xuXG5cdFx0XHRcdFx0aWYgKCBqICUgMiA9PT0gMCApIHtcblxuXHRcdFx0XHRcdFx0bWFrZShcblx0XHRcdFx0XHRcdFx0dlsgaSBdWyBrICsgMSBdLFxuXHRcdFx0XHRcdFx0XHR2WyBpICsgMSBdWyBrIF0sXG5cdFx0XHRcdFx0XHRcdHZbIGkgXVsgayBdLFxuXHRcdFx0XHRcdFx0XHRtYXRlcmlhbEluZGV4XG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0bWFrZShcblx0XHRcdFx0XHRcdFx0dlsgaSBdWyBrICsgMSBdLFxuXHRcdFx0XHRcdFx0XHR2WyBpICsgMSBdWyBrICsgMSBdLFxuXHRcdFx0XHRcdFx0XHR2WyBpICsgMSBdWyBrIF0sXG5cdFx0XHRcdFx0XHRcdG1hdGVyaWFsSW5kZXhcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblxuXHRcdC8vIEFuZ2xlIGFyb3VuZCB0aGUgWSBheGlzLCBjb3VudGVyLWNsb2Nrd2lzZSB3aGVuIGxvb2tpbmcgZnJvbSBhYm92ZS5cblxuXHRcdGZ1bmN0aW9uIGF6aW11dGgoIHZlY3RvciApIHtcblxuXHRcdFx0cmV0dXJuIE1hdGguYXRhbjIoIHZlY3Rvci56LCAtIHZlY3Rvci54ICk7XG5cblx0XHR9XG5cblxuXHRcdC8vIEFuZ2xlIGFib3ZlIHRoZSBYWiBwbGFuZS5cblxuXHRcdGZ1bmN0aW9uIGluY2xpbmF0aW9uKCB2ZWN0b3IgKSB7XG5cblx0XHRcdHJldHVybiBNYXRoLmF0YW4yKCAtIHZlY3Rvci55LCBNYXRoLnNxcnQoICggdmVjdG9yLnggKiB2ZWN0b3IueCApICsgKCB2ZWN0b3IueiAqIHZlY3Rvci56ICkgKSApO1xuXG5cdFx0fVxuXG5cblx0XHQvLyBUZXh0dXJlIGZpeGluZyBoZWxwZXIuIFNwaGVyZXMgaGF2ZSBzb21lIG9kZCBiZWhhdmlvdXJzLlxuXG5cdFx0ZnVuY3Rpb24gY29ycmVjdFVWKCB1diwgdmVjdG9yLCBhemltdXRoICkge1xuXG5cdFx0XHRpZiAoICggYXppbXV0aCA8IDAgKSAmJiAoIHV2LnggPT09IDEgKSApIHV2ID0gbmV3IFRIUkVFLlZlY3RvcjIoIHV2LnggLSAxLCB1di55ICk7XG5cdFx0XHRpZiAoICggdmVjdG9yLnggPT09IDAgKSAmJiAoIHZlY3Rvci56ID09PSAwICkgKSB1diA9IG5ldyBUSFJFRS5WZWN0b3IyKCBhemltdXRoIC8gMiAvIE1hdGguUEkgKyAwLjUsIHV2LnkgKTtcblx0XHRcdHJldHVybiB1di5jbG9uZSgpO1xuXG5cdFx0fVxuXG5cblx0fTtcblxuXHRUSFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XG5cdFRIUkVFLlBvbHloZWRyb25HZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnk7XG5cblx0VEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBwYXJhbWV0ZXJzID0gdGhpcy5wYXJhbWV0ZXJzO1xuXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkoXG5cdFx0XHRwYXJhbWV0ZXJzLnZlcnRpY2VzLFxuXHRcdFx0cGFyYW1ldGVycy5pbmRpY2VzLFxuXHRcdFx0cGFyYW1ldGVycy5yYWRpdXMsXG5cdFx0XHRwYXJhbWV0ZXJzLmRldGFpbFxuXHRcdCk7XG5cblx0fTtcblxuXHQvLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9Eb2RlY2FoZWRyb25HZW9tZXRyeS5qc1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIEFiZSBQYXpvcyAvIGh0dHBzOi8vaGFtb2lkLmNvbVxuXHQgKi9cblxuXHRUSFJFRS5Eb2RlY2FoZWRyb25HZW9tZXRyeSA9IGZ1bmN0aW9uICggcmFkaXVzLCBkZXRhaWwgKSB7XG5cblx0XHR2YXIgdCA9ICggMSArIE1hdGguc3FydCggNSApICkgLyAyO1xuXHRcdHZhciByID0gMSAvIHQ7XG5cblx0XHR2YXIgdmVydGljZXMgPSBbXG5cblx0XHRcdC8vICjCsTEsIMKxMSwgwrExKVxuXHRcdFx0LSAxLCAtIDEsIC0gMSwgICAgLSAxLCAtIDEsICAxLFxuXHRcdFx0LSAxLCAgMSwgLSAxLCAgICAtIDEsICAxLCAgMSxcblx0XHRcdCAxLCAtIDEsIC0gMSwgICAgIDEsIC0gMSwgIDEsXG5cdFx0XHQgMSwgIDEsIC0gMSwgICAgIDEsICAxLCAgMSxcblxuXHRcdFx0Ly8gKDAsIMKxMS/PhiwgwrHPhilcblx0XHRcdCAwLCAtIHIsIC0gdCwgICAgIDAsIC0gciwgIHQsXG5cdFx0XHQgMCwgIHIsIC0gdCwgICAgIDAsICByLCAgdCxcblxuXHRcdFx0Ly8gKMKxMS/PhiwgwrHPhiwgMClcblx0XHRcdC0gciwgLSB0LCAgMCwgICAgLSByLCAgdCwgIDAsXG5cdFx0XHQgciwgLSB0LCAgMCwgICAgIHIsICB0LCAgMCxcblxuXHRcdFx0Ly8gKMKxz4YsIDAsIMKxMS/Philcblx0XHRcdC0gdCwgIDAsIC0gciwgICAgIHQsICAwLCAtIHIsXG5cdFx0XHQtIHQsICAwLCAgciwgICAgIHQsICAwLCAgclxuXHRcdF07XG5cblx0XHR2YXIgaW5kaWNlcyA9IFtcblx0XHRcdCAzLCAxMSwgIDcsICAgICAgMywgIDcsIDE1LCAgICAgIDMsIDE1LCAxMyxcblx0XHRcdCA3LCAxOSwgMTcsICAgICAgNywgMTcsICA2LCAgICAgIDcsICA2LCAxNSxcblx0XHRcdDE3LCAgNCwgIDgsICAgICAxNywgIDgsIDEwLCAgICAgMTcsIDEwLCAgNixcblx0XHRcdCA4LCAgMCwgMTYsICAgICAgOCwgMTYsICAyLCAgICAgIDgsICAyLCAxMCxcblx0XHRcdCAwLCAxMiwgIDEsICAgICAgMCwgIDEsIDE4LCAgICAgIDAsIDE4LCAxNixcblx0XHRcdCA2LCAxMCwgIDIsICAgICAgNiwgIDIsIDEzLCAgICAgIDYsIDEzLCAxNSxcblx0XHRcdCAyLCAxNiwgMTgsICAgICAgMiwgMTgsICAzLCAgICAgIDIsICAzLCAxMyxcblx0XHRcdDE4LCAgMSwgIDksICAgICAxOCwgIDksIDExLCAgICAgMTgsIDExLCAgMyxcblx0XHRcdCA0LCAxNCwgMTIsICAgICAgNCwgMTIsICAwLCAgICAgIDQsICAwLCAgOCxcblx0XHRcdDExLCAgOSwgIDUsICAgICAxMSwgIDUsIDE5LCAgICAgMTEsIDE5LCAgNyxcblx0XHRcdDE5LCAgNSwgMTQsICAgICAxOSwgMTQsICA0LCAgICAgMTksICA0LCAxNyxcblx0XHRcdCAxLCAxMiwgMTQsICAgICAgMSwgMTQsICA1LCAgICAgIDEsICA1LCAgOVxuXHRcdF07XG5cblx0XHRUSFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkuY2FsbCggdGhpcywgdmVydGljZXMsIGluZGljZXMsIHJhZGl1cywgZGV0YWlsICk7XG5cblx0XHR0aGlzLnR5cGUgPSAnRG9kZWNhaGVkcm9uR2VvbWV0cnknO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0XHRkZXRhaWw6IGRldGFpbFxuXHRcdH07XG5cblx0fTtcblxuXHRUSFJFRS5Eb2RlY2FoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkucHJvdG90eXBlICk7XG5cdFRIUkVFLkRvZGVjYWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkRvZGVjYWhlZHJvbkdlb21ldHJ5O1xuXG5cdFRIUkVFLkRvZGVjYWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBwYXJhbWV0ZXJzID0gdGhpcy5wYXJhbWV0ZXJzO1xuXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5Eb2RlY2FoZWRyb25HZW9tZXRyeShcblx0XHRcdHBhcmFtZXRlcnMucmFkaXVzLFxuXHRcdFx0cGFyYW1ldGVycy5kZXRhaWxcblx0XHQpO1xuXG5cdH07XG5cblx0Ly8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvSWNvc2FoZWRyb25HZW9tZXRyeS5qc1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIHRpbW90aHlwcmF0bGV5IC8gaHR0cHM6Ly9naXRodWIuY29tL3RpbW90aHlwcmF0bGV5XG5cdCAqL1xuXG5cdFRIUkVFLkljb3NhaGVkcm9uR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHJhZGl1cywgZGV0YWlsICkge1xuXG5cdFx0dmFyIHQgPSAoIDEgKyBNYXRoLnNxcnQoIDUgKSApIC8gMjtcblxuXHRcdHZhciB2ZXJ0aWNlcyA9IFtcblx0XHRcdC0gMSwgIHQsICAwLCAgICAxLCAgdCwgIDAsICAgLSAxLCAtIHQsICAwLCAgICAxLCAtIHQsICAwLFxuXHRcdFx0IDAsIC0gMSwgIHQsICAgIDAsICAxLCAgdCwgICAgMCwgLSAxLCAtIHQsICAgIDAsICAxLCAtIHQsXG5cdFx0XHQgdCwgIDAsIC0gMSwgICAgdCwgIDAsICAxLCAgIC0gdCwgIDAsIC0gMSwgICAtIHQsICAwLCAgMVxuXHRcdF07XG5cblx0XHR2YXIgaW5kaWNlcyA9IFtcblx0XHRcdCAwLCAxMSwgIDUsICAgIDAsICA1LCAgMSwgICAgMCwgIDEsICA3LCAgICAwLCAgNywgMTAsICAgIDAsIDEwLCAxMSxcblx0XHRcdCAxLCAgNSwgIDksICAgIDUsIDExLCAgNCwgICAxMSwgMTAsICAyLCAgIDEwLCAgNywgIDYsICAgIDcsICAxLCAgOCxcblx0XHRcdCAzLCAgOSwgIDQsICAgIDMsICA0LCAgMiwgICAgMywgIDIsICA2LCAgICAzLCAgNiwgIDgsICAgIDMsICA4LCAgOSxcblx0XHRcdCA0LCAgOSwgIDUsICAgIDIsICA0LCAxMSwgICAgNiwgIDIsIDEwLCAgICA4LCAgNiwgIDcsICAgIDksICA4LCAgMVxuXHRcdF07XG5cblx0XHRUSFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkuY2FsbCggdGhpcywgdmVydGljZXMsIGluZGljZXMsIHJhZGl1cywgZGV0YWlsICk7XG5cblx0XHR0aGlzLnR5cGUgPSAnSWNvc2FoZWRyb25HZW9tZXRyeSc7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHRyYWRpdXM6IHJhZGl1cyxcblx0XHRcdGRldGFpbDogZGV0YWlsXG5cdFx0fTtcblxuXHR9O1xuXG5cdFRIUkVFLkljb3NhaGVkcm9uR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZSApO1xuXHRUSFJFRS5JY29zYWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkljb3NhaGVkcm9uR2VvbWV0cnk7XG5cblx0VEhSRUUuSWNvc2FoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgcGFyYW1ldGVycyA9IHRoaXMucGFyYW1ldGVycztcblxuXHRcdHJldHVybiBuZXcgVEhSRUUuSWNvc2FoZWRyb25HZW9tZXRyeShcblx0XHRcdHBhcmFtZXRlcnMucmFkaXVzLFxuXHRcdFx0cGFyYW1ldGVycy5kZXRhaWxcblx0XHQpO1xuXG5cdH07XG5cblx0Ly8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvT2N0YWhlZHJvbkdlb21ldHJ5LmpzXG5cblx0LyoqXG5cdCAqIEBhdXRob3IgdGltb3RoeXByYXRsZXkgLyBodHRwczovL2dpdGh1Yi5jb20vdGltb3RoeXByYXRsZXlcblx0ICovXG5cblx0VEhSRUUuT2N0YWhlZHJvbkdlb21ldHJ5ID0gZnVuY3Rpb24gKCByYWRpdXMsIGRldGFpbCApIHtcblxuXHRcdHZhciB2ZXJ0aWNlcyA9IFtcblx0XHRcdDEsIDAsIDAsICAgLSAxLCAwLCAwLCAgICAwLCAxLCAwLCAgICAwLCAtIDEsIDAsICAgIDAsIDAsIDEsICAgIDAsIDAsIC0gMVxuXHRcdF07XG5cblx0XHR2YXIgaW5kaWNlcyA9IFtcblx0XHRcdDAsIDIsIDQsICAgIDAsIDQsIDMsICAgIDAsIDMsIDUsICAgIDAsIDUsIDIsICAgIDEsIDIsIDUsICAgIDEsIDUsIDMsICAgIDEsIDMsIDQsICAgIDEsIDQsIDJcblx0XHRdO1xuXG5cdFx0VEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5LmNhbGwoIHRoaXMsIHZlcnRpY2VzLCBpbmRpY2VzLCByYWRpdXMsIGRldGFpbCApO1xuXG5cdFx0dGhpcy50eXBlID0gJ09jdGFoZWRyb25HZW9tZXRyeSc7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHRyYWRpdXM6IHJhZGl1cyxcblx0XHRcdGRldGFpbDogZGV0YWlsXG5cdFx0fTtcblxuXHR9O1xuXG5cdFRIUkVFLk9jdGFoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkucHJvdG90eXBlICk7XG5cdFRIUkVFLk9jdGFoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5PY3RhaGVkcm9uR2VvbWV0cnk7XG5cblx0VEhSRUUuT2N0YWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBwYXJhbWV0ZXJzID0gdGhpcy5wYXJhbWV0ZXJzO1xuXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5PY3RhaGVkcm9uR2VvbWV0cnkoXG5cdFx0XHRwYXJhbWV0ZXJzLnJhZGl1cyxcblx0XHRcdHBhcmFtZXRlcnMuZGV0YWlsXG5cdFx0KTtcblxuXHR9O1xuXG5cdC8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL1RldHJhaGVkcm9uR2VvbWV0cnkuanNcblxuXHQvKipcblx0ICogQGF1dGhvciB0aW1vdGh5cHJhdGxleSAvIGh0dHBzOi8vZ2l0aHViLmNvbS90aW1vdGh5cHJhdGxleVxuXHQgKi9cblxuXHRUSFJFRS5UZXRyYWhlZHJvbkdlb21ldHJ5ID0gZnVuY3Rpb24gKCByYWRpdXMsIGRldGFpbCApIHtcblxuXHRcdHZhciB2ZXJ0aWNlcyA9IFtcblx0XHRcdCAxLCAgMSwgIDEsICAgLSAxLCAtIDEsICAxLCAgIC0gMSwgIDEsIC0gMSwgICAgMSwgLSAxLCAtIDFcblx0XHRdO1xuXG5cdFx0dmFyIGluZGljZXMgPSBbXG5cdFx0XHQgMiwgIDEsICAwLCAgICAwLCAgMywgIDIsICAgIDEsICAzLCAgMCwgICAgMiwgIDMsICAxXG5cdFx0XTtcblxuXHRcdFRIUkVFLlBvbHloZWRyb25HZW9tZXRyeS5jYWxsKCB0aGlzLCB2ZXJ0aWNlcywgaW5kaWNlcywgcmFkaXVzLCBkZXRhaWwgKTtcblxuXHRcdHRoaXMudHlwZSA9ICdUZXRyYWhlZHJvbkdlb21ldHJ5JztcblxuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRcdHJhZGl1czogcmFkaXVzLFxuXHRcdFx0ZGV0YWlsOiBkZXRhaWxcblx0XHR9O1xuXG5cdH07XG5cblx0VEhSRUUuVGV0cmFoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkucHJvdG90eXBlICk7XG5cdFRIUkVFLlRldHJhaGVkcm9uR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuVGV0cmFoZWRyb25HZW9tZXRyeTtcblxuXHRUSFJFRS5UZXRyYWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBwYXJhbWV0ZXJzID0gdGhpcy5wYXJhbWV0ZXJzO1xuXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5UZXRyYWhlZHJvbkdlb21ldHJ5KFxuXHRcdFx0cGFyYW1ldGVycy5yYWRpdXMsXG5cdFx0XHRwYXJhbWV0ZXJzLmRldGFpbFxuXHRcdCk7XG5cblx0fTtcblxuXHQvLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9QYXJhbWV0cmljR2VvbWV0cnkuanNcblxuXHQvKipcblx0ICogQGF1dGhvciB6ejg1IC8gaHR0cHM6Ly9naXRodWIuY29tL3p6ODVcblx0ICogUGFyYW1ldHJpYyBTdXJmYWNlcyBHZW9tZXRyeVxuXHQgKiBiYXNlZCBvbiB0aGUgYnJpbGxpYW50IGFydGljbGUgYnkgQHByaWRlb3V0IGh0dHA6Ly9wcmlkZW91dC5uZXQvYmxvZy8/cD00NFxuXHQgKlxuXHQgKiBuZXcgVEhSRUUuUGFyYW1ldHJpY0dlb21ldHJ5KCBwYXJhbWV0cmljRnVuY3Rpb24sIHVTZWdtZW50cywgeVNlZ2VtZW50cyApO1xuXHQgKlxuXHQgKi9cblxuXHRUSFJFRS5QYXJhbWV0cmljR2VvbWV0cnkgPSBmdW5jdGlvbiAoIGZ1bmMsIHNsaWNlcywgc3RhY2tzICkge1xuXG5cdFx0VEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG5cdFx0dGhpcy50eXBlID0gJ1BhcmFtZXRyaWNHZW9tZXRyeSc7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHRmdW5jOiBmdW5jLFxuXHRcdFx0c2xpY2VzOiBzbGljZXMsXG5cdFx0XHRzdGFja3M6IHN0YWNrc1xuXHRcdH07XG5cblx0XHR2YXIgdmVydHMgPSB0aGlzLnZlcnRpY2VzO1xuXHRcdHZhciBmYWNlcyA9IHRoaXMuZmFjZXM7XG5cdFx0dmFyIHV2cyA9IHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdO1xuXG5cdFx0dmFyIGksIGosIHA7XG5cdFx0dmFyIHUsIHY7XG5cblx0XHR2YXIgc2xpY2VDb3VudCA9IHNsaWNlcyArIDE7XG5cblx0XHRmb3IgKCBpID0gMDsgaSA8PSBzdGFja3M7IGkgKysgKSB7XG5cblx0XHRcdHYgPSBpIC8gc3RhY2tzO1xuXG5cdFx0XHRmb3IgKCBqID0gMDsgaiA8PSBzbGljZXM7IGogKysgKSB7XG5cblx0XHRcdFx0dSA9IGogLyBzbGljZXM7XG5cblx0XHRcdFx0cCA9IGZ1bmMoIHUsIHYgKTtcblx0XHRcdFx0dmVydHMucHVzaCggcCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHR2YXIgYSwgYiwgYywgZDtcblx0XHR2YXIgdXZhLCB1dmIsIHV2YywgdXZkO1xuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBzdGFja3M7IGkgKysgKSB7XG5cblx0XHRcdGZvciAoIGogPSAwOyBqIDwgc2xpY2VzOyBqICsrICkge1xuXG5cdFx0XHRcdGEgPSBpICogc2xpY2VDb3VudCArIGo7XG5cdFx0XHRcdGIgPSBpICogc2xpY2VDb3VudCArIGogKyAxO1xuXHRcdFx0XHRjID0gKCBpICsgMSApICogc2xpY2VDb3VudCArIGogKyAxO1xuXHRcdFx0XHRkID0gKCBpICsgMSApICogc2xpY2VDb3VudCArIGo7XG5cblx0XHRcdFx0dXZhID0gbmV3IFRIUkVFLlZlY3RvcjIoIGogLyBzbGljZXMsIGkgLyBzdGFja3MgKTtcblx0XHRcdFx0dXZiID0gbmV3IFRIUkVFLlZlY3RvcjIoICggaiArIDEgKSAvIHNsaWNlcywgaSAvIHN0YWNrcyApO1xuXHRcdFx0XHR1dmMgPSBuZXcgVEhSRUUuVmVjdG9yMiggKCBqICsgMSApIC8gc2xpY2VzLCAoIGkgKyAxICkgLyBzdGFja3MgKTtcblx0XHRcdFx0dXZkID0gbmV3IFRIUkVFLlZlY3RvcjIoIGogLyBzbGljZXMsICggaSArIDEgKSAvIHN0YWNrcyApO1xuXG5cdFx0XHRcdGZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgZCApICk7XG5cdFx0XHRcdHV2cy5wdXNoKCBbIHV2YSwgdXZiLCB1dmQgXSApO1xuXG5cdFx0XHRcdGZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYiwgYywgZCApICk7XG5cdFx0XHRcdHV2cy5wdXNoKCBbIHV2Yi5jbG9uZSgpLCB1dmMsIHV2ZC5jbG9uZSgpIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gY29uc29sZS5sb2codGhpcyk7XG5cblx0XHQvLyBtYWdpYyBidWxsZXRcblx0XHQvLyB2YXIgZGlmZiA9IHRoaXMubWVyZ2VWZXJ0aWNlcygpO1xuXHRcdC8vIGNvbnNvbGUubG9nKCdyZW1vdmVkICcsIGRpZmYsICcgdmVydGljZXMgYnkgbWVyZ2luZycpO1xuXG5cdFx0dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcblx0XHR0aGlzLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XG5cblx0fTtcblxuXHRUSFJFRS5QYXJhbWV0cmljR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XG5cdFRIUkVFLlBhcmFtZXRyaWNHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5QYXJhbWV0cmljR2VvbWV0cnk7XG5cblx0Ly8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvV2lyZWZyYW1lR2VvbWV0cnkuanNcblxuXHQvKipcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICovXG5cblx0VEhSRUUuV2lyZWZyYW1lR2VvbWV0cnkgPSBmdW5jdGlvbiAoIGdlb21ldHJ5ICkge1xuXG5cdFx0VEhSRUUuQnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG5cdFx0dmFyIGVkZ2UgPSBbIDAsIDAgXSwgaGFzaCA9IHt9O1xuXG5cdFx0ZnVuY3Rpb24gc29ydEZ1bmN0aW9uKCBhLCBiICkge1xuXG5cdFx0XHRyZXR1cm4gYSAtIGI7XG5cblx0XHR9XG5cblx0XHR2YXIga2V5cyA9IFsgJ2EnLCAnYicsICdjJyBdO1xuXG5cdFx0aWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5ICkge1xuXG5cdFx0XHR2YXIgdmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcblx0XHRcdHZhciBmYWNlcyA9IGdlb21ldHJ5LmZhY2VzO1xuXHRcdFx0dmFyIG51bUVkZ2VzID0gMDtcblxuXHRcdFx0Ly8gYWxsb2NhdGUgbWF4aW1hbCBzaXplXG5cdFx0XHR2YXIgZWRnZXMgPSBuZXcgVWludDMyQXJyYXkoIDYgKiBmYWNlcy5sZW5ndGggKTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gZmFjZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgZmFjZSA9IGZhY2VzWyBpIF07XG5cblx0XHRcdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgMzsgaiArKyApIHtcblxuXHRcdFx0XHRcdGVkZ2VbIDAgXSA9IGZhY2VbIGtleXNbIGogXSBdO1xuXHRcdFx0XHRcdGVkZ2VbIDEgXSA9IGZhY2VbIGtleXNbICggaiArIDEgKSAlIDMgXSBdO1xuXHRcdFx0XHRcdGVkZ2Uuc29ydCggc29ydEZ1bmN0aW9uICk7XG5cblx0XHRcdFx0XHR2YXIga2V5ID0gZWRnZS50b1N0cmluZygpO1xuXG5cdFx0XHRcdFx0aWYgKCBoYXNoWyBrZXkgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRlZGdlc1sgMiAqIG51bUVkZ2VzIF0gPSBlZGdlWyAwIF07XG5cdFx0XHRcdFx0XHRlZGdlc1sgMiAqIG51bUVkZ2VzICsgMSBdID0gZWRnZVsgMSBdO1xuXHRcdFx0XHRcdFx0aGFzaFsga2V5IF0gPSB0cnVlO1xuXHRcdFx0XHRcdFx0bnVtRWRnZXMgKys7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBjb29yZHMgPSBuZXcgRmxvYXQzMkFycmF5KCBudW1FZGdlcyAqIDIgKiAzICk7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IG51bUVkZ2VzOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCAyOyBqICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIHZlcnRleCA9IHZlcnRpY2VzWyBlZGdlcyBbIDIgKiBpICsgaiBdIF07XG5cblx0XHRcdFx0XHR2YXIgaW5kZXggPSA2ICogaSArIDMgKiBqO1xuXHRcdFx0XHRcdGNvb3Jkc1sgaW5kZXggKyAwIF0gPSB2ZXJ0ZXgueDtcblx0XHRcdFx0XHRjb29yZHNbIGluZGV4ICsgMSBdID0gdmVydGV4Lnk7XG5cdFx0XHRcdFx0Y29vcmRzWyBpbmRleCArIDIgXSA9IHZlcnRleC56O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggY29vcmRzLCAzICkgKTtcblxuXHRcdH0gZWxzZSBpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkgKSB7XG5cblx0XHRcdGlmICggZ2VvbWV0cnkuaW5kZXggIT09IG51bGwgKSB7XG5cblx0XHRcdFx0Ly8gSW5kZXhlZCBCdWZmZXJHZW9tZXRyeVxuXG5cdFx0XHRcdHZhciBpbmRpY2VzID0gZ2VvbWV0cnkuaW5kZXguYXJyYXk7XG5cdFx0XHRcdHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cdFx0XHRcdHZhciBkcmF3Y2FsbHMgPSBnZW9tZXRyeS5kcmF3Y2FsbHM7XG5cdFx0XHRcdHZhciBudW1FZGdlcyA9IDA7XG5cblx0XHRcdFx0aWYgKCBkcmF3Y2FsbHMubGVuZ3RoID09PSAwICkge1xuXG5cdFx0XHRcdFx0Z2VvbWV0cnkuYWRkR3JvdXAoIDAsIGluZGljZXMubGVuZ3RoICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGFsbG9jYXRlIG1heGltYWwgc2l6ZVxuXHRcdFx0XHR2YXIgZWRnZXMgPSBuZXcgVWludDMyQXJyYXkoIDIgKiBpbmRpY2VzLmxlbmd0aCApO1xuXG5cdFx0XHRcdGZvciAoIHZhciBvID0gMCwgb2wgPSBkcmF3Y2FsbHMubGVuZ3RoOyBvIDwgb2w7ICsrIG8gKSB7XG5cblx0XHRcdFx0XHR2YXIgZHJhd2NhbGwgPSBkcmF3Y2FsbHNbIG8gXTtcblxuXHRcdFx0XHRcdHZhciBzdGFydCA9IGRyYXdjYWxsLnN0YXJ0O1xuXHRcdFx0XHRcdHZhciBjb3VudCA9IGRyYXdjYWxsLmNvdW50O1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSBzdGFydCwgaWwgPSBzdGFydCArIGNvdW50OyBpIDwgaWw7IGkgKz0gMyApIHtcblxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgMzsgaiArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRlZGdlWyAwIF0gPSBpbmRpY2VzWyBpICsgaiBdO1xuXHRcdFx0XHRcdFx0XHRlZGdlWyAxIF0gPSBpbmRpY2VzWyBpICsgKCBqICsgMSApICUgMyBdO1xuXHRcdFx0XHRcdFx0XHRlZGdlLnNvcnQoIHNvcnRGdW5jdGlvbiApO1xuXG5cdFx0XHRcdFx0XHRcdHZhciBrZXkgPSBlZGdlLnRvU3RyaW5nKCk7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBoYXNoWyBrZXkgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0ZWRnZXNbIDIgKiBudW1FZGdlcyBdID0gZWRnZVsgMCBdO1xuXHRcdFx0XHRcdFx0XHRcdGVkZ2VzWyAyICogbnVtRWRnZXMgKyAxIF0gPSBlZGdlWyAxIF07XG5cdFx0XHRcdFx0XHRcdFx0aGFzaFsga2V5IF0gPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdG51bUVkZ2VzICsrO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgY29vcmRzID0gbmV3IEZsb2F0MzJBcnJheSggbnVtRWRnZXMgKiAyICogMyApO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IG51bUVkZ2VzOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8IDI7IGogKysgKSB7XG5cblx0XHRcdFx0XHRcdHZhciBpbmRleCA9IDYgKiBpICsgMyAqIGo7XG5cdFx0XHRcdFx0XHR2YXIgaW5kZXgyID0gZWRnZXNbIDIgKiBpICsgaiBdO1xuXG5cdFx0XHRcdFx0XHRjb29yZHNbIGluZGV4ICsgMCBdID0gdmVydGljZXMuZ2V0WCggaW5kZXgyICk7XG5cdFx0XHRcdFx0XHRjb29yZHNbIGluZGV4ICsgMSBdID0gdmVydGljZXMuZ2V0WSggaW5kZXgyICk7XG5cdFx0XHRcdFx0XHRjb29yZHNbIGluZGV4ICsgMiBdID0gdmVydGljZXMuZ2V0WiggaW5kZXgyICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBjb29yZHMsIDMgKSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIG5vbi1pbmRleGVkIEJ1ZmZlckdlb21ldHJ5XG5cblx0XHRcdFx0dmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcblx0XHRcdFx0dmFyIG51bUVkZ2VzID0gdmVydGljZXMubGVuZ3RoIC8gMztcblx0XHRcdFx0dmFyIG51bVRyaXMgPSBudW1FZGdlcyAvIDM7XG5cblx0XHRcdFx0dmFyIGNvb3JkcyA9IG5ldyBGbG9hdDMyQXJyYXkoIG51bUVkZ2VzICogMiAqIDMgKTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBudW1UcmlzOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8IDM7IGogKysgKSB7XG5cblx0XHRcdFx0XHRcdHZhciBpbmRleCA9IDE4ICogaSArIDYgKiBqO1xuXG5cdFx0XHRcdFx0XHR2YXIgaW5kZXgxID0gOSAqIGkgKyAzICogajtcblx0XHRcdFx0XHRcdGNvb3Jkc1sgaW5kZXggKyAwIF0gPSB2ZXJ0aWNlc1sgaW5kZXgxIF07XG5cdFx0XHRcdFx0XHRjb29yZHNbIGluZGV4ICsgMSBdID0gdmVydGljZXNbIGluZGV4MSArIDEgXTtcblx0XHRcdFx0XHRcdGNvb3Jkc1sgaW5kZXggKyAyIF0gPSB2ZXJ0aWNlc1sgaW5kZXgxICsgMiBdO1xuXG5cdFx0XHRcdFx0XHR2YXIgaW5kZXgyID0gOSAqIGkgKyAzICogKCAoIGogKyAxICkgJSAzICk7XG5cdFx0XHRcdFx0XHRjb29yZHNbIGluZGV4ICsgMyBdID0gdmVydGljZXNbIGluZGV4MiBdO1xuXHRcdFx0XHRcdFx0Y29vcmRzWyBpbmRleCArIDQgXSA9IHZlcnRpY2VzWyBpbmRleDIgKyAxIF07XG5cdFx0XHRcdFx0XHRjb29yZHNbIGluZGV4ICsgNSBdID0gdmVydGljZXNbIGluZGV4MiArIDIgXTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGNvb3JkcywgMyApICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9O1xuXG5cdFRIUkVFLldpcmVmcmFtZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xuXHRUSFJFRS5XaXJlZnJhbWVHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5XaXJlZnJhbWVHZW9tZXRyeTtcblxuXHQvLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9BeGlzSGVscGVyLmpzXG5cblx0LyoqXG5cdCAqIEBhdXRob3Igc3JvdWNoZXJheSAvIGh0dHA6Ly9zcm91Y2hlcmF5Lm9yZy9cblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICovXG5cblx0VEhSRUUuQXhpc0hlbHBlciA9IGZ1bmN0aW9uICggc2l6ZSApIHtcblxuXHRcdHNpemUgPSBzaXplIHx8IDE7XG5cblx0XHR2YXIgdmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KCBbXG5cdFx0XHQwLCAwLCAwLCAgc2l6ZSwgMCwgMCxcblx0XHRcdDAsIDAsIDAsICAwLCBzaXplLCAwLFxuXHRcdFx0MCwgMCwgMCwgIDAsIDAsIHNpemVcblx0XHRdICk7XG5cblx0XHR2YXIgY29sb3JzID0gbmV3IEZsb2F0MzJBcnJheSggW1xuXHRcdFx0MSwgMCwgMCwgIDEsIDAuNiwgMCxcblx0XHRcdDAsIDEsIDAsICAwLjYsIDEsIDAsXG5cdFx0XHQwLCAwLCAxLCAgMCwgMC42LCAxXG5cdFx0XSApO1xuXG5cdFx0dmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCk7XG5cdFx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG5cdFx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAnY29sb3InLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBjb2xvcnMsIDMgKSApO1xuXG5cdFx0dmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7IHZlcnRleENvbG9yczogVEhSRUUuVmVydGV4Q29sb3JzIH0gKTtcblxuXHRcdFRIUkVFLkxpbmVTZWdtZW50cy5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxuXHR9O1xuXG5cdFRIUkVFLkF4aXNIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGluZVNlZ21lbnRzLnByb3RvdHlwZSApO1xuXHRUSFJFRS5BeGlzSGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkF4aXNIZWxwZXI7XG5cblx0Ly8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvQXJyb3dIZWxwZXIuanNcblxuXHQvKipcblx0ICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG5cdCAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly9naXRodWIuY29tL3p6ODVcblx0ICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xuXHQgKlxuXHQgKiBDcmVhdGVzIGFuIGFycm93IGZvciB2aXN1YWxpemluZyBkaXJlY3Rpb25zXG5cdCAqXG5cdCAqIFBhcmFtZXRlcnM6XG5cdCAqICBkaXIgLSBWZWN0b3IzXG5cdCAqICBvcmlnaW4gLSBWZWN0b3IzXG5cdCAqICBsZW5ndGggLSBOdW1iZXJcblx0ICogIGNvbG9yIC0gY29sb3IgaW4gaGV4IHZhbHVlXG5cdCAqICBoZWFkTGVuZ3RoIC0gTnVtYmVyXG5cdCAqICBoZWFkV2lkdGggLSBOdW1iZXJcblx0ICovXG5cblx0VEhSRUUuQXJyb3dIZWxwZXIgPSAoIGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBsaW5lR2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcblx0XHRsaW5lR2VvbWV0cnkudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIDAgKSwgbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDEsIDAgKSApO1xuXG5cdFx0dmFyIGNvbmVHZW9tZXRyeSA9IG5ldyBUSFJFRS5DeWxpbmRlckdlb21ldHJ5KCAwLCAwLjUsIDEsIDUsIDEgKTtcblx0XHRjb25lR2VvbWV0cnkudHJhbnNsYXRlKCAwLCAtIDAuNSwgMCApO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIEFycm93SGVscGVyKCBkaXIsIG9yaWdpbiwgbGVuZ3RoLCBjb2xvciwgaGVhZExlbmd0aCwgaGVhZFdpZHRoICkge1xuXG5cdFx0XHQvLyBkaXIgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXG5cblx0XHRcdFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuXHRcdFx0aWYgKCBjb2xvciA9PT0gdW5kZWZpbmVkICkgY29sb3IgPSAweGZmZmYwMDtcblx0XHRcdGlmICggbGVuZ3RoID09PSB1bmRlZmluZWQgKSBsZW5ndGggPSAxO1xuXHRcdFx0aWYgKCBoZWFkTGVuZ3RoID09PSB1bmRlZmluZWQgKSBoZWFkTGVuZ3RoID0gMC4yICogbGVuZ3RoO1xuXHRcdFx0aWYgKCBoZWFkV2lkdGggPT09IHVuZGVmaW5lZCApIGhlYWRXaWR0aCA9IDAuMiAqIGhlYWRMZW5ndGg7XG5cblx0XHRcdHRoaXMucG9zaXRpb24uY29weSggb3JpZ2luICk7XG5cdFx0XHRcblx0XHRcdGlmICggaGVhZExlbmd0aCA8IGxlbmd0aCApIHtcblx0XHRcdFx0dGhpcy5saW5lID0gbmV3IFRIUkVFLkxpbmUoIGxpbmVHZW9tZXRyeSwgbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBjb2xvciB9ICkgKTtcblx0XHRcdFx0dGhpcy5saW5lLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblx0XHRcdFx0dGhpcy5hZGQoIHRoaXMubGluZSApO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmNvbmUgPSBuZXcgVEhSRUUuTWVzaCggY29uZUdlb21ldHJ5LCBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yIH0gKSApO1xuXHRcdFx0dGhpcy5jb25lLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblx0XHRcdHRoaXMuYWRkKCB0aGlzLmNvbmUgKTtcblxuXHRcdFx0dGhpcy5zZXREaXJlY3Rpb24oIGRpciApO1xuXHRcdFx0dGhpcy5zZXRMZW5ndGgoIGxlbmd0aCwgaGVhZExlbmd0aCwgaGVhZFdpZHRoICk7XG5cblx0XHR9XG5cblx0fSgpICk7XG5cblx0VEhSRUUuQXJyb3dIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XG5cdFRIUkVFLkFycm93SGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkFycm93SGVscGVyO1xuXG5cdFRIUkVFLkFycm93SGVscGVyLnByb3RvdHlwZS5zZXREaXJlY3Rpb24gPSAoIGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBheGlzID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHR2YXIgcmFkaWFucztcblxuXHRcdHJldHVybiBmdW5jdGlvbiBzZXREaXJlY3Rpb24oIGRpciApIHtcblxuXHRcdFx0Ly8gZGlyIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxuXG5cdFx0XHRpZiAoIGRpci55ID4gMC45OTk5OSApIHtcblxuXHRcdFx0XHR0aGlzLnF1YXRlcm5pb24uc2V0KCAwLCAwLCAwLCAxICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGRpci55IDwgLSAwLjk5OTk5ICkge1xuXG5cdFx0XHRcdHRoaXMucXVhdGVybmlvbi5zZXQoIDEsIDAsIDAsIDAgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRheGlzLnNldCggZGlyLnosIDAsIC0gZGlyLnggKS5ub3JtYWxpemUoKTtcblxuXHRcdFx0XHRyYWRpYW5zID0gTWF0aC5hY29zKCBkaXIueSApO1xuXG5cdFx0XHRcdHRoaXMucXVhdGVybmlvbi5zZXRGcm9tQXhpc0FuZ2xlKCBheGlzLCByYWRpYW5zICk7XG5cblx0XHRcdH1cblxuXHRcdH07XG5cblx0fSgpICk7XG5cblx0VEhSRUUuQXJyb3dIZWxwZXIucHJvdG90eXBlLnNldExlbmd0aCA9IGZ1bmN0aW9uICggbGVuZ3RoLCBoZWFkTGVuZ3RoLCBoZWFkV2lkdGggKSB7XG5cblx0XHRpZiAoIGhlYWRMZW5ndGggPT09IHVuZGVmaW5lZCApIGhlYWRMZW5ndGggPSAwLjIgKiBsZW5ndGg7XG5cdFx0aWYgKCBoZWFkV2lkdGggPT09IHVuZGVmaW5lZCApIGhlYWRXaWR0aCA9IDAuMiAqIGhlYWRMZW5ndGg7XG5cblx0XHRpZiAoIGhlYWRMZW5ndGggPCBsZW5ndGggKXtcblx0XHRcdHRoaXMubGluZS5zY2FsZS5zZXQoIDEsIGxlbmd0aCAtIGhlYWRMZW5ndGgsIDEgKTtcblx0XHRcdHRoaXMubGluZS51cGRhdGVNYXRyaXgoKTtcblx0XHR9XG5cblx0XHR0aGlzLmNvbmUuc2NhbGUuc2V0KCBoZWFkV2lkdGgsIGhlYWRMZW5ndGgsIGhlYWRXaWR0aCApO1xuXHRcdHRoaXMuY29uZS5wb3NpdGlvbi55ID0gbGVuZ3RoO1xuXHRcdHRoaXMuY29uZS51cGRhdGVNYXRyaXgoKTtcblxuXHR9O1xuXG5cdFRIUkVFLkFycm93SGVscGVyLnByb3RvdHlwZS5zZXRDb2xvciA9IGZ1bmN0aW9uICggY29sb3IgKSB7XG5cblx0XHRpZiAoIHRoaXMubGluZSAhPT0gdW5kZWZpbmVkICkgdGhpcy5saW5lLm1hdGVyaWFsLmNvbG9yLnNldCggY29sb3IgKTtcblx0XHR0aGlzLmNvbmUubWF0ZXJpYWwuY29sb3Iuc2V0KCBjb2xvciApO1xuXG5cdH07XG5cblx0Ly8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvQm94SGVscGVyLmpzXG5cblx0LyoqXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqL1xuXG5cdFRIUkVFLkJveEhlbHBlciA9IGZ1bmN0aW9uICggb2JqZWN0ICkge1xuXG5cdFx0dmFyIGluZGljZXMgPSBuZXcgVWludDE2QXJyYXkoIFsgMCwgMSwgMSwgMiwgMiwgMywgMywgMCwgNCwgNSwgNSwgNiwgNiwgNywgNywgNCwgMCwgNCwgMSwgNSwgMiwgNiwgMywgNyBdICk7XG5cdFx0dmFyIHBvc2l0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkoIDggKiAzICk7XG5cblx0XHR2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKTtcblx0XHRnZW9tZXRyeS5zZXRJbmRleCggbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggaW5kaWNlcywgMSApICk7XG5cdFx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbnMsIDMgKSApO1xuXG5cdFx0VEhSRUUuTGluZVNlZ21lbnRzLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IDB4ZmZmZjAwIH0gKSApO1xuXG5cdFx0aWYgKCBvYmplY3QgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0dGhpcy51cGRhdGUoIG9iamVjdCApO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0VEhSRUUuQm94SGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcblx0VEhSRUUuQm94SGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkJveEhlbHBlcjtcblxuXHRUSFJFRS5Cb3hIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9ICggZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIGJveCA9IG5ldyBUSFJFRS5Cb3gzKCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cblx0XHRcdGJveC5zZXRGcm9tT2JqZWN0KCBvYmplY3QgKTtcblxuXHRcdFx0aWYgKCBib3guZW1wdHkoKSApIHJldHVybjtcblxuXHRcdFx0dmFyIG1pbiA9IGJveC5taW47XG5cdFx0XHR2YXIgbWF4ID0gYm94Lm1heDtcblxuXHRcdFx0Lypcblx0XHRcdCAgNV9fX180XG5cdFx0XHQxL19fXzAvfFxuXHRcdFx0fCA2X198Xzdcblx0XHRcdDIvX19fMy9cblxuXHRcdFx0MDogbWF4LngsIG1heC55LCBtYXguelxuXHRcdFx0MTogbWluLngsIG1heC55LCBtYXguelxuXHRcdFx0MjogbWluLngsIG1pbi55LCBtYXguelxuXHRcdFx0MzogbWF4LngsIG1pbi55LCBtYXguelxuXHRcdFx0NDogbWF4LngsIG1heC55LCBtaW4uelxuXHRcdFx0NTogbWluLngsIG1heC55LCBtaW4uelxuXHRcdFx0NjogbWluLngsIG1pbi55LCBtaW4uelxuXHRcdFx0NzogbWF4LngsIG1pbi55LCBtaW4uelxuXHRcdFx0Ki9cblxuXHRcdFx0dmFyIHBvc2l0aW9uID0gdGhpcy5nZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXHRcdFx0dmFyIGFycmF5ID0gcG9zaXRpb24uYXJyYXk7XG5cblx0XHRcdGFycmF5WyAgMCBdID0gbWF4Lng7IGFycmF5WyAgMSBdID0gbWF4Lnk7IGFycmF5WyAgMiBdID0gbWF4Lno7XG5cdFx0XHRhcnJheVsgIDMgXSA9IG1pbi54OyBhcnJheVsgIDQgXSA9IG1heC55OyBhcnJheVsgIDUgXSA9IG1heC56O1xuXHRcdFx0YXJyYXlbICA2IF0gPSBtaW4ueDsgYXJyYXlbICA3IF0gPSBtaW4ueTsgYXJyYXlbICA4IF0gPSBtYXguejtcblx0XHRcdGFycmF5WyAgOSBdID0gbWF4Lng7IGFycmF5WyAxMCBdID0gbWluLnk7IGFycmF5WyAxMSBdID0gbWF4Lno7XG5cdFx0XHRhcnJheVsgMTIgXSA9IG1heC54OyBhcnJheVsgMTMgXSA9IG1heC55OyBhcnJheVsgMTQgXSA9IG1pbi56O1xuXHRcdFx0YXJyYXlbIDE1IF0gPSBtaW4ueDsgYXJyYXlbIDE2IF0gPSBtYXgueTsgYXJyYXlbIDE3IF0gPSBtaW4uejtcblx0XHRcdGFycmF5WyAxOCBdID0gbWluLng7IGFycmF5WyAxOSBdID0gbWluLnk7IGFycmF5WyAyMCBdID0gbWluLno7XG5cdFx0XHRhcnJheVsgMjEgXSA9IG1heC54OyBhcnJheVsgMjIgXSA9IG1pbi55OyBhcnJheVsgMjMgXSA9IG1pbi56O1xuXG5cdFx0XHRwb3NpdGlvbi5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdHRoaXMuZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cblx0XHR9XG5cblx0fSApKCk7XG5cblx0Ly8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvQm91bmRpbmdCb3hIZWxwZXIuanNcblxuXHQvKipcblx0ICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG5cdCAqL1xuXG5cdC8vIGEgaGVscGVyIHRvIHNob3cgdGhlIHdvcmxkLWF4aXMtYWxpZ25lZCBib3VuZGluZyBib3ggZm9yIGFuIG9iamVjdFxuXG5cdFRIUkVFLkJvdW5kaW5nQm94SGVscGVyID0gZnVuY3Rpb24gKCBvYmplY3QsIGhleCApIHtcblxuXHRcdHZhciBjb2xvciA9ICggaGV4ICE9PSB1bmRlZmluZWQgKSA/IGhleCA6IDB4ODg4ODg4O1xuXG5cdFx0dGhpcy5vYmplY3QgPSBvYmplY3Q7XG5cblx0XHR0aGlzLmJveCA9IG5ldyBUSFJFRS5Cb3gzKCk7XG5cblx0XHRUSFJFRS5NZXNoLmNhbGwoIHRoaXMsIG5ldyBUSFJFRS5Cb3hHZW9tZXRyeSggMSwgMSwgMSApLCBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yLCB3aXJlZnJhbWU6IHRydWUgfSApICk7XG5cblx0fTtcblxuXHRUSFJFRS5Cb3VuZGluZ0JveEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NZXNoLnByb3RvdHlwZSApO1xuXHRUSFJFRS5Cb3VuZGluZ0JveEhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Cb3VuZGluZ0JveEhlbHBlcjtcblxuXHRUSFJFRS5Cb3VuZGluZ0JveEhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy5ib3guc2V0RnJvbU9iamVjdCggdGhpcy5vYmplY3QgKTtcblxuXHRcdHRoaXMuYm94LnNpemUoIHRoaXMuc2NhbGUgKTtcblxuXHRcdHRoaXMuYm94LmNlbnRlciggdGhpcy5wb3NpdGlvbiApO1xuXG5cdH07XG5cblx0Ly8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvQ2FtZXJhSGVscGVyLmpzXG5cblx0LyoqXG5cdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG5cdCAqXG5cdCAqXHQtIHNob3dzIGZydXN0dW0sIGxpbmUgb2Ygc2lnaHQgYW5kIHVwIG9mIHRoZSBjYW1lcmFcblx0ICpcdC0gc3VpdGFibGUgZm9yIGZhc3QgdXBkYXRlc1xuXHQgKiBcdC0gYmFzZWQgb24gZnJ1c3R1bSB2aXN1YWxpemF0aW9uIGluIGxpZ2h0Z2wuanMgc2hhZG93bWFwIGV4YW1wbGVcblx0ICpcdFx0aHR0cDovL2V2YW53LmdpdGh1Yi5jb20vbGlnaHRnbC5qcy90ZXN0cy9zaGFkb3dtYXAuaHRtbFxuXHQgKi9cblxuXHRUSFJFRS5DYW1lcmFIZWxwZXIgPSBmdW5jdGlvbiAoIGNhbWVyYSApIHtcblxuXHRcdHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuXHRcdHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogMHhmZmZmZmYsIHZlcnRleENvbG9yczogVEhSRUUuRmFjZUNvbG9ycyB9ICk7XG5cblx0XHR2YXIgcG9pbnRNYXAgPSB7fTtcblxuXHRcdC8vIGNvbG9yc1xuXG5cdFx0dmFyIGhleEZydXN0dW0gPSAweGZmYWEwMDtcblx0XHR2YXIgaGV4Q29uZSA9IDB4ZmYwMDAwO1xuXHRcdHZhciBoZXhVcCA9IDB4MDBhYWZmO1xuXHRcdHZhciBoZXhUYXJnZXQgPSAweGZmZmZmZjtcblx0XHR2YXIgaGV4Q3Jvc3MgPSAweDMzMzMzMztcblxuXHRcdC8vIG5lYXJcblxuXHRcdGFkZExpbmUoIFwibjFcIiwgXCJuMlwiLCBoZXhGcnVzdHVtICk7XG5cdFx0YWRkTGluZSggXCJuMlwiLCBcIm40XCIsIGhleEZydXN0dW0gKTtcblx0XHRhZGRMaW5lKCBcIm40XCIsIFwibjNcIiwgaGV4RnJ1c3R1bSApO1xuXHRcdGFkZExpbmUoIFwibjNcIiwgXCJuMVwiLCBoZXhGcnVzdHVtICk7XG5cblx0XHQvLyBmYXJcblxuXHRcdGFkZExpbmUoIFwiZjFcIiwgXCJmMlwiLCBoZXhGcnVzdHVtICk7XG5cdFx0YWRkTGluZSggXCJmMlwiLCBcImY0XCIsIGhleEZydXN0dW0gKTtcblx0XHRhZGRMaW5lKCBcImY0XCIsIFwiZjNcIiwgaGV4RnJ1c3R1bSApO1xuXHRcdGFkZExpbmUoIFwiZjNcIiwgXCJmMVwiLCBoZXhGcnVzdHVtICk7XG5cblx0XHQvLyBzaWRlc1xuXG5cdFx0YWRkTGluZSggXCJuMVwiLCBcImYxXCIsIGhleEZydXN0dW0gKTtcblx0XHRhZGRMaW5lKCBcIm4yXCIsIFwiZjJcIiwgaGV4RnJ1c3R1bSApO1xuXHRcdGFkZExpbmUoIFwibjNcIiwgXCJmM1wiLCBoZXhGcnVzdHVtICk7XG5cdFx0YWRkTGluZSggXCJuNFwiLCBcImY0XCIsIGhleEZydXN0dW0gKTtcblxuXHRcdC8vIGNvbmVcblxuXHRcdGFkZExpbmUoIFwicFwiLCBcIm4xXCIsIGhleENvbmUgKTtcblx0XHRhZGRMaW5lKCBcInBcIiwgXCJuMlwiLCBoZXhDb25lICk7XG5cdFx0YWRkTGluZSggXCJwXCIsIFwibjNcIiwgaGV4Q29uZSApO1xuXHRcdGFkZExpbmUoIFwicFwiLCBcIm40XCIsIGhleENvbmUgKTtcblxuXHRcdC8vIHVwXG5cblx0XHRhZGRMaW5lKCBcInUxXCIsIFwidTJcIiwgaGV4VXAgKTtcblx0XHRhZGRMaW5lKCBcInUyXCIsIFwidTNcIiwgaGV4VXAgKTtcblx0XHRhZGRMaW5lKCBcInUzXCIsIFwidTFcIiwgaGV4VXAgKTtcblxuXHRcdC8vIHRhcmdldFxuXG5cdFx0YWRkTGluZSggXCJjXCIsIFwidFwiLCBoZXhUYXJnZXQgKTtcblx0XHRhZGRMaW5lKCBcInBcIiwgXCJjXCIsIGhleENyb3NzICk7XG5cblx0XHQvLyBjcm9zc1xuXG5cdFx0YWRkTGluZSggXCJjbjFcIiwgXCJjbjJcIiwgaGV4Q3Jvc3MgKTtcblx0XHRhZGRMaW5lKCBcImNuM1wiLCBcImNuNFwiLCBoZXhDcm9zcyApO1xuXG5cdFx0YWRkTGluZSggXCJjZjFcIiwgXCJjZjJcIiwgaGV4Q3Jvc3MgKTtcblx0XHRhZGRMaW5lKCBcImNmM1wiLCBcImNmNFwiLCBoZXhDcm9zcyApO1xuXG5cdFx0ZnVuY3Rpb24gYWRkTGluZSggYSwgYiwgaGV4ICkge1xuXG5cdFx0XHRhZGRQb2ludCggYSwgaGV4ICk7XG5cdFx0XHRhZGRQb2ludCggYiwgaGV4ICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBhZGRQb2ludCggaWQsIGhleCApIHtcblxuXHRcdFx0Z2VvbWV0cnkudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoKSApO1xuXHRcdFx0Z2VvbWV0cnkuY29sb3JzLnB1c2goIG5ldyBUSFJFRS5Db2xvciggaGV4ICkgKTtcblxuXHRcdFx0aWYgKCBwb2ludE1hcFsgaWQgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHBvaW50TWFwWyBpZCBdID0gW107XG5cblx0XHRcdH1cblxuXHRcdFx0cG9pbnRNYXBbIGlkIF0ucHVzaCggZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoIC0gMSApO1xuXG5cdFx0fVxuXG5cdFx0VEhSRUUuTGluZVNlZ21lbnRzLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG5cdFx0dGhpcy5jYW1lcmEgPSBjYW1lcmE7XG5cdFx0dGhpcy5jYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXG5cdFx0dGhpcy5tYXRyaXggPSBjYW1lcmEubWF0cml4V29ybGQ7XG5cdFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cblx0XHR0aGlzLnBvaW50TWFwID0gcG9pbnRNYXA7XG5cblx0XHR0aGlzLnVwZGF0ZSgpO1xuXG5cdH07XG5cblx0VEhSRUUuQ2FtZXJhSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcblx0VEhSRUUuQ2FtZXJhSGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkNhbWVyYUhlbHBlcjtcblxuXHRUSFJFRS5DYW1lcmFIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBnZW9tZXRyeSwgcG9pbnRNYXA7XG5cblx0XHR2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHR2YXIgY2FtZXJhID0gbmV3IFRIUkVFLkNhbWVyYSgpO1xuXG5cdFx0ZnVuY3Rpb24gc2V0UG9pbnQoIHBvaW50LCB4LCB5LCB6ICkge1xuXG5cdFx0XHR2ZWN0b3Iuc2V0KCB4LCB5LCB6ICkudW5wcm9qZWN0KCBjYW1lcmEgKTtcblxuXHRcdFx0dmFyIHBvaW50cyA9IHBvaW50TWFwWyBwb2ludCBdO1xuXG5cdFx0XHRpZiAoIHBvaW50cyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRnZW9tZXRyeS52ZXJ0aWNlc1sgcG9pbnRzWyBpIF0gXS5jb3B5KCB2ZWN0b3IgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblx0XHRcdHBvaW50TWFwID0gdGhpcy5wb2ludE1hcDtcblxuXHRcdFx0dmFyIHcgPSAxLCBoID0gMTtcblxuXHRcdFx0Ly8gd2UgbmVlZCBqdXN0IGNhbWVyYSBwcm9qZWN0aW9uIG1hdHJpeFxuXHRcdFx0Ly8gd29ybGQgbWF0cml4IG11c3QgYmUgaWRlbnRpdHlcblxuXHRcdFx0Y2FtZXJhLnByb2plY3Rpb25NYXRyaXguY29weSggdGhpcy5jYW1lcmEucHJvamVjdGlvbk1hdHJpeCApO1xuXG5cdFx0XHQvLyBjZW50ZXIgLyB0YXJnZXRcblxuXHRcdFx0c2V0UG9pbnQoIFwiY1wiLCAwLCAwLCAtIDEgKTtcblx0XHRcdHNldFBvaW50KCBcInRcIiwgMCwgMCwgIDEgKTtcblxuXHRcdFx0Ly8gbmVhclxuXG5cdFx0XHRzZXRQb2ludCggXCJuMVwiLCAtIHcsIC0gaCwgLSAxICk7XG5cdFx0XHRzZXRQb2ludCggXCJuMlwiLCAgIHcsIC0gaCwgLSAxICk7XG5cdFx0XHRzZXRQb2ludCggXCJuM1wiLCAtIHcsICAgaCwgLSAxICk7XG5cdFx0XHRzZXRQb2ludCggXCJuNFwiLCAgIHcsICAgaCwgLSAxICk7XG5cblx0XHRcdC8vIGZhclxuXG5cdFx0XHRzZXRQb2ludCggXCJmMVwiLCAtIHcsIC0gaCwgMSApO1xuXHRcdFx0c2V0UG9pbnQoIFwiZjJcIiwgICB3LCAtIGgsIDEgKTtcblx0XHRcdHNldFBvaW50KCBcImYzXCIsIC0gdywgICBoLCAxICk7XG5cdFx0XHRzZXRQb2ludCggXCJmNFwiLCAgIHcsICAgaCwgMSApO1xuXG5cdFx0XHQvLyB1cFxuXG5cdFx0XHRzZXRQb2ludCggXCJ1MVwiLCAgIHcgKiAwLjcsIGggKiAxLjEsIC0gMSApO1xuXHRcdFx0c2V0UG9pbnQoIFwidTJcIiwgLSB3ICogMC43LCBoICogMS4xLCAtIDEgKTtcblx0XHRcdHNldFBvaW50KCBcInUzXCIsICAgICAgICAgMCwgaCAqIDIsICAgLSAxICk7XG5cblx0XHRcdC8vIGNyb3NzXG5cblx0XHRcdHNldFBvaW50KCBcImNmMVwiLCAtIHcsICAgMCwgMSApO1xuXHRcdFx0c2V0UG9pbnQoIFwiY2YyXCIsICAgdywgICAwLCAxICk7XG5cdFx0XHRzZXRQb2ludCggXCJjZjNcIiwgICAwLCAtIGgsIDEgKTtcblx0XHRcdHNldFBvaW50KCBcImNmNFwiLCAgIDAsICAgaCwgMSApO1xuXG5cdFx0XHRzZXRQb2ludCggXCJjbjFcIiwgLSB3LCAgIDAsIC0gMSApO1xuXHRcdFx0c2V0UG9pbnQoIFwiY24yXCIsICAgdywgICAwLCAtIDEgKTtcblx0XHRcdHNldFBvaW50KCBcImNuM1wiLCAgIDAsIC0gaCwgLSAxICk7XG5cdFx0XHRzZXRQb2ludCggXCJjbjRcIiwgICAwLCAgIGgsIC0gMSApO1xuXG5cdFx0XHRnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPSB0cnVlO1xuXG5cdFx0fTtcblxuXHR9KCk7XG5cblx0Ly8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvRGlyZWN0aW9uYWxMaWdodEhlbHBlci5qc1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuXHQgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcblx0ICovXG5cblx0VEhSRUUuRGlyZWN0aW9uYWxMaWdodEhlbHBlciA9IGZ1bmN0aW9uICggbGlnaHQsIHNpemUgKSB7XG5cblx0XHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cblx0XHR0aGlzLmxpZ2h0ID0gbGlnaHQ7XG5cdFx0dGhpcy5saWdodC51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXG5cdFx0dGhpcy5tYXRyaXggPSBsaWdodC5tYXRyaXhXb3JsZDtcblx0XHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblxuXHRcdHNpemUgPSBzaXplIHx8IDE7XG5cblx0XHR2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcblx0XHRnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKFxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjMoIC0gc2l6ZSwgICBzaXplLCAwICksXG5cdFx0XHRuZXcgVEhSRUUuVmVjdG9yMyggICBzaXplLCAgIHNpemUsIDAgKSxcblx0XHRcdG5ldyBUSFJFRS5WZWN0b3IzKCAgIHNpemUsIC0gc2l6ZSwgMCApLFxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjMoIC0gc2l6ZSwgLSBzaXplLCAwICksXG5cdFx0XHRuZXcgVEhSRUUuVmVjdG9yMyggLSBzaXplLCAgIHNpemUsIDAgKVxuXHRcdCk7XG5cblx0XHR2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgZm9nOiBmYWxzZSB9ICk7XG5cdFx0bWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5saWdodC5jb2xvciApLm11bHRpcGx5U2NhbGFyKCB0aGlzLmxpZ2h0LmludGVuc2l0eSApO1xuXG5cdFx0dGhpcy5saWdodFBsYW5lID0gbmV3IFRIUkVFLkxpbmUoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXHRcdHRoaXMuYWRkKCB0aGlzLmxpZ2h0UGxhbmUgKTtcblxuXHRcdGdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XG5cdFx0Z2VvbWV0cnkudmVydGljZXMucHVzaChcblx0XHRcdG5ldyBUSFJFRS5WZWN0b3IzKCksXG5cdFx0XHRuZXcgVEhSRUUuVmVjdG9yMygpXG5cdFx0KTtcblxuXHRcdG1hdGVyaWFsID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7IGZvZzogZmFsc2UgfSApO1xuXHRcdG1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMubGlnaHQuY29sb3IgKS5tdWx0aXBseVNjYWxhciggdGhpcy5saWdodC5pbnRlbnNpdHkgKTtcblxuXHRcdHRoaXMudGFyZ2V0TGluZSA9IG5ldyBUSFJFRS5MaW5lKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblx0XHR0aGlzLmFkZCggdGhpcy50YXJnZXRMaW5lICk7XG5cblx0XHR0aGlzLnVwZGF0ZSgpO1xuXG5cdH07XG5cblx0VEhSRUUuRGlyZWN0aW9uYWxMaWdodEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblx0VEhSRUUuRGlyZWN0aW9uYWxMaWdodEhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0SGVscGVyO1xuXG5cdFRIUkVFLkRpcmVjdGlvbmFsTGlnaHRIZWxwZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLmxpZ2h0UGxhbmUuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuXHRcdHRoaXMubGlnaHRQbGFuZS5tYXRlcmlhbC5kaXNwb3NlKCk7XG5cdFx0dGhpcy50YXJnZXRMaW5lLmdlb21ldHJ5LmRpc3Bvc2UoKTtcblx0XHR0aGlzLnRhcmdldExpbmUubWF0ZXJpYWwuZGlzcG9zZSgpO1xuXG5cdH07XG5cblx0VEhSRUUuRGlyZWN0aW9uYWxMaWdodEhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHR2YXIgdjIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdHZhciB2MyA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2MS5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubGlnaHQubWF0cml4V29ybGQgKTtcblx0XHRcdHYyLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5saWdodC50YXJnZXQubWF0cml4V29ybGQgKTtcblx0XHRcdHYzLnN1YlZlY3RvcnMoIHYyLCB2MSApO1xuXG5cdFx0XHR0aGlzLmxpZ2h0UGxhbmUubG9va0F0KCB2MyApO1xuXHRcdFx0dGhpcy5saWdodFBsYW5lLm1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMubGlnaHQuY29sb3IgKS5tdWx0aXBseVNjYWxhciggdGhpcy5saWdodC5pbnRlbnNpdHkgKTtcblxuXHRcdFx0dGhpcy50YXJnZXRMaW5lLmdlb21ldHJ5LnZlcnRpY2VzWyAxIF0uY29weSggdjMgKTtcblx0XHRcdHRoaXMudGFyZ2V0TGluZS5nZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPSB0cnVlO1xuXHRcdFx0dGhpcy50YXJnZXRMaW5lLm1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMubGlnaHRQbGFuZS5tYXRlcmlhbC5jb2xvciApO1xuXG5cdFx0fTtcblxuXHR9KCk7XG5cblx0Ly8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvRWRnZXNIZWxwZXIuanNcblxuXHQvKipcblx0ICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG5cdCAqIEBwYXJhbSBvYmplY3QgVEhSRUUuTWVzaCB3aG9zZSBnZW9tZXRyeSB3aWxsIGJlIHVzZWRcblx0ICogQHBhcmFtIGhleCBsaW5lIGNvbG9yXG5cdCAqIEBwYXJhbSB0aHJlc2hvbGRBbmdsZSB0aGUgbWluaW11bSBhbmdsZSAoaW4gZGVncmVlcyksXG5cdCAqIGJldHdlZW4gdGhlIGZhY2Ugbm9ybWFscyBvZiBhZGphY2VudCBmYWNlcyxcblx0ICogdGhhdCBpcyByZXF1aXJlZCB0byByZW5kZXIgYW4gZWRnZS4gQSB2YWx1ZSBvZiAxMCBtZWFuc1xuXHQgKiBhbiBlZGdlIGlzIG9ubHkgcmVuZGVyZWQgaWYgdGhlIGFuZ2xlIGlzIGF0IGxlYXN0IDEwIGRlZ3JlZXMuXG5cdCAqL1xuXG5cdFRIUkVFLkVkZ2VzSGVscGVyID0gZnVuY3Rpb24gKCBvYmplY3QsIGhleCwgdGhyZXNob2xkQW5nbGUgKSB7XG5cblx0XHR2YXIgY29sb3IgPSAoIGhleCAhPT0gdW5kZWZpbmVkICkgPyBoZXggOiAweGZmZmZmZjtcblxuXHRcdFRIUkVFLkxpbmVTZWdtZW50cy5jYWxsKCB0aGlzLCBuZXcgVEhSRUUuRWRnZXNHZW9tZXRyeSggb2JqZWN0Lmdlb21ldHJ5LCB0aHJlc2hvbGRBbmdsZSApLCBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yIH0gKSApO1xuXG5cdFx0dGhpcy5tYXRyaXggPSBvYmplY3QubWF0cml4V29ybGQ7XG5cdFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cblx0fTtcblxuXHRUSFJFRS5FZGdlc0hlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaW5lU2VnbWVudHMucHJvdG90eXBlICk7XG5cdFRIUkVFLkVkZ2VzSGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkVkZ2VzSGVscGVyO1xuXG5cdC8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL0ZhY2VOb3JtYWxzSGVscGVyLmpzXG5cblx0LyoqXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuXHQqL1xuXG5cdFRIUkVFLkZhY2VOb3JtYWxzSGVscGVyID0gZnVuY3Rpb24gKCBvYmplY3QsIHNpemUsIGhleCwgbGluZXdpZHRoICkge1xuXG5cdFx0Ly8gRmFjZU5vcm1hbHNIZWxwZXIgb25seSBzdXBwb3J0cyBUSFJFRS5HZW9tZXRyeVxuXG5cdFx0dGhpcy5vYmplY3QgPSBvYmplY3Q7XG5cblx0XHR0aGlzLnNpemUgPSAoIHNpemUgIT09IHVuZGVmaW5lZCApID8gc2l6ZSA6IDE7XG5cblx0XHR2YXIgY29sb3IgPSAoIGhleCAhPT0gdW5kZWZpbmVkICkgPyBoZXggOiAweGZmZmYwMDtcblxuXHRcdHZhciB3aWR0aCA9ICggbGluZXdpZHRoICE9PSB1bmRlZmluZWQgKSA/IGxpbmV3aWR0aCA6IDE7XG5cblx0XHQvL1xuXG5cdFx0dmFyIG5Ob3JtYWxzID0gMDtcblxuXHRcdHZhciBvYmpHZW9tZXRyeSA9IHRoaXMub2JqZWN0Lmdlb21ldHJ5O1xuXG5cdFx0aWYgKCBvYmpHZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5ICkge1xuXG5cdFx0XHRuTm9ybWFscyA9IG9iakdlb21ldHJ5LmZhY2VzLmxlbmd0aDtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkZhY2VOb3JtYWxzSGVscGVyOiBvbmx5IFRIUkVFLkdlb21ldHJ5IGlzIHN1cHBvcnRlZC4gVXNlIFRIUkVFLlZlcnRleE5vcm1hbHNIZWxwZXIsIGluc3RlYWQuJyApO1xuXG5cdFx0fVxuXG5cdFx0Ly9cblxuXHRcdHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpO1xuXG5cdFx0dmFyIHBvc2l0aW9ucyA9IG5ldyBUSFJFRS5GbG9hdDMyQXR0cmlidXRlKCBuTm9ybWFscyAqIDIgKiAzLCAzICk7XG5cblx0XHRnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIHBvc2l0aW9ucyApO1xuXG5cdFx0VEhSRUUuTGluZVNlZ21lbnRzLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yLCBsaW5ld2lkdGg6IHdpZHRoIH0gKSApO1xuXG5cdFx0Ly9cblxuXHRcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXHRcdHRoaXMudXBkYXRlKCk7XG5cblx0fTtcblxuXHRUSFJFRS5GYWNlTm9ybWFsc0hlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaW5lU2VnbWVudHMucHJvdG90eXBlICk7XG5cdFRIUkVFLkZhY2VOb3JtYWxzSGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkZhY2VOb3JtYWxzSGVscGVyO1xuXG5cdFRIUkVFLkZhY2VOb3JtYWxzSGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSAoIGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0dmFyIHYyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHR2YXIgbm9ybWFsTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDMoKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiB1cGRhdGUoKSB7XG5cblx0XHRcdHRoaXMub2JqZWN0LnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XG5cblx0XHRcdG5vcm1hbE1hdHJpeC5nZXROb3JtYWxNYXRyaXgoIHRoaXMub2JqZWN0Lm1hdHJpeFdvcmxkICk7XG5cblx0XHRcdHZhciBtYXRyaXhXb3JsZCA9IHRoaXMub2JqZWN0Lm1hdHJpeFdvcmxkO1xuXG5cdFx0XHR2YXIgcG9zaXRpb24gPSB0aGlzLmdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cblx0XHRcdC8vXG5cblx0XHRcdHZhciBvYmpHZW9tZXRyeSA9IHRoaXMub2JqZWN0Lmdlb21ldHJ5O1xuXG5cdFx0XHR2YXIgdmVydGljZXMgPSBvYmpHZW9tZXRyeS52ZXJ0aWNlcztcblxuXHRcdFx0dmFyIGZhY2VzID0gb2JqR2VvbWV0cnkuZmFjZXM7XG5cblx0XHRcdHZhciBpZHggPSAwO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBmYWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBmYWNlID0gZmFjZXNbIGkgXTtcblxuXHRcdFx0XHR2YXIgbm9ybWFsID0gZmFjZS5ub3JtYWw7XG5cblx0XHRcdFx0djEuY29weSggdmVydGljZXNbIGZhY2UuYSBdIClcblx0XHRcdFx0XHQuYWRkKCB2ZXJ0aWNlc1sgZmFjZS5iIF0gKVxuXHRcdFx0XHRcdC5hZGQoIHZlcnRpY2VzWyBmYWNlLmMgXSApXG5cdFx0XHRcdFx0LmRpdmlkZVNjYWxhciggMyApXG5cdFx0XHRcdFx0LmFwcGx5TWF0cml4NCggbWF0cml4V29ybGQgKTtcblxuXHRcdFx0XHR2Mi5jb3B5KCBub3JtYWwgKS5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKCB0aGlzLnNpemUgKS5hZGQoIHYxICk7XG5cblx0XHRcdFx0cG9zaXRpb24uc2V0WFlaKCBpZHgsIHYxLngsIHYxLnksIHYxLnogKTtcblxuXHRcdFx0XHRpZHggPSBpZHggKyAxO1xuXG5cdFx0XHRcdHBvc2l0aW9uLnNldFhZWiggaWR4LCB2Mi54LCB2Mi55LCB2Mi56ICk7XG5cblx0XHRcdFx0aWR4ID0gaWR4ICsgMTtcblxuXHRcdFx0fVxuXG5cdFx0XHRwb3NpdGlvbi5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fVxuXG5cdH0oKSApO1xuXG5cdC8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL0dyaWRIZWxwZXIuanNcblxuXHQvKipcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICovXG5cblx0VEhSRUUuR3JpZEhlbHBlciA9IGZ1bmN0aW9uICggc2l6ZSwgc3RlcCApIHtcblxuXHRcdHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuXHRcdHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyB2ZXJ0ZXhDb2xvcnM6IFRIUkVFLlZlcnRleENvbG9ycyB9ICk7XG5cblx0XHR0aGlzLmNvbG9yMSA9IG5ldyBUSFJFRS5Db2xvciggMHg0NDQ0NDQgKTtcblx0XHR0aGlzLmNvbG9yMiA9IG5ldyBUSFJFRS5Db2xvciggMHg4ODg4ODggKTtcblxuXHRcdGZvciAoIHZhciBpID0gLSBzaXplOyBpIDw9IHNpemU7IGkgKz0gc3RlcCApIHtcblxuXHRcdFx0Z2VvbWV0cnkudmVydGljZXMucHVzaChcblx0XHRcdFx0bmV3IFRIUkVFLlZlY3RvcjMoIC0gc2l6ZSwgMCwgaSApLCBuZXcgVEhSRUUuVmVjdG9yMyggc2l6ZSwgMCwgaSApLFxuXHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMyggaSwgMCwgLSBzaXplICksIG5ldyBUSFJFRS5WZWN0b3IzKCBpLCAwLCBzaXplIClcblx0XHRcdCk7XG5cblx0XHRcdHZhciBjb2xvciA9IGkgPT09IDAgPyB0aGlzLmNvbG9yMSA6IHRoaXMuY29sb3IyO1xuXG5cdFx0XHRnZW9tZXRyeS5jb2xvcnMucHVzaCggY29sb3IsIGNvbG9yLCBjb2xvciwgY29sb3IgKTtcblxuXHRcdH1cblxuXHRcdFRIUkVFLkxpbmVTZWdtZW50cy5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxuXHR9O1xuXG5cdFRIUkVFLkdyaWRIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGluZVNlZ21lbnRzLnByb3RvdHlwZSApO1xuXHRUSFJFRS5HcmlkSGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkdyaWRIZWxwZXI7XG5cblx0VEhSRUUuR3JpZEhlbHBlci5wcm90b3R5cGUuc2V0Q29sb3JzID0gZnVuY3Rpb24oIGNvbG9yQ2VudGVyTGluZSwgY29sb3JHcmlkICkge1xuXG5cdFx0dGhpcy5jb2xvcjEuc2V0KCBjb2xvckNlbnRlckxpbmUgKTtcblx0XHR0aGlzLmNvbG9yMi5zZXQoIGNvbG9yR3JpZCApO1xuXG5cdFx0dGhpcy5nZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlID0gdHJ1ZTtcblxuXHR9O1xuXG5cdC8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL0hlbWlzcGhlcmVMaWdodEhlbHBlci5qc1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuXHQgKi9cblxuXHRUSFJFRS5IZW1pc3BoZXJlTGlnaHRIZWxwZXIgPSBmdW5jdGlvbiAoIGxpZ2h0LCBzcGhlcmVTaXplICkge1xuXG5cdFx0VEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG5cdFx0dGhpcy5saWdodCA9IGxpZ2h0O1xuXHRcdHRoaXMubGlnaHQudXBkYXRlTWF0cml4V29ybGQoKTtcblxuXHRcdHRoaXMubWF0cml4ID0gbGlnaHQubWF0cml4V29ybGQ7XG5cdFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cblx0XHR0aGlzLmNvbG9ycyA9IFsgbmV3IFRIUkVFLkNvbG9yKCksIG5ldyBUSFJFRS5Db2xvcigpIF07XG5cblx0XHR2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoIHNwaGVyZVNpemUsIDQsIDIgKTtcblx0XHRnZW9tZXRyeS5yb3RhdGVYKCAtIE1hdGguUEkgLyAyICk7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gODsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRnZW9tZXRyeS5mYWNlc1sgaSBdLmNvbG9yID0gdGhpcy5jb2xvcnNbIGkgPCA0ID8gMCA6IDEgXTtcblxuXHRcdH1cblxuXHRcdHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCggeyB2ZXJ0ZXhDb2xvcnM6IFRIUkVFLkZhY2VDb2xvcnMsIHdpcmVmcmFtZTogdHJ1ZSB9ICk7XG5cblx0XHR0aGlzLmxpZ2h0U3BoZXJlID0gbmV3IFRIUkVFLk1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXHRcdHRoaXMuYWRkKCB0aGlzLmxpZ2h0U3BoZXJlICk7XG5cblx0XHR0aGlzLnVwZGF0ZSgpO1xuXG5cdH07XG5cblx0VEhSRUUuSGVtaXNwaGVyZUxpZ2h0SGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xuXHRUSFJFRS5IZW1pc3BoZXJlTGlnaHRIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuSGVtaXNwaGVyZUxpZ2h0SGVscGVyO1xuXG5cdFRIUkVFLkhlbWlzcGhlcmVMaWdodEhlbHBlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHRoaXMubGlnaHRTcGhlcmUuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuXHRcdHRoaXMubGlnaHRTcGhlcmUubWF0ZXJpYWwuZGlzcG9zZSgpO1xuXG5cdH07XG5cblx0VEhSRUUuSGVtaXNwaGVyZUxpZ2h0SGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHRoaXMuY29sb3JzWyAwIF0uY29weSggdGhpcy5saWdodC5jb2xvciApLm11bHRpcGx5U2NhbGFyKCB0aGlzLmxpZ2h0LmludGVuc2l0eSApO1xuXHRcdFx0dGhpcy5jb2xvcnNbIDEgXS5jb3B5KCB0aGlzLmxpZ2h0Lmdyb3VuZENvbG9yICkubXVsdGlwbHlTY2FsYXIoIHRoaXMubGlnaHQuaW50ZW5zaXR5ICk7XG5cblx0XHRcdHRoaXMubGlnaHRTcGhlcmUubG9va0F0KCB2ZWN0b3Iuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLmxpZ2h0Lm1hdHJpeFdvcmxkICkubmVnYXRlKCkgKTtcblx0XHRcdHRoaXMubGlnaHRTcGhlcmUuZ2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZSA9IHRydWU7XG5cblx0XHR9XG5cblx0fSgpO1xuXG5cdC8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL1BvaW50TGlnaHRIZWxwZXIuanNcblxuXHQvKipcblx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICovXG5cblx0VEhSRUUuUG9pbnRMaWdodEhlbHBlciA9IGZ1bmN0aW9uICggbGlnaHQsIHNwaGVyZVNpemUgKSB7XG5cblx0XHR0aGlzLmxpZ2h0ID0gbGlnaHQ7XG5cdFx0dGhpcy5saWdodC51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXG5cdFx0dmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLlNwaGVyZUdlb21ldHJ5KCBzcGhlcmVTaXplLCA0LCAyICk7XG5cdFx0dmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCB7IHdpcmVmcmFtZTogdHJ1ZSwgZm9nOiBmYWxzZSB9ICk7XG5cdFx0bWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5saWdodC5jb2xvciApLm11bHRpcGx5U2NhbGFyKCB0aGlzLmxpZ2h0LmludGVuc2l0eSApO1xuXG5cdFx0VEhSRUUuTWVzaC5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxuXHRcdHRoaXMubWF0cml4ID0gdGhpcy5saWdodC5tYXRyaXhXb3JsZDtcblx0XHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblxuXHRcdC8qXG5cdFx0dmFyIGRpc3RhbmNlR2VvbWV0cnkgPSBuZXcgVEhSRUUuSWNvc2FoZWRyb25HZW9tZXRyeSggMSwgMiApO1xuXHRcdHZhciBkaXN0YW5jZU1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBoZXhDb2xvciwgZm9nOiBmYWxzZSwgd2lyZWZyYW1lOiB0cnVlLCBvcGFjaXR5OiAwLjEsIHRyYW5zcGFyZW50OiB0cnVlIH0gKTtcblxuXHRcdHRoaXMubGlnaHRTcGhlcmUgPSBuZXcgVEhSRUUuTWVzaCggYnVsYkdlb21ldHJ5LCBidWxiTWF0ZXJpYWwgKTtcblx0XHR0aGlzLmxpZ2h0RGlzdGFuY2UgPSBuZXcgVEhSRUUuTWVzaCggZGlzdGFuY2VHZW9tZXRyeSwgZGlzdGFuY2VNYXRlcmlhbCApO1xuXG5cdFx0dmFyIGQgPSBsaWdodC5kaXN0YW5jZTtcblxuXHRcdGlmICggZCA9PT0gMC4wICkge1xuXG5cdFx0XHR0aGlzLmxpZ2h0RGlzdGFuY2UudmlzaWJsZSA9IGZhbHNlO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhpcy5saWdodERpc3RhbmNlLnNjYWxlLnNldCggZCwgZCwgZCApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5hZGQoIHRoaXMubGlnaHREaXN0YW5jZSApO1xuXHRcdCovXG5cblx0fTtcblxuXHRUSFJFRS5Qb2ludExpZ2h0SGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1lc2gucHJvdG90eXBlICk7XG5cdFRIUkVFLlBvaW50TGlnaHRIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuUG9pbnRMaWdodEhlbHBlcjtcblxuXHRUSFJFRS5Qb2ludExpZ2h0SGVscGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy5nZW9tZXRyeS5kaXNwb3NlKCk7XG5cdFx0dGhpcy5tYXRlcmlhbC5kaXNwb3NlKCk7XG5cblx0fTtcblxuXHRUSFJFRS5Qb2ludExpZ2h0SGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLm1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMubGlnaHQuY29sb3IgKS5tdWx0aXBseVNjYWxhciggdGhpcy5saWdodC5pbnRlbnNpdHkgKTtcblxuXHRcdC8qXG5cdFx0dmFyIGQgPSB0aGlzLmxpZ2h0LmRpc3RhbmNlO1xuXG5cdFx0aWYgKCBkID09PSAwLjAgKSB7XG5cblx0XHRcdHRoaXMubGlnaHREaXN0YW5jZS52aXNpYmxlID0gZmFsc2U7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aGlzLmxpZ2h0RGlzdGFuY2UudmlzaWJsZSA9IHRydWU7XG5cdFx0XHR0aGlzLmxpZ2h0RGlzdGFuY2Uuc2NhbGUuc2V0KCBkLCBkLCBkICk7XG5cblx0XHR9XG5cdFx0Ki9cblxuXHR9O1xuXG5cdC8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL1NrZWxldG9uSGVscGVyLmpzXG5cblx0LyoqXG5cdCAqIEBhdXRob3IgU2VhbiBHcmlmZmluIC8gaHR0cDovL3R3aXR0ZXIuY29tL3NncmlmXG5cdCAqIEBhdXRob3IgTWljaGFlbCBHdWVycmVybyAvIGh0dHA6Ly9yZWFsaXR5bWVsdGRvd24uY29tXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqIEBhdXRob3IgaWtlcnIgLyBodHRwOi8vdmVyb2xkLmNvbVxuXHQgKi9cblxuXHRUSFJFRS5Ta2VsZXRvbkhlbHBlciA9IGZ1bmN0aW9uICggb2JqZWN0ICkge1xuXG5cdFx0dGhpcy5ib25lcyA9IHRoaXMuZ2V0Qm9uZUxpc3QoIG9iamVjdCApO1xuXG5cdFx0dmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmJvbmVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0dmFyIGJvbmUgPSB0aGlzLmJvbmVzWyBpIF07XG5cblx0XHRcdGlmICggYm9uZS5wYXJlbnQgaW5zdGFuY2VvZiBUSFJFRS5Cb25lICkge1xuXG5cdFx0XHRcdGdlb21ldHJ5LnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCkgKTtcblx0XHRcdFx0Z2VvbWV0cnkudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoKSApO1xuXHRcdFx0XHRnZW9tZXRyeS5jb2xvcnMucHVzaCggbmV3IFRIUkVFLkNvbG9yKCAwLCAwLCAxICkgKTtcblx0XHRcdFx0Z2VvbWV0cnkuY29sb3JzLnB1c2goIG5ldyBUSFJFRS5Db2xvciggMCwgMSwgMCApICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGdlb21ldHJ5LmR5bmFtaWMgPSB0cnVlO1xuXG5cdFx0dmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7IHZlcnRleENvbG9yczogVEhSRUUuVmVydGV4Q29sb3JzLCBkZXB0aFRlc3Q6IGZhbHNlLCBkZXB0aFdyaXRlOiBmYWxzZSwgdHJhbnNwYXJlbnQ6IHRydWUgfSApO1xuXG5cdFx0VEhSRUUuTGluZVNlZ21lbnRzLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG5cdFx0dGhpcy5yb290ID0gb2JqZWN0O1xuXG5cdFx0dGhpcy5tYXRyaXggPSBvYmplY3QubWF0cml4V29ybGQ7XG5cdFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cblx0XHR0aGlzLnVwZGF0ZSgpO1xuXG5cdH07XG5cblxuXHRUSFJFRS5Ta2VsZXRvbkhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaW5lU2VnbWVudHMucHJvdG90eXBlICk7XG5cdFRIUkVFLlNrZWxldG9uSGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlNrZWxldG9uSGVscGVyO1xuXG5cdFRIUkVFLlNrZWxldG9uSGVscGVyLnByb3RvdHlwZS5nZXRCb25lTGlzdCA9IGZ1bmN0aW9uKCBvYmplY3QgKSB7XG5cblx0XHR2YXIgYm9uZUxpc3QgPSBbXTtcblxuXHRcdGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuQm9uZSApIHtcblxuXHRcdFx0Ym9uZUxpc3QucHVzaCggb2JqZWN0ICk7XG5cblx0XHR9XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBvYmplY3QuY2hpbGRyZW4ubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRib25lTGlzdC5wdXNoLmFwcGx5KCBib25lTGlzdCwgdGhpcy5nZXRCb25lTGlzdCggb2JqZWN0LmNoaWxkcmVuWyBpIF0gKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGJvbmVMaXN0O1xuXG5cdH07XG5cblx0VEhSRUUuU2tlbGV0b25IZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cblx0XHR2YXIgbWF0cml4V29ybGRJbnYgPSBuZXcgVEhSRUUuTWF0cml4NCgpLmdldEludmVyc2UoIHRoaXMucm9vdC5tYXRyaXhXb3JsZCApO1xuXG5cdFx0dmFyIGJvbmVNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG5cdFx0dmFyIGogPSAwO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5ib25lcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdHZhciBib25lID0gdGhpcy5ib25lc1sgaSBdO1xuXG5cdFx0XHRpZiAoIGJvbmUucGFyZW50IGluc3RhbmNlb2YgVEhSRUUuQm9uZSApIHtcblxuXHRcdFx0XHRib25lTWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIG1hdHJpeFdvcmxkSW52LCBib25lLm1hdHJpeFdvcmxkICk7XG5cdFx0XHRcdGdlb21ldHJ5LnZlcnRpY2VzWyBqIF0uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBib25lTWF0cml4ICk7XG5cblx0XHRcdFx0Ym9uZU1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBtYXRyaXhXb3JsZEludiwgYm9uZS5wYXJlbnQubWF0cml4V29ybGQgKTtcblx0XHRcdFx0Z2VvbWV0cnkudmVydGljZXNbIGogKyAxIF0uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBib25lTWF0cml4ICk7XG5cblx0XHRcdFx0aiArPSAyO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPSB0cnVlO1xuXG5cdFx0Z2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cblx0fTtcblxuXHQvLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9TcG90TGlnaHRIZWxwZXIuanNcblxuXHQvKipcblx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG5cdCovXG5cblx0VEhSRUUuU3BvdExpZ2h0SGVscGVyID0gZnVuY3Rpb24gKCBsaWdodCApIHtcblxuXHRcdFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuXHRcdHRoaXMubGlnaHQgPSBsaWdodDtcblx0XHR0aGlzLmxpZ2h0LnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cblx0XHR0aGlzLm1hdHJpeCA9IGxpZ2h0Lm1hdHJpeFdvcmxkO1xuXHRcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0dmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkN5bGluZGVyR2VvbWV0cnkoIDAsIDEsIDEsIDgsIDEsIHRydWUgKTtcblxuXHRcdGdlb21ldHJ5LnRyYW5zbGF0ZSggMCwgLSAwLjUsIDAgKTtcblx0XHRnZW9tZXRyeS5yb3RhdGVYKCAtIE1hdGguUEkgLyAyICk7XG5cblx0XHR2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHsgd2lyZWZyYW1lOiB0cnVlLCBmb2c6IGZhbHNlIH0gKTtcblxuXHRcdHRoaXMuY29uZSA9IG5ldyBUSFJFRS5NZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblx0XHR0aGlzLmFkZCggdGhpcy5jb25lICk7XG5cblx0XHR0aGlzLnVwZGF0ZSgpO1xuXG5cdH07XG5cblx0VEhSRUUuU3BvdExpZ2h0SGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xuXHRUSFJFRS5TcG90TGlnaHRIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuU3BvdExpZ2h0SGVscGVyO1xuXG5cdFRIUkVFLlNwb3RMaWdodEhlbHBlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHRoaXMuY29uZS5nZW9tZXRyeS5kaXNwb3NlKCk7XG5cdFx0dGhpcy5jb25lLm1hdGVyaWFsLmRpc3Bvc2UoKTtcblxuXHR9O1xuXG5cdFRIUkVFLlNwb3RMaWdodEhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0dmFyIHZlY3RvcjIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIGNvbmVMZW5ndGggPSB0aGlzLmxpZ2h0LmRpc3RhbmNlID8gdGhpcy5saWdodC5kaXN0YW5jZSA6IDEwMDAwO1xuXHRcdFx0dmFyIGNvbmVXaWR0aCA9IGNvbmVMZW5ndGggKiBNYXRoLnRhbiggdGhpcy5saWdodC5hbmdsZSApO1xuXG5cdFx0XHR0aGlzLmNvbmUuc2NhbGUuc2V0KCBjb25lV2lkdGgsIGNvbmVXaWR0aCwgY29uZUxlbmd0aCApO1xuXG5cdFx0XHR2ZWN0b3Iuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLmxpZ2h0Lm1hdHJpeFdvcmxkICk7XG5cdFx0XHR2ZWN0b3IyLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5saWdodC50YXJnZXQubWF0cml4V29ybGQgKTtcblxuXHRcdFx0dGhpcy5jb25lLmxvb2tBdCggdmVjdG9yMi5zdWIoIHZlY3RvciApICk7XG5cblx0XHRcdHRoaXMuY29uZS5tYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmxpZ2h0LmNvbG9yICkubXVsdGlwbHlTY2FsYXIoIHRoaXMubGlnaHQuaW50ZW5zaXR5ICk7XG5cblx0XHR9O1xuXG5cdH0oKTtcblxuXHQvLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9WZXJ0ZXhOb3JtYWxzSGVscGVyLmpzXG5cblx0LyoqXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuXHQqL1xuXG5cdFRIUkVFLlZlcnRleE5vcm1hbHNIZWxwZXIgPSBmdW5jdGlvbiAoIG9iamVjdCwgc2l6ZSwgaGV4LCBsaW5ld2lkdGggKSB7XG5cblx0XHR0aGlzLm9iamVjdCA9IG9iamVjdDtcblxuXHRcdHRoaXMuc2l6ZSA9ICggc2l6ZSAhPT0gdW5kZWZpbmVkICkgPyBzaXplIDogMTtcblxuXHRcdHZhciBjb2xvciA9ICggaGV4ICE9PSB1bmRlZmluZWQgKSA/IGhleCA6IDB4ZmYwMDAwO1xuXG5cdFx0dmFyIHdpZHRoID0gKCBsaW5ld2lkdGggIT09IHVuZGVmaW5lZCApID8gbGluZXdpZHRoIDogMTtcblxuXHRcdC8vXG5cblx0XHR2YXIgbk5vcm1hbHMgPSAwO1xuXG5cdFx0dmFyIG9iakdlb21ldHJ5ID0gdGhpcy5vYmplY3QuZ2VvbWV0cnk7XG5cblx0XHRpZiAoIG9iakdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuR2VvbWV0cnkgKSB7XG5cblx0XHRcdG5Ob3JtYWxzID0gb2JqR2VvbWV0cnkuZmFjZXMubGVuZ3RoICogMztcblxuXHRcdH0gZWxzZSBpZiAoIG9iakdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkgKSB7XG5cblx0XHRcdG5Ob3JtYWxzID0gb2JqR2VvbWV0cnkuYXR0cmlidXRlcy5ub3JtYWwuY291bnRcblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHR2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKTtcblxuXHRcdHZhciBwb3NpdGlvbnMgPSBuZXcgVEhSRUUuRmxvYXQzMkF0dHJpYnV0ZSggbk5vcm1hbHMgKiAyICogMywgMyApO1xuXG5cdFx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBwb3NpdGlvbnMgKTtcblxuXHRcdFRIUkVFLkxpbmVTZWdtZW50cy5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBjb2xvciwgbGluZXdpZHRoOiB3aWR0aCB9ICkgKTtcblxuXHRcdC8vXG5cblx0XHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblxuXHRcdHRoaXMudXBkYXRlKCk7XG5cblx0fTtcblxuXHRUSFJFRS5WZXJ0ZXhOb3JtYWxzSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcblx0VEhSRUUuVmVydGV4Tm9ybWFsc0hlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5WZXJ0ZXhOb3JtYWxzSGVscGVyO1xuXG5cdFRIUkVFLlZlcnRleE5vcm1hbHNIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9ICggZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHR2YXIgdjIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdHZhciBub3JtYWxNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4MygpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcblxuXHRcdFx0dmFyIGtleXMgPSBbICdhJywgJ2InLCAnYycgXTtcblxuXHRcdFx0dGhpcy5vYmplY3QudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcblxuXHRcdFx0bm9ybWFsTWF0cml4LmdldE5vcm1hbE1hdHJpeCggdGhpcy5vYmplY3QubWF0cml4V29ybGQgKTtcblxuXHRcdFx0dmFyIG1hdHJpeFdvcmxkID0gdGhpcy5vYmplY3QubWF0cml4V29ybGQ7XG5cblx0XHRcdHZhciBwb3NpdGlvbiA9IHRoaXMuZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblxuXHRcdFx0Ly9cblxuXHRcdFx0dmFyIG9iakdlb21ldHJ5ID0gdGhpcy5vYmplY3QuZ2VvbWV0cnk7XG5cblx0XHRcdGlmICggb2JqR2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5HZW9tZXRyeSApIHtcblxuXHRcdFx0XHR2YXIgdmVydGljZXMgPSBvYmpHZW9tZXRyeS52ZXJ0aWNlcztcblxuXHRcdFx0XHR2YXIgZmFjZXMgPSBvYmpHZW9tZXRyeS5mYWNlcztcblxuXHRcdFx0XHR2YXIgaWR4ID0gMDtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBmYWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIGZhY2UgPSBmYWNlc1sgaSBdO1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IGZhY2UudmVydGV4Tm9ybWFscy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHRcdFx0dmFyIHZlcnRleCA9IHZlcnRpY2VzWyBmYWNlWyBrZXlzWyBqIF0gXSBdO1xuXG5cdFx0XHRcdFx0XHR2YXIgbm9ybWFsID0gZmFjZS52ZXJ0ZXhOb3JtYWxzWyBqIF07XG5cblx0XHRcdFx0XHRcdHYxLmNvcHkoIHZlcnRleCApLmFwcGx5TWF0cml4NCggbWF0cml4V29ybGQgKTtcblxuXHRcdFx0XHRcdFx0djIuY29weSggbm9ybWFsICkuYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhciggdGhpcy5zaXplICkuYWRkKCB2MSApO1xuXG5cdFx0XHRcdFx0XHRwb3NpdGlvbi5zZXRYWVooIGlkeCwgdjEueCwgdjEueSwgdjEueiApO1xuXG5cdFx0XHRcdFx0XHRpZHggPSBpZHggKyAxO1xuXG5cdFx0XHRcdFx0XHRwb3NpdGlvbi5zZXRYWVooIGlkeCwgdjIueCwgdjIueSwgdjIueiApO1xuXG5cdFx0XHRcdFx0XHRpZHggPSBpZHggKyAxO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIGlmICggb2JqR2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSApIHtcblxuXHRcdFx0XHR2YXIgb2JqUG9zID0gb2JqR2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblxuXHRcdFx0XHR2YXIgb2JqTm9ybSA9IG9iakdlb21ldHJ5LmF0dHJpYnV0ZXMubm9ybWFsO1xuXG5cdFx0XHRcdHZhciBpZHggPSAwO1xuXG5cdFx0XHRcdC8vIGZvciBzaW1wbGljaXR5LCBpZ25vcmUgaW5kZXggYW5kIGRyYXdjYWxscywgYW5kIHJlbmRlciBldmVyeSBub3JtYWxcblxuXHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gb2JqUG9zLmNvdW50OyBqIDwgamw7IGogKysgKSB7XG5cblx0XHRcdFx0XHR2MS5zZXQoIG9ialBvcy5nZXRYKCBqICksIG9ialBvcy5nZXRZKCBqICksIG9ialBvcy5nZXRaKCBqICkgKS5hcHBseU1hdHJpeDQoIG1hdHJpeFdvcmxkICk7XG5cblx0XHRcdFx0XHR2Mi5zZXQoIG9iak5vcm0uZ2V0WCggaiApLCBvYmpOb3JtLmdldFkoIGogKSwgb2JqTm9ybS5nZXRaKCBqICkgKTtcblxuXHRcdFx0XHRcdHYyLmFwcGx5TWF0cml4Myggbm9ybWFsTWF0cml4ICkubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIoIHRoaXMuc2l6ZSApLmFkZCggdjEgKTtcblxuXHRcdFx0XHRcdHBvc2l0aW9uLnNldFhZWiggaWR4LCB2MS54LCB2MS55LCB2MS56ICk7XG5cblx0XHRcdFx0XHRpZHggPSBpZHggKyAxO1xuXG5cdFx0XHRcdFx0cG9zaXRpb24uc2V0WFlaKCBpZHgsIHYyLngsIHYyLnksIHYyLnogKTtcblxuXHRcdFx0XHRcdGlkeCA9IGlkeCArIDE7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9XG5cblx0fSgpICk7XG5cblx0Ly8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvV2lyZWZyYW1lSGVscGVyLmpzXG5cblx0LyoqXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqL1xuXG5cdFRIUkVFLldpcmVmcmFtZUhlbHBlciA9IGZ1bmN0aW9uICggb2JqZWN0LCBoZXggKSB7XG5cblx0XHR2YXIgY29sb3IgPSAoIGhleCAhPT0gdW5kZWZpbmVkICkgPyBoZXggOiAweGZmZmZmZjtcblxuXHRcdFRIUkVFLkxpbmVTZWdtZW50cy5jYWxsKCB0aGlzLCBuZXcgVEhSRUUuV2lyZWZyYW1lR2VvbWV0cnkoIG9iamVjdC5nZW9tZXRyeSApLCBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yIH0gKSApO1xuXG5cdFx0dGhpcy5tYXRyaXggPSBvYmplY3QubWF0cml4V29ybGQ7XG5cdFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cblx0fTtcblxuXHRUSFJFRS5XaXJlZnJhbWVIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGluZVNlZ21lbnRzLnByb3RvdHlwZSApO1xuXHRUSFJFRS5XaXJlZnJhbWVIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuV2lyZWZyYW1lSGVscGVyO1xuXG5cdC8vIEZpbGU6c3JjL2V4dHJhcy9vYmplY3RzL0ltbWVkaWF0ZVJlbmRlck9iamVjdC5qc1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuXHQgKi9cblxuXHRUSFJFRS5JbW1lZGlhdGVSZW5kZXJPYmplY3QgPSBmdW5jdGlvbiAoIG1hdGVyaWFsICkge1xuXG5cdFx0VEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG5cdFx0dGhpcy5tYXRlcmlhbCA9IG1hdGVyaWFsO1xuXHRcdHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKCByZW5kZXJDYWxsYmFjayApIHt9O1xuXG5cdH07XG5cblx0VEhSRUUuSW1tZWRpYXRlUmVuZGVyT2JqZWN0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xuXHRUSFJFRS5JbW1lZGlhdGVSZW5kZXJPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuSW1tZWRpYXRlUmVuZGVyT2JqZWN0O1xuXG5cdC8vIEZpbGU6c3JjL2V4dHJhcy9vYmplY3RzL01vcnBoQmxlbmRNZXNoLmpzXG5cblx0LyoqXG5cdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG5cdCAqL1xuXG5cdFRIUkVFLk1vcnBoQmxlbmRNZXNoID0gZnVuY3Rpb24oIGdlb21ldHJ5LCBtYXRlcmlhbCApIHtcblxuXHRcdFRIUkVFLk1lc2guY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cblx0XHR0aGlzLmFuaW1hdGlvbnNNYXAgPSB7fTtcblx0XHR0aGlzLmFuaW1hdGlvbnNMaXN0ID0gW107XG5cblx0XHQvLyBwcmVwYXJlIGRlZmF1bHQgYW5pbWF0aW9uXG5cdFx0Ly8gKGFsbCBmcmFtZXMgcGxheWVkIHRvZ2V0aGVyIGluIDEgc2Vjb25kKVxuXG5cdFx0dmFyIG51bUZyYW1lcyA9IHRoaXMuZ2VvbWV0cnkubW9ycGhUYXJnZXRzLmxlbmd0aDtcblxuXHRcdHZhciBuYW1lID0gXCJfX2RlZmF1bHRcIjtcblxuXHRcdHZhciBzdGFydEZyYW1lID0gMDtcblx0XHR2YXIgZW5kRnJhbWUgPSBudW1GcmFtZXMgLSAxO1xuXG5cdFx0dmFyIGZwcyA9IG51bUZyYW1lcyAvIDE7XG5cblx0XHR0aGlzLmNyZWF0ZUFuaW1hdGlvbiggbmFtZSwgc3RhcnRGcmFtZSwgZW5kRnJhbWUsIGZwcyApO1xuXHRcdHRoaXMuc2V0QW5pbWF0aW9uV2VpZ2h0KCBuYW1lLCAxICk7XG5cblx0fTtcblxuXHRUSFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NZXNoLnByb3RvdHlwZSApO1xuXHRUSFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Nb3JwaEJsZW5kTWVzaDtcblxuXHRUSFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuY3JlYXRlQW5pbWF0aW9uID0gZnVuY3Rpb24gKCBuYW1lLCBzdGFydCwgZW5kLCBmcHMgKSB7XG5cblx0XHR2YXIgYW5pbWF0aW9uID0ge1xuXG5cdFx0XHRzdGFydDogc3RhcnQsXG5cdFx0XHRlbmQ6IGVuZCxcblxuXHRcdFx0bGVuZ3RoOiBlbmQgLSBzdGFydCArIDEsXG5cblx0XHRcdGZwczogZnBzLFxuXHRcdFx0ZHVyYXRpb246ICggZW5kIC0gc3RhcnQgKSAvIGZwcyxcblxuXHRcdFx0bGFzdEZyYW1lOiAwLFxuXHRcdFx0Y3VycmVudEZyYW1lOiAwLFxuXG5cdFx0XHRhY3RpdmU6IGZhbHNlLFxuXG5cdFx0XHR0aW1lOiAwLFxuXHRcdFx0ZGlyZWN0aW9uOiAxLFxuXHRcdFx0d2VpZ2h0OiAxLFxuXG5cdFx0XHRkaXJlY3Rpb25CYWNrd2FyZHM6IGZhbHNlLFxuXHRcdFx0bWlycm9yZWRMb29wOiBmYWxzZVxuXG5cdFx0fTtcblxuXHRcdHRoaXMuYW5pbWF0aW9uc01hcFsgbmFtZSBdID0gYW5pbWF0aW9uO1xuXHRcdHRoaXMuYW5pbWF0aW9uc0xpc3QucHVzaCggYW5pbWF0aW9uICk7XG5cblx0fTtcblxuXHRUSFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuYXV0b0NyZWF0ZUFuaW1hdGlvbnMgPSBmdW5jdGlvbiAoIGZwcyApIHtcblxuXHRcdHZhciBwYXR0ZXJuID0gLyhbYS16XSspXz8oXFxkKykvO1xuXG5cdFx0dmFyIGZpcnN0QW5pbWF0aW9uLCBmcmFtZVJhbmdlcyA9IHt9O1xuXG5cdFx0dmFyIGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdHZhciBtb3JwaCA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1sgaSBdO1xuXHRcdFx0dmFyIGNodW5rcyA9IG1vcnBoLm5hbWUubWF0Y2goIHBhdHRlcm4gKTtcblxuXHRcdFx0aWYgKCBjaHVua3MgJiYgY2h1bmtzLmxlbmd0aCA+IDEgKSB7XG5cblx0XHRcdFx0dmFyIG5hbWUgPSBjaHVua3NbIDEgXTtcblxuXHRcdFx0XHRpZiAoICEgZnJhbWVSYW5nZXNbIG5hbWUgXSApIGZyYW1lUmFuZ2VzWyBuYW1lIF0gPSB7IHN0YXJ0OiBJbmZpbml0eSwgZW5kOiAtIEluZmluaXR5IH07XG5cblx0XHRcdFx0dmFyIHJhbmdlID0gZnJhbWVSYW5nZXNbIG5hbWUgXTtcblxuXHRcdFx0XHRpZiAoIGkgPCByYW5nZS5zdGFydCApIHJhbmdlLnN0YXJ0ID0gaTtcblx0XHRcdFx0aWYgKCBpID4gcmFuZ2UuZW5kICkgcmFuZ2UuZW5kID0gaTtcblxuXHRcdFx0XHRpZiAoICEgZmlyc3RBbmltYXRpb24gKSBmaXJzdEFuaW1hdGlvbiA9IG5hbWU7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZvciAoIHZhciBuYW1lIGluIGZyYW1lUmFuZ2VzICkge1xuXG5cdFx0XHR2YXIgcmFuZ2UgPSBmcmFtZVJhbmdlc1sgbmFtZSBdO1xuXHRcdFx0dGhpcy5jcmVhdGVBbmltYXRpb24oIG5hbWUsIHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQsIGZwcyApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5maXJzdEFuaW1hdGlvbiA9IGZpcnN0QW5pbWF0aW9uO1xuXG5cdH07XG5cblx0VEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnNldEFuaW1hdGlvbkRpcmVjdGlvbkZvcndhcmQgPSBmdW5jdGlvbiAoIG5hbWUgKSB7XG5cblx0XHR2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XG5cblx0XHRpZiAoIGFuaW1hdGlvbiApIHtcblxuXHRcdFx0YW5pbWF0aW9uLmRpcmVjdGlvbiA9IDE7XG5cdFx0XHRhbmltYXRpb24uZGlyZWN0aW9uQmFja3dhcmRzID0gZmFsc2U7XG5cblx0XHR9XG5cblx0fTtcblxuXHRUSFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuc2V0QW5pbWF0aW9uRGlyZWN0aW9uQmFja3dhcmQgPSBmdW5jdGlvbiAoIG5hbWUgKSB7XG5cblx0XHR2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XG5cblx0XHRpZiAoIGFuaW1hdGlvbiApIHtcblxuXHRcdFx0YW5pbWF0aW9uLmRpcmVjdGlvbiA9IC0gMTtcblx0XHRcdGFuaW1hdGlvbi5kaXJlY3Rpb25CYWNrd2FyZHMgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0VEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnNldEFuaW1hdGlvbkZQUyA9IGZ1bmN0aW9uICggbmFtZSwgZnBzICkge1xuXG5cdFx0dmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc01hcFsgbmFtZSBdO1xuXG5cdFx0aWYgKCBhbmltYXRpb24gKSB7XG5cblx0XHRcdGFuaW1hdGlvbi5mcHMgPSBmcHM7XG5cdFx0XHRhbmltYXRpb24uZHVyYXRpb24gPSAoIGFuaW1hdGlvbi5lbmQgLSBhbmltYXRpb24uc3RhcnQgKSAvIGFuaW1hdGlvbi5mcHM7XG5cblx0XHR9XG5cblx0fTtcblxuXHRUSFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuc2V0QW5pbWF0aW9uRHVyYXRpb24gPSBmdW5jdGlvbiAoIG5hbWUsIGR1cmF0aW9uICkge1xuXG5cdFx0dmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc01hcFsgbmFtZSBdO1xuXG5cdFx0aWYgKCBhbmltYXRpb24gKSB7XG5cblx0XHRcdGFuaW1hdGlvbi5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuXHRcdFx0YW5pbWF0aW9uLmZwcyA9ICggYW5pbWF0aW9uLmVuZCAtIGFuaW1hdGlvbi5zdGFydCApIC8gYW5pbWF0aW9uLmR1cmF0aW9uO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0VEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnNldEFuaW1hdGlvbldlaWdodCA9IGZ1bmN0aW9uICggbmFtZSwgd2VpZ2h0ICkge1xuXG5cdFx0dmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc01hcFsgbmFtZSBdO1xuXG5cdFx0aWYgKCBhbmltYXRpb24gKSB7XG5cblx0XHRcdGFuaW1hdGlvbi53ZWlnaHQgPSB3ZWlnaHQ7XG5cblx0XHR9XG5cblx0fTtcblxuXHRUSFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuc2V0QW5pbWF0aW9uVGltZSA9IGZ1bmN0aW9uICggbmFtZSwgdGltZSApIHtcblxuXHRcdHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcblxuXHRcdGlmICggYW5pbWF0aW9uICkge1xuXG5cdFx0XHRhbmltYXRpb24udGltZSA9IHRpbWU7XG5cblx0XHR9XG5cblx0fTtcblxuXHRUSFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuZ2V0QW5pbWF0aW9uVGltZSA9IGZ1bmN0aW9uICggbmFtZSApIHtcblxuXHRcdHZhciB0aW1lID0gMDtcblxuXHRcdHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcblxuXHRcdGlmICggYW5pbWF0aW9uICkge1xuXG5cdFx0XHR0aW1lID0gYW5pbWF0aW9uLnRpbWU7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGltZTtcblxuXHR9O1xuXG5cdFRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5nZXRBbmltYXRpb25EdXJhdGlvbiA9IGZ1bmN0aW9uICggbmFtZSApIHtcblxuXHRcdHZhciBkdXJhdGlvbiA9IC0gMTtcblxuXHRcdHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcblxuXHRcdGlmICggYW5pbWF0aW9uICkge1xuXG5cdFx0XHRkdXJhdGlvbiA9IGFuaW1hdGlvbi5kdXJhdGlvbjtcblxuXHRcdH1cblxuXHRcdHJldHVybiBkdXJhdGlvbjtcblxuXHR9O1xuXG5cdFRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5wbGF5QW5pbWF0aW9uID0gZnVuY3Rpb24gKCBuYW1lICkge1xuXG5cdFx0dmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc01hcFsgbmFtZSBdO1xuXG5cdFx0aWYgKCBhbmltYXRpb24gKSB7XG5cblx0XHRcdGFuaW1hdGlvbi50aW1lID0gMDtcblx0XHRcdGFuaW1hdGlvbi5hY3RpdmUgPSB0cnVlO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCBcIlRIUkVFLk1vcnBoQmxlbmRNZXNoOiBhbmltYXRpb25bXCIgKyBuYW1lICsgXCJdIHVuZGVmaW5lZCBpbiAucGxheUFuaW1hdGlvbigpXCIgKTtcblxuXHRcdH1cblxuXHR9O1xuXG5cdFRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5zdG9wQW5pbWF0aW9uID0gZnVuY3Rpb24gKCBuYW1lICkge1xuXG5cdFx0dmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc01hcFsgbmFtZSBdO1xuXG5cdFx0aWYgKCBhbmltYXRpb24gKSB7XG5cblx0XHRcdGFuaW1hdGlvbi5hY3RpdmUgPSBmYWxzZTtcblxuXHRcdH1cblxuXHR9O1xuXG5cdFRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoIGRlbHRhICkge1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHRoaXMuYW5pbWF0aW9uc0xpc3QubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNMaXN0WyBpIF07XG5cblx0XHRcdGlmICggISBhbmltYXRpb24uYWN0aXZlICkgY29udGludWU7XG5cblx0XHRcdHZhciBmcmFtZVRpbWUgPSBhbmltYXRpb24uZHVyYXRpb24gLyBhbmltYXRpb24ubGVuZ3RoO1xuXG5cdFx0XHRhbmltYXRpb24udGltZSArPSBhbmltYXRpb24uZGlyZWN0aW9uICogZGVsdGE7XG5cblx0XHRcdGlmICggYW5pbWF0aW9uLm1pcnJvcmVkTG9vcCApIHtcblxuXHRcdFx0XHRpZiAoIGFuaW1hdGlvbi50aW1lID4gYW5pbWF0aW9uLmR1cmF0aW9uIHx8IGFuaW1hdGlvbi50aW1lIDwgMCApIHtcblxuXHRcdFx0XHRcdGFuaW1hdGlvbi5kaXJlY3Rpb24gKj0gLSAxO1xuXG5cdFx0XHRcdFx0aWYgKCBhbmltYXRpb24udGltZSA+IGFuaW1hdGlvbi5kdXJhdGlvbiApIHtcblxuXHRcdFx0XHRcdFx0YW5pbWF0aW9uLnRpbWUgPSBhbmltYXRpb24uZHVyYXRpb247XG5cdFx0XHRcdFx0XHRhbmltYXRpb24uZGlyZWN0aW9uQmFja3dhcmRzID0gdHJ1ZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggYW5pbWF0aW9uLnRpbWUgPCAwICkge1xuXG5cdFx0XHRcdFx0XHRhbmltYXRpb24udGltZSA9IDA7XG5cdFx0XHRcdFx0XHRhbmltYXRpb24uZGlyZWN0aW9uQmFja3dhcmRzID0gZmFsc2U7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGFuaW1hdGlvbi50aW1lID0gYW5pbWF0aW9uLnRpbWUgJSBhbmltYXRpb24uZHVyYXRpb247XG5cblx0XHRcdFx0aWYgKCBhbmltYXRpb24udGltZSA8IDAgKSBhbmltYXRpb24udGltZSArPSBhbmltYXRpb24uZHVyYXRpb247XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIGtleWZyYW1lID0gYW5pbWF0aW9uLnN0YXJ0ICsgVEhSRUUuTWF0aC5jbGFtcCggTWF0aC5mbG9vciggYW5pbWF0aW9uLnRpbWUgLyBmcmFtZVRpbWUgKSwgMCwgYW5pbWF0aW9uLmxlbmd0aCAtIDEgKTtcblx0XHRcdHZhciB3ZWlnaHQgPSBhbmltYXRpb24ud2VpZ2h0O1xuXG5cdFx0XHRpZiAoIGtleWZyYW1lICE9PSBhbmltYXRpb24uY3VycmVudEZyYW1lICkge1xuXG5cdFx0XHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBhbmltYXRpb24ubGFzdEZyYW1lIF0gPSAwO1xuXHRcdFx0XHR0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgYW5pbWF0aW9uLmN1cnJlbnRGcmFtZSBdID0gMSAqIHdlaWdodDtcblxuXHRcdFx0XHR0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sga2V5ZnJhbWUgXSA9IDA7XG5cblx0XHRcdFx0YW5pbWF0aW9uLmxhc3RGcmFtZSA9IGFuaW1hdGlvbi5jdXJyZW50RnJhbWU7XG5cdFx0XHRcdGFuaW1hdGlvbi5jdXJyZW50RnJhbWUgPSBrZXlmcmFtZTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgbWl4ID0gKCBhbmltYXRpb24udGltZSAlIGZyYW1lVGltZSApIC8gZnJhbWVUaW1lO1xuXG5cdFx0XHRpZiAoIGFuaW1hdGlvbi5kaXJlY3Rpb25CYWNrd2FyZHMgKSBtaXggPSAxIC0gbWl4O1xuXG5cdFx0XHRpZiAoIGFuaW1hdGlvbi5jdXJyZW50RnJhbWUgIT09IGFuaW1hdGlvbi5sYXN0RnJhbWUgKSB7XG5cblx0XHRcdFx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIGFuaW1hdGlvbi5jdXJyZW50RnJhbWUgXSA9IG1peCAqIHdlaWdodDtcblx0XHRcdFx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIGFuaW1hdGlvbi5sYXN0RnJhbWUgXSA9ICggMSAtIG1peCApICogd2VpZ2h0O1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBhbmltYXRpb24uY3VycmVudEZyYW1lIF0gPSB3ZWlnaHQ7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9O1xuXG5cdGlmKCB0eXBlb2YgZGVmaW5lICE9PSBcInVuZGVmaW5lZFwiICYmIGRlZmluZSBpbnN0YW5jZW9mIEZ1bmN0aW9uICYmIGRlZmluZS5hbWQgIT0gdW5kZWZpbmVkICl7XG5cblx0XHRkZWZpbmUoZnVuY3Rpb24oKXtcblxuXHRcdFx0cmV0dXJuIFRIUkVFO1xuXG5cdFx0fSk7XG5cblx0fVxuXHRlbHNlIGlmKCB0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiICYmIG1vZHVsZS5leHBvcnRzICl7XG5cblx0XHRtb2R1bGUuZXhwb3J0cyA9IFRIUkVFO1xuXG5cdH1cblx0ZWxzZSBpZiggdGhpcyAhPSB1bmRlZmluZWQgKXtcblxuXHRcdHRoaXMuVEhSRUUgPSBUSFJFRTtcblxuXHR9O1xuXG59KSh0aGlzIHx8IHt9KTsiLCJpbXBvcnQgdGhyZWVqcyBcdFx0XHRcdGZyb20gXCJ0aHJlZS1qc1wiO1xuY29uc3QgVEhSRUUgPSB0aHJlZWpzKCk7XG5cbmltcG9ydCBjb25maWcgXHRcdFx0XHRmcm9tICcuLi91dGlscy9jb25maWcnO1xuaW1wb3J0IHJhZiBcdFx0XHRcdFx0ZnJvbSAnLi4vdXRpbHMvcmFmJztcbmltcG9ydCBtYXBwZXIgXHRcdFx0XHRmcm9tICcuLi91dGlscy9tYXBwZXInO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuXHRpbml0OiBmdW5jdGlvbigpIHtcblxuXHRcdHRoaXMucmVuZGVyICBcdFx0PSB0aGlzLnJlbmRlci5iaW5kKHRoaXMpO1xuXHRcdHRoaXMub25DbGljayBcdFx0PSB0aGlzLm9uQ2xpY2suYmluZCh0aGlzKTtcblx0XHR0aGlzLm9uUmVzaXplICBcdFx0PSB0aGlzLm9uUmVzaXplLmJpbmQodGhpcyk7XG5cdFx0dGhpcy5vbk1vdmVcdFx0XHQ9IHRoaXMub25Nb3ZlLmJpbmQodGhpcyk7XG5cdFx0dGhpcy5jbG9jayAgIFx0XHQ9IG5ldyBUSFJFRS5DbG9jaygpO1xuXHRcdHRoaXMuY2FtZXJhUG9zXHRcdD0gbmV3IFRIUkVFLlZlY3RvcjMoIGNvbmZpZy5jYW1lcmEucG9zaXRpb24ueCwgY29uZmlnLmNhbWVyYS5wb3NpdGlvbi55LCBjb25maWcuY2FtZXJhLnBvc2l0aW9uLnogKTtcblx0XHR0aGlzLmN1cnJlbnRDYW1lcmFQb3MgPSBuZXcgVEhSRUUuVmVjdG9yMyggdGhpcy5jYW1lcmFQb3MueCwgdGhpcy5jYW1lcmFQb3MueSwgdGhpcy5jYW1lcmFQb3MueiApO1xuXG5cdFx0dGhpcy5wbGFuZSAgIFx0XHQ9IG51bGw7XG5cdFx0dGhpcy5leHBsb3Npb25zUG9zIFx0PSBbXTtcblx0XHR0aGlzLmV4cGxvc2lvbnNUaW1lID0gW107XG5cblx0XHQvLyBLRUVQIFRISVMgU0hJVFxuXHRcdC8vIEFERCBWQUxVRVMgSU4gQSBQUkVERUZJTkVEIExFTkdUSCBBUlJBWVxuXHRcdC8vIFBPUCBUSEUgTEFTVFMgQU5EIFVOU0hJRlQgVEhFIE5FVyBPTkVTXG5cdFx0Zm9yKCBsZXQgaSA9IDAgOyBpIDwgY29uZmlnLnBhcnRpY2xlcy5tYXhFeHBsb3Npb25zIC0gMSA7IGkrKyApIHtcblx0XHRcdHRoaXMuZXhwbG9zaW9uc1Bvc1tpXSAgPSBuZXcgVEhSRUUuVmVjdG9yMiggMCwgMCwgMCApO1xuXHRcdFx0dGhpcy5leHBsb3Npb25zVGltZVtpXSA9IDEwMDtcblx0XHRcdHRoaXMuZXhwbG9zaW9uc0luZGV4ICAgPSAwO1xuXHRcdH1cblxuXHRcdC8vLy8gSU5JVFxuXHRcdHRoaXMuc2NlbmUgXHQgICA9IG5ldyBUSFJFRS5TY2VuZSgpO1xuXHRcdHRoaXMuY29udGFpbmVyID0gY29uZmlnLmNhbnZhcy5lbGVtZW50O1xuXG5cdFx0dGhpcy5jYW1lcmEgXHRcdCAgID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKDQ1LCB0aGlzLnJhdGlvLCAxNSwgMzAwMCk7XG5cdFx0dGhpcy5jYW1lcmEucG9zaXRpb24ueCA9IGNvbmZpZy5jYW1lcmEucG9zaXRpb24ueDtcblx0XHR0aGlzLmNhbWVyYS5wb3NpdGlvbi55ID0gY29uZmlnLmNhbWVyYS5wb3NpdGlvbi55O1xuXHRcdHRoaXMuY2FtZXJhLnBvc2l0aW9uLnogPSBjb25maWcuY2FtZXJhLnBvc2l0aW9uLno7XG5cdFx0dGhpcy5jYW1lcmEubG9va0F0KGNvbmZpZy5jYW1lcmEudGFyZ2V0KTtcblxuXHRcdGlmICggY29uZmlnLmF4aXNIZWxwZXIgKSB7XG5cdFx0XHR0aGlzLmF4aXNIZWxwZXIgPSAgbmV3IFRIUkVFLkF4aXNIZWxwZXIoIDUgKTtcblx0XHRcdHRoaXMuc2NlbmUuYWRkKCB0aGlzLmF4aXNIZWxwZXIgKTtcblx0XHR9XG5cblx0XHQvLy8vIFJFTkRFUkVSXG5cdFx0dGhpcy5yZW5kZXJlciA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlcmVyKCk7XG5cdFx0dGhpcy5yZW5kZXJlci5zZXRDbGVhckNvbG9yKGNvbmZpZy5jYW52YXMuY29sb3IsIDEuMCk7XG5cdFx0dGhpcy5yZW5kZXJlci5zZXRTaXplKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuXG5cdFx0Ly8vLyBBTUJJQU5UIExJR0hUXG5cdFx0dGhpcy5hbWJpZW50ID0gbmV3IFRIUkVFLkFtYmllbnRMaWdodCggY29uZmlnLmxpZ2h0cy5hbWJpZW50LmNvbG9yICk7XG5cblx0XHQvLy8vIEFERCBPQkpFQ1RTIFRPIFNDRU5FXG5cdFx0dGhpcy5zY2VuZS5hZGQoIHRoaXMuYW1iaWVudCApO1xuXG5cdFx0Ly8vLyBBREQgQ0FOVkFTIFRPIERPTVxuXHRcdHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKCB0aGlzLnJlbmRlcmVyLmRvbUVsZW1lbnQgKTtcblxuXHRcdHRoaXMuY3JlYXRlUGFydGljbGVzKCk7XG5cblx0XHQvLy8vIFJFR0lTVCBSRU5ERVJFUlxuXHRcdHJhZi5yZWdpc3RlciggdGhpcy5yZW5kZXIgKTtcblx0XHRyYWYuc3RhcnQoKTtcblx0XHR0aGlzLm9uUmVzaXplKCk7XG5cblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggJ2NsaWNrJywgdGhpcy5vbkNsaWNrICk7XG5cdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoICdyZXNpemUnLCB0aGlzLm9uUmVzaXplICk7XG5cdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoICdtb3VzZW1vdmUnLCB0aGlzLm9uTW92ZSApO1xuXHR9LFxuXG5cdGNyZWF0ZVBhcnRpY2xlczogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy51bmlmb3JtcyA9IHtcblx0XHRcdHRpbWU6IHsgdHlwZTogJ2YnLCB2YWx1ZTogMC4wIH0sXG5cdFx0XHRtYXA6IHsgdHlwZTogJ3QnLCB2YWx1ZTogVEhSRUUuSW1hZ2VVdGlscy5sb2FkVGV4dHVyZShjb25maWcucGFydGljbGVzLnRleHR1cmUpIH0sXG5cblx0XHR9XG5cblx0XHR0aGlzLmdlb21ldHJ5IFx0PSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKTtcblx0XHR0aGlzLnZlcnRpY2VzIFx0PSBuZXcgRmxvYXQzMkFycmF5KCBjb25maWcucGFydGljbGVzLmNvdW50ICogMyApO1xuXHRcdHRoaXMuc2l6ZXMgXHRcdD0gbmV3IEZsb2F0MzJBcnJheSggY29uZmlnLnBhcnRpY2xlcy5jb3VudCApO1xuXG5cdFx0Zm9yKCBsZXQgaSA9IDAgOyBpIDwgY29uZmlnLnBhcnRpY2xlcy5jb3VudCA7IGkrKyApIHtcblxuXHRcdFx0Ly8gbGV0IGFuZ2xlMSA9IE1hdGgucmFuZG9tKCkgKiBNYXRoLlBJICogMjtcblx0XHRcdC8vIGxldCBhbmdsZTIgPSBNYXRoLmFjb3MoIE1hdGgucmFuZG9tKCkgKiAyIC0gMSApO1xuXHRcdFx0Ly8gbGV0IGRpc3QgICA9IDQwMDtcblxuXHRcdFx0Ly8gbGV0IHBYID0gZGlzdCAqIE1hdGguc2luKCBhbmdsZTEgKSAqIE1hdGguY29zKCBhbmdsZTIgKTtcblx0XHRcdC8vIGxldCBwWSA9IGRpc3QgKiBNYXRoLnNpbiggYW5nbGUxICkgKiBNYXRoLnNpbiggYW5nbGUyICk7XG5cdFx0XHQvLyBsZXQgcFogPSBkaXN0ICogTWF0aC5jb3MoIGFuZ2xlMSApO1xuXG5cdFx0XHQvLyB0aGlzLnZlcnRpY2VzW2kgKiAzXSA9IHBYO1xuXHRcdFx0Ly8gdGhpcy52ZXJ0aWNlc1tpICogMyArIDFdID0gcFk7XG5cdFx0XHQvLyB0aGlzLnZlcnRpY2VzW2kgKiAzICsgMl0gPSBwWjtcblxuXHRcdFx0dGhpcy52ZXJ0aWNlc1tpICogM10gPSBNYXRoLnJhbmRvbSgpO1xuXHRcdFx0dGhpcy52ZXJ0aWNlc1tpICogMyArIDFdID0gTWF0aC5yYW5kb20oKTtcblx0XHRcdHRoaXMudmVydGljZXNbaSAqIDMgKyAyXSA9IDA7XG5cblx0XHRcdHRoaXMuc2l6ZXNbIGkgXSA9IDE7XG5cdFx0fVxuXG5cdFx0dGhpcy5nZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIHRoaXMudmVydGljZXMsIDMgKSApO1xuXHRcdHRoaXMuZ2VvbWV0cnkuYWRkQXR0cmlidXRlKCAnc2l6ZScsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIHRoaXMuc2l6ZXMsIDEgKSApO1xuXG5cdFx0dGhpcy5tYXRlcmlhbCA9IG5ldyBUSFJFRS5TaGFkZXJNYXRlcmlhbCgge1xuXHRcdFx0dW5pZm9ybXM6IHRoaXMudW5pZm9ybXMsXG5cdFx0XHR0cmFuc3BhcmVudDogdHJ1ZSxcblx0XHRcdHZlcnRleFNoYWRlcjogcmVxdWlyZSgnLi4vc2hhZGVycy9ub2lzZXMvbm9pc2UyRC5nbHNsJykgKyByZXF1aXJlKCcuLi9zaGFkZXJzL3BhcnRpY2xlcy52ZXJ0ZXguZ2xzbCcpLFxuXHRcdFx0ZnJhZ21lbnRTaGFkZXI6IHJlcXVpcmUoJy4uL3NoYWRlcnMvcGFydGljbGVzLmZyYWdtZW50Lmdsc2wnKVxuXHRcdH0pO1xuXG5cdFx0dGhpcy5wYXJ0aWNsZVN5c3RlbSA9IG5ldyBUSFJFRS5Qb2ludHMoIHRoaXMuZ2VvbWV0cnksIHRoaXMubWF0ZXJpYWwgKTtcblxuXHRcdHRoaXMuc2NlbmUuYWRkKHRoaXMucGFydGljbGVTeXN0ZW0pO1xuXHR9LFxuXG5cdG9uQ2xpY2s6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0fSxcblxuXHRvbk1vdmU6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR0aGlzLmNhbWVyYVBvcy54ID0gZXZlbnQuY2xpZW50WCAtIHRoaXMuaGFsZldpZHRoO1xuXHRcdHRoaXMuY2FtZXJhUG9zLnkgPSBldmVudC5jbGllbnRZIC0gdGhpcy5oYWxmSGVpZ2h0O1xuXHR9LFxuXG5cdG9uUmVzaXplOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnJlbmRlcmVyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG5cdFx0dGhpcy5yYXRpbyA9IHdpbmRvdy5pbm5lcldpZHRoIC8gd2luZG93LmlubmVySGVpZ2h0O1xuXG5cdFx0dGhpcy5jYW1lcmEuYXNwZWN0ID0gdGhpcy5yYXRpbztcblx0XHR0aGlzLmNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cblx0XHR0aGlzLmhhbGZXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoICogLjU7XG5cdFx0dGhpcy5oYWxmSGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0ICogLjU7XG5cdH0sXG5cblx0cmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHRsZXQgZGVsdGEgPSB0aGlzLmNsb2NrLmdldERlbHRhKCk7XG5cblx0XHR0aGlzLmN1cnJlbnRDYW1lcmFQb3MueCArPSAoICggdGhpcy5jYW1lcmFQb3MueCAqIC43KSAtIHRoaXMuY3VycmVudENhbWVyYVBvcy54ICkgKiAwLjAxO1xuXHRcdHRoaXMuY3VycmVudENhbWVyYVBvcy55ICs9ICggKCB0aGlzLmNhbWVyYVBvcy55ICogLjgpIC0gdGhpcy5jdXJyZW50Q2FtZXJhUG9zLnkgKSAqIDAuMDE7XG5cblx0XHR0aGlzLmNhbWVyYS5wb3NpdGlvbi5zZXQoIHRoaXMuY3VycmVudENhbWVyYVBvcy54LCB0aGlzLmN1cnJlbnRDYW1lcmFQb3MueSwgdGhpcy5jdXJyZW50Q2FtZXJhUG9zLnogKTtcblx0XHR0aGlzLmNhbWVyYS5sb29rQXQoY29uZmlnLmNhbWVyYS50YXJnZXQpO1xuXG5cdFx0dGhpcy51bmlmb3Jtcy50aW1lLnZhbHVlICs9IGRlbHRhO1xuXG5cdFx0dGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEpO1xuXHR9XG5cbn07IiwiaW1wb3J0IHNjZW5lIGZyb20gJy4vY29tcG9uZW50cy9zY2VuZSdcblxud2luZG93Lm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuXG5cdHNjZW5lLmluaXQoKTtcblxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBcIi8vXFxuLy8gRGVzY3JpcHRpb24gOiBBcnJheSBhbmQgdGV4dHVyZWxlc3MgR0xTTCAyRCBzaW1wbGV4IG5vaXNlIGZ1bmN0aW9uLlxcbi8vICAgICAgQXV0aG9yIDogSWFuIE1jRXdhbiwgQXNoaW1hIEFydHMuXFxuLy8gIE1haW50YWluZXIgOiBzdGVndVxcbi8vICAgICBMYXN0bW9kIDogMjAxMTA4MjIgKGlqbSlcXG4vLyAgICAgTGljZW5zZSA6IENvcHlyaWdodCAoQykgMjAxMSBBc2hpbWEgQXJ0cy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cXG4vLyAgICAgICAgICAgICAgIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZS5cXG4vLyAgICAgICAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9hc2hpbWEvd2ViZ2wtbm9pc2VcXG4vLyAgICAgICAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9zdGVndS93ZWJnbC1ub2lzZVxcbi8vIFxcblxcbnZlYzMgbW9kMjg5KHZlYzMgeCkge1xcbiAgcmV0dXJuIHggLSBmbG9vcih4ICogKDEuMCAvIDI4OS4wKSkgKiAyODkuMDtcXG59XFxuXFxudmVjMiBtb2QyODkodmVjMiB4KSB7XFxuICByZXR1cm4geCAtIGZsb29yKHggKiAoMS4wIC8gMjg5LjApKSAqIDI4OS4wO1xcbn1cXG5cXG52ZWMzIHBlcm11dGUodmVjMyB4KSB7XFxuICByZXR1cm4gbW9kMjg5KCgoeCozNC4wKSsxLjApKngpO1xcbn1cXG5cXG5mbG9hdCBzbm9pc2UodmVjMiB2KVxcbiAge1xcbiAgY29uc3QgdmVjNCBDID0gdmVjNCgwLjIxMTMyNDg2NTQwNTE4NywgIC8vICgzLjAtc3FydCgzLjApKS82LjBcXG4gICAgICAgICAgICAgICAgICAgICAgMC4zNjYwMjU0MDM3ODQ0MzksICAvLyAwLjUqKHNxcnQoMy4wKS0xLjApXFxuICAgICAgICAgICAgICAgICAgICAgLTAuNTc3MzUwMjY5MTg5NjI2LCAgLy8gLTEuMCArIDIuMCAqIEMueFxcbiAgICAgICAgICAgICAgICAgICAgICAwLjAyNDM5MDI0MzkwMjQzOSk7IC8vIDEuMCAvIDQxLjBcXG4vLyBGaXJzdCBjb3JuZXJcXG4gIHZlYzIgaSAgPSBmbG9vcih2ICsgZG90KHYsIEMueXkpICk7XFxuICB2ZWMyIHgwID0gdiAtICAgaSArIGRvdChpLCBDLnh4KTtcXG5cXG4vLyBPdGhlciBjb3JuZXJzXFxuICB2ZWMyIGkxO1xcbiAgLy9pMS54ID0gc3RlcCggeDAueSwgeDAueCApOyAvLyB4MC54ID4geDAueSA/IDEuMCA6IDAuMFxcbiAgLy9pMS55ID0gMS4wIC0gaTEueDtcXG4gIGkxID0gKHgwLnggPiB4MC55KSA/IHZlYzIoMS4wLCAwLjApIDogdmVjMigwLjAsIDEuMCk7XFxuICAvLyB4MCA9IHgwIC0gMC4wICsgMC4wICogQy54eCA7XFxuICAvLyB4MSA9IHgwIC0gaTEgKyAxLjAgKiBDLnh4IDtcXG4gIC8vIHgyID0geDAgLSAxLjAgKyAyLjAgKiBDLnh4IDtcXG4gIHZlYzQgeDEyID0geDAueHl4eSArIEMueHh6ejtcXG4gIHgxMi54eSAtPSBpMTtcXG5cXG4vLyBQZXJtdXRhdGlvbnNcXG4gIGkgPSBtb2QyODkoaSk7IC8vIEF2b2lkIHRydW5jYXRpb24gZWZmZWN0cyBpbiBwZXJtdXRhdGlvblxcbiAgdmVjMyBwID0gcGVybXV0ZSggcGVybXV0ZSggaS55ICsgdmVjMygwLjAsIGkxLnksIDEuMCApKVxcblxcdFxcdCsgaS54ICsgdmVjMygwLjAsIGkxLngsIDEuMCApKTtcXG5cXG4gIHZlYzMgbSA9IG1heCgwLjUgLSB2ZWMzKGRvdCh4MCx4MCksIGRvdCh4MTIueHkseDEyLnh5KSwgZG90KHgxMi56dyx4MTIuencpKSwgMC4wKTtcXG4gIG0gPSBtKm0gO1xcbiAgbSA9IG0qbSA7XFxuXFxuLy8gR3JhZGllbnRzOiA0MSBwb2ludHMgdW5pZm9ybWx5IG92ZXIgYSBsaW5lLCBtYXBwZWQgb250byBhIGRpYW1vbmQuXFxuLy8gVGhlIHJpbmcgc2l6ZSAxNyoxNyA9IDI4OSBpcyBjbG9zZSB0byBhIG11bHRpcGxlIG9mIDQxICg0MSo3ID0gMjg3KVxcblxcbiAgdmVjMyB4ID0gMi4wICogZnJhY3QocCAqIEMud3d3KSAtIDEuMDtcXG4gIHZlYzMgaCA9IGFicyh4KSAtIDAuNTtcXG4gIHZlYzMgb3ggPSBmbG9vcih4ICsgMC41KTtcXG4gIHZlYzMgYTAgPSB4IC0gb3g7XFxuXFxuLy8gTm9ybWFsaXNlIGdyYWRpZW50cyBpbXBsaWNpdGx5IGJ5IHNjYWxpbmcgbVxcbi8vIEFwcHJveGltYXRpb24gb2Y6IG0gKj0gaW52ZXJzZXNxcnQoIGEwKmEwICsgaCpoICk7XFxuICBtICo9IDEuNzkyODQyOTE0MDAxNTkgLSAwLjg1MzczNDcyMDk1MzE0ICogKCBhMCphMCArIGgqaCApO1xcblxcbi8vIENvbXB1dGUgZmluYWwgbm9pc2UgdmFsdWUgYXQgUFxcbiAgdmVjMyBnO1xcbiAgZy54ICA9IGEwLnggICogeDAueCAgKyBoLnggICogeDAueTtcXG4gIGcueXogPSBhMC55eiAqIHgxMi54eiArIGgueXogKiB4MTIueXc7XFxuICByZXR1cm4gMTMwLjAgKiBkb3QobSwgZyk7XFxufVxcblwiO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBcInVuaWZvcm0gc2FtcGxlcjJEIG1hcDtcXG5cXG52b2lkIG1haW4oKSB7XFxuXFxuXFx0Z2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKCBtYXAsIHZlYzIoIGdsX1BvaW50Q29vcmQueCwgMS4wIC0gZ2xfUG9pbnRDb29yZC55ICkgKTtcXG5cXG5cXHRnbF9GcmFnQ29sb3IgPSBnbF9GcmFnQ29sb3IgKiB2ZWM0KCAxLiwgMS4sIDEuLCAxLiApO1xcblxcbn1cXG5cIjtcbiIsIm1vZHVsZS5leHBvcnRzID0gXCJcXG5cXG4jZGVmaW5lIE1fUEkgMy4xNDE1OTI2NTM1ODk3OTMyMzg0NjI2NDMzODMyNzk1XFxuI2RlZmluZSBESVNUIDMwMC4wXFxuXFxudW5pZm9ybSBmbG9hdCB0aW1lO1xcblxcbmF0dHJpYnV0ZSBmbG9hdCBzaXplO1xcblxcbnZvaWQgbWFpbigpIHtcXG5cXHR2ZWMyIGZha2VQb3NpdGlvbiAgID0gdmVjMiggcG9zaXRpb24ueCwgcG9zaXRpb24ueSApO1xcblxcdHZlYzMgbmV3UG9zaXRpb25cXHQ9IHZlYzMoIC4wLCAuMCwgLjAgKTtcXG5cXG5cXHRmYWtlUG9zaXRpb24ueCA9IHNub2lzZSggdmVjMiggcG9zaXRpb24ueCwgdGltZSAqIC4wMDEgKSApO1xcblxcdGZha2VQb3NpdGlvbi55ID0gc25vaXNlKCB2ZWMyKCBwb3NpdGlvbi55LCB0aW1lICogLjAwMSApICk7XFxuXFxuXFx0ZmxvYXQgYW5nbGUxID0gMi4gKiBNX1BJICogZmFrZVBvc2l0aW9uLng7XFxuXFx0ZmxvYXQgYW5nbGUyID0gYWNvcyggZmFrZVBvc2l0aW9uLnkgKiAyLiAtIDEuICk7XFxuXFxuXFx0bmV3UG9zaXRpb24ueCA9IERJU1QgKiBzaW4oIGFuZ2xlMSApICogY29zKCBhbmdsZTIgKTtcXG5cXHRuZXdQb3NpdGlvbi55ID0gRElTVCAqIHNpbiggYW5nbGUxICkgKiBzaW4oIGFuZ2xlMiApO1xcblxcdG5ld1Bvc2l0aW9uLnogPSBESVNUICogY29zKCBhbmdsZTEgKTtcXG5cXG5cXHR2ZWM0IG12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBuZXdQb3NpdGlvbiwgMS4gKTtcXG5cXG5cXHRnbF9Qb2ludFNpemUgPSBzaXplICogKCA1MDAuIC8gLSBtdlBvc2l0aW9uLnogKTtcXG5cXG4gICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbXZQb3NpdGlvbjtcXG59XCI7XG4iLCJpbXBvcnQgdGhyZWVqcyBmcm9tIFwidGhyZWUtanNcIjtcbmNvbnN0IFRIUkVFID0gdGhyZWVqcygpO1xuXG5cbnZhciBjb25maWcgPSB7XG5cdFxuXHRjYW52YXM6IHtcblx0XHRlbGVtZW50IDogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvbnRhaW5lcicpLFxuXHRcdGNvbG9yIDogMHgxYTIwMzNcblx0fSxcblx0XG5cdGNhbWVyYToge1xuXHRcdHBvc2l0aW9uIDogbmV3IFRIUkVFLlZlY3RvcjMoMCwgMCwgODAwKSxcblx0XHR0YXJnZXQgOiBuZXcgVEhSRUUuVmVjdG9yMygwLCAwLCAwKVxuXHR9LFxuXG5cdGF4aXNIZWxwZXI6IGZhbHNlLFxuXHRcblx0bGlnaHRzOiB7XG5cdFx0YW1iaWVudDoge1xuXHRcdFx0Y29sb3IgOiAweGZmZmZmZlxuXHRcdH0gXG5cdH0sXG5cblx0cGFydGljbGVzOiB7XG5cdFx0Y291bnQ6IDUwMDAwMCxcblx0XHRtYXhFeHBsb3Npb25zOiAxMDAsXG5cdFx0dGV4dHVyZSA6IFwiLi9hc3NldHMvbWVkaWFzL3Ntb2tlXzMucG5nXCJcblx0fSxcblxuXHRkcmF3RmllbGQ6IHtcblx0XHRtYXhIZWlnaHQ6IDYwMCxcblx0XHRtYXhXaWR0aDogNjAwLFxuXHRcdG1heERlcHRoOiAxNTAsXG5cdFx0bWl0aWdhdG9yOiAuM1xuXHR9LFxuXG5cdHBsYW5lOiB7XG5cdFx0d2lkdGg6IDcwMCxcblx0XHRoZWlnaHQ6IDcwMCxcblx0XHR3aXJlZnJhbWU6IHRydWUsXG5cdFx0b3BhY2l0eTogMCxcblx0fVxuXHRcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbmZpZzsiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vdG9tbXljb3IvbWFwcGVySlMvYmxvYi9tYXN0ZXIvbWFwcGVyLW1pbi5qc1xuZnVuY3Rpb24gbWFwcGVyKHZhbCxvTWluLG9NYXgsbk1pbixuTWF4KXtyZXR1cm4oKCh2YWwtb01pbikqKG5NYXgtbk1pbikpLyhvTWF4LW9NaW4pKSsobk1pbik7fVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcHBlcjsiLCJmdW5jdGlvbiBSYWYoKSB7XG5cblx0dGhpcy5sb29wID0gdGhpcy5sb29wLmJpbmQodGhpcyk7XG5cdHRoaXMuc3RhcnQgPSB0aGlzLnN0YXJ0LmJpbmQodGhpcyk7XG5cdHRoaXMuc3RvcCA9IHRoaXMuc3RvcC5iaW5kKHRoaXMpO1xuXHR0aGlzLmNvbnRyb2wgPSB0aGlzLmNvbnRyb2wuYmluZCh0aGlzKTtcblxuXHR0aGlzLnRvUmVmcmVzaCA9IFtdO1xuXG5cdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5jb250cm9sKTtcblxufVxuXG5SYWYucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXG5cdHRoaXMudG9SZWZyZXNoLnB1c2goY2FsbGJhY2spO1xuXG59XG5cblJhZi5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbigpIHtcblxuXHR0aGlzLmxvb3AoKTtcblxufVxuXG5SYWYucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbigpIHtcblxuXHRjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnJlcXVlc3QpO1xuXG59XG5cblJhZi5wcm90b3R5cGUubG9vcCA9IGZ1bmN0aW9uKCkge1xuXG5cdHZhciBpO1xuXHRmb3IoIGkgPSAwIDsgaSA8IHRoaXMudG9SZWZyZXNoLmxlbmd0aCA7IGkrKyApIHtcblx0XHR0aGlzLnRvUmVmcmVzaFtpXSgpO1xuXHR9XG5cblx0dGhpcy5yZXF1ZXN0ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuc3RhcnQpO1xuXG59XG5cblJhZi5wcm90b3R5cGUuY29udHJvbCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdGlmIChldmVudC5rZXlDb2RlID09PSAwIHx8IGV2ZW50LmtleUNvZGUgPT09IDMyKSB7XG5cblx0XHRpZiAodGhpcy5yZXF1ZXN0ICE9IG51bGwpXG5cdFx0XHR0aGlzLnN0b3AoKTtcblx0XHRlbHNlXG5cdFx0XHR0aGlzLnN0YXJ0KCk7XG5cblx0fVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgUmFmKCk7XG5cblxuXG5cblx0XG4iXX0=